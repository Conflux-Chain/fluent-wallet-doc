exports.id = 474;
exports.ids = [474];
exports.modules = {

/***/ 99817:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var CONST = __webpack_require__(61381);

var _require = __webpack_require__(65251),
    isHexString = _require.isHexString,
    isString = _require.isString;
/**
 * Check conflux address's prefix
 *
 * @param address {string}
 * @return {boolean}
 *
 * @example
 */


function hasNetworkPrefix(address) {
  if (!isString(address)) {
    return false;
  }

  var parts = address.toLowerCase().split(':');

  if (parts.length !== 2 && parts.length !== 3) {
    return false;
  }

  var prefix = parts[0];

  if (prefix === CONST.PREFIX_CFX || prefix === CONST.PREFIX_CFXTEST) {
    return true;
  }

  return prefix.startsWith(CONST.PREFIX_NET) && /^([1-9]\d*)$/.test(prefix.slice(3));
}
/**
 * simplify a verbose address(return a non-verbose address)
 *
 * @param address {string}
 * @return {string}
 *
 */


function simplifyCfxAddress(address) {
  if (!hasNetworkPrefix(address)) {
    throw new Error('invalid base32 address');
  }

  var parts = address.toLocaleLowerCase().split(':');

  if (parts.length !== 3) {
    return address;
  }

  return "".concat(parts[0], ":").concat(parts[2]);
}

function shortenCfxAddress(address) {
  var compress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  address = simplifyCfxAddress(address);

  var _address$split = address.split(':'),
      _address$split2 = _slicedToArray(_address$split, 2),
      netPre = _address$split2[0],
      body = _address$split2[1];

  var tailLen = netPre === 'cfx' && !compress ? 8 : 4;
  var pre = body.slice(0, 3);
  var tail = body.slice(body.length - tailLen);
  return "".concat(netPre, ":").concat(pre, "...").concat(tail);
}

function isZeroAddress(address) {
  if (!isHexString(address)) throw new Error('Only hex is allowed');
  return address === CONST.ZERO_ADDRESS_HEX;
}

function isInternalContractAddress(address) {
  if (!isHexString(address)) throw new Error('Only hex is allowed');
  return address === CONST.ADMIN_CONTROL || address === CONST.SPONSOR_CONTROL || address === CONST.STAKING || address === CONST.CONFLUX_CONTEXT || address === CONST.POS_REGISTER;
}

function isValidHexAddress(address) {
  return isHexString(address) && address.length === 42;
} // TOOD check address's checksum


function isValidCfxHexAddress(address) {
  if (address.length !== 42) return false;
  if (isZeroAddress(address) || isInternalContractAddress(address)) return true;
  return address.startsWith('0x1') || address.startsWith('0x8');
}

module.exports = {
  hasNetworkPrefix: hasNetworkPrefix,
  simplifyCfxAddress: simplifyCfxAddress,
  shortenCfxAddress: shortenCfxAddress,
  isZeroAddress: isZeroAddress,
  isInternalContractAddress: isInternalContractAddress,
  isValidHexAddress: isValidHexAddress,
  isValidCfxHexAddress: isValidCfxHexAddress
};

/***/ }),

/***/ 60411:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JSBI = __webpack_require__(29034);

var ALPHABET = 'ABCDEFGHJKMNPRSTUVWXYZ0123456789';
var ALPHABET_MAP = {};

for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);

  if (ALPHABET_MAP[x] !== undefined) {
    throw new TypeError(x + ' is ambiguous');
  }

  ALPHABET_MAP[x] = z;
} // pre defined BigInt could faster about 40 percent


var BIGINT_0 = JSBI.BigInt(0);
var BIGINT_1 = JSBI.BigInt(1);
var BIGINT_5 = JSBI.BigInt(5);
var BIGINT_35 = JSBI.BigInt(35);
var BIGINT_0B00001 = JSBI.BigInt(1);
var BIGINT_0B00010 = JSBI.BigInt(2);
var BIGINT_0B00100 = JSBI.BigInt(4);
var BIGINT_0B01000 = JSBI.BigInt(8);
var BIGINT_0B10000 = JSBI.BigInt(16);
var BIGINT_0X07FFFFFFFF = JSBI.BigInt(0x07ffffffff);
var BIGINT_0X98F2BC8E61 = JSBI.BigInt(0x98f2bc8e61);
var BIGINT_0X79B76D99E2 = JSBI.BigInt(0x79b76d99e2);
var BIGINT_0XF33E5FB3C4 = JSBI.BigInt(0xf33e5fb3c4);
var BIGINT_0XAE2EABE2A8 = JSBI.BigInt(0xae2eabe2a8);
var BIGINT_0X1E4F43E470 = JSBI.BigInt(0x1e4f43e470);

function convertBit(buffer, inBits, outBits, pad) {
  var mask = (1 << outBits) - 1;
  var array = [];
  var bits = 0;
  var value = 0;

  var _iterator = _createForOfIteratorHelper(buffer),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _byte = _step.value;
      bits += inBits;
      value = value << inBits | _byte;

      while (bits >= outBits) {
        bits -= outBits;
        array.push(value >>> bits & mask);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  value = value << outBits - bits & mask;

  if (bits && pad) {
    array.push(value);
  } else if (value && !pad) {
    throw new Error('Excess padding');
  } else if (bits >= inBits && !pad) {
    throw new Error('Non-zero padding');
  }

  return array;
}

function polyMod(buffer) {
  var checksumBigInt = BIGINT_1;

  var _iterator2 = _createForOfIteratorHelper(buffer),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _byte2 = _step2.value;
      // c0 = c >> 35;
      var high = JSBI.signedRightShift(checksumBigInt, BIGINT_35); // XXX: checksumBigInt must be positive, signedRightShift is ok
      // c = ((c & 0x07ffffffff) << 5) ^ d;

      checksumBigInt = JSBI.bitwiseAnd(checksumBigInt, BIGINT_0X07FFFFFFFF);
      checksumBigInt = JSBI.leftShift(checksumBigInt, BIGINT_5);
      checksumBigInt = _byte2 ? JSBI.bitwiseXor(checksumBigInt, JSBI.BigInt(_byte2)) : checksumBigInt; // bit ^ 0 = bit

      if (JSBI.notEqual(JSBI.bitwiseAnd(high, BIGINT_0B00001), BIGINT_0)) {
        checksumBigInt = JSBI.bitwiseXor(checksumBigInt, BIGINT_0X98F2BC8E61);
      }

      if (JSBI.notEqual(JSBI.bitwiseAnd(high, BIGINT_0B00010), BIGINT_0)) {
        checksumBigInt = JSBI.bitwiseXor(checksumBigInt, BIGINT_0X79B76D99E2);
      }

      if (JSBI.notEqual(JSBI.bitwiseAnd(high, BIGINT_0B00100), BIGINT_0)) {
        checksumBigInt = JSBI.bitwiseXor(checksumBigInt, BIGINT_0XF33E5FB3C4);
      }

      if (JSBI.notEqual(JSBI.bitwiseAnd(high, BIGINT_0B01000), BIGINT_0)) {
        checksumBigInt = JSBI.bitwiseXor(checksumBigInt, BIGINT_0XAE2EABE2A8);
      }

      if (JSBI.notEqual(JSBI.bitwiseAnd(high, BIGINT_0B10000), BIGINT_0)) {
        checksumBigInt = JSBI.bitwiseXor(checksumBigInt, BIGINT_0X1E4F43E470);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return JSBI.bitwiseXor(checksumBigInt, BIGINT_1);
}

module.exports = {
  convertBit: convertBit,
  polyMod: polyMod,
  ALPHABET: ALPHABET,
  ALPHABET_MAP: ALPHABET_MAP
};

/***/ }),

/***/ 90845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];


try {
  var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@conflux-dev/conflux-address-rust'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
      _encode = _require.encode,
      decode = _require.decode;

  module.exports = {
    encode: function encode(hexAddress, netId) {
      var verbose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (Buffer.isBuffer(hexAddress)) {
        hexAddress = hexAddress.toString('hex');
      }

      return _encode(hexAddress, netId, verbose);
    },
    decode: decode
  };
} catch (e) {
  // console.log('To gain a address conversion performance boost, install @conflux-dev/conflux-address-rust')
  module.exports = __webpack_require__(92605);
}

/***/ }),

/***/ 92605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];


function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = __webpack_require__(60411),
    ALPHABET = _require.ALPHABET,
    ALPHABET_MAP = _require.ALPHABET_MAP,
    polyMod = _require.polyMod,
    convertBit = _require.convertBit;

var CONST = __webpack_require__(61381);

var _require2 = __webpack_require__(65251),
    isHexString = _require2.isHexString;

var VERSION_BYTE = 0;
var NET_ID_LIMIT = 0xFFFFFFFF;

function encodeNetId(netId) {
  if (!Number.isInteger(netId)) {
    throw new Error('netId should be passed as an integer');
  }

  if (netId < 0 || netId > NET_ID_LIMIT) {
    throw new Error('netId should be passed as in range [0, 0xFFFFFFFF]');
  }

  switch (netId) {
    case CONST.NETID_TEST:
      return CONST.PREFIX_CFXTEST;

    case CONST.NETID_MAIN:
      return CONST.PREFIX_CFX;

    default:
      return "".concat(CONST.PREFIX_NET).concat(netId);
  }
}

function isValidNetId(netId) {
  return /^([1-9]\d*)$/.test(netId) && Number(netId) <= NET_ID_LIMIT;
}

function decodeNetId(payload) {
  switch (payload) {
    case CONST.PREFIX_CFXTEST:
      return CONST.NETID_TEST;

    case CONST.PREFIX_CFX:
      return CONST.NETID_MAIN;

    default:
      {
        var prefix = payload.slice(0, 3);
        var netId = payload.slice(3);

        if (prefix !== CONST.PREFIX_NET || !isValidNetId(netId)) {
          throw new Error("netId prefix should be passed by 'cfx', 'cfxtest' or 'net[n]' ");
        }

        if (Number(netId) === CONST.NETID_TEST || Number(netId) === CONST.NETID_MAIN) {
          throw new Error('net1 or net1029 are invalid');
        }

        return Number(netId);
      }
  }
}

function getAddressType(hexAddress) {
  if (hexAddress.length < 1) {
    throw new Error('Empty payload in address');
  }

  switch (hexAddress[0] & 0xf0) {
    case 0x10:
      return CONST.TYPE_USER;

    case 0x80:
      return CONST.TYPE_CONTRACT;

    case 0x00:
      var _iterator = _createForOfIteratorHelper(hexAddress),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;

          if (x !== 0x00) {
            return CONST.TYPE_BUILTIN;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return CONST.TYPE_NULL;

    default:
      return CONST.TYPE_UNKNOWN;
    // throw new Error('hexAddress should start with 0x0, 0x1 or 0x8')
  }
}

function encode(hexAddress, netId) {
  var verbose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (isHexString(hexAddress)) {
    hexAddress = Buffer.from(hexAddress.slice(2), 'hex');
  }

  if (!(hexAddress instanceof Buffer)) {
    throw new Error('hexAddress should be passed as a Buffer');
  }

  if (hexAddress.length < 20) {
    throw new Error('hexAddress should be at least 20 bytes');
  }

  var addressType = getAddressType(hexAddress).toUpperCase();
  var netName = encodeNetId(netId).toUpperCase();
  var netName5Bits = Buffer.from(netName).map(function (_byte) {
    return _byte & 31;
  });
  var payload5Bits = convertBit([VERSION_BYTE].concat(_toConsumableArray(hexAddress)), 8, 5, true);
  var checksumBigInt = polyMod([].concat(_toConsumableArray(netName5Bits), [0], _toConsumableArray(payload5Bits), [0, 0, 0, 0, 0, 0, 0, 0]));
  var checksumBytes = Buffer.from(checksumBigInt.toString(16).padStart(10, '0'), 'hex');
  var checksum5Bits = convertBit(checksumBytes, 8, 5, true);
  var payload = payload5Bits.map(function (_byte2) {
    return ALPHABET[_byte2];
  }).join('');
  var checksum = checksum5Bits.map(function (_byte3) {
    return ALPHABET[_byte3];
  }).join('');
  return verbose ? "".concat(netName, ":TYPE.").concat(addressType, ":").concat(payload).concat(checksum) : "".concat(netName, ":").concat(payload).concat(checksum).toLowerCase();
}

function decode(address) {
  // don't allow mixed case
  var lowered = address.toLowerCase();
  var uppered = address.toUpperCase();

  if (address !== lowered && address !== uppered) {
    throw new Error('Mixed-case address ' + address);
  }

  var _address$toUpperCase$ = address.toUpperCase().match(/^([^:]+):(.+:)?(.{34})(.{8})$/),
      _address$toUpperCase$2 = _slicedToArray(_address$toUpperCase$, 5),
      netName = _address$toUpperCase$2[1],
      shouldHaveType = _address$toUpperCase$2[2],
      payload = _address$toUpperCase$2[3],
      checksum = _address$toUpperCase$2[4];

  var prefix5Bits = Buffer.from(netName).map(function (_byte4) {
    return _byte4 & 31;
  });
  var payload5Bits = [];

  var _iterator2 = _createForOfIteratorHelper(payload),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _char = _step2.value;
      payload5Bits.push(ALPHABET_MAP[_char]);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var checksum5Bits = [];

  var _iterator3 = _createForOfIteratorHelper(checksum),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _char2 = _step3.value;
      checksum5Bits.push(ALPHABET_MAP[_char2]);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var _convertBit = convertBit(payload5Bits, 5, 8),
      _convertBit2 = _toArray(_convertBit),
      version = _convertBit2[0],
      addressBytes = _convertBit2.slice(1);

  if (version !== VERSION_BYTE) {
    throw new Error('Can not recognize version byte');
  }

  var hexAddress = Buffer.from(addressBytes);
  var netId = decodeNetId(netName.toLowerCase());
  var type = getAddressType(hexAddress);

  if (shouldHaveType && "type.".concat(type, ":") !== shouldHaveType.toLowerCase()) {
    throw new Error('Type of address doesn\'t match');
  }

  var bigInt = polyMod([].concat(_toConsumableArray(prefix5Bits), [0], payload5Bits, checksum5Bits));

  if (Number(bigInt)) {
    throw new Error("Invalid checksum for ".concat(address));
  }

  return {
    hexAddress: hexAddress,
    netId: netId,
    type: type
  };
}

module.exports = {
  encode: encode,
  decode: decode
};

/***/ }),

/***/ 61381:
/***/ ((module) => {

"use strict";


var TYPE_USER = 'user';
var TYPE_CONTRACT = 'contract';
var TYPE_BUILTIN = 'builtin';
var TYPE_NULL = 'null';
var TYPE_UNKNOWN = 'unknown';
var PREFIX_CFX = 'cfx';
var PREFIX_CFXTEST = 'cfxtest';
var PREFIX_NET = 'net';
var NETID_MAIN = 1029;
var NETID_TEST = 1;
var ZERO_ADDRESS_HEX = '0x0000000000000000000000000000000000000000';
var ADMIN_CONTROL = '0x0888000000000000000000000000000000000000';
var SPONSOR_CONTROL = '0x0888000000000000000000000000000000000001';
var STAKING = '0x0888000000000000000000000000000000000002';
var CONFLUX_CONTEXT = '0x0888000000000000000000000000000000000004';
var POS_REGISTER = '0x0888000000000000000000000000000000000005';
module.exports = {
  TYPE_USER: TYPE_USER,
  TYPE_CONTRACT: TYPE_CONTRACT,
  TYPE_BUILTIN: TYPE_BUILTIN,
  TYPE_NULL: TYPE_NULL,
  TYPE_UNKNOWN: TYPE_UNKNOWN,
  PREFIX_CFX: PREFIX_CFX,
  PREFIX_CFXTEST: PREFIX_CFXTEST,
  PREFIX_NET: PREFIX_NET,
  NETID_MAIN: NETID_MAIN,
  NETID_TEST: NETID_TEST,
  ZERO_ADDRESS_HEX: ZERO_ADDRESS_HEX,
  ADMIN_CONTROL: ADMIN_CONTROL,
  SPONSOR_CONTROL: SPONSOR_CONTROL,
  STAKING: STAKING,
  CONFLUX_CONTEXT: CONFLUX_CONTEXT,
  POS_REGISTER: POS_REGISTER
};

/***/ }),

/***/ 40376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = __webpack_require__(90845),
    encode = _require.encode,
    decode = _require.decode;

var _require2 = __webpack_require__(99817),
    rest = _extends({}, _require2);

var _require3 = __webpack_require__(65251),
    isString = _require3.isString;
/**
 * Check whether a given address is valid, will return a boolean value
 *
 * @param address {string}
 * @return {boolean}
 *
 */


function isValidCfxAddress(address) {
  if (!isString(address)) {
    return false;
  }

  try {
    decode(address);
    return true;
  } catch (e) {
    return false;
  }
}
/**
 * Check whether a given address is valid, if not valid will throw an error
 *
 * @param address {string}
 *
 */


function verifyCfxAddress(address) {
  decode(address);
  return true;
}

module.exports = _objectSpread({
  encode: encode,
  decode: decode,
  isValidCfxAddress: isValidCfxAddress,
  verifyCfxAddress: verifyCfxAddress
}, rest);

/***/ }),

/***/ 65251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isHexString = function (v) {
  return typeof v === 'string' && v.match(/^0x[0-9A-Fa-f]*$/);
};

exports.isString = function (data) {
  return typeof data === 'string';
};

/***/ }),

/***/ 64168:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "vU": () => (/* binding */ Interface)
});

// UNUSED EXPORTS: ErrorDescription, Indexed, LogDescription, TransactionDescription, checkResultErrors

// EXTERNAL MODULE: ../../node_modules/@ethersproject/address/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(58194);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var bytes_lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/hash/lib.esm/id.js
var id = __webpack_require__(32235);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(59256);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/properties/lib.esm/index.js + 1 modules
var properties_lib_esm = __webpack_require__(84427);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/_version.js
const version = "abi/5.6.3";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js






const logger = new logger_lib_esm/* Logger */.Yd(version);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return (0,bytes_lib_esm/* hexConcat */.xs)(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData((0,bytes_lib_esm/* concat */.zo)(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = (0,bytes_lib_esm/* arrayify */.lE)(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = (0,bytes_lib_esm/* concat */.zo)([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = (0,bytes_lib_esm/* arrayify */.lE)(bignumber/* BigNumber.from */.O$.from(value));
        if (bytes.length > this.wordSize) {
            logger.throwError("value out-of-bounds", logger_lib_esm/* Logger.errors.BUFFER_OVERRUN */.Yd.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = (0,bytes_lib_esm/* concat */.zo)([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_data", (0,bytes_lib_esm/* arrayify */.lE)(data));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "wordSize", wordSize || 32);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_coerceFunc", coerceFunc);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return (0,bytes_lib_esm/* hexlify */.Dv)(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger.throwError("data out-of-bounds", logger_lib_esm/* Logger.errors.BUFFER_OVERRUN */.Yd.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return bignumber/* BigNumber.from */.O$.from(this.readBytes(this.wordSize));
    }
}
//# sourceMappingURL=abstract-coder.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/address.js




class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = (0,lib_esm/* getAddress */.Kn)(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return (0,lib_esm/* getAddress */.Kn)((0,bytes_lib_esm/* hexZeroPad */.$m)(reader.readValue().toHexString(), 20));
    }
}
//# sourceMappingURL=address.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js


// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}
//# sourceMappingURL=anonymous.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/array.js



const array_logger = new logger_lib_esm/* Logger */.Yd(version);


function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                array_logger.throwError("cannot encode object for signature with missing names", logger_lib_esm/* Logger.errors.INVALID_ARGUMENT */.Yd.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                array_logger.throwError("cannot encode object for signature with duplicate names", logger_lib_esm/* Logger.errors.INVALID_ARGUMENT */.Yd.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        array_logger.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        array_logger.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === logger_lib_esm/* Logger.errors.BUFFER_OVERRUN */.Yd.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === logger_lib_esm/* Logger.errors.BUFFER_OVERRUN */.Yd.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        array_logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                array_logger.throwError("insufficient data length", logger_lib_esm/* Logger.errors.BUFFER_OVERRUN */.Yd.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js


class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}
//# sourceMappingURL=boolean.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js



class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = (0,bytes_lib_esm/* arrayify */.lE)(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, (0,bytes_lib_esm/* hexlify */.Dv)(super.decode(reader)));
    }
}
//# sourceMappingURL=bytes.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js



// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = (0,bytes_lib_esm/* arrayify */.lE)(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, (0,bytes_lib_esm/* hexlify */.Dv)(reader.readBytes(this.size)));
    }
}
//# sourceMappingURL=fixed-bytes.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/null.js


class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}
//# sourceMappingURL=null.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js

const NegativeOne = ( /*#__PURE__*/bignumber/* BigNumber.from */.O$.from(-1));
const Zero = ( /*#__PURE__*/bignumber/* BigNumber.from */.O$.from(0));
const One = ( /*#__PURE__*/bignumber/* BigNumber.from */.O$.from(1));
const Two = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from(2))));
const WeiPerEther = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from("1000000000000000000"))));
const MaxUint256 = ( /*#__PURE__*/bignumber/* BigNumber.from */.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
const MinInt256 = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"))));
const MaxInt256 = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))));

//# sourceMappingURL=bignumbers.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/number.js




class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = bignumber/* BigNumber.from */.O$.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}
//# sourceMappingURL=number.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/strings/lib.esm/utf8.js + 1 modules
var utf8 = __webpack_require__(71320);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/string.js



class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, (0,utf8/* toUtf8Bytes */.Y0)(value));
    }
    decode(reader) {
        return (0,utf8/* toUtf8String */.ZN)(super.decode(reader));
    }
}
//# sourceMappingURL=string.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js



class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}
//# sourceMappingURL=tuple.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/fragments.js





const fragments_logger = new logger_lib_esm/* Logger */.Yd(version);
;
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        fragments_logger.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        fragments_logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        fragments_logger.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            fragments_logger.throwError("use fromString", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            fragments_logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
;
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            fragments_logger.throwError("use a static from method", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return fragments_logger.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return fragments_logger.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            fragments_logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            fragments_logger.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            fragments_logger.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    fragments_logger.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            fragments_logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            fragments_logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = bignumber/* BigNumber.from */.O$.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                fragments_logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                fragments_logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            fragments_logger.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            fragments_logger.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        fragments_logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            fragments_logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            fragments_logger.throwError("cannot format a constructor for sighash", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            fragments_logger.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            fragments_logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? bignumber/* BigNumber.from */.O$.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            fragments_logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            fragments_logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            fragments_logger.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? bignumber/* BigNumber.from */.O$.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            fragments_logger.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            fragments_logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                fragments_logger.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        fragments_logger.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            fragments_logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            fragments_logger.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            fragments_logger.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        fragments_logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    fragments_logger.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}
//# sourceMappingURL=fragments.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js

// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI




const abi_coder_logger = new logger_lib_esm/* Logger */.Yd(version);











const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                abi_coder_logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                abi_coder_logger.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return abi_coder_logger.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            abi_coder_logger.throwError("types/values length mismatch", logger_lib_esm/* Logger.errors.INVALID_ARGUMENT */.Yd.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader((0,bytes_lib_esm/* arrayify */.lE)(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();
//# sourceMappingURL=abi-coder.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abi/lib.esm/interface.js












const interface_logger = new logger_lib_esm/* Logger */.Yd(version);

class LogDescription extends properties_lib_esm/* Description */.dk {
}
class TransactionDescription extends properties_lib_esm/* Description */.dk {
}
class ErrorDescription extends properties_lib_esm/* Description */.dk {
}
class Indexed extends properties_lib_esm/* Description */.dk {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_abiCoder", (0,properties_lib_esm/* getStatic */.tu)(new.target, "getAbiCoder")());
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "functions", {});
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "errors", {});
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "events", {});
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        interface_logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    (0,properties_lib_esm/* defineReadOnly */.zG)(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                interface_logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            interface_logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return (0,lib_esm/* getAddress */.Kn)(address);
    }
    static getSighash(fragment) {
        return (0,bytes_lib_esm/* hexDataSlice */.p3)((0,id.id)(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return (0,id.id)(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if ((0,bytes_lib_esm/* isHexString */.A7)(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            interface_logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                interface_logger.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                interface_logger.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            interface_logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if ((0,bytes_lib_esm/* isHexString */.A7)(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            interface_logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                interface_logger.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                interface_logger.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            interface_logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if ((0,bytes_lib_esm/* isHexString */.A7)(nameOrSignatureOrSighash)) {
            const getSighash = (0,properties_lib_esm/* getStatic */.tu)(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            interface_logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                interface_logger.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                interface_logger.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            interface_logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return (0,properties_lib_esm/* getStatic */.tu)(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return (0,properties_lib_esm/* getStatic */.tu)(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = (0,bytes_lib_esm/* arrayify */.lE)(data);
        if ((0,bytes_lib_esm/* hexlify */.Dv)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            interface_logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", (0,bytes_lib_esm/* hexlify */.Dv)(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return (0,bytes_lib_esm/* hexlify */.Dv)((0,bytes_lib_esm/* concat */.zo)([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = (0,bytes_lib_esm/* arrayify */.lE)(data);
        if ((0,bytes_lib_esm/* hexlify */.Dv)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            interface_logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", (0,bytes_lib_esm/* hexlify */.Dv)(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return (0,bytes_lib_esm/* hexlify */.Dv)((0,bytes_lib_esm/* concat */.zo)([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = (0,bytes_lib_esm/* arrayify */.lE)(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = (0,bytes_lib_esm/* hexlify */.Dv)(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return interface_logger.throwError("call revert exception" + message, logger_lib_esm/* Logger.errors.CALL_EXCEPTION */.Yd.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: (0,bytes_lib_esm/* hexlify */.Dv)(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return (0,bytes_lib_esm/* hexlify */.Dv)(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            interface_logger.throwError("too many arguments for " + eventFragment.format(), logger_lib_esm/* Logger.errors.UNEXPECTED_ARGUMENT */.Yd.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return (0,id.id)(value);
            }
            else if (param.type === "bytes") {
                return (0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* hexlify */.Dv)(value));
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return (0,bytes_lib_esm/* hexZeroPad */.$m)((0,bytes_lib_esm/* hexlify */.Dv)(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    interface_logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                interface_logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            interface_logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push((0,id.id)(value));
                }
                else if (param.type === "bytes") {
                    topics.push((0,keccak256_lib_esm/* keccak256 */.w)(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!(0,bytes_lib_esm/* isHexString */.A7)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                interface_logger.throwError("fragment/topic mismatch", logger_lib_esm/* Logger.errors.INVALID_ARGUMENT */.Yd.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0,bytes_lib_esm/* concat */.zo)(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: bignumber/* BigNumber.from */.O$.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = (0,bytes_lib_esm/* hexlify */.Dv)(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ 58194:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Kn": () => (/* binding */ getAddress)
});

// UNUSED EXPORTS: getContractAddress, getCreate2Address, getIcapAddress, isAddress

// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(59256);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/address/lib.esm/_version.js
const version = "address/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/address/lib.esm/index.js







const logger = new logger_lib_esm/* Logger */.Yd(version);
function getChecksumAddress(address) {
    if (!(0,lib_esm/* isHexString */.A7)(address, 20)) {
        logger.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = (0,lib_esm/* arrayify */.lE)((0,keccak256_lib_esm/* keccak256 */.w)(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
;
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger.throwArgumentError("bad icap checksum", "address", address);
        }
        result = (0,bignumber/* _base36To16 */.g$)(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
function getIcapAddress(address) {
    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if (hexDataLength(salt) !== 32) {
        logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if (hexDataLength(initCodeHash) !== 32) {
        logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 43495:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": () => (/* binding */ version)
/* harmony export */ });
const version = "bignumber/5.6.2";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 10528:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Zm": () => (/* binding */ isBigNumberish),
/* harmony export */   "O$": () => (/* binding */ BigNumber),
/* harmony export */   "g$": () => (/* binding */ _base36To16)
/* harmony export */ });
/* unused harmony export _base16To36 */
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62197);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75398);
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57036);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43495);

/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */

var BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__/* .Logger */ .Yd(_version__WEBPACK_IMPORTED_MODULE_2__/* .version */ .i);
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__/* .isHexString */ .A7)(value) ||
        (typeof (value) === "bigint") ||
        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__/* .isBytes */ ._t)(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot call constructor directly; use BigNumber.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__/* .Logger.errors.UNSUPPORTED_OPERATION */ .Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger.throwError("this platform does not support BigInt", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__/* .Logger.errors.UNSUPPORTED_OPERATION */ .Yd.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__/* .Logger.errors.UNEXPECTED_ARGUMENT */ .Yd.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger.throwError("BigNumber.toString does not accept parameters", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__/* .Logger.errors.UNEXPECTED_ARGUMENT */ .Yd.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard, toHex(new BN(value)));
            }
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__/* .isBytes */ ._t)(anyValue)) {
            return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__/* .hexlify */ .Dv)(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__/* .isHexString */ .A7)(hex) || (hex[0] === "-" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__/* .isHexString */ .A7)(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__/* .Logger.errors.NUMERIC_FAULT */ .Yd.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}
//# sourceMappingURL=bignumber.js.map

/***/ }),

/***/ 75398:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "lE": () => (/* binding */ arrayify),
  "zo": () => (/* binding */ concat),
  "xs": () => (/* binding */ hexConcat),
  "E1": () => (/* binding */ hexDataLength),
  "p3": () => (/* binding */ hexDataSlice),
  "$P": () => (/* binding */ hexValue),
  "$m": () => (/* binding */ hexZeroPad),
  "Dv": () => (/* binding */ hexlify),
  "_t": () => (/* binding */ isBytes),
  "Zq": () => (/* binding */ isBytesLike),
  "A7": () => (/* binding */ isHexString),
  "gV": () => (/* binding */ joinSignature),
  "N": () => (/* binding */ splitSignature),
  "G1": () => (/* binding */ stripZeros)
});

// UNUSED EXPORTS: hexStripZeros, zeroPad

// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/_version.js
const version = "bytes/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js



const logger = new lib_esm/* Logger */.Yd(version);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
        logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
        return "0x0";
    }
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
        offset++;
    }
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        let bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        }
        else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        }
        else {
            logger.throwArgumentError("invalid signature string", "signature", signature);
        }
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
                result.v += 27;
            }
            else {
                logger.throwArgumentError("signature invalid v byte", "signature", signature);
            }
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - (result.v % 2);
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) {
            bytes[32] |= 0x80;
        }
        result._vs = hexlify(bytes.slice(32, 64));
    }
    else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);
            if (result.recoveryParam == null) {
                result.recoveryParam = recoveryParam;
            }
            else if (result.recoveryParam !== recoveryParam) {
                logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) {
                result.s = s;
            }
            else if (result.s !== s) {
                logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) {
                logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            }
            else if (result.v === 0 || result.v === 1) {
                result.recoveryParam = result.v;
            }
            else {
                result.recoveryParam = 1 - (result.v % 2);
            }
        }
        else {
            if (result.v == null) {
                result.v = 27 + result.recoveryParam;
            }
            else {
                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));
                if (result.recoveryParam !== recId) {
                    logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
                }
            }
        }
        if (result.r == null || !isHexString(result.r)) {
            logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        }
        else {
            result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
            logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        }
        else {
            result.s = hexZeroPad(result.s, 32);
        }
        const vs = arrayify(result.s);
        if (vs[0] >= 128) {
            logger.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
            vs[0] |= 0x80;
        }
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) {
                logger.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) {
            result._vs = _vs;
        }
        else if (result._vs !== _vs) {
            logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        (signature.recoveryParam ? "0x1c" : "0x1b")
    ]));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 32235:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "id": () => (/* binding */ id)
/* harmony export */ });
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59256);
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71320);


function id(text) {
    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__/* .keccak256 */ .w)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__/* .toUtf8Bytes */ .Y0)(text));
}
//# sourceMappingURL=id.js.map

/***/ }),

/***/ 71173:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "m$": () => (/* binding */ HDNode),
  "cD": () => (/* binding */ defaultPath),
  "JJ": () => (/* binding */ entropyToMnemonic),
  "oy": () => (/* binding */ mnemonicToEntropy)
});

// UNUSED EXPORTS: getAccountPath, isValidMnemonic, mnemonicToSeed

// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/properties/lib.esm/index.js + 1 modules
var properties_lib_esm = __webpack_require__(84427);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/basex/lib.esm/index.js
/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */


class BaseX {
    constructor(alphabet) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "alphabet", alphabet);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "base", alphabet.length);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_alphabetMap", {});
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_leader", alphabet.charAt(0));
        // pre-compute lookup table
        for (let i = 0; i < alphabet.length; i++) {
            this._alphabetMap[alphabet.charAt(i)] = i;
        }
    }
    encode(value) {
        let source = (0,lib_esm/* arrayify */.lE)(value);
        if (source.length === 0) {
            return "";
        }
        let digits = [0];
        for (let i = 0; i < source.length; ++i) {
            let carry = source[i];
            for (let j = 0; j < digits.length; ++j) {
                carry += digits[j] << 8;
                digits[j] = carry % this.base;
                carry = (carry / this.base) | 0;
            }
            while (carry > 0) {
                digits.push(carry % this.base);
                carry = (carry / this.base) | 0;
            }
        }
        let string = "";
        // deal with leading zeros
        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
            string += this._leader;
        }
        // convert digits to a string
        for (let q = digits.length - 1; q >= 0; --q) {
            string += this.alphabet[digits[q]];
        }
        return string;
    }
    decode(value) {
        if (typeof (value) !== "string") {
            throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value.length === 0) {
            return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i = 0; i < value.length; i++) {
            let byte = this._alphabetMap[value[i]];
            if (byte === undefined) {
                throw new Error("Non-base" + this.base + " character");
            }
            let carry = byte;
            for (let j = 0; j < bytes.length; ++j) {
                carry += bytes[j] * this.base;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while (carry > 0) {
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        // deal with leading zeros
        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
            bytes.push(0);
        }
        return (0,lib_esm/* arrayify */.lE)(new Uint8Array(bytes.reverse()));
    }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

//console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/strings/lib.esm/utf8.js + 1 modules
var utf8 = __webpack_require__(71320);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
var pbkdf2 = __webpack_require__(55183);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/index.js + 2 modules
var signing_key_lib_esm = __webpack_require__(3378);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/sha2/lib.esm/sha2.js + 1 modules
var sha2 = __webpack_require__(58254);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/sha2/lib.esm/types.js
var types = __webpack_require__(21723);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/transactions/lib.esm/index.js + 3 modules
var transactions_lib_esm = __webpack_require__(11482);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/hash/lib.esm/id.js
var id = __webpack_require__(32235);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/wordlists/lib.esm/_version.js
const version = "wordlists/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/wordlists/lib.esm/wordlist.js

// This gets overridden by rollup
const exportWordlist = false;




const logger = new logger_lib_esm/* Logger */.Yd(version);
class Wordlist {
    constructor(locale) {
        logger.checkAbstract(new.target, Wordlist);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "locale", locale);
    }
    // Subclasses may override this
    split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
    }
    // Subclasses may override this
    join(words) {
        return words.join(" ");
    }
    static check(wordlist) {
        const words = [];
        for (let i = 0; i < 2048; i++) {
            const word = wordlist.getWord(i);
            /* istanbul ignore if */
            if (i !== wordlist.getWordIndex(word)) {
                return "0x";
            }
            words.push(word);
        }
        return (0,id.id)(words.join("\n") + "\n");
    }
    static register(lang, name) {
        if (!name) {
            name = lang.locale;
        }
        /* istanbul ignore if */
        if (exportWordlist) {
            try {
                const anyGlobal = window;
                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
                    if (!anyGlobal._ethers.wordlists[name]) {
                        (0,properties_lib_esm/* defineReadOnly */.zG)(anyGlobal._ethers.wordlists, name, lang);
                    }
                }
            }
            catch (error) { }
        }
    }
}
//# sourceMappingURL=wordlist.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/wordlists/lib.esm/lang-en.js


const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
    if (wordlist != null) {
        return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
}
class LangEn extends Wordlist {
    constructor() {
        super("en");
    }
    getWord(index) {
        loadWords(this);
        return wordlist[index];
    }
    getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
    }
}
const langEn = new LangEn();
Wordlist.register(langEn);

//# sourceMappingURL=lang-en.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/wordlists/lib.esm/wordlists.js


const wordlists = {
    en: langEn
};
//# sourceMappingURL=wordlists.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/hdnode/lib.esm/_version.js
const _version_version = "hdnode/5.6.2";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/hdnode/lib.esm/index.js













const lib_esm_logger = new logger_lib_esm/* Logger */.Yd(_version_version);
const N = bignumber/* BigNumber.from */.O$.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
// "Bitcoin seed"
const MasterSecret = (0,utf8/* toUtf8Bytes */.Y0)("Bitcoin seed");
const HardenedBit = 0x80000000;
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
    return ((1 << bits) - 1) << (8 - bits);
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
    return (1 << bits) - 1;
}
function bytes32(value) {
    return (0,lib_esm/* hexZeroPad */.$m)((0,lib_esm/* hexlify */.Dv)(value), 32);
}
function base58check(data) {
    return Base58.encode((0,lib_esm/* concat */.zo)([data, (0,lib_esm/* hexDataSlice */.p3)((0,sha2/* sha256 */.JQ)((0,sha2/* sha256 */.JQ)(data)), 0, 4)]));
}
function getWordlist(wordlist) {
    if (wordlist == null) {
        return wordlists.en;
    }
    if (typeof (wordlist) === "string") {
        const words = wordlists[wordlist];
        if (words == null) {
            lib_esm_logger.throwArgumentError("unknown locale", "wordlist", wordlist);
        }
        return words;
    }
    return wordlist;
}
const _constructorGuard = {};
const defaultPath = "m/44'/60'/0'/0/0";
;
class HDNode {
    /**
     *  This constructor should not be called directly.
     *
     *  Please use:
     *   - fromMnemonic
     *   - fromSeed
     */
    constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        /* istanbul ignore if */
        if (constructorGuard !== _constructorGuard) {
            throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
            const signingKey = new signing_key_lib_esm/* SigningKey */.Et(privateKey);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "privateKey", signingKey.privateKey);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "publicKey", signingKey.compressedPublicKey);
        }
        else {
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "privateKey", null);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "publicKey", (0,lib_esm/* hexlify */.Dv)(publicKey));
        }
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "parentFingerprint", parentFingerprint);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "fingerprint", (0,lib_esm/* hexDataSlice */.p3)((0,sha2/* ripemd160 */.bP)((0,sha2/* sha256 */.JQ)(this.publicKey)), 0, 4));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "address", (0,transactions_lib_esm/* computeAddress */.db)(this.publicKey));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "chainCode", chainCode);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "index", index);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "depth", depth);
        if (mnemonicOrPath == null) {
            // From a source that does not preserve the path (e.g. extended keys)
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "mnemonic", null);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "path", null);
        }
        else if (typeof (mnemonicOrPath) === "string") {
            // From a source that does not preserve the mnemonic (e.g. neutered)
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "mnemonic", null);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "path", mnemonicOrPath);
        }
        else {
            // From a fully qualified source
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "mnemonic", mnemonicOrPath);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "path", mnemonicOrPath.path);
        }
    }
    get extendedKey() {
        // We only support the mainnet values for now, but if anyone needs
        // testnet values, let me know. I believe current sentiment is that
        // we should always use mainnet, and use BIP-44 to derive the network
        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
        //   - Testnet: public=0x043587CF, private=0x04358394
        if (this.depth >= 256) {
            throw new Error("Depth too large!");
        }
        return base58check((0,lib_esm/* concat */.zo)([
            ((this.privateKey != null) ? "0x0488ADE4" : "0x0488B21E"),
            (0,lib_esm/* hexlify */.Dv)(this.depth),
            this.parentFingerprint,
            (0,lib_esm/* hexZeroPad */.$m)((0,lib_esm/* hexlify */.Dv)(this.index), 4),
            this.chainCode,
            ((this.privateKey != null) ? (0,lib_esm/* concat */.zo)(["0x00", this.privateKey]) : this.publicKey),
        ]));
    }
    neuter() {
        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(index) {
        if (index > 0xffffffff) {
            throw new Error("invalid index - " + String(index));
        }
        // Base path
        let path = this.path;
        if (path) {
            path += "/" + (index & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
            if (!this.privateKey) {
                throw new Error("cannot derive child of neutered node");
            }
            // Data = 0x00 || ser_256(k_par)
            data.set((0,lib_esm/* arrayify */.lE)(this.privateKey), 1);
            // Hardened path
            if (path) {
                path += "'";
            }
        }
        else {
            // Data = ser_p(point(k_par))
            data.set((0,lib_esm/* arrayify */.lE)(this.publicKey));
        }
        // Data += ser_32(i)
        for (let i = 24; i >= 0; i -= 8) {
            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);
        }
        const I = (0,lib_esm/* arrayify */.lE)((0,sha2/* computeHmac */.Gy)(types/* SupportedAlgorithm.sha512 */.p.sha512, this.chainCode, data));
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // The private key
        let ki = null;
        // The public key
        let Ki = null;
        if (this.privateKey) {
            ki = bytes32(bignumber/* BigNumber.from */.O$.from(IL).add(this.privateKey).mod(N));
        }
        else {
            const ek = new signing_key_lib_esm/* SigningKey */.Et((0,lib_esm/* hexlify */.Dv)(IL));
            Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
            mnemonicOrPath = Object.freeze({
                phrase: srcMnemonic.phrase,
                path: path,
                locale: (srcMnemonic.locale || "en")
            });
        }
        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
    }
    derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || (components[0] === "m" && this.depth !== 0)) {
            throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
            components.shift();
        }
        let result = this;
        for (let i = 0; i < components.length; i++) {
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
                const index = parseInt(component.substring(0, component.length - 1));
                if (index >= HardenedBit) {
                    throw new Error("invalid path index - " + component);
                }
                result = result._derive(HardenedBit + index);
            }
            else if (component.match(/^[0-9]+$/)) {
                const index = parseInt(component);
                if (index >= HardenedBit) {
                    throw new Error("invalid path index - " + component);
                }
                result = result._derive(index);
            }
            else {
                throw new Error("invalid path component - " + component);
            }
        }
        return result;
    }
    static _fromSeed(seed, mnemonic) {
        const seedArray = (0,lib_esm/* arrayify */.lE)(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
            throw new Error("invalid seed");
        }
        const I = (0,lib_esm/* arrayify */.lE)((0,sha2/* computeHmac */.Gy)(types/* SupportedAlgorithm.sha512 */.p.sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
    }
    static fromMnemonic(mnemonic, password, wordlist) {
        // If a locale name was passed in, find the associated wordlist
        wordlist = getWordlist(wordlist);
        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
            phrase: mnemonic,
            path: "m",
            locale: wordlist.locale
        });
    }
    static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
    }
    static fromExtendedKey(extendedKey) {
        const bytes = Base58.decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
            lib_esm_logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes[4];
        const parentFingerprint = (0,lib_esm/* hexlify */.Dv)(bytes.slice(5, 9));
        const index = parseInt((0,lib_esm/* hexlify */.Dv)(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = (0,lib_esm/* hexlify */.Dv)(bytes.slice(13, 45));
        const key = bytes.slice(45, 78);
        switch ((0,lib_esm/* hexlify */.Dv)(bytes.slice(0, 4))) {
            // Public Key
            case "0x0488b21e":
            case "0x043587cf":
                return new HDNode(_constructorGuard, null, (0,lib_esm/* hexlify */.Dv)(key), parentFingerprint, chainCode, index, depth, null);
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
                if (key[0] !== 0) {
                    break;
                }
                return new HDNode(_constructorGuard, (0,lib_esm/* hexlify */.Dv)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return lib_esm_logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
}
function mnemonicToSeed(mnemonic, password) {
    if (!password) {
        password = "";
    }
    const salt = (0,utf8/* toUtf8Bytes */.Y0)("mnemonic" + password, utf8/* UnicodeNormalizationForm.NFKD */.Uj.NFKD);
    return (0,pbkdf2/* pbkdf2 */.n)((0,utf8/* toUtf8Bytes */.Y0)(mnemonic, utf8/* UnicodeNormalizationForm.NFKD */.Uj.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = getWordlist(wordlist);
    lib_esm_logger.checkNormalize();
    const words = wordlist.split(mnemonic);
    if ((words.length % 3) !== 0) {
        throw new Error("invalid mnemonic");
    }
    const entropy = (0,lib_esm/* arrayify */.lE)(new Uint8Array(Math.ceil(11 * words.length / 8)));
    let offset = 0;
    for (let i = 0; i < words.length; i++) {
        let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
        if (index === -1) {
            throw new Error("invalid mnemonic");
        }
        for (let bit = 0; bit < 11; bit++) {
            if (index & (1 << (10 - bit))) {
                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));
            }
            offset++;
        }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = (0,lib_esm/* arrayify */.lE)((0,sha2/* sha256 */.JQ)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
        throw new Error("invalid checksum");
    }
    return (0,lib_esm/* hexlify */.Dv)(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
    wordlist = getWordlist(wordlist);
    entropy = (0,lib_esm/* arrayify */.lE)(entropy);
    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {
        throw new Error("invalid entropy");
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i++) {
        // Consume the whole byte (with still more to go)
        if (remainingBits > 8) {
            indices[indices.length - 1] <<= 8;
            indices[indices.length - 1] |= entropy[i];
            remainingBits -= 8;
            // This byte will complete an 11-bit index
        }
        else {
            indices[indices.length - 1] <<= remainingBits;
            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
            // Start the next word
            indices.push(entropy[i] & getLowerMask(8 - remainingBits));
            remainingBits += 3;
        }
    }
    // Compute the checksum bits
    const checksumBits = entropy.length / 4;
    const checksum = (0,lib_esm/* arrayify */.lE)((0,sha2/* sha256 */.JQ)(entropy))[0] & getUpperMask(checksumBits);
    // Shift the checksum into the word indices
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));
    return wordlist.join(indices.map((index) => wordlist.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
        return true;
    }
    catch (error) { }
    return false;
}
function getAccountPath(index) {
    if (typeof (index) !== "number" || index < 0 || index >= HardenedBit || index % 1) {
        lib_esm_logger.throwArgumentError("invalid account index", "index", index);
    }
    return `m/44'/60'/${index}'/0/0`;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 59256:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": () => (/* binding */ keccak256)
/* harmony export */ });
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83669);
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75398);



function keccak256(data) {
    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__/* .arrayify */ .lE)(data));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57036:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Yd": () => (/* binding */ Logger)
});

// UNUSED EXPORTS: ErrorCode, LogLevel

;// CONCATENATED MODULE: ../../node_modules/@ethersproject/logger/lib.esm/_version.js
const version = "logger/5.6.0";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];

let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
;
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 55183:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": () => (/* binding */ pbkdf2)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75398);
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58254);



function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
    password = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__/* .arrayify */ .lE)(password);
    salt = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__/* .arrayify */ .lE)(salt);
    let hLen;
    let l = 1;
    const DK = new Uint8Array(keylen);
    const block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    //salt.copy(block1, 0, 0, salt.length)
    let r;
    let T;
    for (let i = 1; i <= l; i++) {
        //block1.writeUInt32BE(i, salt.length)
        block1[salt.length] = (i >> 24) & 0xff;
        block1[salt.length + 1] = (i >> 16) & 0xff;
        block1[salt.length + 2] = (i >> 8) & 0xff;
        block1[salt.length + 3] = i & 0xff;
        //let U = createHmac(password).update(block1).digest();
        let U = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__/* .arrayify */ .lE)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__/* .computeHmac */ .Gy)(hashAlgorithm, password, block1));
        if (!hLen) {
            hLen = U.length;
            T = new Uint8Array(hLen);
            l = Math.ceil(keylen / hLen);
            r = keylen - (l - 1) * hLen;
        }
        //U.copy(T, 0, 0, hLen)
        T.set(U);
        for (let j = 1; j < iterations; j++) {
            //U = createHmac(password).update(U).digest();
            U = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__/* .arrayify */ .lE)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__/* .computeHmac */ .Gy)(hashAlgorithm, password, U));
            for (let k = 0; k < hLen; k++)
                T[k] ^= U[k];
        }
        const destPos = (i - 1) * hLen;
        const len = (i === l ? r : hLen);
        //T.copy(DK, destPos, 0, len)
        DK.set((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__/* .arrayify */ .lE)(T).slice(0, len), destPos);
    }
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__/* .hexlify */ .Dv)(DK);
}
//# sourceMappingURL=pbkdf2.js.map

/***/ }),

/***/ 84427:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "dk": () => (/* binding */ Description),
  "uj": () => (/* binding */ checkProperties),
  "p$": () => (/* binding */ deepCopy),
  "zG": () => (/* binding */ defineReadOnly),
  "tu": () => (/* binding */ getStatic),
  "mE": () => (/* binding */ resolveProperties),
  "DC": () => (/* binding */ shallowCopy)
});

// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/properties/lib.esm/_version.js
const version = "properties/5.6.0";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/properties/lib.esm/index.js

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const logger = new lib_esm/* Logger */.Yd(version);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof (object) !== "object") {
        logger.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key) => {
        if (!properties[key]) {
            logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 62191:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "O": () => (/* binding */ randomBytes)
});

// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/random/lib.esm/_version.js
const version = "random/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/random/lib.esm/random.js




const logger = new logger_lib_esm/* Logger */.Yd(version);
// Debugging line for testing browser lib in node
//const window = { crypto: { getRandomValues: () => { } } };
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
function getGlobal() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
}
;
const anyGlobal = getGlobal();
let random_crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!random_crypto || !random_crypto.getRandomValues) {
    logger.warn("WARNING: Missing strong random number source");
    random_crypto = {
        getRandomValues: function (buffer) {
            return logger.throwError("no secure random source avaialble", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "crypto.getRandomValues"
            });
        }
    };
}
function randomBytes(length) {
    if (length <= 0 || length > 1024 || (length % 1) || length != length) {
        logger.throwArgumentError("invalid length", "length", length);
    }
    const result = new Uint8Array(length);
    random_crypto.getRandomValues(result);
    return (0,lib_esm/* arrayify */.lE)(result);
}
;
//# sourceMappingURL=random.js.map

/***/ }),

/***/ 58254:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Gy": () => (/* binding */ computeHmac),
  "bP": () => (/* binding */ ripemd160),
  "JQ": () => (/* binding */ sha256)
});

// UNUSED EXPORTS: sha512

// EXTERNAL MODULE: ../../node_modules/hash.js/lib/hash.js
var lib_hash = __webpack_require__(34485);
var hash_default = /*#__PURE__*/__webpack_require__.n(lib_hash);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/sha2/lib.esm/types.js
var types = __webpack_require__(21723);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/sha2/lib.esm/_version.js
const version = "sha2/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/sha2/lib.esm/sha2.js


//const _ripemd160 = _hash.ripemd160;




const logger = new logger_lib_esm/* Logger */.Yd(version);
function ripemd160(data) {
    return "0x" + (hash_default().ripemd160().update((0,lib_esm/* arrayify */.lE)(data)).digest("hex"));
}
function sha256(data) {
    return "0x" + (hash_default().sha256().update((0,lib_esm/* arrayify */.lE)(data)).digest("hex"));
}
function sha512(data) {
    return "0x" + (hash.sha512().update(arrayify(data)).digest("hex"));
}
function computeHmac(algorithm, key, data) {
    if (!types/* SupportedAlgorithm */.p[algorithm]) {
        logger.throwError("unsupported algorithm " + algorithm, logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
            operation: "hmac",
            algorithm: algorithm
        });
    }
    return "0x" + hash_default().hmac((hash_default())[algorithm], (0,lib_esm/* arrayify */.lE)(key)).update((0,lib_esm/* arrayify */.lE)(data)).digest("hex");
}
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ 21723:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "p": () => (/* binding */ SupportedAlgorithm)
/* harmony export */ });
var SupportedAlgorithm;
(function (SupportedAlgorithm) {
    SupportedAlgorithm["sha256"] = "sha256";
    SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 3378:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Et": () => (/* binding */ SigningKey),
  "VW": () => (/* binding */ computePublicKey),
  "LO": () => (/* binding */ recoverPublicKey)
});

// EXTERNAL MODULE: ../../node_modules/bn.js/lib/bn.js
var bn = __webpack_require__(62197);
var bn_default = /*#__PURE__*/__webpack_require__.n(bn);
// EXTERNAL MODULE: ../../node_modules/hash.js/lib/hash.js
var hash = __webpack_require__(34485);
var hash_default = /*#__PURE__*/__webpack_require__.n(hash);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js



var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var minimalisticAssert = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var utils_1 = createCommonjsModule(function (module, exports) {
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};
});

var utils_1$1 = createCommonjsModule(function (module, exports) {
'use strict';

var utils = exports;




utils.assert = minimalisticAssert;
utils.toArray = utils_1.toArray;
utils.zero2 = utils_1.zero2;
utils.toHex = utils_1.toHex;
utils.encode = utils_1.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new (bn_default())(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;
});

'use strict';



var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new (bn_default())(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn_default().red(conf.prime) : bn_default().mont(this.p);

  // Useful for many curves
  this.zero = new (bn_default())(0).toRed(this.red);
  this.one = new (bn_default())(1).toRed(this.red);
  this.two = new (bn_default())(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new (bn_default())(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert$1(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

'use strict';






var assert$2 = utils_1$1.assert;

function ShortCurve(conf) {
  base.call(this, 'short', conf);

  this.a = new (bn_default())(conf.a, 16).toRed(this.red);
  this.b = new (bn_default())(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new (bn_default())(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new (bn_default())(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new (bn_default())(vec.a, 16),
        b: new (bn_default())(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn_default().mont(num);
  var tinv = new (bn_default())(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new (bn_default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new (bn_default())(1);
  var y1 = new (bn_default())(0);
  var x2 = new (bn_default())(0);
  var y2 = new (bn_default())(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new (bn_default())(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new (bn_default())(x, 16);
    this.y = new (bn_default())(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new (bn_default())(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new (bn_default())(0);
  } else {
    this.x = new (bn_default())(x, 16);
    this.y = new (bn_default())(y, 16);
    this.z = new (bn_default())(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new (bn_default())(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var curve_1 = createCommonjsModule(function (module, exports) {
'use strict';

var curve = exports;

curve.base = base;
curve.short = short_1;
curve.mont = /*RicMoo:ethers:require(./mont)*/(null);
curve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);
});

var curves_1 = createCommonjsModule(function (module, exports) {
'use strict';

var curves = exports;





var assert = utils_1$1.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve_1.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve_1.edwards(options);
  else
    this.curve = new curve_1.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: (hash_default()).sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: (hash_default()).sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: (hash_default()).sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: (hash_default()).sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: (hash_default()).sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: (hash_default()).sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: (hash_default()).sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: (hash_default()).sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});
});

'use strict';





function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new (hash_default()).hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils_1.toArray(entropy, entropyEnc);
  add = utils_1.toArray(add, addEnc);

  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils_1.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils_1.encode(res, enc);
};

'use strict';



var assert$3 = utils_1$1.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new (bn_default())(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$3(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert$3(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert$3(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

'use strict';




var assert$4 = utils_1$1.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new (bn_default())(options.r, 16);
  this.s = new (bn_default())(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new (bn_default())(r);
  this.s = new (bn_default())(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};

'use strict';





var rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });
var assert$5 = utils_1$1.assert;




function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),
      'Unknown curve ' + options);

    options = curves_1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new (bn_default())(2));
  for (;;) {
    var priv = new (bn_default())(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new (bn_default())(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new (bn_default())(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new (bn_default())(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature$1, key, enc) {
  msg = this._truncateToN(new (bn_default())(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature$1 = new signature(signature$1, 'hex');

  // Perform primitive values validation
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, 'The recovery param is more than two bits');
  signature$1 = new signature(signature$1, enc);

  var n = this.n;
  var e = new (bn_default())(msg);
  var r = signature$1.r;
  var s = signature$1.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

var elliptic_1 = createCommonjsModule(function (module, exports) {
'use strict';

var elliptic = exports;

elliptic.version = /*RicMoo:ethers*/{ version: "6.5.4" }.version;
elliptic.utils = utils_1$1;
elliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });
elliptic.curve = curve_1;
elliptic.curves = curves_1;

// Protocols
elliptic.ec = ec;
elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);
});

var EC$1 = elliptic_1.ec;


//# sourceMappingURL=elliptic.js.map

// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/properties/lib.esm/index.js + 1 modules
var properties_lib_esm = __webpack_require__(84427);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/_version.js
const version = "signing-key/5.6.2";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/index.js






const logger = new logger_lib_esm/* Logger */.Yd(version);
let _curve = null;
function getCurve() {
    if (!_curve) {
        _curve = new EC$1("secp256k1");
    }
    return _curve;
}
class SigningKey {
    constructor(privateKey) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "curve", "secp256k1");
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "privateKey", (0,lib_esm/* hexlify */.Dv)(privateKey));
        if ((0,lib_esm/* hexDataLength */.E1)(this.privateKey) !== 32) {
            logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        const keyPair = getCurve().keyFromPrivate((0,lib_esm/* arrayify */.lE)(this.privateKey));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_isSigningKey", true);
    }
    _addPoint(other) {
        const p0 = getCurve().keyFromPublic((0,lib_esm/* arrayify */.lE)(this.publicKey));
        const p1 = getCurve().keyFromPublic((0,lib_esm/* arrayify */.lE)(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
        const keyPair = getCurve().keyFromPrivate((0,lib_esm/* arrayify */.lE)(this.privateKey));
        const digestBytes = (0,lib_esm/* arrayify */.lE)(digest);
        if (digestBytes.length !== 32) {
            logger.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature = keyPair.sign(digestBytes, { canonical: true });
        return (0,lib_esm/* splitSignature */.N)({
            recoveryParam: signature.recoveryParam,
            r: (0,lib_esm/* hexZeroPad */.$m)("0x" + signature.r.toString(16), 32),
            s: (0,lib_esm/* hexZeroPad */.$m)("0x" + signature.s.toString(16), 32),
        });
    }
    computeSharedSecret(otherKey) {
        const keyPair = getCurve().keyFromPrivate((0,lib_esm/* arrayify */.lE)(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic((0,lib_esm/* arrayify */.lE)(computePublicKey(otherKey)));
        return (0,lib_esm/* hexZeroPad */.$m)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
        return !!(value && value._isSigningKey);
    }
}
function recoverPublicKey(digest, signature) {
    const sig = (0,lib_esm/* splitSignature */.N)(signature);
    const rs = { r: (0,lib_esm/* arrayify */.lE)(sig.r), s: (0,lib_esm/* arrayify */.lE)(sig.s) };
    return "0x" + getCurve().recoverPubKey((0,lib_esm/* arrayify */.lE)(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
    const bytes = (0,lib_esm/* arrayify */.lE)(key);
    if (bytes.length === 32) {
        const signingKey = new SigningKey(bytes);
        if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
    }
    else if (bytes.length === 33) {
        if (compressed) {
            return (0,lib_esm/* hexlify */.Dv)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    }
    else if (bytes.length === 65) {
        if (!compressed) {
            return (0,lib_esm/* hexlify */.Dv)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 71320:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Uj": () => (/* binding */ UnicodeNormalizationForm),
  "Y0": () => (/* binding */ toUtf8Bytes),
  "ZN": () => (/* binding */ toUtf8String)
});

// UNUSED EXPORTS: Utf8ErrorFuncs, Utf8ErrorReason, _toEscapedUtf8String, _toUtf8String, toUtf8CodePoints

// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/strings/lib.esm/_version.js
const version = "strings/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/strings/lib.esm/utf8.js




const logger = new logger_lib_esm/* Logger */.Yd(version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = (0,lib_esm/* arrayify */.lE)(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return (0,lib_esm/* arrayify */.lE)(result);
}
;
function escapeChar(value) {
    const hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ 11482:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "db": () => (/* binding */ computeAddress),
  "RJ": () => (/* binding */ recoverAddress),
  "qC": () => (/* binding */ serialize)
});

// UNUSED EXPORTS: TransactionTypes, accessListify, parse

// EXTERNAL MODULE: ../../node_modules/@ethersproject/address/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(58194);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var bytes_lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(59256);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/properties/lib.esm/index.js + 1 modules
var properties_lib_esm = __webpack_require__(84427);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/rlp/lib.esm/_version.js
const version = "rlp/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/rlp/lib.esm/index.js

//See: https://github.com/ethereum/wiki/wiki/RLP



const logger = new logger_lib_esm/* Logger */.Yd(version);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!(0,bytes_lib_esm/* isBytesLike */.Zq)(object)) {
        logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call((0,bytes_lib_esm/* arrayify */.lE)(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return (0,bytes_lib_esm/* hexlify */.Dv)(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
}
function decode(data) {
    const bytes = arrayify(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/index.js + 2 modules
var signing_key_lib_esm = __webpack_require__(3378);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/transactions/lib.esm/_version.js
const _version_version = "transactions/5.6.2";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/transactions/lib.esm/index.js











const lib_esm_logger = new logger_lib_esm/* Logger */.Yd(_version_version);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
;
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return getAddress(value);
}
function handleNumber(value) {
    if (value === "0x") {
        return Zero;
    }
    return BigNumber.from(value);
}
// Legacy Transaction Fields
const transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" },
];
const allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true
};
function computeAddress(key) {
    const publicKey = (0,signing_key_lib_esm/* computePublicKey */.VW)(key);
    return (0,lib_esm/* getAddress */.Kn)((0,bytes_lib_esm/* hexDataSlice */.p3)((0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* hexDataSlice */.p3)(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
    return computeAddress((0,signing_key_lib_esm/* recoverPublicKey */.LO)((0,bytes_lib_esm/* arrayify */.lE)(digest), signature));
}
function formatNumber(value, name) {
    const result = (0,bytes_lib_esm/* stripZeros */.G1)(bignumber/* BigNumber.from */.O$.from(value).toHexString());
    if (result.length > 32) {
        lib_esm_logger.throwArgumentError("invalid length for " + name, ("transaction:" + name), value);
    }
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: (0,lib_esm/* getAddress */.Kn)(addr),
        storageKeys: (storageKeys || []).map((storageKey, index) => {
            if ((0,bytes_lib_esm/* hexDataLength */.E1)(storageKey) !== 32) {
                lib_esm_logger.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    lib_esm_logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        const gasPrice = bignumber/* BigNumber.from */.O$.from(transaction.gasPrice);
        const maxFeePerGas = bignumber/* BigNumber.from */.O$.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
            lib_esm_logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                gasPrice, maxFeePerGas
            });
        }
    }
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? (0,lib_esm/* getAddress */.Kn)(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = (0,bytes_lib_esm/* splitSignature */.N)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.r));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.s));
    }
    return (0,bytes_lib_esm/* hexConcat */.xs)(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature) {
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? (0,lib_esm/* getAddress */.Kn)(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = (0,bytes_lib_esm/* splitSignature */.N)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.r));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.s));
    }
    return (0,bytes_lib_esm/* hexConcat */.xs)(["0x01", encode(fields)]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    (0,properties_lib_esm/* checkProperties */.uj)(transaction, allowedTransactionKeys);
    const raw = [];
    transactionFields.forEach(function (fieldInfo) {
        let value = transaction[fieldInfo.name] || ([]);
        const options = {};
        if (fieldInfo.numeric) {
            options.hexPad = "left";
        }
        value = (0,bytes_lib_esm/* arrayify */.lE)((0,bytes_lib_esm/* hexlify */.Dv)(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
            lib_esm_logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
        }
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = (0,bytes_lib_esm/* stripZeros */.G1)(value);
            if (value.length > fieldInfo.maxLength) {
                lib_esm_logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
            }
        }
        raw.push((0,bytes_lib_esm/* hexlify */.Dv)(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof (chainId) !== "number") {
            lib_esm_logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
    }
    else if (signature && !(0,bytes_lib_esm/* isBytesLike */.Zq)(signature) && signature.v > 28) {
        // No chainId provided, but the signature is signing with EIP-155; derive chainId
        chainId = Math.floor((signature.v - 35) / 2);
    }
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push((0,bytes_lib_esm/* hexlify */.Dv)(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) {
        return encode(raw);
    }
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    const sig = (0,bytes_lib_esm/* splitSignature */.N)(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    let v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) {
            lib_esm_logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
    }
    else if (sig.v !== v) {
        lib_esm_logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
    raw.push((0,bytes_lib_esm/* hexlify */.Dv)(v));
    raw.push((0,bytes_lib_esm/* stripZeros */.G1)((0,bytes_lib_esm/* arrayify */.lE)(sig.r)));
    raw.push((0,bytes_lib_esm/* stripZeros */.G1)((0,bytes_lib_esm/* arrayify */.lE)(sig.s)));
    return encode(raw);
}
function serialize(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
            lib_esm_logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch (transaction.type) {
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
        default:
            break;
    }
    return lib_esm_logger.throwError(`unsupported transaction type: ${transaction.type}`, logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
function _parseEipSignature(tx, fields, serialize) {
    try {
        const recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
            throw new Error("bad recid");
        }
        tx.v = recid;
    }
    catch (error) {
        lib_esm_logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = hexZeroPad(fields[1], 32);
    tx.s = hexZeroPad(fields[2], 32);
    try {
        const digest = keccak256(serialize(tx));
        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    }
    catch (error) { }
}
function _parseEip1559(payload) {
    const transaction = RLP.decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
        lib_esm_logger.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
    }
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8]),
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) {
        return tx;
    }
    tx.hash = keccak256(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    const transaction = RLP.decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
        lib_esm_logger.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
    }
    const tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) {
        return tx;
    }
    tx.hash = keccak256(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    const transaction = RLP.decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
        lib_esm_logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    const tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) {
        return tx;
    }
    try {
        tx.v = BigNumber.from(transaction[6]).toNumber();
    }
    catch (error) {
        // @TODO: What makes snese to do? The v is too big
        return tx;
    }
    tx.r = hexZeroPad(transaction[7], 32);
    tx.s = hexZeroPad(transaction[8], 32);
    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    }
    else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        let recoveryParam = tx.v - 27;
        const raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push(hexlify(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        const digest = keccak256(RLP.encode(raw));
        try {
            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });
        }
        catch (error) { }
        tx.hash = keccak256(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    const payload = arrayify(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) {
        return _parse(payload);
    }
    // Typed Transaction (EIP-2718)
    switch (payload[0]) {
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
        default:
            break;
    }
    return lib_esm_logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 77962:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "bM": () => (/* binding */ formatUnits),
  "vz": () => (/* binding */ parseUnits)
});

// UNUSED EXPORTS: commify, formatEther, parseEther

// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/_version.js
var _version = __webpack_require__(43495);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js




const logger = new logger_lib_esm/* Logger */.Yd(_version/* version */.i);

const _constructorGuard = {};
const Zero = bignumber/* BigNumber.from */.O$.from(0);
const NegativeOne = bignumber/* BigNumber.from */.O$.from(-1);
function throwFault(message, fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value !== undefined) {
        params.value = value;
    }
    return logger.throwError(message, logger_lib_esm/* Logger.errors.NUMERIC_FAULT */.Yd.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while (zeros.length < 256) {
    zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof (decimals) !== "number") {
        try {
            decimals = bignumber/* BigNumber.from */.O$.from(decimals).toNumber();
        }
        catch (e) { }
    }
    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return ("1" + zeros.substring(0, decimals));
    }
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = bignumber/* BigNumber.from */.O$.from(value);
    const negative = value.lt(Zero);
    if (negative) {
        value = value.mul(NegativeOne);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
    }
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
        value = whole;
    }
    else {
        value = whole + "." + fraction;
    }
    if (negative) {
        value = "-" + value;
    }
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof (value) !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger.throwArgumentError("invalid decimal value", "value", value);
    }
    // Is it negative?
    const negative = (value.substring(0, 1) === "-");
    if (negative) {
        value = value.substring(1);
    }
    if (value === ".") {
        logger.throwArgumentError("missing value", "value", value);
    }
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) {
        logger.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
        whole = "0";
    }
    if (!fraction) {
        fraction = "0";
    }
    // Trim trailing zeros
    while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
    }
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") {
        fraction = "0";
    }
    // Fully pad the string with zeros to get to wei
    while (fraction.length < multiplier.length - 1) {
        fraction += "0";
    }
    const wholeValue = bignumber/* BigNumber.from */.O$.from(whole);
    const fractionValue = bignumber/* BigNumber.from */.O$.from(fraction);
    let wei = (wholeValue.mul(multiplier)).add(fractionValue);
    if (negative) {
        wei = wei.mul(NegativeOne);
    }
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) {
            return value;
        }
        if (typeof (value) === "number") {
            value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof (value) === "string") {
            if (value === "fixed") {
                // defaults...
            }
            else if (value === "ufixed") {
                signed = false;
            }
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                    logger.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = (match[1] !== "u");
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            const check = (key, type, defaultValue) => {
                if (value[key] == null) {
                    return defaultValue;
                }
                if (typeof (value[key]) !== type) {
                    logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
            logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
            logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) {
            logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || (decimals % 1)) {
            logger.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
            return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return (this._value === "0.0" || this._value === "0");
    }
    isNegative() {
        return (this._value[0] === "-");
    }
    toString() { return this._value; }
    toHexString(width) {
        if (width == null) {
            return this._hex;
        }
        if (width % 8) {
            logger.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = bignumber/* BigNumber.from */.O$.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return (0,lib_esm/* hexZeroPad */.$m)(hex, width / 8);
    }
    toUnsafeFloat() { return parseFloat(this.toString()); }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !(0,bignumber/* isBigNumberish */.Zm)(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) {
            decimals = 0;
        }
        if (format == null) {
            format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
        }
        else {
            hex = numeric.toHexString();
            hex = (0,lib_esm/* hexZeroPad */.$m)(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if ((0,lib_esm/* arrayify */.lE)(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
        }
        let numeric = bignumber/* BigNumber.from */.O$.from(value);
        if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof (value) === "string") {
            return FixedNumber.fromString(value, format);
        }
        if ((0,lib_esm/* isBytes */._t)(value)) {
            return FixedNumber.fromBytes(value, format);
        }
        try {
            return FixedNumber.fromValue(value, 0, format);
        }
        catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== logger_lib_esm/* Logger.errors.INVALID_ARGUMENT */.Yd.errors.INVALID_ARGUMENT) {
                throw error;
            }
        }
        return logger.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
//# sourceMappingURL=fixednumber.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/units/lib.esm/_version.js
const version = "units/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/units/lib.esm/index.js




const lib_esm_logger = new logger_lib_esm/* Logger */.Yd(version);
const names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether",
];
// Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.
function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === "." || value === "-.") {
        lib_esm_logger.throwArgumentError("invalid value", "value", value);
    }
    // Make sure we have at least one whole digit (0 if none)
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
    }
    // Make sure we have at least 1 whole digit with no leading zeros
    while (whole.substring(0, 1) === "0") {
        whole = whole.substring(1);
    }
    if (whole === "") {
        whole = "0";
    }
    let suffix = "";
    if (comps.length === 2) {
        suffix = "." + (comps[1] || "0");
    }
    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
        suffix = suffix.substring(0, suffix.length - 1);
    }
    const formatted = [];
    while (whole.length) {
        if (whole.length <= 3) {
            formatted.unshift(whole);
            break;
        }
        else {
            const index = whole.length - 3;
            formatted.unshift(whole.substring(index));
            whole = whole.substring(0, index);
        }
    }
    return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
    if (typeof (unitName) === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) {
            unitName = 3 * index;
        }
    }
    return formatFixed(value, (unitName != null) ? unitName : 18);
}
function parseUnits(value, unitName) {
    if (typeof (value) !== "string") {
        lib_esm_logger.throwArgumentError("value must be a string", "value", value);
    }
    if (typeof (unitName) === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) {
            unitName = 3 * index;
        }
    }
    return parseFixed(value, (unitName != null) ? unitName : 18);
}
function formatEther(wei) {
    return formatUnits(wei, 18);
}
function parseEther(ether) {
    return parseUnits(ether, 18);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 15842:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];

__webpack_unused_export__ = true;
var errors_1 = __webpack_require__(9341);
var Tag = 0x05;
function asUInt16BE(value) {
    var b = Buffer.alloc(2);
    b.writeUInt16BE(value, 0);
    return b;
}
var initialAcc = {
    data: Buffer.alloc(0),
    dataLength: 0,
    sequence: 0
};
/**
 *
 */
var createHIDframing = function (channel, packetSize) {
    return {
        makeBlocks: function (apdu) {
            var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);
            var blockSize = packetSize - 5;
            var nbBlocks = Math.ceil(data.length / blockSize);
            data = Buffer.concat([
                data,
                Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),
            ]);
            var blocks = [];
            for (var i = 0; i < nbBlocks; i++) {
                var head = Buffer.alloc(5);
                head.writeUInt16BE(channel, 0);
                head.writeUInt8(Tag, 2);
                head.writeUInt16BE(i, 3);
                var chunk = data.slice(i * blockSize, (i + 1) * blockSize);
                blocks.push(Buffer.concat([head, chunk]));
            }
            return blocks;
        },
        reduceResponse: function (acc, chunk) {
            var _a = acc || initialAcc, data = _a.data, dataLength = _a.dataLength, sequence = _a.sequence;
            if (chunk.readUInt16BE(0) !== channel) {
                throw new errors_1.TransportError("Invalid channel", "InvalidChannel");
            }
            if (chunk.readUInt8(2) !== Tag) {
                throw new errors_1.TransportError("Invalid tag", "InvalidTag");
            }
            if (chunk.readUInt16BE(3) !== sequence) {
                throw new errors_1.TransportError("Invalid sequence", "InvalidSequence");
            }
            if (!acc) {
                dataLength = chunk.readUInt16BE(5);
            }
            sequence++;
            var chunkData = chunk.slice(acc ? 5 : 7);
            data = Buffer.concat([data, chunkData]);
            if (data.length > dataLength) {
                data = data.slice(0, dataLength);
            }
            return {
                data: data,
                dataLength: dataLength,
                sequence: sequence
            };
        },
        getReducedResult: function (acc) {
            if (acc && acc.dataLength === acc.data.length) {
                return acc.data;
            }
        }
    };
};
exports.Z = createHIDframing;
//# sourceMappingURL=hid-framing.js.map

/***/ }),

/***/ 9341:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AccountNameRequiredError": () => (/* binding */ AccountNameRequiredError),
  "AccountNotSupported": () => (/* binding */ AccountNotSupported),
  "AmountRequired": () => (/* binding */ AmountRequired),
  "BluetoothRequired": () => (/* binding */ BluetoothRequired),
  "BtcUnmatchedApp": () => (/* binding */ BtcUnmatchedApp),
  "CantOpenDevice": () => (/* binding */ CantOpenDevice),
  "CantScanQRCode": () => (/* binding */ CantScanQRCode),
  "CashAddrNotSupported": () => (/* binding */ CashAddrNotSupported),
  "CurrencyNotSupported": () => (/* binding */ CurrencyNotSupported),
  "DBNotReset": () => (/* binding */ DBNotReset),
  "DBWrongPassword": () => (/* binding */ DBWrongPassword),
  "DeviceAppVerifyNotSupported": () => (/* binding */ DeviceAppVerifyNotSupported),
  "DeviceGenuineSocketEarlyClose": () => (/* binding */ DeviceGenuineSocketEarlyClose),
  "DeviceHalted": () => (/* binding */ DeviceHalted),
  "DeviceInOSUExpected": () => (/* binding */ DeviceInOSUExpected),
  "DeviceNameInvalid": () => (/* binding */ DeviceNameInvalid),
  "DeviceNotGenuineError": () => (/* binding */ DeviceNotGenuineError),
  "DeviceOnDashboardExpected": () => (/* binding */ DeviceOnDashboardExpected),
  "DeviceOnDashboardUnexpected": () => (/* binding */ DeviceOnDashboardUnexpected),
  "DeviceShouldStayInApp": () => (/* binding */ DeviceShouldStayInApp),
  "DeviceSocketFail": () => (/* binding */ DeviceSocketFail),
  "DeviceSocketNoBulkStatus": () => (/* binding */ DeviceSocketNoBulkStatus),
  "DisconnectedDevice": () => (/* binding */ DisconnectedDevice),
  "DisconnectedDeviceDuringOperation": () => (/* binding */ DisconnectedDeviceDuringOperation),
  "ETHAddressNonEIP": () => (/* binding */ ETHAddressNonEIP),
  "EnpointConfigError": () => (/* binding */ EnpointConfigError),
  "EthAppPleaseEnableContractData": () => (/* binding */ EthAppPleaseEnableContractData),
  "FeeEstimationFailed": () => (/* binding */ FeeEstimationFailed),
  "FeeNotLoaded": () => (/* binding */ FeeNotLoaded),
  "FeeRequired": () => (/* binding */ FeeRequired),
  "FeeTooHigh": () => (/* binding */ FeeTooHigh),
  "FirmwareNotRecognized": () => (/* binding */ FirmwareNotRecognized),
  "FirmwareOrAppUpdateRequired": () => (/* binding */ FirmwareOrAppUpdateRequired),
  "GasLessThanEstimate": () => (/* binding */ GasLessThanEstimate),
  "GenuineCheckFailed": () => (/* binding */ GenuineCheckFailed),
  "HardResetFail": () => (/* binding */ HardResetFail),
  "InvalidAddress": () => (/* binding */ InvalidAddress),
  "InvalidAddressBecauseDestinationIsAlsoSource": () => (/* binding */ InvalidAddressBecauseDestinationIsAlsoSource),
  "InvalidXRPTag": () => (/* binding */ InvalidXRPTag),
  "LatestMCUInstalledError": () => (/* binding */ LatestMCUInstalledError),
  "LedgerAPI4xx": () => (/* binding */ LedgerAPI4xx),
  "LedgerAPI5xx": () => (/* binding */ LedgerAPI5xx),
  "LedgerAPIError": () => (/* binding */ LedgerAPIError),
  "LedgerAPIErrorWithMessage": () => (/* binding */ LedgerAPIErrorWithMessage),
  "LedgerAPINotAvailable": () => (/* binding */ LedgerAPINotAvailable),
  "MCUNotGenuineToDashboard": () => (/* binding */ MCUNotGenuineToDashboard),
  "ManagerAppAlreadyInstalledError": () => (/* binding */ ManagerAppAlreadyInstalledError),
  "ManagerAppDepInstallRequired": () => (/* binding */ ManagerAppDepInstallRequired),
  "ManagerAppDepUninstallRequired": () => (/* binding */ ManagerAppDepUninstallRequired),
  "ManagerAppRelyOnBTCError": () => (/* binding */ ManagerAppRelyOnBTCError),
  "ManagerDeviceLockedError": () => (/* binding */ ManagerDeviceLockedError),
  "ManagerFirmwareNotEnoughSpaceError": () => (/* binding */ ManagerFirmwareNotEnoughSpaceError),
  "ManagerNotEnoughSpaceError": () => (/* binding */ ManagerNotEnoughSpaceError),
  "ManagerUninstallBTCDep": () => (/* binding */ ManagerUninstallBTCDep),
  "NetworkDown": () => (/* binding */ NetworkDown),
  "NoAccessToCamera": () => (/* binding */ NoAccessToCamera),
  "NoAddressesFound": () => (/* binding */ NoAddressesFound),
  "NoDBPathGiven": () => (/* binding */ NoDBPathGiven),
  "NotEnoughBalance": () => (/* binding */ NotEnoughBalance),
  "NotEnoughBalanceBecauseDestinationNotCreated": () => (/* binding */ NotEnoughBalanceBecauseDestinationNotCreated),
  "NotEnoughBalanceInParentAccount": () => (/* binding */ NotEnoughBalanceInParentAccount),
  "NotEnoughBalanceToDelegate": () => (/* binding */ NotEnoughBalanceToDelegate),
  "NotEnoughGas": () => (/* binding */ NotEnoughGas),
  "NotEnoughSpendableBalance": () => (/* binding */ NotEnoughSpendableBalance),
  "NotSupportedLegacyAddress": () => (/* binding */ NotSupportedLegacyAddress),
  "PairingFailed": () => (/* binding */ PairingFailed),
  "PasswordIncorrectError": () => (/* binding */ PasswordIncorrectError),
  "PasswordsDontMatchError": () => (/* binding */ PasswordsDontMatchError),
  "RecipientRequired": () => (/* binding */ RecipientRequired),
  "RecommendSubAccountsToEmpty": () => (/* binding */ RecommendSubAccountsToEmpty),
  "RecommendUndelegation": () => (/* binding */ RecommendUndelegation),
  "StatusCodes": () => (/* binding */ StatusCodes),
  "SyncError": () => (/* binding */ SyncError),
  "TimeoutTagged": () => (/* binding */ TimeoutTagged),
  "TransportError": () => (/* binding */ TransportError),
  "TransportInterfaceNotAvailable": () => (/* binding */ TransportInterfaceNotAvailable),
  "TransportOpenUserCancelled": () => (/* binding */ TransportOpenUserCancelled),
  "TransportRaceCondition": () => (/* binding */ TransportRaceCondition),
  "TransportStatusError": () => (/* binding */ TransportStatusError),
  "TransportWebUSBGestureRequired": () => (/* binding */ TransportWebUSBGestureRequired),
  "UnavailableTezosOriginatedAccountReceive": () => (/* binding */ UnavailableTezosOriginatedAccountReceive),
  "UnavailableTezosOriginatedAccountSend": () => (/* binding */ UnavailableTezosOriginatedAccountSend),
  "UnexpectedBootloader": () => (/* binding */ UnexpectedBootloader),
  "UnknownMCU": () => (/* binding */ UnknownMCU),
  "UpdateFetchFileFail": () => (/* binding */ UpdateFetchFileFail),
  "UpdateIncorrectHash": () => (/* binding */ UpdateIncorrectHash),
  "UpdateIncorrectSig": () => (/* binding */ UpdateIncorrectSig),
  "UpdateYourApp": () => (/* binding */ UpdateYourApp),
  "UserRefusedAddress": () => (/* binding */ UserRefusedAddress),
  "UserRefusedAllowManager": () => (/* binding */ UserRefusedAllowManager),
  "UserRefusedDeviceNameChange": () => (/* binding */ UserRefusedDeviceNameChange),
  "UserRefusedFirmwareUpdate": () => (/* binding */ UserRefusedFirmwareUpdate),
  "UserRefusedOnDevice": () => (/* binding */ UserRefusedOnDevice),
  "WebsocketConnectionError": () => (/* binding */ WebsocketConnectionError),
  "WebsocketConnectionFailed": () => (/* binding */ WebsocketConnectionFailed),
  "WrongAppForCurrency": () => (/* binding */ WrongAppForCurrency),
  "WrongDeviceForAccount": () => (/* binding */ WrongDeviceForAccount),
  "addCustomErrorDeserializer": () => (/* reexport */ addCustomErrorDeserializer),
  "createCustomErrorClass": () => (/* reexport */ createCustomErrorClass),
  "deserializeError": () => (/* reexport */ deserializeError),
  "getAltStatusMessage": () => (/* binding */ getAltStatusMessage),
  "serializeError": () => (/* reexport */ serializeError)
});

;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/errors/lib-es/helpers.js
/* eslint-disable no-continue */
/* eslint-disable no-unused-vars */
/* eslint-disable no-param-reassign */
/* eslint-disable no-prototype-builtins */
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var errorClasses = {};
var deserializers = {};
var addCustomErrorDeserializer = function (name, deserializer) {
    deserializers[name] = deserializer;
};
var createCustomErrorClass = function (name) {
    var C = function CustomError(message, fields) {
        Object.assign(this, fields);
        this.name = name;
        this.message = message || name;
        this.stack = new Error().stack;
    };
    C.prototype = new Error();
    errorClasses[name] = C;
    return C;
};
// inspired from https://github.com/programble/errio/blob/master/index.js
var deserializeError = function (object) {
    if (typeof object === "object" && object) {
        try {
            // $FlowFixMe FIXME HACK
            var msg = JSON.parse(object.message);
            if (msg.message && msg.name) {
                object = msg;
            }
        }
        catch (e) {
            // nothing
        }
        var error = void 0;
        if (typeof object.name === "string") {
            var name_1 = object.name;
            var des = deserializers[name_1];
            if (des) {
                error = des(object);
            }
            else {
                var constructor = name_1 === "Error" ? Error : errorClasses[name_1];
                if (!constructor) {
                    console.warn("deserializing an unknown class '" + name_1 + "'");
                    constructor = createCustomErrorClass(name_1);
                }
                error = Object.create(constructor.prototype);
                try {
                    for (var prop in object) {
                        if (object.hasOwnProperty(prop)) {
                            error[prop] = object[prop];
                        }
                    }
                }
                catch (e) {
                    // sometimes setting a property can fail (e.g. .name)
                }
            }
        }
        else {
            error = new Error(object.message);
        }
        if (!error.stack && Error.captureStackTrace) {
            Error.captureStackTrace(error, deserializeError);
        }
        return error;
    }
    return new Error(String(object));
};
// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js
var serializeError = function (value) {
    if (!value)
        return value;
    if (typeof value === "object") {
        return destroyCircular(value, []);
    }
    if (typeof value === "function") {
        return "[Function: " + (value.name || "anonymous") + "]";
    }
    return value;
};
// https://www.npmjs.com/package/destroy-circular
function destroyCircular(from, seen) {
    var e_1, _a;
    var to = {};
    seen.push(from);
    try {
        for (var _b = __values(Object.keys(from)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var value = from[key];
            if (typeof value === "function") {
                continue;
            }
            if (!value || typeof value !== "object") {
                to[key] = value;
                continue;
            }
            if (seen.indexOf(from[key]) === -1) {
                to[key] = destroyCircular(from[key], seen.slice(0));
                continue;
            }
            to[key] = "[Circular]";
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (typeof from.name === "string") {
        to.name = from.name;
    }
    if (typeof from.message === "string") {
        to.message = from.message;
    }
    if (typeof from.stack === "string") {
        to.stack = from.stack;
    }
    return to;
}
//# sourceMappingURL=helpers.js.map
;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/errors/lib-es/index.js


var AccountNameRequiredError = createCustomErrorClass("AccountNameRequired");
var AccountNotSupported = createCustomErrorClass("AccountNotSupported");
var AmountRequired = createCustomErrorClass("AmountRequired");
var BluetoothRequired = createCustomErrorClass("BluetoothRequired");
var BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp");
var CantOpenDevice = createCustomErrorClass("CantOpenDevice");
var CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported");
var CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported");
var DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported");
var DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose");
var DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine");
var DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected");
var DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected");
var DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected");
var DeviceHalted = createCustomErrorClass("DeviceHalted");
var DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid");
var DeviceSocketFail = createCustomErrorClass("DeviceSocketFail");
var DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus");
var DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");
var DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");
var EnpointConfigError = createCustomErrorClass("EnpointConfig");
var EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData");
var FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed");
var FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized");
var HardResetFail = createCustomErrorClass("HardResetFail");
var InvalidXRPTag = createCustomErrorClass("InvalidXRPTag");
var InvalidAddress = createCustomErrorClass("InvalidAddress");
var InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");
var LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError");
var UnknownMCU = createCustomErrorClass("UnknownMCU");
var LedgerAPIError = createCustomErrorClass("LedgerAPIError");
var LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage");
var LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable");
var ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled");
var ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC");
var ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired");
var ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired");
var ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked");
var ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace");
var ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace");
var ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep");
var NetworkDown = createCustomErrorClass("NetworkDown");
var NoAddressesFound = createCustomErrorClass("NoAddressesFound");
var NotEnoughBalance = createCustomErrorClass("NotEnoughBalance");
var NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate");
var NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount");
var NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance");
var NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");
var NoAccessToCamera = createCustomErrorClass("NoAccessToCamera");
var NotEnoughGas = createCustomErrorClass("NotEnoughGas");
var NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress");
var GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate");
var PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch");
var PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect");
var RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty");
var RecommendUndelegation = createCustomErrorClass("RecommendUndelegation");
var TimeoutTagged = createCustomErrorClass("TimeoutTagged");
var UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader");
var MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard");
var RecipientRequired = createCustomErrorClass("RecipientRequired");
var UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");
var UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend");
var UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail");
var UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash");
var UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig");
var UpdateYourApp = createCustomErrorClass("UpdateYourApp");
var UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange");
var UserRefusedAddress = createCustomErrorClass("UserRefusedAddress");
var UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate");
var UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager");
var UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice"); // TODO rename because it's just for transaction refusal
var TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");
var TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");
var TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");
var TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");
var DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp");
var WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError");
var WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed");
var WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount");
var WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency");
var ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP");
var CantScanQRCode = createCustomErrorClass("CantScanQRCode");
var FeeNotLoaded = createCustomErrorClass("FeeNotLoaded");
var FeeRequired = createCustomErrorClass("FeeRequired");
var FeeTooHigh = createCustomErrorClass("FeeTooHigh");
var SyncError = createCustomErrorClass("SyncError");
var PairingFailed = createCustomErrorClass("PairingFailed");
var GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed");
var LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx");
var LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx");
var FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired");
// db stuff, no need to translate
var NoDBPathGiven = createCustomErrorClass("NoDBPathGiven");
var DBWrongPassword = createCustomErrorClass("DBWrongPassword");
var DBNotReset = createCustomErrorClass("DBNotReset");
/**
 * TransportError is used for any generic transport errors.
 * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.
 */
function TransportError(message, id) {
    this.name = "TransportError";
    this.message = message;
    this.stack = new Error().stack;
    this.id = id;
}
TransportError.prototype = new Error();
addCustomErrorDeserializer("TransportError", function (e) { return new TransportError(e.message, e.id); });
var StatusCodes = {
    PIN_REMAINING_ATTEMPTS: 0x63c0,
    INCORRECT_LENGTH: 0x6700,
    MISSING_CRITICAL_PARAMETER: 0x6800,
    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,
    SECURITY_STATUS_NOT_SATISFIED: 0x6982,
    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,
    INCORRECT_DATA: 0x6a80,
    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,
    REFERENCED_DATA_NOT_FOUND: 0x6a88,
    FILE_ALREADY_EXISTS: 0x6a89,
    INCORRECT_P1_P2: 0x6b00,
    INS_NOT_SUPPORTED: 0x6d00,
    CLA_NOT_SUPPORTED: 0x6e00,
    TECHNICAL_PROBLEM: 0x6f00,
    OK: 0x9000,
    MEMORY_PROBLEM: 0x9240,
    NO_EF_SELECTED: 0x9400,
    INVALID_OFFSET: 0x9402,
    FILE_NOT_FOUND: 0x9404,
    INCONSISTENT_FILE: 0x9408,
    ALGORITHM_NOT_SUPPORTED: 0x9484,
    INVALID_KCV: 0x9485,
    CODE_NOT_INITIALIZED: 0x9802,
    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,
    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,
    CONTRADICTION_INVALIDATION: 0x9810,
    CODE_BLOCKED: 0x9840,
    MAX_VALUE_REACHED: 0x9850,
    GP_AUTH_FAILED: 0x6300,
    LICENSING: 0x6f42,
    HALTED: 0x6faa
};
function getAltStatusMessage(code) {
    switch (code) {
        // improve text of most common errors
        case 0x6700:
            return "Incorrect length";
        case 0x6800:
            return "Missing critical parameter";
        case 0x6982:
            return "Security not satisfied (dongle locked or have invalid access rights)";
        case 0x6985:
            return "Condition of use not satisfied (denied by the user?)";
        case 0x6a80:
            return "Invalid data received";
        case 0x6b00:
            return "Invalid parameter received";
    }
    if (0x6f00 <= code && code <= 0x6fff) {
        return "Internal error, please report";
    }
}
/**
 * Error thrown when a device returned a non success status.
 * the error.statusCode is one of the `StatusCodes` exported by this library.
 */
function TransportStatusError(statusCode) {
    this.name = "TransportStatusError";
    var statusText = Object.keys(StatusCodes).find(function (k) { return StatusCodes[k] === statusCode; }) ||
        "UNKNOWN_ERROR";
    var smsg = getAltStatusMessage(statusCode) || statusText;
    var statusCodeStr = statusCode.toString(16);
    this.message = "Ledger device: " + smsg + " (0x" + statusCodeStr + ")";
    this.stack = new Error().stack;
    this.statusCode = statusCode;
    this.statusText = statusText;
}
TransportStatusError.prototype = new Error();
addCustomErrorDeserializer("TransportStatusError", function (e) { return new TransportStatusError(e.statusCode); });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8585:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Xb": () => (/* binding */ Hub),
/* harmony export */   "Gd": () => (/* binding */ getCurrentHub),
/* harmony export */   "vi": () => (/* binding */ getHubFromCarrier),
/* harmony export */   "cu": () => (/* binding */ getMainCarrier),
/* harmony export */   "pj": () => (/* binding */ makeMain)
/* harmony export */ });
/* unused harmony exports API_VERSION, setHubOnCarrier */
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63699);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7790);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58536);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65907);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4266);
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51684);
/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92430);




/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
var API_VERSION = 4;

/**
 * Default maximum number of breadcrumbs added to an event. Can be overwritten
 * with {@link Options.maxBreadcrumbs}.
 */
var DEFAULT_BREADCRUMBS = 100;

/**
 * A layer in the process stack.
 * @hidden
 */

/**
 * @inheritDoc
 */
class Hub  {
  /** Is a {@link Layer}[] containing the client and scope */
    __init() {this._stack = [{}];}

  /** Contains the last event id of a captured event.  */
  

  /**
   * Creates a new instance of the hub, will push one {@link Layer} into the
   * internal stack on creation.
   *
   * @param client bound to the hub.
   * @param scope bound to the hub.
   * @param version number, higher number means higher priority.
   */
   constructor(client, scope = new _scope_js__WEBPACK_IMPORTED_MODULE_0__/* .Scope */ .s(),   _version = API_VERSION) {;this._version = _version;Hub.prototype.__init.call(this);
    this.getStackTop().scope = scope;
    if (client) {
      this.bindClient(client);
    }
  }

  /**
   * @inheritDoc
   */
   isOlderThan(version) {
    return this._version < version;
  }

  /**
   * @inheritDoc
   */
   bindClient(client) {
    var top = this.getStackTop();
    top.client = client;
    if (client && client.setupIntegrations) {
      client.setupIntegrations();
    }
  }

  /**
   * @inheritDoc
   */
   pushScope() {
    // We want to clone the content of prev scope
    var scope = _scope_js__WEBPACK_IMPORTED_MODULE_0__/* .Scope.clone */ .s.clone(this.getScope());
    this.getStack().push({
      client: this.getClient(),
      scope,
    });
    return scope;
  }

  /**
   * @inheritDoc
   */
   popScope() {
    if (this.getStack().length <= 1) return false;
    return !!this.getStack().pop();
  }

  /**
   * @inheritDoc
   */
   withScope(callback) {
    var scope = this.pushScope();
    try {
      callback(scope);
    } finally {
      this.popScope();
    }
  }

  /**
   * @inheritDoc
   */
   getClient() {
    return this.getStackTop().client ;
  }

  /** Returns the scope of the top stack. */
   getScope() {
    return this.getStackTop().scope;
  }

  /** Returns the scope stack for domains or the process. */
   getStack() {
    return this._stack;
  }

  /** Returns the topmost scope layer in the order domain > local > process. */
   getStackTop() {
    return this._stack[this._stack.length - 1];
  }

  /**
   * @inheritDoc
   */
     captureException(exception, hint) {
    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)());
    var syntheticException = new Error('Sentry syntheticException');
    this._withClient((client, scope) => {
      client.captureException(
        exception,
        {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId,
        },
        scope,
      );
    });
    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureMessage(
    message,
        level,
    hint,
  ) {
    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)());
    var syntheticException = new Error(message);
    this._withClient((client, scope) => {
      client.captureMessage(
        message,
        level,
        {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId,
        },
        scope,
      );
    });
    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureEvent(event, hint) {
    var eventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)();
    if (event.type !== 'transaction') {
      this._lastEventId = eventId;
    }

    this._withClient((client, scope) => {
      client.captureEvent(event, { ...hint, event_id: eventId }, scope);
    });
    return eventId;
  }

  /**
   * @inheritDoc
   */
   lastEventId() {
    return this._lastEventId;
  }

  /**
   * @inheritDoc
   */
   addBreadcrumb(breadcrumb, hint) {
    const { scope, client } = this.getStackTop();

    if (!scope || !client) return;

        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =
      (client.getOptions && client.getOptions()) || {};

    if (maxBreadcrumbs <= 0) return;

    var timestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dateTimestampInSeconds */ .yW)();
    var mergedBreadcrumb = { timestamp, ...breadcrumb };
    var finalBreadcrumb = beforeBreadcrumb
      ? ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .consoleSandbox */ .Cf)(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )
      : mergedBreadcrumb;

    if (finalBreadcrumb === null) return;

    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
  }

  /**
   * @inheritDoc
   */
   setUser(user) {
    var scope = this.getScope();
    if (scope) scope.setUser(user);
  }

  /**
   * @inheritDoc
   */
   setTags(tags) {
    var scope = this.getScope();
    if (scope) scope.setTags(tags);
  }

  /**
   * @inheritDoc
   */
   setExtras(extras) {
    var scope = this.getScope();
    if (scope) scope.setExtras(extras);
  }

  /**
   * @inheritDoc
   */
   setTag(key, value) {
    var scope = this.getScope();
    if (scope) scope.setTag(key, value);
  }

  /**
   * @inheritDoc
   */
   setExtra(key, extra) {
    var scope = this.getScope();
    if (scope) scope.setExtra(key, extra);
  }

  /**
   * @inheritDoc
   */
     setContext(name, context) {
    var scope = this.getScope();
    if (scope) scope.setContext(name, context);
  }

  /**
   * @inheritDoc
   */
   configureScope(callback) {
    const { scope, client } = this.getStackTop();
    if (scope && client) {
      callback(scope);
    }
  }

  /**
   * @inheritDoc
   */
   run(callback) {
    var oldHub = makeMain(this);
    try {
      callback(this);
    } finally {
      makeMain(oldHub);
    }
  }

  /**
   * @inheritDoc
   */
   getIntegration(integration) {
    var client = this.getClient();
    if (!client) return null;
    try {
      return client.getIntegration(integration);
    } catch (_oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.warn */ .kg.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
      return null;
    }
  }

  /**
   * @inheritDoc
   */
   startTransaction(context, customSamplingContext) {
    return this._callExtensionMethod('startTransaction', context, customSamplingContext);
  }

  /**
   * @inheritDoc
   */
   traceHeaders() {
    return this._callExtensionMethod('traceHeaders');
  }

  /**
   * @inheritDoc
   */
   captureSession(endSession = false) {
    // both send the update and pull the session from the scope
    if (endSession) {
      return this.endSession();
    }

    // only send the update
    this._sendSessionUpdate();
  }

  /**
   * @inheritDoc
   */
   endSession() {
    var layer = this.getStackTop();
    var scope = layer && layer.scope;
    var session = scope && scope.getSession();
    if (session) {
      (0,_session_js__WEBPACK_IMPORTED_MODULE_4__/* .closeSession */ .RJ)(session);
    }
    this._sendSessionUpdate();

    // the session is over; take it off of the scope
    if (scope) {
      scope.setSession();
    }
  }

  /**
   * @inheritDoc
   */
   startSession(context) {
    const { scope, client } = this.getStackTop();
    const { release, environment } = (client && client.getOptions()) || {};

    // Will fetch userAgent if called from browser sdk
    var global = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalObject */ .R)();
    const { userAgent } = global.navigator || {};

    var session = (0,_session_js__WEBPACK_IMPORTED_MODULE_4__/* .makeSession */ .Hv)({
      release,
      environment,
      ...(scope && { user: scope.getUser() }),
      ...(userAgent && { userAgent }),
      ...context,
    });

    if (scope) {
      // End existing session if there's one
      var currentSession = scope.getSession && scope.getSession();
      if (currentSession && currentSession.status === 'ok') {
        (0,_session_js__WEBPACK_IMPORTED_MODULE_4__/* .updateSession */ .CT)(currentSession, { status: 'exited' });
      }
      this.endSession();

      // Afterwards we set the new session on the scope
      scope.setSession(session);
    }

    return session;
  }

  /**
   * Sends the current Session on the scope
   */
   _sendSessionUpdate() {
    const { scope, client } = this.getStackTop();
    if (!scope) return;

    var session = scope.getSession();
    if (session) {
      if (client && client.captureSession) {
        client.captureSession(session);
      }
    }
  }

  /**
   * Internal helper function to call a method on the top client if it exists.
   *
   * @param method The method to call on the client.
   * @param args Arguments to pass to the client function.
   */
   _withClient(callback) {
    const { scope, client } = this.getStackTop();
    if (client) {
      callback(client, scope);
    }
  }

  /**
   * Calls global extension method and binding current instance to the function call
   */
  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
     _callExtensionMethod(method, ...args) {
    var carrier = getMainCarrier();
    var sentry = carrier.__SENTRY__;
    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
      return sentry.extensions[method].apply(this, args);
    }
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.warn */ .kg.warn(`Extension method ${method} couldn't be found, doing nothing.`);
  }
}

/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
function getMainCarrier() {
  var carrier = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalObject */ .R)();
  carrier.__SENTRY__ = carrier.__SENTRY__ || {
    extensions: {},
    hub: undefined,
  };
  return carrier;
}

/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
function makeMain(hub) {
  var registry = getMainCarrier();
  var oldHub = getHubFromCarrier(registry);
  setHubOnCarrier(registry, hub);
  return oldHub;
}

/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
function getCurrentHub() {
  // Get main carrier (global for every environment)
  var registry = getMainCarrier();

  // If there's no hub, or its an old API, assign a new one
  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
    setHubOnCarrier(registry, new Hub());
  }

  // Prefer domains over global if they are there (applicable only to Node environment)
  if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__/* .isNodeEnv */ .KV)()) {
    return getHubFromActiveDomain(registry);
  }
  // Return hub that lives on a global object
  return getHubFromCarrier(registry);
}

/**
 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
 * @returns discovered hub
 */
function getHubFromActiveDomain(registry) {
  try {
    var sentry = getMainCarrier().__SENTRY__;
    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;

    // If there's no active domain, just return global hub
    if (!activeDomain) {
      return getHubFromCarrier(registry);
    }

    // If there's no hub on current domain, or it's an old API, assign a new one
    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, _scope_js__WEBPACK_IMPORTED_MODULE_0__/* .Scope.clone */ .s.clone(registryHubTopStack.scope)));
    }

    // Return hub that lives on a domain
    return getHubFromCarrier(activeDomain);
  } catch (_Oo) {
    // Return hub that lives on a global object
    return getHubFromCarrier(registry);
  }
}

/**
 * This will tell whether a carrier has a hub on it or not
 * @param carrier object
 */
function hasHubOnCarrier(carrier) {
  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}

/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
function getHubFromCarrier(carrier) {
  return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalSingleton */ .Y)('hub', () => new Hub(), carrier);
}

/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
function setHubOnCarrier(carrier, hub) {
  if (!carrier) return false;
  var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});
  __SENTRY__.hub = hub;
  return true;
}


//# sourceMappingURL=hub.js.map


/***/ }),

/***/ 51684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "s": () => (/* binding */ Scope),
/* harmony export */   "c": () => (/* binding */ addGlobalEventProcessor)
/* harmony export */ });
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81757);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7790);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97946);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58536);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65907);
/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92430);



/**
 * Absolute maximum number of breadcrumbs added to an event.
 * The `maxBreadcrumbs` option cannot be higher than this value.
 */
var MAX_BREADCRUMBS = 100;

/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
class Scope  {
  /** Flag if notifying is happening. */
  

  /** Callback for client to receive scope changes. */
  

  /** Callback list that will be called after {@link applyToEvent}. */
  

  /** Array of breadcrumbs. */
  

  /** User */
  

  /** Tags */
  

  /** Extra */
  

  /** Contexts */
  

  /** Attachments */
  

  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  

  /** Fingerprint */
  

  /** Severity */
    

  /** Transaction Name */
  

  /** Span */
  

  /** Session */
  

  /** Request Mode Session Status */
  

   constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
  }

  /**
   * Inherit values from the parent scope.
   * @param scope to clone.
   */
   static clone(scope) {
    var newScope = new Scope();
    if (scope) {
      newScope._breadcrumbs = [...scope._breadcrumbs];
      newScope._tags = { ...scope._tags };
      newScope._extra = { ...scope._extra };
      newScope._contexts = { ...scope._contexts };
      newScope._user = scope._user;
      newScope._level = scope._level;
      newScope._span = scope._span;
      newScope._session = scope._session;
      newScope._transactionName = scope._transactionName;
      newScope._fingerprint = scope._fingerprint;
      newScope._eventProcessors = [...scope._eventProcessors];
      newScope._requestSession = scope._requestSession;
      newScope._attachments = [...scope._attachments];
    }
    return newScope;
  }

  /**
   * Add internal on change listener. Used for sub SDKs that need to store the scope.
   * @hidden
   */
   addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }

  /**
   * @inheritDoc
   */
   addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }

  /**
   * @inheritDoc
   */
   setUser(user) {
    this._user = user || {};
    if (this._session) {
      (0,_session_js__WEBPACK_IMPORTED_MODULE_0__/* .updateSession */ .CT)(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   getUser() {
    return this._user;
  }

  /**
   * @inheritDoc
   */
   getRequestSession() {
    return this._requestSession;
  }

  /**
   * @inheritDoc
   */
   setRequestSession(requestSession) {
    this._requestSession = requestSession;
    return this;
  }

  /**
   * @inheritDoc
   */
   setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags,
    };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras,
    };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setLevel(
        level,
  ) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setContext(key, context) {
    if (context === null) {
            delete this._contexts[key];
    } else {
      this._contexts = { ...this._contexts, [key]: context };
    }

    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setSpan(span) {
    this._span = span;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   getSpan() {
    return this._span;
  }

  /**
   * @inheritDoc
   */
   getTransaction() {
    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
    // have a pointer to the currently-active transaction.
    var span = this.getSpan();
    return span && span.transaction;
  }

  /**
   * @inheritDoc
   */
   setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   getSession() {
    return this._session;
  }

  /**
   * @inheritDoc
   */
   update(captureContext) {
    if (!captureContext) {
      return this;
    }

    if (typeof captureContext === 'function') {
      var updatedScope = (captureContext )(this);
      return updatedScope instanceof Scope ? updatedScope : this;
    }

    if (captureContext instanceof Scope) {
      this._tags = { ...this._tags, ...captureContext._tags };
      this._extra = { ...this._extra, ...captureContext._extra };
      this._contexts = { ...this._contexts, ...captureContext._contexts };
      if (captureContext._user && Object.keys(captureContext._user).length) {
        this._user = captureContext._user;
      }
      if (captureContext._level) {
        this._level = captureContext._level;
      }
      if (captureContext._fingerprint) {
        this._fingerprint = captureContext._fingerprint;
      }
      if (captureContext._requestSession) {
        this._requestSession = captureContext._requestSession;
      }
    } else if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .isPlainObject */ .PO)(captureContext)) {
            captureContext = captureContext ;
      this._tags = { ...this._tags, ...captureContext.tags };
      this._extra = { ...this._extra, ...captureContext.extra };
      this._contexts = { ...this._contexts, ...captureContext.contexts };
      if (captureContext.user) {
        this._user = captureContext.user;
      }
      if (captureContext.level) {
        this._level = captureContext.level;
      }
      if (captureContext.fingerprint) {
        this._fingerprint = captureContext.fingerprint;
      }
      if (captureContext.requestSession) {
        this._requestSession = captureContext.requestSession;
      }
    }

    return this;
  }

  /**
   * @inheritDoc
   */
   clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = undefined;
    this._transactionName = undefined;
    this._fingerprint = undefined;
    this._requestSession = undefined;
    this._span = undefined;
    this._session = undefined;
    this._notifyScopeListeners();
    this._attachments = [];
    return this;
  }

  /**
   * @inheritDoc
   */
   addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;

    // No data has been changed, so don't notify scope listeners
    if (maxCrumbs <= 0) {
      return this;
    }

    var mergedBreadcrumb = {
      timestamp: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dateTimestampInSeconds */ .yW)(),
      ...breadcrumb,
    };
    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);
    this._notifyScopeListeners();

    return this;
  }

  /**
   * @inheritDoc
   */
   clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }

  /**
   * @inheritDoc
   */
   getAttachments() {
    return this._attachments;
  }

  /**
   * @inheritDoc
   */
   clearAttachments() {
    this._attachments = [];
    return this;
  }

  /**
   * Applies the current context and fingerprint to the event.
   * Note that breadcrumbs will be added by the client.
   * Also if the event has already breadcrumbs on it, we do not merge them.
   * @param event Event
   * @param hint May contain additional information about the original exception.
   * @hidden
   */
   applyToEvent(event, hint = {}) {
    if (this._extra && Object.keys(this._extra).length) {
      event.extra = { ...this._extra, ...event.extra };
    }
    if (this._tags && Object.keys(this._tags).length) {
      event.tags = { ...this._tags, ...event.tags };
    }
    if (this._user && Object.keys(this._user).length) {
      event.user = { ...this._user, ...event.user };
    }
    if (this._contexts && Object.keys(this._contexts).length) {
      event.contexts = { ...this._contexts, ...event.contexts };
    }
    if (this._level) {
      event.level = this._level;
    }
    if (this._transactionName) {
      event.transaction = this._transactionName;
    }

    // We want to set the trace context for normal events only if there isn't already
    // a trace context on the event. There is a product feature in place where we link
    // errors with transaction and it relies on that.
    if (this._span) {
      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };
      var transactionName = this._span.transaction && this._span.transaction.name;
      if (transactionName) {
        event.tags = { transaction: transactionName, ...event.tags };
      }
    }

    this._applyFingerprint(event);

    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];
    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;

    event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };

    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);
  }

  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry
   */
   setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };

    return this;
  }

  /**
   * This will be called after {@link applyToEvent} is finished.
   */
   _notifyEventProcessors(
    processors,
    event,
    hint,
    index = 0,
  ) {
    return new _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .SyncPromise */ .cW((resolve, reject) => {
      var processor = processors[index];
      if (event === null || typeof processor !== 'function') {
        resolve(event);
      } else {
        var result = processor({ ...event }, hint) ;

        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
          processor.id &&
          result === null &&
          _sentry_utils__WEBPACK_IMPORTED_MODULE_4__/* .logger.log */ .kg.log(`Event processor "${processor.id}" dropped event`);

        if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .isThenable */ .J8)(result)) {
          void result
            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))
            .then(null, reject);
        } else {
          void this._notifyEventProcessors(processors, result, hint, index + 1)
            .then(resolve)
            .then(null, reject);
        }
      }
    });
  }

  /**
   * This will be called on every set call.
   */
   _notifyScopeListeners() {
    // We need this check for this._notifyingListeners to be able to work on scope during updates
    // If this check is not here we'll produce endless recursion when something is done with the scope
    // during the callback.
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach(callback => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }

  /**
   * Applies fingerprint from the scope to the event if there's one,
   * uses message if there's one instead or get rid of empty fingerprint
   */
   _applyFingerprint(event) {
    // Make sure it's an array first and we actually have something in place
    event.fingerprint = event.fingerprint
      ? Array.isArray(event.fingerprint)
        ? event.fingerprint
        : [event.fingerprint]
      : [];

    // If we have something on the scope, then merge it with event
    if (this._fingerprint) {
      event.fingerprint = event.fingerprint.concat(this._fingerprint);
    }

    // If we have no data at all, remove empty array default
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  }
}

/**
 * Returns the global event processors.
 */
function getGlobalEventProcessors() {
  return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalSingleton */ .Y)('globalEventProcessors', () => []);
}

/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
function addGlobalEventProcessor(callback) {
  getGlobalEventProcessors().push(callback);
}


//# sourceMappingURL=scope.js.map


/***/ }),

/***/ 92430:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RJ": () => (/* binding */ closeSession),
/* harmony export */   "Hv": () => (/* binding */ makeSession),
/* harmony export */   "CT": () => (/* binding */ updateSession)
/* harmony export */ });
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7790);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63699);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21995);


/**
 * Creates a new `Session` object by setting certain default parameters. If optional @param context
 * is passed, the passed properties are applied to the session object.
 *
 * @param context (optional) additional properties to be applied to the returned session object
 *
 * @returns a new `Session` object
 */
function makeSession(context) {
  // Both timestamp and started are in seconds since the UNIX epoch.
  var startingTime = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .timestampInSeconds */ .ph)();

  var session = {
    sid: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: 'ok',
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session),
  };

  if (context) {
    updateSession(session, context);
  }

  return session;
}

/**
 * Updates a session object with the properties passed in the context.
 *
 * Note that this function mutates the passed object and returns void.
 * (Had to do this instead of returning a new and updated session because closing and sending a session
 * makes an update to the session after it was passed to the sending logic.
 * @see BaseClient.captureSession )
 *
 * @param session the `Session` to update
 * @param context the `SessionContext` holding the properties that should be updated in @param session
 */
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }

    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }

  session.timestamp = context.timestamp || (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .timestampInSeconds */ .ph)();

  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    // Good enough uuid validation.  Kamil
    session.sid = context.sid.length === 32 ? context.sid : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)();
  }
  if (context.init !== undefined) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === 'number') {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = undefined;
  } else if (typeof context.duration === 'number') {
    session.duration = context.duration;
  } else {
    var duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === 'number') {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}

/**
 * Closes a session by setting its status and updating the session object with it.
 * Internally calls `updateSession` to update the passed session object.
 *
 * Note that this function mutates the passed session (@see updateSession for explanation).
 *
 * @param session the `Session` object to be closed
 * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,
 *               this function will keep the previously set status, unless it was `'ok'` in which case
 *               it is changed to `'exited'`.
 */
function closeSession(session, status) {
  let context = {};
  if (status) {
    context = { status };
  } else if (session.status === 'ok') {
    context = { status: 'exited' };
  }

  updateSession(session, context);
}

/**
 * Serializes a passed session object to a JSON object with a slightly different structure.
 * This is necessary because the Sentry backend requires a slightly different schema of a session
 * than the one the JS SDKs use internally.
 *
 * @param session the session to be converted
 *
 * @returns a JSON object of the passed session
 */
function sessionToJSON(session) {
  return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dropUndefinedKeys */ .Jr)({
    sid: `${session.sid}`,
    init: session.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(session.started * 1000).toISOString(),
    timestamp: new Date(session.timestamp * 1000).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,
    duration: session.duration,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent,
    },
  });
}


//# sourceMappingURL=session.js.map


/***/ }),

/***/ 78900:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ro": () => (/* binding */ addExtensionMethods),
  "lb": () => (/* binding */ startIdleTransaction)
});

// UNUSED EXPORTS: _addTracingExtensions

// EXTERNAL MODULE: ../../node_modules/@sentry/hub/esm/hub.js
var hub = __webpack_require__(8585);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/logger.js
var logger = __webpack_require__(58536);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/is.js
var is = __webpack_require__(81757);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/node.js + 1 modules
var node = __webpack_require__(4266);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/instrument.js
var instrument = __webpack_require__(64005);
// EXTERNAL MODULE: ../../node_modules/@sentry/tracing/esm/utils.js
var utils = __webpack_require__(92517);
;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/errors.js



/**
 * Configures global error listeners
 */
function registerErrorInstrumentation() {
  (0,instrument/* addInstrumentationHandler */.o)('error', errorCallback);
  (0,instrument/* addInstrumentationHandler */.o)('unhandledrejection', errorCallback);
}

/**
 * If an error or unhandled promise occurs, we mark the active transaction as failed
 */
function errorCallback() {
  var activeTransaction = (0,utils/* getActiveTransaction */.x1)();
  if (activeTransaction) {
    var status = 'internal_error';
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`[Tracing] Transaction: ${status} -> Global error occured`);
    activeTransaction.setStatus(status);
  }
}


//# sourceMappingURL=errors.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/tracing/esm/idletransaction.js
var idletransaction = __webpack_require__(40564);
// EXTERNAL MODULE: ../../node_modules/@sentry/tracing/esm/transaction.js
var esm_transaction = __webpack_require__(18235);
;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/hubextensions.js
/* module decorator */ module = __webpack_require__.hmd(module);







/** Returns all trace headers that are currently on the top scope. */
function traceHeaders() {
  var scope = this.getScope();
  if (scope) {
    var span = scope.getSpan();
    if (span) {
      return {
        'sentry-trace': span.toTraceparent(),
      };
    }
  }
  return {};
}

/**
 * Makes a sampling decision for the given transaction and stores it on the transaction.
 *
 * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be
 * sent to Sentry.
 *
 * @param transaction: The transaction needing a sampling decision
 * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`
 * @param samplingContext: Default and user-provided data which may be used to help make the decision
 *
 * @returns The given transaction with its `sampled` value set
 */
function sample(
  transaction,
  options,
  samplingContext,
) {
  // nothing to do if tracing is not enabled
  if (!(0,utils/* hasTracingEnabled */.zu)(options)) {
    transaction.sampled = false;
    return transaction;
  }

  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that
  if (transaction.sampled !== undefined) {
    transaction.setMetadata({
      transactionSampling: { method: 'explicitly_set' },
    });
    return transaction;
  }

  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should
  // work; prefer the hook if so
  let sampleRate;
  if (typeof options.tracesSampler === 'function') {
    sampleRate = options.tracesSampler(samplingContext);
    transaction.setMetadata({
      transactionSampling: {
        method: 'client_sampler',
        // cast to number in case it's a boolean
        rate: Number(sampleRate),
      },
    });
  } else if (samplingContext.parentSampled !== undefined) {
    sampleRate = samplingContext.parentSampled;
    transaction.setMetadata({
      transactionSampling: { method: 'inheritance' },
    });
  } else {
    sampleRate = options.tracesSampleRate;
    transaction.setMetadata({
      transactionSampling: {
        method: 'client_rate',
        // cast to number in case it's a boolean
        rate: Number(sampleRate),
      },
    });
  }

  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The
  // only valid values are booleans or numbers between 0 and 1.)
  if (!isValidSampleRate(sampleRate)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('[Tracing] Discarding transaction because of invalid sample rate.');
    transaction.sampled = false;
    return transaction;
  }

  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped
  if (!sampleRate) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.log */.kg.log(
        `[Tracing] Discarding transaction because ${
          typeof options.tracesSampler === 'function'
            ? 'tracesSampler returned 0 or false'
            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'
        }`,
      );
    transaction.sampled = false;
    return transaction;
  }

  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is
  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.
  transaction.sampled = Math.random() < (sampleRate );

  // if we're not going to keep it, we're done
  if (!transaction.sampled) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.log */.kg.log(
        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
          sampleRate,
        )})`,
      );
    return transaction;
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);
  return transaction;
}

/**
 * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).
 */
function isValidSampleRate(rate) {
  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck
    if ((0,is/* isNaN */.i2)(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn(
        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
          rate,
        )} of type ${JSON.stringify(typeof rate)}.`,
      );
    return false;
  }

  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false
  if (rate < 0 || rate > 1) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
    return false;
  }
  return true;
}

/**
 * Creates a new transaction and adds a sampling decision if it doesn't yet have one.
 *
 * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if
 * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an
 * "extension method."
 *
 * @param this: The Hub starting the transaction
 * @param transactionContext: Data used to configure the transaction
 * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)
 *
 * @returns The new transaction
 *
 * @see {@link Hub.startTransaction}
 */
function _startTransaction(
  
  transactionContext,
  customSamplingContext,
) {
  var client = this.getClient();
  var options = (client && client.getOptions()) || {};

  let transaction = new esm_transaction/* Transaction */.Y(transactionContext, this);
  transaction = sample(transaction, options, {
    parentSampled: transactionContext.parentSampled,
    transactionContext,
    ...customSamplingContext,
  });
  if (transaction.sampled) {
    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));
  }
  return transaction;
}

/**
 * Create new idle transaction.
 */
function startIdleTransaction(
  hub,
  transactionContext,
  idleTimeout,
  finalTimeout,
  onScope,
  customSamplingContext,
) {
  var client = hub.getClient();
  var options = (client && client.getOptions()) || {};

  let transaction = new idletransaction/* IdleTransaction */.io(transactionContext, hub, idleTimeout, finalTimeout, onScope);
  transaction = sample(transaction, options, {
    parentSampled: transactionContext.parentSampled,
    transactionContext,
    ...customSamplingContext,
  });
  if (transaction.sampled) {
    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));
  }
  return transaction;
}

/**
 * @private
 */
function _addTracingExtensions() {
  var carrier = (0,hub/* getMainCarrier */.cu)();
  if (!carrier.__SENTRY__) {
    return;
  }
  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
  if (!carrier.__SENTRY__.extensions.startTransaction) {
    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
  }
  if (!carrier.__SENTRY__.extensions.traceHeaders) {
    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
  }
}

/**
 * @private
 */
function _autoloadDatabaseIntegrations() {
  var carrier = (0,hub/* getMainCarrier */.cu)();
  if (!carrier.__SENTRY__) {
    return;
  }

  var packageToIntegrationMapping = {
    mongodb() {
      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/mongo') 

;
      return new integration.Mongo();
    },
    mongoose() {
      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/mongo') 

;
      return new integration.Mongo({ mongoose: true });
    },
    mysql() {
      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/mysql') 

;
      return new integration.Mysql();
    },
    pg() {
      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/postgres') 

;
      return new integration.Postgres();
    },
  };

  var mappedPackages = Object.keys(packageToIntegrationMapping)
    .filter(moduleName => !!(0,node/* loadModule */.$y)(moduleName))
    .map(pkg => {
      try {
        return packageToIntegrationMapping[pkg]();
      } catch (e) {
        return undefined;
      }
    })
    .filter(p => p) ;

  if (mappedPackages.length > 0) {
    carrier.__SENTRY__.integrations = [...(carrier.__SENTRY__.integrations || []), ...mappedPackages];
  }
}

/**
 * This patches the global object and injects the Tracing extensions methods
 */
function addExtensionMethods() {
  _addTracingExtensions();

  // Detect and automatically load specified integrations.
  if ((0,node/* isNodeEnv */.KV)()) {
    _autoloadDatabaseIntegrations();
  }

  // If an error happens globally, we should make sure transaction status is set to error.
  registerErrorInstrumentation();
}


//# sourceMappingURL=hubextensions.js.map


/***/ }),

/***/ 40564:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mg": () => (/* binding */ DEFAULT_FINAL_TIMEOUT),
/* harmony export */   "nT": () => (/* binding */ DEFAULT_IDLE_TIMEOUT),
/* harmony export */   "io": () => (/* binding */ IdleTransaction)
/* harmony export */ });
/* unused harmony exports HEARTBEAT_INTERVAL, IdleTransactionSpanRecorder */
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7790);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58536);
/* harmony import */ var _span_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28207);
/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18235);




var DEFAULT_IDLE_TIMEOUT = 1000;
var DEFAULT_FINAL_TIMEOUT = 30000;
var HEARTBEAT_INTERVAL = 5000;

/**
 * @inheritDoc
 */
class IdleTransactionSpanRecorder extends _span_js__WEBPACK_IMPORTED_MODULE_0__/* .SpanRecorder */ .gB {
   constructor(
      _pushActivity,
      _popActivity,
     transactionSpanId,
    maxlen,
  ) {
    super(maxlen);this._pushActivity = _pushActivity;this._popActivity = _popActivity;this.transactionSpanId = transactionSpanId;;
  }

  /**
   * @inheritDoc
   */
   add(span) {
    // We should make sure we do not push and pop activities for
    // the transaction that this span recorder belongs to.
    if (span.spanId !== this.transactionSpanId) {
      // We patch span.finish() to pop an activity after setting an endTimestamp.
      span.finish = (endTimestamp) => {
        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)();
        this._popActivity(span.spanId);
      };

      // We should only push new activities if the span does not have an end timestamp.
      if (span.endTimestamp === undefined) {
        this._pushActivity(span.spanId);
      }
    }

    super.add(span);
  }
}

/**
 * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.
 * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will
 * put itself on the scope on creation.
 */
class IdleTransaction extends _transaction_js__WEBPACK_IMPORTED_MODULE_2__/* .Transaction */ .Y {
  // Activities store a list of active spans
   __init() {this.activities = {};}

  // Track state of activities in previous heartbeat
  

  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
   __init2() {this._heartbeatCounter = 0;}

  // We should not use heartbeat if we finished a transaction
   __init3() {this._finished = false;}

    __init4() {this._beforeFinishCallbacks = [];}

  /**
   * Timer that tracks Transaction idleTimeout
   */
  

   constructor(
    transactionContext,
      _idleHub,
    /**
     * The time to wait in ms until the idle transaction will be finished. This timer is started each time
     * there are no active spans on this transaction.
     */
      _idleTimeout = DEFAULT_IDLE_TIMEOUT,
    /**
     * The final value in ms that a transaction cannot exceed
     */
      _finalTimeout = DEFAULT_FINAL_TIMEOUT,
    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends
      _onScope = false,
  ) {
    super(transactionContext, _idleHub);this._idleHub = _idleHub;this._idleTimeout = _idleTimeout;this._finalTimeout = _finalTimeout;this._onScope = _onScope;IdleTransaction.prototype.__init.call(this);IdleTransaction.prototype.__init2.call(this);IdleTransaction.prototype.__init3.call(this);IdleTransaction.prototype.__init4.call(this);;

    if (_onScope) {
      // There should only be one active transaction on the scope
      clearActiveTransaction(_idleHub);

      // We set the transaction here on the scope so error events pick up the trace
      // context and attach it to the error.
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);
      _idleHub.configureScope(scope => scope.setSpan(this));
    }

    this._startIdleTimeout();
    setTimeout(() => {
      if (!this._finished) {
        this.setStatus('deadline_exceeded');
        this.finish();
      }
    }, this._finalTimeout);
  }

  /** {@inheritDoc} */
   finish(endTimestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)()) {
    this._finished = true;
    this.activities = {};

    if (this.spanRecorder) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);

      for (var callback of this._beforeFinishCallbacks) {
        callback(this, endTimestamp);
      }

      this.spanRecorder.spans = this.spanRecorder.spans.filter((span) => {
        // If we are dealing with the transaction itself, we just return it
        if (span.spanId === this.spanId) {
          return true;
        }

        // We cancel all pending spans with status "cancelled" to indicate the idle transaction was finished early
        if (!span.endTimestamp) {
          span.endTimestamp = endTimestamp;
          span.setStatus('cancelled');
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
            _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));
        }

        var keepSpan = span.startTimestamp < endTimestamp;
        if (!keepSpan) {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
            _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(
              '[Tracing] discarding Span since it happened after Transaction was finished',
              JSON.stringify(span, undefined, 2),
            );
        }
        return keepSpan;
      });

      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] flushing IdleTransaction');
    } else {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] No active IdleTransaction');
    }

    // if `this._onScope` is `true`, the transaction put itself on the scope when it started
    if (this._onScope) {
      clearActiveTransaction(this._idleHub);
    }

    return super.finish(endTimestamp);
  }

  /**
   * Register a callback function that gets excecuted before the transaction finishes.
   * Useful for cleanup or if you want to add any additional spans based on current context.
   *
   * This is exposed because users have no other way of running something before an idle transaction
   * finishes.
   */
   registerBeforeFinishCallback(callback) {
    this._beforeFinishCallbacks.push(callback);
  }

  /**
   * @inheritDoc
   */
   initSpanRecorder(maxlen) {
    if (!this.spanRecorder) {
      var pushActivity = (id) => {
        if (this._finished) {
          return;
        }
        this._pushActivity(id);
      };
      var popActivity = (id) => {
        if (this._finished) {
          return;
        }
        this._popActivity(id);
      };

      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);

      // Start heartbeat so that transactions do not run forever.
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('Starting heartbeat');
      this._pingHeartbeat();
    }
    this.spanRecorder.add(this);
  }

  /**
   * Cancels the existing idletimeout, if there is one
   */
   _cancelIdleTimeout() {
    if (this._idleTimeoutID) {
      clearTimeout(this._idleTimeoutID);
      this._idleTimeoutID = undefined;
    }
  }

  /**
   * Creates an idletimeout
   */
   _startIdleTimeout(endTimestamp) {
    this._cancelIdleTimeout();
    this._idleTimeoutID = setTimeout(() => {
      if (!this._finished && Object.keys(this.activities).length === 0) {
        this.finish(endTimestamp);
      }
    }, this._idleTimeout);
  }

  /**
   * Start tracking a specific activity.
   * @param spanId The span id that represents the activity
   */
   _pushActivity(spanId) {
    this._cancelIdleTimeout();
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`[Tracing] pushActivity: ${spanId}`);
    this.activities[spanId] = true;
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] new activities count', Object.keys(this.activities).length);
  }

  /**
   * Remove an activity from usage
   * @param spanId The span id that represents the activity
   */
   _popActivity(spanId) {
    if (this.activities[spanId]) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`[Tracing] popActivity ${spanId}`);
            delete this.activities[spanId];
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] new activities count', Object.keys(this.activities).length);
    }

    if (Object.keys(this.activities).length === 0) {
      // We need to add the timeout here to have the real endtimestamp of the transaction
      // Remember timestampWithMs is in seconds, timeout is in ms
      var endTimestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)() + this._idleTimeout / 1000;
      this._startIdleTimeout(endTimestamp);
    }
  }

  /**
   * Checks when entries of this.activities are not changing for 3 beats.
   * If this occurs we finish the transaction.
   */
   _beat() {
    // We should not be running heartbeat if the idle transaction is finished.
    if (this._finished) {
      return;
    }

    var heartbeatString = Object.keys(this.activities).join('');

    if (heartbeatString === this._prevHeartbeatString) {
      this._heartbeatCounter += 1;
    } else {
      this._heartbeatCounter = 1;
    }

    this._prevHeartbeatString = heartbeatString;

    if (this._heartbeatCounter >= 3) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] Transaction finished because of no change for 3 heart beats');
      this.setStatus('deadline_exceeded');
      this.finish();
    } else {
      this._pingHeartbeat();
    }
  }

  /**
   * Pings the heartbeat
   */
   _pingHeartbeat() {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);
    setTimeout(() => {
      this._beat();
    }, HEARTBEAT_INTERVAL);
  }
}

/**
 * Reset transaction on scope to `undefined`
 */
function clearActiveTransaction(hub) {
  var scope = hub.getScope();
  if (scope) {
    var transaction = scope.getTransaction();
    if (transaction) {
      scope.setSpan(undefined);
    }
  }
}


//# sourceMappingURL=idletransaction.js.map


/***/ }),

/***/ 28207:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dr": () => (/* binding */ Span),
/* harmony export */   "gB": () => (/* binding */ SpanRecorder)
/* harmony export */ });
/* unused harmony export spanStatusfromHttpCode */
/* harmony import */ var _sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12885);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63699);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7790);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21995);



/**
 * Keeps track of finished spans for a given transaction
 * @internal
 * @hideconstructor
 * @hidden
 */
class SpanRecorder {
   __init() {this.spans = [];}

   constructor(maxlen = 1000) {;SpanRecorder.prototype.__init.call(this);
    this._maxlen = maxlen;
  }

  /**
   * This is just so that we don't run out of memory while recording a lot
   * of spans. At some point we just stop and flush out the start of the
   * trace tree (i.e.the first n spans with the smallest
   * start_timestamp).
   */
   add(span) {
    if (this.spans.length > this._maxlen) {
      span.spanRecorder = undefined;
    } else {
      this.spans.push(span);
    }
  }
}

/**
 * Span contains all data about a span
 */
class Span  {
  /**
   * @inheritDoc
   */
   __init2() {this.traceId = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .uuid4 */ .DM)();}

  /**
   * @inheritDoc
   */
   __init3() {this.spanId = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .uuid4 */ .DM)().substring(16);}

  /**
   * @inheritDoc
   */
  

  /**
   * Internal keeper of the status
   */
  

  /**
   * @inheritDoc
   */
  

  /**
   * Timestamp in seconds when the span was created.
   */
   __init4() {this.startTimestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)();}

  /**
   * Timestamp in seconds when the span ended.
   */
  

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
   __init5() {this.tags = {};}

  /**
   * @inheritDoc
   */
     __init6() {this.data = {};}

  /**
   * List of spans that were finalized
   */
  

  /**
   * @inheritDoc
   */
  

  /**
   * You should never call the constructor manually, always use `Sentry.startTransaction()`
   * or call `startChild()` on an existing span.
   * @internal
   * @hideconstructor
   * @hidden
   */
   constructor(spanContext) {;Span.prototype.__init2.call(this);Span.prototype.__init3.call(this);Span.prototype.__init4.call(this);Span.prototype.__init5.call(this);Span.prototype.__init6.call(this);
    if (!spanContext) {
      return this;
    }
    if (spanContext.traceId) {
      this.traceId = spanContext.traceId;
    }
    if (spanContext.spanId) {
      this.spanId = spanContext.spanId;
    }
    if (spanContext.parentSpanId) {
      this.parentSpanId = spanContext.parentSpanId;
    }
    // We want to include booleans as well here
    if ('sampled' in spanContext) {
      this.sampled = spanContext.sampled;
    }
    if (spanContext.op) {
      this.op = spanContext.op;
    }
    if (spanContext.description) {
      this.description = spanContext.description;
    }
    if (spanContext.data) {
      this.data = spanContext.data;
    }
    if (spanContext.tags) {
      this.tags = spanContext.tags;
    }
    if (spanContext.status) {
      this.status = spanContext.status;
    }
    if (spanContext.startTimestamp) {
      this.startTimestamp = spanContext.startTimestamp;
    }
    if (spanContext.endTimestamp) {
      this.endTimestamp = spanContext.endTimestamp;
    }
  }

  /**
   * @inheritDoc
   */
   startChild(
    spanContext,
  ) {
    var childSpan = new Span({
      ...spanContext,
      parentSpanId: this.spanId,
      sampled: this.sampled,
      traceId: this.traceId,
    });

    childSpan.spanRecorder = this.spanRecorder;
    if (childSpan.spanRecorder) {
      childSpan.spanRecorder.add(childSpan);
    }

    childSpan.transaction = this.transaction;

    return childSpan;
  }

  /**
   * @inheritDoc
   */
   setTag(key, value) {
    this.tags = { ...this.tags, [key]: value };
    return this;
  }

  /**
   * @inheritDoc
   */
     setData(key, value) {
    this.data = { ...this.data, [key]: value };
    return this;
  }

  /**
   * @inheritDoc
   */
   setStatus(value) {
    this.status = value;
    return this;
  }

  /**
   * @inheritDoc
   */
   setHttpStatus(httpStatus) {
    this.setTag('http.status_code', String(httpStatus));
    var spanStatus = spanStatusfromHttpCode(httpStatus);
    if (spanStatus !== 'unknown_error') {
      this.setStatus(spanStatus);
    }
    return this;
  }

  /**
   * @inheritDoc
   */
   isSuccess() {
    return this.status === 'ok';
  }

  /**
   * @inheritDoc
   */
   finish(endTimestamp) {
    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)();
  }

  /**
   * @inheritDoc
   */
   toTraceparent() {
    let sampledString = '';
    if (this.sampled !== undefined) {
      sampledString = this.sampled ? '-1' : '-0';
    }
    return `${this.traceId}-${this.spanId}${sampledString}`;
  }

  /**
   * @inheritDoc
   */
   toContext() {
    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dropUndefinedKeys */ .Jr)({
      data: this.data,
      description: this.description,
      endTimestamp: this.endTimestamp,
      op: this.op,
      parentSpanId: this.parentSpanId,
      sampled: this.sampled,
      spanId: this.spanId,
      startTimestamp: this.startTimestamp,
      status: this.status,
      tags: this.tags,
      traceId: this.traceId,
    });
  }

  /**
   * @inheritDoc
   */
   updateWithContext(spanContext) {
    this.data = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_3__/* ._nullishCoalesce */ .h)(spanContext.data, () => ( {}));
    this.description = spanContext.description;
    this.endTimestamp = spanContext.endTimestamp;
    this.op = spanContext.op;
    this.parentSpanId = spanContext.parentSpanId;
    this.sampled = spanContext.sampled;
    this.spanId = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_3__/* ._nullishCoalesce */ .h)(spanContext.spanId, () => ( this.spanId));
    this.startTimestamp = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_3__/* ._nullishCoalesce */ .h)(spanContext.startTimestamp, () => ( this.startTimestamp));
    this.status = spanContext.status;
    this.tags = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_3__/* ._nullishCoalesce */ .h)(spanContext.tags, () => ( {}));
    this.traceId = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_3__/* ._nullishCoalesce */ .h)(spanContext.traceId, () => ( this.traceId));

    return this;
  }

  /**
   * @inheritDoc
   */
   getTraceContext()

 {
    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dropUndefinedKeys */ .Jr)({
      data: Object.keys(this.data).length > 0 ? this.data : undefined,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
      trace_id: this.traceId,
    });
  }

  /**
   * @inheritDoc
   */
   toJSON()

 {
    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dropUndefinedKeys */ .Jr)({
      data: Object.keys(this.data).length > 0 ? this.data : undefined,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      start_timestamp: this.startTimestamp,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
      timestamp: this.endTimestamp,
      trace_id: this.traceId,
    });
  }
}

/**
 * Converts a HTTP status code into a {@link SpanStatusType}.
 *
 * @param httpStatus The HTTP response status code.
 * @returns The span status or unknown_error.
 */
function spanStatusfromHttpCode(httpStatus) {
  if (httpStatus < 400 && httpStatus >= 100) {
    return 'ok';
  }

  if (httpStatus >= 400 && httpStatus < 500) {
    switch (httpStatus) {
      case 401:
        return 'unauthenticated';
      case 403:
        return 'permission_denied';
      case 404:
        return 'not_found';
      case 409:
        return 'already_exists';
      case 413:
        return 'failed_precondition';
      case 429:
        return 'resource_exhausted';
      default:
        return 'invalid_argument';
    }
  }

  if (httpStatus >= 500 && httpStatus < 600) {
    switch (httpStatus) {
      case 501:
        return 'unimplemented';
      case 503:
        return 'unavailable';
      case 504:
        return 'deadline_exceeded';
      default:
        return 'internal_error';
    }
  }

  return 'unknown_error';
}


//# sourceMappingURL=span.js.map


/***/ }),

/***/ 18235:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Y": () => (/* binding */ Transaction)
/* harmony export */ });
/* harmony import */ var _sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12885);
/* harmony import */ var _sentry_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8585);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58536);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21995);
/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46990);
/* harmony import */ var _span_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28207);





/** JSDoc */
class Transaction extends _span_js__WEBPACK_IMPORTED_MODULE_0__/* .Span */ .Dr  {
  

  /**
   * The reference to the current hub.
   */
  

   __init() {this._measurements = {};}

  /**
   * This constructor should never be called manually. Those instrumenting tracing should use
   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
   * @internal
   * @hideconstructor
   * @hidden
   */
   constructor(transactionContext, hub) {
    super(transactionContext);Transaction.prototype.__init.call(this);;

    this._hub = hub || (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_1__/* .getCurrentHub */ .Gd)();

    this.name = transactionContext.name || '';

    this.metadata = transactionContext.metadata || {};
    this._trimEnd = transactionContext.trimEnd;

    // this is because transactions are also spans, and spans have a transaction pointer
    this.transaction = this;
  }

  /**
   * JSDoc
   */
   setName(name) {
    this.name = name;
  }

  /**
   * Attaches SpanRecorder to the span itself
   * @param maxlen maximum number of spans that can be recorded
   */
   initSpanRecorder(maxlen = 1000) {
    if (!this.spanRecorder) {
      this.spanRecorder = new _span_js__WEBPACK_IMPORTED_MODULE_0__/* .SpanRecorder */ .gB(maxlen);
    }
    this.spanRecorder.add(this);
  }

  /**
   * @inheritDoc
   */
   setMeasurement(name, value, unit = '') {
    this._measurements[name] = { value, unit };
  }

  /**
   * Set metadata for this transaction.
   * @hidden
   */
   setMetadata(newMetadata) {
    this.metadata = { ...this.metadata, ...newMetadata };
  }

  /**
   * @inheritDoc
   */
   finish(endTimestamp) {
    // This transaction is already finished, so we should not flush it again.
    if (this.endTimestamp !== undefined) {
      return undefined;
    }

    if (!this.name) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .logger.warn */ .kg.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');
      this.name = '<unlabeled transaction>';
    }

    // just sets the end timestamp
    super.finish(endTimestamp);

    if (this.sampled !== true) {
      // At this point if `sampled !== true` we want to discard the transaction.
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .logger.log */ .kg.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');

      var client = this._hub.getClient();
      if (client) {
        client.recordDroppedEvent('sample_rate', 'transaction');
      }

      return undefined;
    }

    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];

    if (this._trimEnd && finishedSpans.length > 0) {
      this.endTimestamp = finishedSpans.reduce((prev, current) => {
        if (prev.endTimestamp && current.endTimestamp) {
          return prev.endTimestamp > current.endTimestamp ? prev : current;
        }
        return prev;
      }).endTimestamp;
    }

    var transaction = {
      contexts: {
        trace: this.getTraceContext(),
      },
      spans: finishedSpans,
      start_timestamp: this.startTimestamp,
      tags: this.tags,
      timestamp: this.endTimestamp,
      transaction: this.name,
      type: 'transaction',
      sdkProcessingMetadata: {
        ...this.metadata,
        baggage: this.getBaggage(),
      },
    };

    var hasMeasurements = Object.keys(this._measurements).length > 0;

    if (hasMeasurements) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        _sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .logger.log */ .kg.log(
          '[Measurements] Adding measurements to transaction',
          JSON.stringify(this._measurements, undefined, 2),
        );
      transaction.measurements = this._measurements;
    }

    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .logger.log */ .kg.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);

    return this._hub.captureEvent(transaction);
  }

  /**
   * @inheritDoc
   */
   toContext() {
    var spanContext = super.toContext();

    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .dropUndefinedKeys */ .Jr)({
      ...spanContext,
      name: this.name,
      trimEnd: this._trimEnd,
    });
  }

  /**
   * @inheritDoc
   */
   updateWithContext(transactionContext) {
    super.updateWithContext(transactionContext);

    this.name = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__/* ._nullishCoalesce */ .h)(transactionContext.name, () => ( ''));

    this._trimEnd = transactionContext.trimEnd;

    return this;
  }

  /**
   * @inheritdoc
   *
   * @experimental
   */
   getBaggage() {
    var existingBaggage = this.metadata.baggage;

    // Only add Sentry baggage items to baggage, if baggage does not exist yet or it is still
    // empty and mutable
    var finalBaggage =
      !existingBaggage || (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .isBaggageMutable */ .Gp)(existingBaggage)
        ? this._populateBaggageWithSentryValues(existingBaggage)
        : existingBaggage;

    // Update the baggage stored on the transaction.
    this.metadata.baggage = finalBaggage;

    return finalBaggage;
  }

  /**
   * Collects and adds data to the passed baggage object.
   *
   * Note: This function does not explicitly check if the passed baggage object is allowed
   * to be modified. Implicitly, `setBaggageValue` will not make modification to the object
   * if it was already set immutable.
   *
   * After adding the data, the baggage object is set immutable to prevent further modifications.
   *
   * @param baggage
   *
   * @returns modified and immutable baggage object
   */
   _populateBaggageWithSentryValues(baggage = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .createBaggage */ .Hn)({})) {
    var hub = this._hub || (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_1__/* .getCurrentHub */ .Gd)();
    var client = hub && hub.getClient();

    if (!client) return baggage;

    const { environment, release } = client.getOptions() || {};
    const { publicKey: public_key } = client.getDsn() || {};

    var rate = this.metadata && this.metadata.transactionSampling && this.metadata.transactionSampling.rate;
    var sample_rate =
      rate !== undefined
        ? rate.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 16 })
        : undefined;

    var scope = hub.getScope();
    const { id: user_id, segment: user_segment } = (scope && scope.getUser()) || {};

    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .createBaggage */ .Hn)(
      (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .dropUndefinedKeys */ .Jr)({
        environment,
        release,
        transaction: this.name,
        user_id,
        user_segment,
        public_key,
        trace_id: this.traceId,
        sample_rate,
        ...(0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getSentryBaggageItems */ .Hk)(baggage), // keep user-added values
      } ),
      '',
      false, // set baggage immutable
    );
  }
}


//# sourceMappingURL=transaction.js.map


/***/ }),

/***/ 92517:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x1": () => (/* binding */ getActiveTransaction),
/* harmony export */   "zu": () => (/* binding */ hasTracingEnabled),
/* harmony export */   "XL": () => (/* binding */ msToSec)
/* harmony export */ });
/* unused harmony export secToMs */
/* harmony import */ var _sentry_hub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8585);



/**
 * Determines if tracing is currently enabled.
 *
 * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.
 */
function hasTracingEnabled(
  maybeOptions,
) {
  var client = (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)().getClient();
  var options = maybeOptions || (client && client.getOptions());
  return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);
}

/** Grabs active transaction off scope, if any */
function getActiveTransaction(maybeHub) {
  var hub = maybeHub || (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)();
  var scope = hub.getScope();
  return scope && (scope.getTransaction() );
}

/**
 * Converts from milliseconds to seconds
 * @param time time in ms
 */
function msToSec(time) {
  return time / 1000;
}

/**
 * Converts from seconds to milliseconds
 * @param time time in seconds
 */
function secToMs(time) {
  return time * 1000;
}


//# sourceMappingURL=utils.js.map


/***/ }),

/***/ 46990:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bU": () => (/* binding */ BAGGAGE_HEADER_NAME),
/* harmony export */   "Hn": () => (/* binding */ createBaggage),
/* harmony export */   "Hk": () => (/* binding */ getSentryBaggageItems),
/* harmony export */   "Gp": () => (/* binding */ isBaggageMutable),
/* harmony export */   "J8": () => (/* binding */ mergeAndSerializeBaggage),
/* harmony export */   "rg": () => (/* binding */ parseBaggageSetMutability)
/* harmony export */ });
/* unused harmony exports MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, getBaggageValue, getThirdPartyBaggage, isSentryBaggageEmpty, parseBaggageHeader, serializeBaggage, setBaggageImmutable, setBaggageValue */
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81757);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58536);



var BAGGAGE_HEADER_NAME = 'baggage';

var SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';

var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;

/**
 * Max length of a serialized baggage string
 *
 * https://www.w3.org/TR/baggage/#limits
 */
var MAX_BAGGAGE_STRING_LENGTH = 8192;

/** Create an instance of Baggage */
function createBaggage(initItems, baggageString = '', mutable = true) {
  return [{ ...initItems }, baggageString, mutable];
}

/** Get a value from baggage */
function getBaggageValue(baggage, key) {
  return baggage[0][key];
}

/** Add a value to baggage */
function setBaggageValue(baggage, key, value) {
  if (isBaggageMutable(baggage)) {
    baggage[0][key] = value;
  }
}

/** Check if the Sentry part of the passed baggage (i.e. the first element in the tuple) is empty */
function isSentryBaggageEmpty(baggage) {
  return Object.keys(baggage[0]).length === 0;
}

/** Returns Sentry specific baggage values */
function getSentryBaggageItems(baggage) {
  return baggage[0];
}

/**
 * Returns 3rd party baggage string of @param baggage
 * @param baggage
 */
function getThirdPartyBaggage(baggage) {
  return baggage[1];
}

/**
 * Checks if baggage is mutable
 * @param baggage
 * @returns true if baggage is mutable, else false
 */
function isBaggageMutable(baggage) {
  return baggage[2];
}

/**
 * Sets the passed baggage immutable
 * @param baggage
 */
function setBaggageImmutable(baggage) {
  baggage[2] = false;
}

/** Serialize a baggage object */
function serializeBaggage(baggage) {
  return Object.keys(baggage[0]).reduce((prev, key) => {
    var val = baggage[0][key] ;
    var baggageEntry = `${SENTRY_BAGGAGE_KEY_PREFIX}${encodeURIComponent(key)}=${encodeURIComponent(val)}`;
    var newVal = prev === '' ? baggageEntry : `${prev},${baggageEntry}`;
    if (newVal.length > MAX_BAGGAGE_STRING_LENGTH) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .logger.warn */ .kg.warn(`Not adding key: ${key} with val: ${val} to baggage due to exceeding baggage size limits.`);
      return prev;
    } else {
      return newVal;
    }
  }, baggage[1]);
}

/**
 * Parse a baggage header from a string or a string array and return a Baggage object
 *
 * If @param includeThirdPartyEntries is set to true, third party baggage entries are added to the Baggage object
 * (This is necessary for merging potentially pre-existing baggage headers in outgoing requests with
 * our `sentry-` values)
 */
function parseBaggageHeader(
  inputBaggageValue,
  includeThirdPartyEntries = false,
) {
  // Adding this check here because we got reports of this function failing due to the input value
  // not being a string. This debug log might help us determine what's going on here.
  if ((!Array.isArray(inputBaggageValue) && !(0,_is_js__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .HD)(inputBaggageValue)) || typeof inputBaggageValue === 'number') {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* .logger.warn */ .kg.warn(
        '[parseBaggageHeader] Received input value of incompatible type: ',
        typeof inputBaggageValue,
        inputBaggageValue,
      );

    // Gonna early-return an empty baggage object so that we don't fail later on
    return createBaggage({}, '');
  }

  var baggageEntries = ((0,_is_js__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .HD)(inputBaggageValue) ? inputBaggageValue : inputBaggageValue.join(','))
    .split(',')
    .map(entry => entry.trim())
    .filter(entry => entry !== '' && (includeThirdPartyEntries || SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(entry)));

  return baggageEntries.reduce(
    ([baggageObj, baggageString], curr) => {
      const [key, val] = curr.split('=');
      if (SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(key)) {
        var baggageKey = decodeURIComponent(key.split('-')[1]);
        return [
          {
            ...baggageObj,
            [baggageKey]: decodeURIComponent(val),
          },
          baggageString,
          true,
        ];
      } else {
        return [baggageObj, baggageString === '' ? curr : `${baggageString},${curr}`, true];
      }
    },
    [{}, '', true],
  );
}

/**
 * Merges the baggage header we saved from the incoming request (or meta tag) with
 * a possibly created or modified baggage header by a third party that's been added
 * to the outgoing request header.
 *
 * In case @param headerBaggageString exists, we can safely add the the 3rd party part of @param headerBaggage
 * with our @param incomingBaggage. This is possible because if we modified anything beforehand,
 * it would only affect parts of the sentry baggage (@see Baggage interface).
 *
 * @param incomingBaggage the baggage header of the incoming request that might contain sentry entries
 * @param thirdPartyBaggageHeader possibly existing baggage header string or string[] added from a third
 *        party to the request headers
 *
 * @return a merged and serialized baggage string to be propagated with the outgoing request
 */
function mergeAndSerializeBaggage(incomingBaggage, thirdPartyBaggageHeader) {
  if (!incomingBaggage && !thirdPartyBaggageHeader) {
    return '';
  }

  var headerBaggage = (thirdPartyBaggageHeader && parseBaggageHeader(thirdPartyBaggageHeader, true)) || undefined;
  var thirdPartyHeaderBaggage = headerBaggage && getThirdPartyBaggage(headerBaggage);

  var finalBaggage = createBaggage((incomingBaggage && incomingBaggage[0]) || {}, thirdPartyHeaderBaggage || '');
  return serializeBaggage(finalBaggage);
}

/**
 * Helper function that takes a raw baggage string (if available) and the processed sentry-trace header
 * data (if available), parses the baggage string and creates a Baggage object
 * If there is no baggage string, it will create an empty Baggage object.
 * In a second step, this functions determines if the created Baggage object should be set immutable
 * to prevent mutation of the Sentry data.
 *
 * Extracted this logic to a function because it's duplicated in a lot of places.
 *
 * @param rawBaggageValue
 * @param sentryTraceHeader
 */
function parseBaggageSetMutability(
  rawBaggageValue,
  sentryTraceHeader,
) {
  var baggage = parseBaggageHeader(rawBaggageValue || '');

  // Because we are always creating a Baggage object by calling `parseBaggageHeader` above
  // (either a filled one or an empty one, even if we didn't get a `baggage` header),
  // we only need to check if we have a sentry-trace header or not. As soon as we have it,
  // we set baggage immutable. In case we don't get a sentry-trace header, we can assume that
  // this SDK is the head of the trace and thus we still permit mutation at this time.
  // There is one exception though, which is that we get a baggage-header with `sentry-`
  // items but NO sentry-trace header. In this case we also set the baggage immutable for now
  // but if smoething like this would ever happen, we should revisit this and determine
  // what this would actually mean for the trace (i.e. is this SDK the head?, what happened
  // before that we don't have a sentry-trace header?, etc)
  (sentryTraceHeader || !isSentryBaggageEmpty(baggage)) && setBaggageImmutable(baggage);

  return baggage;
}


//# sourceMappingURL=baggage.js.map


/***/ }),

/***/ 54194:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": () => (/* binding */ getLocationHref),
/* harmony export */   "R": () => (/* binding */ htmlTreeAsString)
/* harmony export */ });
/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65907);
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81757);



/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem, keyAttrs) {
  

  // try/catch both:
  // - accessing event.target (see getsentry/raven-js#838, #768)
  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
  // - can throw an exception in some circumstances.
  try {
    let currentElem = elem ;
    var MAX_TRAVERSE_HEIGHT = 5;
    var MAX_OUTPUT_LEN = 80;
    var out = [];
    let height = 0;
    let len = 0;
    var separator = ' > ';
    var sepLength = separator.length;
    let nextStr;

        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      // bail out if
      // - nextStr is the 'html' element
      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
      //   (ignore this limit if we are on the first iteration)
      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
        break;
      }

      out.push(nextStr);

      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }

    return out.reverse().join(separator);
  } catch (_oO) {
    return '<unknown>';
  }
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el, keyAttrs) {
  var elem = el 

;

  var out = [];
  let className;
  let classes;
  let key;
  let attr;
  let i;

  if (!elem || !elem.tagName) {
    return '';
  }

  out.push(elem.tagName.toLowerCase());

  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
  var keyAttrPairs =
    keyAttrs && keyAttrs.length
      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])
      : null;

  if (keyAttrPairs && keyAttrPairs.length) {
    keyAttrPairs.forEach(keyAttrPair => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }

        className = elem.className;
    if (className && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isString */ .HD)(className)) {
      classes = className.split(/\s+/);
      for (i = 0; i < classes.length; i++) {
        out.push(`.${classes[i]}`);
      }
    }
  }
  var allowedAttrs = ['type', 'name', 'title', 'alt'];
  for (i = 0; i < allowedAttrs.length; i++) {
    key = allowedAttrs[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push(`[${key}="${attr}"]`);
    }
  }
  return out.join('');
}

/**
 * A safe form of location.href
 */
function getLocationHref() {
  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalObject */ .R)();
  try {
    return global.document.location.href;
  } catch (oO) {
    return '';
  }
}


//# sourceMappingURL=browser.js.map


/***/ }),

/***/ 12885:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ _nullishCoalesce)
/* harmony export */ });
/**
 * Polyfill for the nullish coalescing operator (`??`).
 *
 * Note that the RHS is wrapped in a function so that if it's a computed value, that evaluation won't happen unless the
 * LHS evaluates to a nullish value, to mimic the operator's short-circuiting behavior.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param lhs The value of the expression to the left of the `??`
 * @param rhsFn A function returning the value of the expression to the right of the `??`
 * @returns The LHS value, unless it's `null` or `undefined`, in which case, the RHS value
 */
function _nullishCoalesce(lhs, rhsFn) {
  // by checking for loose equality to `null`, we catch both `null` and `undefined`
  return lhs != null ? lhs : rhsFn();
}

// Sucrase version:
// function _nullishCoalesce(lhs, rhsFn) {
//   if (lhs != null) {
//     return lhs;
//   } else {
//     return rhsFn();
//   }
// }


//# sourceMappingURL=_nullishCoalesce.js.map


/***/ }),

/***/ 65907:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": () => (/* binding */ getGlobalObject),
/* harmony export */   "Y": () => (/* binding */ getGlobalSingleton)
/* harmony export */ });
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4266);


/** Internal */

var fallbackGlobalObject = {};

/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
function getGlobalObject() {
  return (
    (0,_node_js__WEBPACK_IMPORTED_MODULE_0__/* .isNodeEnv */ .KV)()
      ? global
      : typeof window !== 'undefined'       ? window       : typeof self !== 'undefined'
      ? self
      : fallbackGlobalObject
  ) ;
}

/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
function getGlobalSingleton(name, creator, obj) {
  var global = (obj || getGlobalObject()) ;
  var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});
  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
  return singleton;
}


//# sourceMappingURL=global.js.map


/***/ }),

/***/ 64005:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": () => (/* binding */ addInstrumentationHandler)
/* harmony export */ });
/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65907);
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(81757);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58536);
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21995);
/* harmony import */ var _stacktrace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69038);
/* harmony import */ var _supports_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49798);







var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();

/**
 * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
 *  - Console API
 *  - Fetch API
 *  - XHR API
 *  - History API
 *  - DOM API (click/typing)
 *  - Error API
 *  - UnhandledRejection API
 */

var handlers = {};
var instrumented = {};

/** Instruments given API */
function instrument(type) {
  if (instrumented[type]) {
    return;
  }

  instrumented[type] = true;

  switch (type) {
    case 'console':
      instrumentConsole();
      break;
    case 'dom':
      instrumentDOM();
      break;
    case 'xhr':
      instrumentXHR();
      break;
    case 'fetch':
      instrumentFetch();
      break;
    case 'history':
      instrumentHistory();
      break;
    case 'error':
      instrumentError();
      break;
    case 'unhandledrejection':
      instrumentUnhandledRejection();
      break;
    default:
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .logger.warn */ .kg.warn('unknown instrumentation type:', type);
      return;
  }
}

/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
function addInstrumentationHandler(type, callback) {
  handlers[type] = handlers[type] || [];
  (handlers[type] ).push(callback);
  instrument(type);
}

/** JSDoc */
function triggerHandlers(type, data) {
  if (!type || !handlers[type]) {
    return;
  }

  for (var handler of handlers[type] || []) {
    try {
      handler(data);
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .logger.error */ .kg.error(
          `Error while triggering instrumentation handler.\nType: ${type}\nName: ${(0,_stacktrace_js__WEBPACK_IMPORTED_MODULE_2__/* .getFunctionName */ .$P)(handler)}\nError:`,
          e,
        );
    }
  }
}

/** JSDoc */
function instrumentConsole() {
  if (!('console' in global)) {
    return;
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .CONSOLE_LEVELS.forEach */ .RU.forEach(function (level) {
    if (!(level in global.console)) {
      return;
    }

    (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global.console, level, function (originalConsoleMethod) {
      return function (...args) {
        triggerHandlers('console', { args, level });

        // this fails for some browsers. :(
        if (originalConsoleMethod) {
          originalConsoleMethod.apply(global.console, args);
        }
      };
    });
  });
}

/** JSDoc */
function instrumentFetch() {
  if (!(0,_supports_js__WEBPACK_IMPORTED_MODULE_4__/* .supportsNativeFetch */ .t$)()) {
    return;
  }

  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global, 'fetch', function (originalFetch) {
    return function (...args) {
      var handlerData = {
        args,
        fetchData: {
          method: getFetchMethod(args),
          url: getFetchUrl(args),
        },
        startTimestamp: Date.now(),
      };

      triggerHandlers('fetch', {
        ...handlerData,
      });

            return originalFetch.apply(global, args).then(
        (response) => {
          triggerHandlers('fetch', {
            ...handlerData,
            endTimestamp: Date.now(),
            response,
          });
          return response;
        },
        (error) => {
          triggerHandlers('fetch', {
            ...handlerData,
            endTimestamp: Date.now(),
            error,
          });
          // NOTE: If you are a Sentry user, and you are seeing this stack frame,
          //       it means the sentry.javascript SDK caught an error invoking your application code.
          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
          throw error;
        },
      );
    };
  });
}

/** Extract `method` from fetch call arguments */
function getFetchMethod(fetchArgs = []) {
  if ('Request' in global && (0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isInstanceOf */ .V9)(fetchArgs[0], Request) && fetchArgs[0].method) {
    return String(fetchArgs[0].method).toUpperCase();
  }
  if (fetchArgs[1] && fetchArgs[1].method) {
    return String(fetchArgs[1].method).toUpperCase();
  }
  return 'GET';
}

/** Extract `url` from fetch call arguments */
function getFetchUrl(fetchArgs = []) {
  if (typeof fetchArgs[0] === 'string') {
    return fetchArgs[0];
  }
  if ('Request' in global && (0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isInstanceOf */ .V9)(fetchArgs[0], Request)) {
    return fetchArgs[0].url;
  }
  return String(fetchArgs[0]);
}

/** JSDoc */
function instrumentXHR() {
  if (!('XMLHttpRequest' in global)) {
    return;
  }

  var xhrproto = XMLHttpRequest.prototype;

  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(xhrproto, 'open', function (originalOpen) {
    return function ( ...args) {
            var xhr = this;
      var url = args[1];
      var xhrInfo = (xhr.__sentry_xhr__ = {
                method: (0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isString */ .HD)(args[0]) ? args[0].toUpperCase() : args[0],
        url: args[1],
      });

      // if Sentry key appears in URL, don't capture it as a request
            if ((0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isString */ .HD)(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
        xhr.__sentry_own_request__ = true;
      }

      var onreadystatechangeHandler = function () {
        if (xhr.readyState === 4) {
          try {
            // touching statusCode in some platforms throws
            // an exception
            xhrInfo.status_code = xhr.status;
          } catch (e) {
            /* do nothing */
          }

          triggerHandlers('xhr', {
            args,
            endTimestamp: Date.now(),
            startTimestamp: Date.now(),
            xhr,
          });
        }
      };

      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
        (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(xhr, 'onreadystatechange', function (original) {
          return function (...readyStateArgs) {
            onreadystatechangeHandler();
            return original.apply(xhr, readyStateArgs);
          };
        });
      } else {
        xhr.addEventListener('readystatechange', onreadystatechangeHandler);
      }

      return originalOpen.apply(xhr, args);
    };
  });

  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(xhrproto, 'send', function (originalSend) {
    return function ( ...args) {
      if (this.__sentry_xhr__ && args[0] !== undefined) {
        this.__sentry_xhr__.body = args[0];
      }

      triggerHandlers('xhr', {
        args,
        startTimestamp: Date.now(),
        xhr: this,
      });

      return originalSend.apply(this, args);
    };
  });
}

let lastHref;

/** JSDoc */
function instrumentHistory() {
  if (!(0,_supports_js__WEBPACK_IMPORTED_MODULE_4__/* .supportsHistory */ .Bf)()) {
    return;
  }

  var oldOnPopState = global.onpopstate;
  global.onpopstate = function ( ...args) {
    var to = global.location.href;
    // keep track of the current URL state, as we always receive only the updated state
    var from = lastHref;
    lastHref = to;
    triggerHandlers('history', {
      from,
      to,
    });
    if (oldOnPopState) {
      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
      // https://github.com/getsentry/sentry-javascript/issues/3344
      // https://github.com/bugsnag/bugsnag-js/issues/469
      try {
        return oldOnPopState.apply(this, args);
      } catch (_oO) {
        // no-empty
      }
    }
  };

  /** @hidden */
  function historyReplacementFunction(originalHistoryFunction) {
    return function ( ...args) {
      var url = args.length > 2 ? args[2] : undefined;
      if (url) {
        // coerce to string (this is what pushState does)
        var from = lastHref;
        var to = String(url);
        // keep track of the current URL state, as we always receive only the updated state
        lastHref = to;
        triggerHandlers('history', {
          from,
          to,
        });
      }
      return originalHistoryFunction.apply(this, args);
    };
  }

  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global.history, 'pushState', historyReplacementFunction);
  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global.history, 'replaceState', historyReplacementFunction);
}

var debounceDuration = 1000;
let debounceTimerID;
let lastCapturedEvent;

/**
 * Decide whether the current event should finish the debounce of previously captured one.
 * @param previous previously captured event
 * @param current event to be captured
 */
function shouldShortcircuitPreviousDebounce(previous, current) {
  // If there was no previous event, it should always be swapped for the new one.
  if (!previous) {
    return true;
  }

  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
  if (previous.type !== current.type) {
    return true;
  }

  try {
    // If both events have the same type, it's still possible that actions were performed on different targets.
    // e.g. 2 clicks on different buttons.
    if (previous.target !== current.target) {
      return true;
    }
  } catch (e) {
    // just accessing `target` property can throw an exception in some rare circumstances
    // see: https://github.com/getsentry/sentry-javascript/issues/838
  }

  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
  // to which an event listener was attached), we treat them as the same action, as we want to capture
  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
  return false;
}

/**
 * Decide whether an event should be captured.
 * @param event event to be captured
 */
function shouldSkipDOMEvent(event) {
  // We are only interested in filtering `keypress` events for now.
  if (event.type !== 'keypress') {
    return false;
  }

  try {
    var target = event.target ;

    if (!target || !target.tagName) {
      return true;
    }

    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
    // e.g.tabbing through elements, hotkeys, etc.
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
      return false;
    }
  } catch (e) {
    // just accessing `target` property can throw an exception in some rare circumstances
    // see: https://github.com/getsentry/sentry-javascript/issues/838
  }

  return true;
}

/**
 * Wraps addEventListener to capture UI breadcrumbs
 * @param handler function that will be triggered
 * @param globalListener indicates whether event was captured by the global event listener
 * @returns wrapped breadcrumb events handler
 * @hidden
 */
function makeDOMEventHandler(handler, globalListener = false) {
  return (event) => {
    // It's possible this handler might trigger multiple times for the same
    // event (e.g. event propagation through node ancestors).
    // Ignore if we've already captured that event.
    if (!event || lastCapturedEvent === event) {
      return;
    }

    // We always want to skip _some_ events.
    if (shouldSkipDOMEvent(event)) {
      return;
    }

    var name = event.type === 'keypress' ? 'input' : event.type;

    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
    if (debounceTimerID === undefined) {
      handler({
        event: event,
        name,
        global: globalListener,
      });
      lastCapturedEvent = event;
    }
    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
    // If that's the case, emit the previous event and store locally the newly-captured DOM event.
    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
      handler({
        event: event,
        name,
        global: globalListener,
      });
      lastCapturedEvent = event;
    }

    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
    clearTimeout(debounceTimerID);
    debounceTimerID = global.setTimeout(() => {
      debounceTimerID = undefined;
    }, debounceDuration);
  };
}

/** JSDoc */
function instrumentDOM() {
  if (!('document' in global)) {
    return;
  }

  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
  // we instrument `addEventListener` so that we don't end up attaching this handler twice.
  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  global.document.addEventListener('click', globalDOMEventHandler, false);
  global.document.addEventListener('keypress', globalDOMEventHandler, false);

  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
  // guaranteed to fire at least once.)
  ['EventTarget', 'Node'].forEach((target) => {
        var proto = (global )[target] && (global )[target].prototype;
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
      return;
    }

    (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(proto, 'addEventListener', function (originalAddEventListener) {
      return function (
        
        type,
        listener,
        options,
      ) {
        if (type === 'click' || type == 'keypress') {
          try {
            var el = this ;
            var handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
            var handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });

            if (!handlerForType.handler) {
              var handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options);
            }

            handlerForType.refCount += 1;
          } catch (e) {
            // Accessing dom properties is always fragile.
            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
          }
        }

        return originalAddEventListener.call(this, type, listener, options);
      };
    });

    (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(
      proto,
      'removeEventListener',
      function (originalRemoveEventListener) {
        return function (
          
          type,
          listener,
          options,
        ) {
          if (type === 'click' || type == 'keypress') {
            try {
              var el = this ;
              var handlers = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers[type];

              if (handlerForType) {
                handlerForType.refCount -= 1;
                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = undefined;
                  delete handlers[type];                 }

                // If there are no longer any custom handlers of any type on this element, cleanup everything.
                if (Object.keys(handlers).length === 0) {
                  delete el.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e) {
              // Accessing dom properties is always fragile.
              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
            }
          }

          return originalRemoveEventListener.call(this, type, listener, options);
        };
      },
    );
  });
}

let _oldOnErrorHandler = null;
/** JSDoc */
function instrumentError() {
  _oldOnErrorHandler = global.onerror;

  global.onerror = function (msg, url, line, column, error) {
    triggerHandlers('error', {
      column,
      error,
      line,
      msg,
      url,
    });

    if (_oldOnErrorHandler) {
            return _oldOnErrorHandler.apply(this, arguments);
    }

    return false;
  };
}

let _oldOnUnhandledRejectionHandler = null;
/** JSDoc */
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;

  global.onunhandledrejection = function (e) {
    triggerHandlers('unhandledrejection', e);

    if (_oldOnUnhandledRejectionHandler) {
            return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }

    return true;
  };
}


//# sourceMappingURL=instrument.js.map


/***/ }),

/***/ 81757:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TX": () => (/* binding */ isDOMError),
/* harmony export */   "fm": () => (/* binding */ isDOMException),
/* harmony export */   "kK": () => (/* binding */ isElement),
/* harmony export */   "VZ": () => (/* binding */ isError),
/* harmony export */   "VW": () => (/* binding */ isErrorEvent),
/* harmony export */   "cO": () => (/* binding */ isEvent),
/* harmony export */   "V9": () => (/* binding */ isInstanceOf),
/* harmony export */   "i2": () => (/* binding */ isNaN),
/* harmony export */   "PO": () => (/* binding */ isPlainObject),
/* harmony export */   "pt": () => (/* binding */ isPrimitive),
/* harmony export */   "Kj": () => (/* binding */ isRegExp),
/* harmony export */   "HD": () => (/* binding */ isString),
/* harmony export */   "Cy": () => (/* binding */ isSyntheticEvent),
/* harmony export */   "J8": () => (/* binding */ isThenable)
/* harmony export */ });
var objectToString = Object.prototype.toString;

/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isError(wat) {
  switch (objectToString.call(wat)) {
    case '[object Error]':
    case '[object Exception]':
    case '[object DOMException]':
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}

function isBuiltin(wat, ty) {
  return objectToString.call(wat) === `[object ${ty}]`;
}

/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isErrorEvent(wat) {
  return isBuiltin(wat, 'ErrorEvent');
}

/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMError(wat) {
  return isBuiltin(wat, 'DOMError');
}

/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMException(wat) {
  return isBuiltin(wat, 'DOMException');
}

/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isString(wat) {
  return isBuiltin(wat, 'String');
}

/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPrimitive(wat) {
  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
}

/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPlainObject(wat) {
  return isBuiltin(wat, 'Object');
}

/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isEvent(wat) {
  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}

/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isElement(wat) {
  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
}

/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isRegExp(wat) {
  return isBuiltin(wat, 'RegExp');
}

/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === 'function');
}

/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
}

/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isNaN(wat) {
  return typeof wat === 'number' && wat !== wat;
}

/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e) {
    return false;
  }
}


//# sourceMappingURL=is.js.map


/***/ }),

/***/ 58536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RU": () => (/* binding */ CONSOLE_LEVELS),
/* harmony export */   "Cf": () => (/* binding */ consoleSandbox),
/* harmony export */   "kg": () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65907);


// TODO: Implement different loggers for different environments
var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();

/** Prefix for logging strings */
var PREFIX = 'Sentry Logger ';

var CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;

/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();

  if (!('console' in global)) {
    return callback();
  }

  var originalConsole = global.console ;
  var wrappedLevels = {};

  // Restore all wrapped console methods
  CONSOLE_LEVELS.forEach(level => {
    // TODO(v7): Remove this check as it's only needed for Node 6
    var originalWrappedFunc =
      originalConsole[level] && (originalConsole[level] ).__sentry_original__;
    if (level in global.console && originalWrappedFunc) {
      wrappedLevels[level] = originalConsole[level] ;
      originalConsole[level] = originalWrappedFunc ;
    }
  });

  try {
    return callback();
  } finally {
    // Revert restoration to wrapped state
    Object.keys(wrappedLevels).forEach(level => {
      originalConsole[level] = wrappedLevels[level ];
    });
  }
}

function makeLogger() {
  let enabled = false;
  var logger = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
  };

  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
    CONSOLE_LEVELS.forEach(name => {
            logger[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            global.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach(name => {
      logger[name] = () => undefined;
    });
  }

  return logger ;
}

// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
let logger;
if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
  logger = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalSingleton */ .Y)('logger', makeLogger);
} else {
  logger = makeLogger();
}


//# sourceMappingURL=logger.js.map


/***/ }),

/***/ 63699:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EG": () => (/* binding */ addExceptionMechanism),
/* harmony export */   "Db": () => (/* binding */ addExceptionTypeValue),
/* harmony export */   "YO": () => (/* binding */ checkOrSetAlreadyCaught),
/* harmony export */   "jH": () => (/* binding */ getEventDescription),
/* harmony export */   "en": () => (/* binding */ parseUrl),
/* harmony export */   "DM": () => (/* binding */ uuid4)
/* harmony export */ });
/* unused harmony exports addContextToFrame, parseSemver, stripUrlQueryAndFragment */
/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65907);
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21995);




/**
 * Extended Window interface that allows for Crypto API usage in IE browsers
 */

/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
function uuid4() {
  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)() ;
  var crypto = global.crypto || global.msCrypto;

  if (!(crypto === void 0) && crypto.getRandomValues) {
    // Use window.crypto API if available
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);

    // set 4 in byte 7
        arr[3] = (arr[3] & 0xfff) | 0x4000;
    // set 2 most significant bits of byte 9 to '10'
        arr[4] = (arr[4] & 0x3fff) | 0x8000;

    var pad = (num) => {
      let v = num.toString(16);
      while (v.length < 4) {
        v = `0${v}`;
      }
      return v;
    };

    return (
      pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7])
    );
  }
  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, c => {
        var r = (Math.random() * 16) | 0;
        var v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
function parseUrl(url)

 {
  if (!url) {
    return {};
  }

  var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

  if (!match) {
    return {};
  }

  // coerce to undefined values to empty string so we don't get 'undefined'
  var query = match[6] || '';
  var fragment = match[8] || '';
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    relative: match[5] + query + fragment, // everything minus origin
  };
}

function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : undefined;
}

/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }

  var firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || '<unknown>';
  }
  return eventId || '<unknown>';
}

/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
function addExceptionTypeValue(event, value, type) {
  var exception = (event.exception = event.exception || {});
  var values = (exception.values = exception.values || []);
  var firstException = (values[0] = values[0] || {});
  if (!firstException.value) {
    firstException.value = value || '';
  }
  if (!firstException.type) {
    firstException.type = type || 'Error';
  }
}

/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
function addExceptionMechanism(event, newMechanism) {
  var firstException = getFirstException(event);
  if (!firstException) {
    return;
  }

  var defaultMechanism = { type: 'generic', handled: true };
  var currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };

  if (newMechanism && 'data' in newMechanism) {
    var mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}

// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
var SEMVER_REGEXP =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;

/**
 * Represents Semantic Versioning object
 */

/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
function parseSemver(input) {
  var match = input.match(SEMVER_REGEXP) || [];
  var major = parseInt(match[1], 10);
  var minor = parseInt(match[2], 10);
  var patch = parseInt(match[3], 10);
  return {
    buildmetadata: match[5],
    major: isNaN(major) ? undefined : major,
    minor: isNaN(minor) ? undefined : minor,
    patch: isNaN(patch) ? undefined : patch,
    prerelease: match[4],
  };
}

/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
function addContextToFrame(lines, frame, linesOfContext = 5) {
  var lineno = frame.lineno || 0;
  var maxLines = lines.length;
  var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);

  frame.pre_context = lines
    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)
    .map((line) => snipLine(line, 0));

  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);

  frame.post_context = lines
    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)
    .map((line) => snipLine(line, 0));
}

/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
function stripUrlQueryAndFragment(urlPath) {
    return urlPath.split(/[\?#]/, 1)[0];
}

/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
function checkOrSetAlreadyCaught(exception) {
    if (exception && (exception ).__sentry_captured__) {
    return true;
  }

  try {
    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
    // `ExtraErrorData` integration
    (0,_object_js__WEBPACK_IMPORTED_MODULE_1__/* .addNonEnumerableProperty */ .xp)(exception , '__sentry_captured__', true);
  } catch (err) {
    // `exception` is a primitive, so we can't mark it seen
  }

  return false;
}


//# sourceMappingURL=misc.js.map


/***/ }),

/***/ 4266:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "l$": () => (/* binding */ dynamicRequire),
  "KV": () => (/* binding */ isNodeEnv),
  "$y": () => (/* binding */ loadModule)
});

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/env.js
/*
 * This module exists for optimizations in the build process through rollup and terser.  We define some global
 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
 * `logger` and preventing node-related code from appearing in browser bundles.
 *
 * Attention:
 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
 * having issues tree-shaking these constants across package boundaries.
 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
 * users to be able to shake away expressions that it guards.
 */

/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
function isBrowserBundle() {
  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
}


//# sourceMappingURL=env.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/node.js
/* module decorator */ module = __webpack_require__.hmd(module);


/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */

/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
function isNodeEnv() {
  // explicitly check for browser bundles as those can be optimized statically
  // by terser/rollup.
  return (
    !isBrowserBundle() &&
    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'
  );
}

/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
function dynamicRequire(mod, request) {
    return mod.require(request);
}

/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
function loadModule(moduleName) {
  let mod;

  try {
    mod = dynamicRequire(module, moduleName);
  } catch (e) {
    // no-empty
  }

  try {
    const { cwd } = dynamicRequire(module, 'process');
    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) ;
  } catch (e) {
    // no-empty
  }

  return mod;
}


//# sourceMappingURL=node.js.map


/***/ }),

/***/ 21995:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "xp": () => (/* binding */ addNonEnumerableProperty),
/* harmony export */   "Sh": () => (/* binding */ convertToPlainObject),
/* harmony export */   "Jr": () => (/* binding */ dropUndefinedKeys),
/* harmony export */   "zf": () => (/* binding */ extractExceptionKeysForMessage),
/* harmony export */   "hl": () => (/* binding */ fill),
/* harmony export */   "HK": () => (/* binding */ getOriginalFunction),
/* harmony export */   "$Q": () => (/* binding */ markFunctionWrapped),
/* harmony export */   "_j": () => (/* binding */ urlEncode)
/* harmony export */ });
/* unused harmony export objectify */
/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54194);
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81757);
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39660);




/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }

  var original = source[name] ;
  var wrapped = replacementFactory(original) ;

  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
  // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
  if (typeof wrapped === 'function') {
    try {
      markFunctionWrapped(wrapped, original);
    } catch (_Oo) {
      // This can throw if multiple fill happens on a global object like XMLHttpRequest
      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
    }
  }

  source[name] = wrapped;
}

/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
function addNonEnumerableProperty(obj, name, value) {
  Object.defineProperty(obj, name, {
    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
    value: value,
    writable: true,
    configurable: true,
  });
}

/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
function markFunctionWrapped(wrapped, original) {
  var proto = original.prototype || {};
  wrapped.prototype = original.prototype = proto;
  addNonEnumerableProperty(wrapped, '__sentry_original__', original);
}

/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
function getOriginalFunction(func) {
  return func.__sentry_original__;
}

/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
function urlEncode(object) {
  return Object.keys(object)
    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)
    .join('&');
}

/**
 * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their
 * non-enumerable properties attached.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor
 *  an Error.
 */
function convertToPlainObject(
  value,
)

 {
  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isError */ .VZ)(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value),
    };
  } else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isEvent */ .cO)(value)) {
    var newObj

 = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value),
    };

    if (typeof CustomEvent !== 'undefined' && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isInstanceOf */ .V9)(value, CustomEvent)) {
      newObj.detail = value.detail;
    }

    return newObj;
  } else {
    return value;
  }
}

/** Creates a string representation of the target of an `Event` object */
function serializeEventTarget(target) {
  try {
    return (0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isElement */ .kK)(target) ? (0,_browser_js__WEBPACK_IMPORTED_MODULE_1__/* .htmlTreeAsString */ .R)(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return '<unknown>';
  }
}

/** Filters out all but an object's own properties */
function getOwnProperties(obj) {
  if (typeof obj === 'object' && obj !== null) {
    var extractedProps = {};
    for (var property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = (obj )[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}

/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  var keys = Object.keys(convertToPlainObject(exception));
  keys.sort();

  if (!keys.length) {
    return '[object has no keys]';
  }

  if (keys[0].length >= maxLength) {
    return (0,_string_js__WEBPACK_IMPORTED_MODULE_2__/* .truncate */ .$G)(keys[0], maxLength);
  }

  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
    var serialized = keys.slice(0, includedKeys).join(', ');
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return (0,_string_js__WEBPACK_IMPORTED_MODULE_2__/* .truncate */ .$G)(serialized, maxLength);
  }

  return '';
}

/**
 * Given any object, return a new object having removed all fields whose value was `undefined`.
 * Works recursively on objects and arrays.
 *
 * Attention: This function keeps circular references in the returned object.
 */
function dropUndefinedKeys(inputValue) {
  // This map keeps track of what already visited nodes map to.
  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular
  // references as the input object.
  var memoizationMap = new Map();

  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API
  return _dropUndefinedKeys(inputValue, memoizationMap);
}

function _dropUndefinedKeys(inputValue, memoizationMap) {
  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isPlainObject */ .PO)(inputValue)) {
    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object
    var memoVal = memoizationMap.get(inputValue);
    if (memoVal !== undefined) {
      return memoVal ;
    }

    var returnValue = {};
    // Store the mapping of this value in case we visit it again, in case of circular data
    memoizationMap.set(inputValue, returnValue);

    for (var key of Object.keys(inputValue)) {
      if (typeof inputValue[key] !== 'undefined') {
        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
      }
    }

    return returnValue ;
  }

  if (Array.isArray(inputValue)) {
    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object
    var memoVal = memoizationMap.get(inputValue);
    if (memoVal !== undefined) {
      return memoVal ;
    }

    var returnValue = [];
    // Store the mapping of this value in case we visit it again, in case of circular data
    memoizationMap.set(inputValue, returnValue);

    inputValue.forEach((item) => {
      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
    });

    return returnValue ;
  }

  return inputValue;
}

/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
function objectify(wat) {
  let objectified;
  switch (true) {
    case wat === undefined || wat === null:
      objectified = new String(wat);
      break;

    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason
    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as
    // an object in order to wrap it.
    case typeof wat === 'symbol' || typeof wat === 'bigint':
      objectified = Object(wat);
      break;

    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`
    case isPrimitive(wat):
            objectified = new (wat ).constructor(wat);
      break;

    // by process of elimination, at this point we know that `wat` must already be an object
    default:
      objectified = wat;
      break;
  }
  return objectified;
}


//# sourceMappingURL=object.js.map


/***/ }),

/***/ 69038:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pE": () => (/* binding */ createStackParser),
/* harmony export */   "$P": () => (/* binding */ getFunctionName),
/* harmony export */   "Sq": () => (/* binding */ stackParserFromStackParserOptions)
/* harmony export */ });
/* unused harmony exports nodeStackLineParser, stripSentryFramesAndReverse */


var STACKTRACE_LIMIT = 50;

/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
function createStackParser(...parsers) {
  var sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);

  return (stack, skipFirst = 0) => {
    var frames = [];

    for (var line of stack.split('\n').slice(skipFirst)) {
      for (var parser of sortedParsers) {
        var frame = parser(line);

        if (frame) {
          frames.push(frame);
          break;
        }
      }
    }

    return stripSentryFramesAndReverse(frames);
  };
}

/**
 * Gets a stack parser implementation from Options.stackParser
 * @see Options
 *
 * If options contains an array of line parsers, it is converted into a parser
 */
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}

/**
 * @hidden
 */
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }

  let localStack = stack;

  var firstFrameFunction = localStack[0].function || '';
  var lastFrameFunction = localStack[localStack.length - 1].function || '';

  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
    localStack = localStack.slice(1);
  }

  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
    localStack = localStack.slice(0, -1);
  }

  // The frame where the crash happened, should be the last entry in the array
  return localStack
    .slice(0, STACKTRACE_LIMIT)
    .map(frame => ({
      ...frame,
      filename: frame.filename || localStack[0].filename,
      function: frame.function || '?',
    }))
    .reverse();
}

var defaultFunctionName = '<anonymous>';

/**
 * Safely extract function name from itself
 */
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== 'function') {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e) {
    // Just accessing custom props in some Selenium environments
    // can cause a "Permission denied" exception (see raven-js#495).
    return defaultFunctionName;
  }
}

function node(getModule) {
  var FILENAME_MATCH = /^\s*[-]{4,}$/;
  var FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;

    return (line) => {
    if (line.match(FILENAME_MATCH)) {
      return {
        filename: line,
      };
    }

    var lineMatch = line.match(FULL_MATCH);
    if (!lineMatch) {
      return undefined;
    }

    let object;
    let method;
    let functionName;
    let typeName;
    let methodName;

    if (lineMatch[1]) {
      functionName = lineMatch[1];

      let methodStart = functionName.lastIndexOf('.');
      if (functionName[methodStart - 1] === '.') {
                methodStart--;
      }

      if (methodStart > 0) {
        object = functionName.substr(0, methodStart);
        method = functionName.substr(methodStart + 1);
        var objectEnd = object.indexOf('.Module');
        if (objectEnd > 0) {
          functionName = functionName.substr(objectEnd + 1);
          object = object.substr(0, objectEnd);
        }
      }
      typeName = undefined;
    }

    if (method) {
      typeName = object;
      methodName = method;
    }

    if (method === '<anonymous>') {
      methodName = undefined;
      functionName = undefined;
    }

    if (functionName === undefined) {
      methodName = methodName || '<anonymous>';
      functionName = typeName ? `${typeName}.${methodName}` : methodName;
    }

    var filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];
    var isNative = lineMatch[5] === 'native';
    var isInternal =
      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\') !== 1);

    // in_app is all that's not an internal Node function or a module within node_modules
    // note that isNative appears to return true even for node core libraries
    // see https://github.com/getsentry/raven-node/issues/176
    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');

    return {
      filename,
      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),
      function: functionName,
      lineno: parseInt(lineMatch[3], 10) || undefined,
      colno: parseInt(lineMatch[4], 10) || undefined,
      in_app,
    };
  };
}

/**
 * Node.js stack line parser
 *
 * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.
 * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain
 */
function nodeStackLineParser(getModule) {
  return [90, node(getModule)];
}


//# sourceMappingURL=stacktrace.js.map


/***/ }),

/***/ 39660:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zC": () => (/* binding */ isMatchingPattern),
/* harmony export */   "nK": () => (/* binding */ safeJoin),
/* harmony export */   "$G": () => (/* binding */ truncate)
/* harmony export */ });
/* unused harmony exports escapeStringForRegex, snipLine */
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81757);


/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
function truncate(str, max = 0) {
  if (typeof str !== 'string' || max === 0) {
    return str;
  }
  return str.length <= max ? str : `${str.substr(0, max)}...`;
}

/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
function snipLine(line, colno) {
  let newLine = line;
  var lineLength = newLine.length;
  if (lineLength <= 150) {
    return newLine;
  }
  if (colno > lineLength) {
        colno = lineLength;
  }

  let start = Math.max(colno - 60, 0);
  if (start < 5) {
    start = 0;
  }

  let end = Math.min(start + 140, lineLength);
  if (end > lineLength - 5) {
    end = lineLength;
  }
  if (end === lineLength) {
    start = Math.max(end - 140, 0);
  }

  newLine = newLine.slice(start, end);
  if (start > 0) {
    newLine = `'{snip} ${newLine}`;
  }
  if (end < lineLength) {
    newLine += ' {snip}';
  }

  return newLine;
}

/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return '';
  }

  var output = [];
    for (let i = 0; i < input.length; i++) {
    var value = input[i];
    try {
      output.push(String(value));
    } catch (e) {
      output.push('[value cannot be serialized]');
    }
  }

  return output.join(delimiter);
}

/**
 * Checks if the value matches a regex or includes the string
 * @param value The string value to be checked against
 * @param pattern Either a regex or a string that must be contained in value
 */
function isMatchingPattern(value, pattern) {
  if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isString */ .HD)(value)) {
    return false;
  }

  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isRegExp */ .Kj)(pattern)) {
    return pattern.test(value);
  }
  if (typeof pattern === 'string') {
    return value.indexOf(pattern) !== -1;
  }
  return false;
}

/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
function escapeStringForRegex(regexString) {
  // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems
  // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.
  return regexString.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}


//# sourceMappingURL=string.js.map


/***/ }),

/***/ 49798:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Du": () => (/* binding */ isNativeFetch),
/* harmony export */   "Ak": () => (/* binding */ supportsFetch),
/* harmony export */   "Bf": () => (/* binding */ supportsHistory),
/* harmony export */   "t$": () => (/* binding */ supportsNativeFetch)
/* harmony export */ });
/* unused harmony exports supportsDOMError, supportsDOMException, supportsErrorEvent, supportsReferrerPolicy, supportsReportingObserver */
/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65907);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58536);



/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
function supportsErrorEvent() {
  try {
    new ErrorEvent('');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMError() {
  try {
    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':
    // 1 argument required, but only 0 present.
    // @ts-ignore It really needs 1 argument, not 0.
    new DOMError('');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMException() {
  try {
    new DOMException('');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
function supportsFetch() {
  if (!('fetch' in (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)())) {
    return false;
  }

  try {
    new Headers();
    new Request('');
    new Response();
    return true;
  } catch (e) {
    return false;
  }
}
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
function isNativeFetch(func) {
  return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}

/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
function supportsNativeFetch() {
  if (!supportsFetch()) {
    return false;
  }

  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();

  // Fast path to avoid DOM I/O
    if (isNativeFetch(global.fetch)) {
    return true;
  }

  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
  // so create a "pure" iframe to see if that has native fetch
  let result = false;
  var doc = global.document;
    if (doc && typeof (doc.createElement ) === 'function') {
    try {
      var sandbox = doc.createElement('iframe');
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
                result = isNativeFetch(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .logger.warn */ .kg.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
    }
  }

  return result;
}

/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
function supportsReportingObserver() {
  return 'ReportingObserver' in getGlobalObject();
}

/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
function supportsReferrerPolicy() {
  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
  // (see https://caniuse.com/#feat=referrer-policy),
  // it doesn't. And it throws an exception instead of ignoring this parameter...
  // REF: https://github.com/getsentry/raven-js/issues/1233

  if (!supportsFetch()) {
    return false;
  }

  try {
    new Request('_', {
      referrerPolicy: 'origin' ,
    });
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
function supportsHistory() {
  // NOTE: in Chrome App environment, touching history.pushState, *even inside
  //       a try/catch block*, will cause Chrome to output an error to console.error
  // borrowed from: https://github.com/angular/angular.js/pull/13945/files
  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();
      var chrome = (global ).chrome;
  var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;

  return !isChromePackagedApp && hasHistoryApi;
}


//# sourceMappingURL=supports.js.map


/***/ }),

/***/ 97946:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cW": () => (/* binding */ SyncPromise),
/* harmony export */   "$2": () => (/* binding */ rejectedSyncPromise),
/* harmony export */   "WD": () => (/* binding */ resolvedSyncPromise)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81757);


/** SyncPromise internal states */
var States; (function (States) {
  /** Pending */
  var PENDING = 0; States[States["PENDING"] = PENDING] = "PENDING";
  /** Resolved / OK */
  var RESOLVED = 1; States[States["RESOLVED"] = RESOLVED] = "RESOLVED";
  /** Rejected / Error */
  var REJECTED = 2; States[States["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));

// Overloads so we can call resolvedSyncPromise without arguments and generic argument

/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
function resolvedSyncPromise(value) {
  return new SyncPromise(resolve => {
    resolve(value);
  });
}

/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
function rejectedSyncPromise(reason) {
  return new SyncPromise((_, reject) => {
    reject(reason);
  });
}

/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
class SyncPromise {
   __init() {this._state = States.PENDING;}
   __init2() {this._handlers = [];}
  

   constructor(
    executor,
  ) {;SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);SyncPromise.prototype.__init5.call(this);SyncPromise.prototype.__init6.call(this);
    try {
      executor(this._resolve, this._reject);
    } catch (e) {
      this._reject(e);
    }
  }

  /** JSDoc */
   then(
    onfulfilled,
    onrejected,
  ) {
    return new SyncPromise((resolve, reject) => {
      this._handlers.push([
        false,
        result => {
          if (!onfulfilled) {
            // TODO: \_()_/
            // TODO: FIXME
            resolve(result );
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e) {
              reject(e);
            }
          }
        },
        reason => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e) {
              reject(e);
            }
          }
        },
      ]);
      this._executeHandlers();
    });
  }

  /** JSDoc */
   catch(
    onrejected,
  ) {
    return this.then(val => val, onrejected);
  }

  /** JSDoc */
   finally(onfinally) {
    return new SyncPromise((resolve, reject) => {
      let val;
      let isRejected;

      return this.then(
        value => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        },
        reason => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        },
      ).then(() => {
        if (isRejected) {
          reject(val);
          return;
        }

        resolve(val );
      });
    });
  }

  /** JSDoc */
    __init3() {this._resolve = (value) => {
    this._setResult(States.RESOLVED, value);
  };}

  /** JSDoc */
    __init4() {this._reject = (reason) => {
    this._setResult(States.REJECTED, reason);
  };}

  /** JSDoc */
    __init5() {this._setResult = (state, value) => {
    if (this._state !== States.PENDING) {
      return;
    }

    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isThenable */ .J8)(value)) {
      void (value ).then(this._resolve, this._reject);
      return;
    }

    this._state = state;
    this._value = value;

    this._executeHandlers();
  };}

  /** JSDoc */
    __init6() {this._executeHandlers = () => {
    if (this._state === States.PENDING) {
      return;
    }

    var cachedHandlers = this._handlers.slice();
    this._handlers = [];

    cachedHandlers.forEach(handler => {
      if (handler[0]) {
        return;
      }

      if (this._state === States.RESOLVED) {
                handler[1](this._value );
      }

      if (this._state === States.REJECTED) {
        handler[2](this._value);
      }

      handler[0] = true;
    });
  };}
}


//# sourceMappingURL=syncpromise.js.map


/***/ }),

/***/ 7790:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z1": () => (/* binding */ browserPerformanceTimeOrigin),
/* harmony export */   "yW": () => (/* binding */ dateTimestampInSeconds),
/* harmony export */   "ph": () => (/* binding */ timestampInSeconds),
/* harmony export */   "_I": () => (/* binding */ timestampWithMs)
/* harmony export */ });
/* unused harmony exports _browserPerformanceTimeOriginMode, usingPerformanceAPI */
/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65907);
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4266);
/* module decorator */ module = __webpack_require__.hmd(module);



/**
 * An object that can return the current timestamp in seconds since the UNIX epoch.
 */

/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
var dateTimestampSource = {
  nowSeconds: () => Date.now() / 1000,
};

/**
 * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}
 * for accessing a high-resolution monotonic clock.
 */

/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
  const { performance } = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();
  if (!performance || !performance.now) {
    return undefined;
  }

  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
  //
  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
  // performance.now() gives a date arbitrarily in the past.
  //
  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
  // undefined.
  //
  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
  // interact with data coming out of performance entries.
  //
  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
  // observed skews that can be as long as days, weeks or months.
  //
  // See https://github.com/getsentry/sentry-javascript/issues/2590.
  //
  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
  // transactions of long-lived web pages.
  var timeOrigin = Date.now() - performance.now();

  return {
    now: () => performance.now(),
    timeOrigin,
  };
}

/**
 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
 * implement the API.
 */
function getNodePerformance() {
  try {
    var perfHooks = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__/* .dynamicRequire */ .l$)(module, 'perf_hooks') ;
    return perfHooks.performance;
  } catch (_) {
    return undefined;
  }
}

/**
 * The Performance API implementation for the current platform, if available.
 */
var platformPerformance = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__/* .isNodeEnv */ .KV)() ? getNodePerformance() : getBrowserPerformance();

var timestampSource =
  platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,
      };

/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);

/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);

// Re-exported with an old name for backwards-compatibility.
var timestampWithMs = timestampInSeconds;

/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
var usingPerformanceAPI = platformPerformance !== undefined;

/**
 * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.
 */
let _browserPerformanceTimeOriginMode;

/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
var browserPerformanceTimeOrigin = (() => {
  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
  // data as reliable if they are within a reasonable threshold of the current time.

  const { performance } = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();
  if (!performance || !performance.now) {
    _browserPerformanceTimeOriginMode = 'none';
    return undefined;
  }

  var threshold = 3600 * 1000;
  var performanceNow = performance.now();
  var dateNow = Date.now();

  // if timeOrigin isn't available set delta to threshold so it isn't used
  var timeOriginDelta = performance.timeOrigin
    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
    : threshold;
  var timeOriginIsReliable = timeOriginDelta < threshold;

  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
  // Date API.
    var navigationStart = performance.timing && performance.timing.navigationStart;
  var hasNavigationStart = typeof navigationStart === 'number';
  // if navigationStart isn't available set delta to threshold so it isn't used
  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  var navigationStartIsReliable = navigationStartDelta < threshold;

  if (timeOriginIsReliable || navigationStartIsReliable) {
    // Use the more reliable time origin
    if (timeOriginDelta <= navigationStartDelta) {
      _browserPerformanceTimeOriginMode = 'timeOrigin';
      return performance.timeOrigin;
    } else {
      _browserPerformanceTimeOriginMode = 'navigationStart';
      return navigationStart;
    }
  }

  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
  _browserPerformanceTimeOriginMode = 'dateNow';
  return dateNow;
})();


//# sourceMappingURL=time.js.map


/***/ }),

/***/ 32287:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": () => (/* binding */ implementsFunction)
/* harmony export */ });
const implementsFunction = (x, fn) => x != null && typeof x[fn] === "function";


/***/ }),

/***/ 87206:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": () => (/* binding */ isArrayLike)
/* harmony export */ });
const isArrayLike = (x) => x != null && typeof x !== "function" && x.length !== undefined;


/***/ }),

/***/ 49040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "m": () => (/* binding */ isFunction)
/* harmony export */ });
const isFunction = (x) => typeof x === "function";


/***/ }),

/***/ 55157:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ isIterable)
/* harmony export */ });
const isIterable = (x) => x != null && typeof x[Symbol.iterator] === "function";


/***/ }),

/***/ 4088:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pS": () => (/* binding */ comp),
/* harmony export */   "zv": () => (/* binding */ compL)
/* harmony export */ });
/* unused harmony export compI */
/* harmony import */ var _thi_ng_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83813);

function comp(...fns) {
    let [a, b, c, d, e, f, g, h, i, j] = fns;
    switch (fns.length) {
        case 0:
            (0,_thi_ng_errors__WEBPACK_IMPORTED_MODULE_0__/* .illegalArity */ .N)(0);
        case 1:
            return a;
        case 2:
            return (...xs) => a(b(...xs));
        case 3:
            return (...xs) => a(b(c(...xs)));
        case 4:
            return (...xs) => a(b(c(d(...xs))));
        case 5:
            return (...xs) => a(b(c(d(e(...xs)))));
        case 6:
            return (...xs) => a(b(c(d(e(f(...xs))))));
        case 7:
            return (...xs) => a(b(c(d(e(f(g(...xs)))))));
        case 8:
            return (...xs) => a(b(c(d(e(f(g(h(...xs))))))));
        case 9:
            return (...xs) => a(b(c(d(e(f(g(h(i(...xs)))))))));
        case 10:
        default:
            const fn = (...xs) => a(b(c(d(e(f(g(h(i(j(...xs))))))))));
            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));
    }
}
function compL(...fns) {
    return comp.apply(null, fns.reverse());
}
/**
 * @deprecated renamed to {@link (compL:1)}
 */
const compI = (/* unused pure expression or super */ null && (compL));


/***/ }),

/***/ 94249:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": () => (/* binding */ identity)
/* harmony export */ });
const identity = (x) => x;


/***/ }),

/***/ 67044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ partial)
/* harmony export */ });
/* harmony import */ var _thi_ng_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48548);

function partial(fn, ...args) {
    let [a, b, c, d, e, f, g, h] = args;
    switch (args.length) {
        case 1:
            return (...xs) => fn(a, ...xs);
        case 2:
            return (...xs) => fn(a, b, ...xs);
        case 3:
            return (...xs) => fn(a, b, c, ...xs);
        case 4:
            return (...xs) => fn(a, b, c, d, ...xs);
        case 5:
            return (...xs) => fn(a, b, c, d, e, ...xs);
        case 6:
            return (...xs) => fn(a, b, c, d, e, f, ...xs);
        case 7:
            return (...xs) => fn(a, b, c, d, e, f, g, ...xs);
        case 8:
            return (...xs) => fn(a, b, c, d, e, f, g, h, ...xs);
        default:
            (0,_thi_ng_errors__WEBPACK_IMPORTED_MODULE_0__/* .illegalArgs */ .w)();
    }
}


/***/ }),

/***/ 80872:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "K5": () => (/* binding */ DCons)
});

// UNUSED EXPORTS: dcons, defDCons

// EXTERNAL MODULE: ../../node_modules/@thi.ng/checks/is-arraylike.js
var is_arraylike = __webpack_require__(87206);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/dcons/node_modules/@thi.ng/compare/compare.js
const compare = (a, b) => {
    if (a === b) {
        return 0;
    }
    if (a == null) {
        return b == null ? 0 : -1;
    }
    if (b == null) {
        return a == null ? 0 : 1;
    }
    if (typeof a.compare === "function") {
        return a.compare(b);
    }
    if (typeof b.compare === "function") {
        return -b.compare(a);
    }
    return a < b ? -1 : a > b ? 1 : 0;
};

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/dcons/node_modules/@thi.ng/equiv/index.js
const OBJP = Object.getPrototypeOf({});
const FN = "function";
const STR = "string";
const equiv = (a, b) => {
    let proto;
    if (a === b) {
        return true;
    }
    if (a != null) {
        if (typeof a.equiv === FN) {
            return a.equiv(b);
        }
    }
    else {
        return a == b;
    }
    if (b != null) {
        if (typeof b.equiv === FN) {
            return b.equiv(a);
        }
    }
    else {
        return a == b;
    }
    if (typeof a === STR || typeof b === STR) {
        return false;
    }
    if (((proto = Object.getPrototypeOf(a)), proto == null || proto === OBJP) &&
        ((proto = Object.getPrototypeOf(b)), proto == null || proto === OBJP)) {
        return equivObject(a, b);
    }
    if (typeof a !== FN &&
        a.length !== undefined &&
        typeof b !== FN &&
        b.length !== undefined) {
        return equivArrayLike(a, b);
    }
    if (a instanceof Set && b instanceof Set) {
        return equivSet(a, b);
    }
    if (a instanceof Map && b instanceof Map) {
        return equivMap(a, b);
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
        return a.toString() === b.toString();
    }
    // NaN
    return a !== a && b !== b;
};
const equivArrayLike = (a, b, _equiv = equiv) => {
    let l = a.length;
    if (l === b.length) {
        while (--l >= 0 && _equiv(a[l], b[l]))
            ;
    }
    return l < 0;
};
const equivSet = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a.keys()].sort(), [...b.keys()].sort());
const equivMap = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a].sort(), [...b].sort());
const equivObject = (a, b, _equiv = equiv) => {
    if (Object.keys(a).length !== Object.keys(b).length) {
        return false;
    }
    for (let k in a) {
        if (!b.hasOwnProperty(k) || !_equiv(a[k], b[k])) {
            return false;
        }
    }
    return true;
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/errors/deferror.js
var deferror = __webpack_require__(90513);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/errors/out-of-bounds.js

const OutOfBoundsError = (0,deferror/* defError */.o)(() => "index out of bounds");
const outOfBounds = (index) => {
    throw new OutOfBoundsError(index);
};
/**
 * Throws an {@link OutOfBoundsError} if `index` outside the `[min..max)` range.
 *
 * @param index
 * @param min
 * @param max
 */
const ensureIndex = (index, min, max) => (index < min || index >= max) && outOfBounds(index);
/**
 * Throws an {@link OutOfBoundsError} if either `x` or `y` is outside their
 * respective `[0..max)` range.
 *
 * @param x
 * @param y
 * @param maxX
 * @param maxY
 * @returns
 */
const ensureIndex2 = (x, y, maxX, maxY) => (x < 0 || x >= maxX || y < 0 || y >= maxY) && outOfBounds([x, y]);

// EXTERNAL MODULE: ../../node_modules/@thi.ng/errors/illegal-arguments.js
var illegal_arguments = __webpack_require__(48548);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/random/system.js + 1 modules
var system = __webpack_require__(9366);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/reduced.js
var reduced = __webpack_require__(23435);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/dcons/dcons.js






class DCons {
    constructor(src) {
        this._length = 0;
        if (src) {
            this.into(src);
        }
    }
    get length() {
        return this._length;
    }
    copy() {
        return new DCons(this);
    }
    empty() {
        return new DCons();
    }
    clear() {
        this.release();
    }
    release() {
        let cell = this.head, next;
        while (cell) {
            next = cell.next;
            delete cell.value;
            delete cell.prev;
            delete cell.next;
            cell = next;
        }
        delete this.head;
        delete this.tail;
        this._length = 0;
        return true;
    }
    compare(o) {
        const n = this._length;
        if (n < o._length) {
            return -1;
        }
        else if (n > o._length) {
            return 1;
        }
        else if (n === 0) {
            return 0;
        }
        else {
            let ca = this.head;
            let cb = o.head;
            let res = 0;
            while (ca && res == 0) {
                res = compare(ca.value, cb.value);
                ca = ca.next;
                cb = cb.next;
            }
            return res;
        }
    }
    equiv(o) {
        if (!(o instanceof DCons || (0,is_arraylike/* isArrayLike */.z)(o)) ||
            this._length !== o.length) {
            return false;
        }
        if (!this._length || this === o)
            return true;
        let cell = this.head;
        for (let x of o) {
            if (!equiv(cell.value, x)) {
                return false;
            }
            cell = cell.next;
        }
        return true;
    }
    *[Symbol.iterator]() {
        let cell = this.head;
        while (cell) {
            yield cell.value;
            cell = cell.next;
        }
    }
    /** {@inheritDoc @thi.ng/api#ISeqable.seq} */
    seq(start = 0, end = this.length) {
        if (start >= end || start < 0)
            return;
        let cell = this.nthCell(start);
        const last = this.nthCell(end - 1);
        const $seq = (cell) => ({
            first() {
                return cell.value;
            },
            next() {
                return cell !== last && cell.next ? $seq(cell.next) : undefined;
            },
        });
        return cell ? $seq(cell) : undefined;
    }
    *cycle() {
        while (true) {
            yield* this;
        }
    }
    /** {@inheritDoc @thi.ng/transducers#IReducible.$reduce} */
    $reduce(rfn, acc) {
        let cell = this.head;
        while (cell && !(0,reduced/* isReduced */.Vp)(acc)) {
            acc = rfn(acc, cell.value);
            cell = cell.next;
        }
        return acc;
    }
    drop() {
        const cell = this.head;
        if (cell) {
            this.head = cell.next;
            if (this.head) {
                delete this.head.prev;
            }
            else {
                delete this.tail;
            }
            this._length--;
            return cell.value;
        }
    }
    cons(value) {
        const cell = { value, next: this.head };
        if (this.head) {
            this.head.prev = cell;
        }
        else {
            this.tail = cell;
        }
        this.head = cell;
        this._length++;
        return this;
    }
    insertBefore(cell, value) {
        if (!cell) {
            (0,illegal_arguments/* illegalArgs */.w)("cell is undefined");
        }
        const newCell = { value, next: cell, prev: cell.prev };
        if (cell.prev) {
            cell.prev.next = newCell;
        }
        else {
            this.head = newCell;
        }
        cell.prev = newCell;
        this._length++;
        return this;
    }
    insertAfter(cell, value) {
        if (!cell) {
            (0,illegal_arguments/* illegalArgs */.w)("cell is undefined");
        }
        const newCell = { value, next: cell.next, prev: cell };
        if (cell.next) {
            cell.next.prev = newCell;
        }
        else {
            this.tail = newCell;
        }
        cell.next = newCell;
        this._length++;
        return this;
    }
    insertBeforeNth(n, x) {
        if (n < 0) {
            n += this._length;
        }
        if (n <= 0) {
            return this.cons(x);
        }
        else {
            ensureIndex(n, 0, this._length);
            return this.insertBefore(this.nthCellUnsafe(n), x);
        }
    }
    insertAfterNth(n, x) {
        if (n < 0) {
            n += this._length;
        }
        if (n >= this._length - 1) {
            return this.push(x);
        }
        else {
            ensureIndex(n, 0, this._length);
            return this.insertAfter(this.nthCellUnsafe(n), x);
        }
    }
    insertSorted(value, cmp) {
        cmp = cmp || compare;
        let cell = this.head;
        while (cell) {
            if (cmp(value, cell.value) <= 0) {
                return this.insertBefore(cell, value);
            }
            cell = cell.next;
        }
        return this.push(value);
    }
    find(value) {
        let cell = this.head;
        while (cell) {
            if (cell.value === value) {
                return cell;
            }
            cell = cell.next;
        }
    }
    findWith(fn) {
        let cell = this.head;
        while (cell) {
            if (fn(cell.value)) {
                return cell;
            }
            cell = cell.next;
        }
    }
    concat(...slices) {
        const res = this.copy();
        for (let slice of slices) {
            res.into(slice);
        }
        return res;
    }
    into(src) {
        for (let x of src) {
            this.push(x);
        }
    }
    slice(from = 0, to = this.length) {
        let a = from < 0 ? from + this._length : from;
        let b = to < 0 ? to + this._length : to;
        if (a < 0 || b < 0) {
            (0,illegal_arguments/* illegalArgs */.w)("invalid indices: ${from} / ${to}");
        }
        const res = new DCons();
        let cell = this.nthCell(a);
        while (cell && ++a <= b) {
            res.push(cell.value);
            cell = cell.next;
        }
        return res;
    }
    splice(at, del = 0, insert) {
        let cell;
        if (typeof at === "number") {
            if (at < 0) {
                at += this._length;
            }
            ensureIndex(at, 0, this._length);
            cell = this.nthCellUnsafe(at);
        }
        else {
            cell = at;
        }
        const removed = new DCons();
        if (del > 0) {
            while (cell && del-- > 0) {
                this.remove(cell);
                removed.push(cell.value);
                cell = cell.next;
            }
        }
        else if (cell) {
            cell = cell.next;
        }
        if (insert) {
            if (cell) {
                for (let i of insert) {
                    this.insertBefore(cell, i);
                }
            }
            else {
                for (let i of insert) {
                    this.push(i);
                }
            }
        }
        return removed;
    }
    remove(cell) {
        if (cell.prev) {
            cell.prev.next = cell.next;
        }
        else {
            this.head = cell.next;
        }
        if (cell.next) {
            cell.next.prev = cell.prev;
        }
        else {
            this.tail = cell.prev;
        }
        this._length--;
        return this;
    }
    swap(a, b) {
        if (a !== b) {
            const t = a.value;
            a.value = b.value;
            b.value = t;
        }
        return this;
    }
    push(value) {
        if (this.tail) {
            const cell = { value, prev: this.tail };
            this.tail.next = cell;
            this.tail = cell;
            this._length++;
            return this;
        }
        else {
            return this.cons(value);
        }
    }
    pop() {
        const cell = this.tail;
        if (!cell) {
            return;
        }
        this.tail = cell.prev;
        if (this.tail) {
            delete this.tail.next;
        }
        else {
            delete this.head;
        }
        this._length--;
        return cell.value;
    }
    first() {
        return this.head && this.head.value;
    }
    peek() {
        return this.tail && this.tail.value;
    }
    setHead(v) {
        if (this.head) {
            this.head.value = v;
            return this;
        }
        return this.cons(v);
    }
    setTail(v) {
        if (this.tail) {
            this.tail.value = v;
            return this;
        }
        return this.push(v);
    }
    setNth(n, v) {
        const cell = this.nthCell(n);
        !cell && (0,illegal_arguments/* illegalArgs */.w)(`index out of bounds: ${n}`);
        cell.value = v;
        return this;
    }
    nth(n, notFound) {
        const cell = this.nthCell(n);
        return cell ? cell.value : notFound;
    }
    nthCell(n) {
        if (n < 0) {
            n += this._length;
        }
        if (n < 0 || n >= this._length) {
            return;
        }
        return this.nthCellUnsafe(n);
    }
    rotateLeft() {
        switch (this._length) {
            case 0:
            case 1:
                return this;
            case 2:
                return this.swap(this.head, this.tail);
            default:
                return this.push(this.drop());
        }
    }
    rotateRight() {
        switch (this._length) {
            case 0:
            case 1:
                return this;
            case 2:
                return this.swap(this.head, this.tail);
            default:
                const x = this.peek();
                this.pop();
                return this.cons(x);
        }
    }
    map(fn) {
        const res = new DCons();
        let cell = this.head;
        while (cell) {
            res.push(fn(cell.value));
            cell = cell.next;
        }
        return res;
    }
    filter(pred) {
        const res = new DCons();
        let cell = this.head;
        while (cell) {
            pred(cell.value) && res.push(cell.value);
            cell = cell.next;
        }
        return res;
    }
    reduce(rfn, initial) {
        let acc = initial;
        let cell = this.head;
        while (cell) {
            // TODO add early termination support
            acc = rfn(acc, cell.value);
            cell = cell.next;
        }
        return acc;
    }
    /**
     * Shuffles list by probabilistically moving cells to head or tail
     * positions.
     *
     * @remarks
     * Supports configurable iterations and custom PRNG via
     * {@link @thi.ng/random#IRandom} (default:
     * {@link @thi.ng/random#SYSTEM}).
     *
     * Default iterations: `ceil(3/2 * log2(n))`
     *
     * @param iter -
     * @param rnd -
     */
    shuffle(iter, rnd = system/* SYSTEM */.w) {
        if (this._length < 2)
            return this;
        for (iter = iter !== null && iter !== void 0 ? iter : Math.ceil(1.5 * Math.log2(this._length)); iter > 0; iter--) {
            let cell = this.head;
            while (cell) {
                const next = cell.next;
                rnd.float() < 0.5 ? this.asHead(cell) : this.asTail(cell);
                cell = next;
            }
        }
        return this;
    }
    /**
     * Merge sort implementation based on Simon Tatham's algorithm:
     * https://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
     *
     * @remarks
     * Uses {@link @thi.ng/compare#compare} as default comparator.
     *
     * @param cmp -
     */
    sort(cmp = compare) {
        if (!this._length)
            return this;
        let inSize = 1;
        while (true) {
            let p = this.head;
            this.head = undefined;
            this.tail = undefined;
            let numMerges = 0;
            while (p) {
                numMerges++;
                let q = p;
                let psize = 0;
                for (let i = 0; i < inSize; i++) {
                    psize++;
                    q = q.next;
                    if (!q)
                        break;
                }
                let qsize = inSize;
                while (psize > 0 || (qsize > 0 && q)) {
                    let e;
                    if (psize === 0) {
                        e = q;
                        q = q.next;
                        qsize--;
                    }
                    else if (!q || qsize === 0) {
                        e = p;
                        p = p.next;
                        psize--;
                    }
                    else if (cmp(p.value, q.value) <= 0) {
                        e = p;
                        p = p.next;
                        psize--;
                    }
                    else {
                        e = q;
                        q = q.next;
                        qsize--;
                    }
                    if (this.tail) {
                        this.tail.next = e;
                    }
                    else {
                        this.head = e;
                    }
                    e.prev = this.tail;
                    this.tail = e;
                }
                p = q;
            }
            this.tail.next = undefined;
            if (numMerges <= 1) {
                return this;
            }
            inSize *= 2;
        }
    }
    reverse() {
        let head = this.head;
        let tail = this.tail;
        let n = (this._length >>> 1) + (this._length & 1);
        while (head && tail && n > 0) {
            const t = head.value;
            head.value = tail.value;
            tail.value = t;
            head = head.next;
            tail = tail.prev;
            n--;
        }
        return this;
    }
    asHead(cell) {
        if (cell === this.head) {
            return this;
        }
        this.remove(cell);
        this.head.prev = cell;
        cell.next = this.head;
        cell.prev = undefined;
        this.head = cell;
        this._length++;
        return this;
    }
    asTail(cell) {
        if (cell === this.tail) {
            return this;
        }
        this.remove(cell);
        this.tail.next = cell;
        cell.prev = this.tail;
        cell.next = undefined;
        this.tail = cell;
        this._length++;
        return this;
    }
    toString() {
        let res = [];
        let cell = this.head;
        while (cell) {
            res.push(String(cell.value));
            cell = cell.next;
        }
        return res.join(", ");
    }
    toJSON() {
        return [...this];
    }
    nthCellUnsafe(n) {
        let cell, dir;
        if (n <= this._length >> 1) {
            cell = this.head;
            dir = "next";
        }
        else {
            cell = this.tail;
            dir = "prev";
            n = this._length - n - 1;
        }
        while (n-- > 0 && cell) {
            cell = cell[dir];
        }
        return cell;
    }
}
/**
 * Functional syntax sugar for `new DCons(src?)`.
 *
 * @param src -
 */
const defDCons = (src) => new DCons(src);
/**
 * @deprecated use {@link defDCons} instead
 */
const dcons = (/* unused pure expression or super */ null && (defDCons));


/***/ }),

/***/ 90513:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": () => (/* binding */ defError)
/* harmony export */ });
const defError = (prefix, suffix = (msg) => (msg !== undefined ? ": " + msg : "")) => class extends Error {
    constructor(msg) {
        super(prefix(msg) + suffix(msg));
    }
};


/***/ }),

/***/ 48548:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": () => (/* binding */ illegalArgs)
/* harmony export */ });
/* unused harmony export IllegalArgumentError */
/* harmony import */ var _deferror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90513);

const IllegalArgumentError = (0,_deferror__WEBPACK_IMPORTED_MODULE_0__/* .defError */ .o)(() => "illegal argument(s)");
const illegalArgs = (msg) => {
    throw new IllegalArgumentError(msg);
};


/***/ }),

/***/ 83813:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ illegalArity)
/* harmony export */ });
/* unused harmony export IllegalArityError */
/* harmony import */ var _deferror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90513);

const IllegalArityError = (0,_deferror__WEBPACK_IMPORTED_MODULE_0__/* .defError */ .o)(() => "illegal arity");
const illegalArity = (n) => {
    throw new IllegalArityError(n);
};


/***/ }),

/***/ 9366:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "w": () => (/* binding */ SYSTEM)
});

// UNUSED EXPORTS: SystemRandom

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/random/arandom.js
const INV_MAX = 1 / 0xffffffff;
class ARandom {
    float(norm = 1) {
        return this.int() * INV_MAX * norm;
    }
    norm(norm = 1) {
        return (this.int() * INV_MAX - 0.5) * 2 * norm;
    }
    minmax(min, max) {
        return this.float() * (max - min) + min;
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/random/system.js

const random = Math.random;
/**
 * A `Math.random()` based {@link IRandom} implementation. Also @see
 * {@link SYSTEM}.
 */
class SystemRandom extends ARandom {
    int() {
        return (random() * 4294967296) /* 2**32 */ >>> 0;
    }
    float(norm = 1) {
        return random() * norm;
    }
    norm(norm = 1) {
        return (random() - 0.5) * 2 * norm;
    }
}
/**
 * Used as default PRNG throughout most other thi.ng projects, though usually is
 * configurable.
 */
const SYSTEM = new SystemRandom();


/***/ }),

/***/ 32883:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "p": () => (/* binding */ comp)
/* harmony export */ });
/* harmony import */ var _thi_ng_compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4088);
/* harmony import */ var _internal_ensure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46145);


function comp(...fns) {
    fns = fns.map(_internal_ensure__WEBPACK_IMPORTED_MODULE_0__/* .ensureTransducer */ .q);
    return _thi_ng_compose__WEBPACK_IMPORTED_MODULE_1__/* .comp.apply */ .pS.apply(null, fns);
}


/***/ }),

/***/ 48008:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": () => (/* binding */ compR)
/* harmony export */ });
/**
 * Reducer composition helper, internally used by various transducers
 * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a
 * reducing function `fn`. Returns a new reducer tuple.
 *
 * @remarks
 * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.
 * `fn` accepts values of type `C` and produces interim results of type
 * `B`, which are then (possibly) passed to the "inner" `rfn[2]`
 * function. Therefore the resulting reducer takes inputs of `C` and an
 * accumulator of type `A`.
 *
 * It is assumed that `fn` internally calls `rfn[2]` to pass its own
 * results for further processing by the nested reducer `rfn`.
 *
 * @example
 * ```ts
 * compR(rfn, fn)
 * // [rfn[0], rfn[1], fn]
 * ```
 *
 * @param rfn -
 * @param fn -
 */
const compR = (rfn, fn) => [rfn[0], rfn[1], fn];


/***/ }),

/***/ 46145:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "q": () => (/* binding */ ensureTransducer)
/* harmony export */ });
/* harmony import */ var _thi_ng_checks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32287);

const ensureTransducer = (x) => (0,_thi_ng_checks__WEBPACK_IMPORTED_MODULE_0__/* .implementsFunction */ .f)(x, "xform") ? x.xform() : x;


/***/ }),

/***/ 46171:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ps": () => (/* binding */ $iter),
  "Vc": () => (/* binding */ iterator1)
});

// UNUSED EXPORTS: iterator

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/node_modules/@thi.ng/api/constants.js
const DEFAULT_EPS = 1e-6;
/**
 * Internal use only. **Do NOT use in user land code!**
 *
 * @internal
 */
const SEMAPHORE = Symbol();
/**
 * No-effect placeholder function.
 */
const NO_OP = () => { };
/**
 * Catch-all event ID
 */
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";

// EXTERNAL MODULE: ../../node_modules/@thi.ng/checks/is-iterable.js
var is_iterable = __webpack_require__(55157);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/internal/ensure.js
var ensure = __webpack_require__(46145);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/reduced.js
var reduced = __webpack_require__(23435);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/iterator.js





/**
 * Takes a transducer and input iterable. Returns iterator of
 * transformed results.
 *
 * @param xform -
 * @param xs -
 */
function* iterator(xform, xs) {
    const rfn = ensureTransducer(xform)(push());
    const complete = rfn[1];
    const reduce = rfn[2];
    for (let x of xs) {
        const y = reduce([], x);
        if (isReduced(y)) {
            yield* unreduced(complete(y.deref()));
            return;
        }
        if (y.length) {
            yield* y;
        }
    }
    yield* unreduced(complete([]));
}
/**
 * Optimized version of {@link iterator} for transducers which are
 * guaranteed to:
 *
 * 1) Only produce none or a single result per input
 * 2) Do not require a `completion` reduction step
 *
 * @param xform -
 * @param xs -
 */
function* iterator1(xform, xs) {
    const reduce = ((0,ensure/* ensureTransducer */.q)(xform)([NO_OP, NO_OP, (_, x) => x]))[2];
    for (let x of xs) {
        let y = reduce(SEMAPHORE, x);
        if ((0,reduced/* isReduced */.Vp)(y)) {
            y = (0,reduced/* unreduced */.Hw)(y.deref());
            if (y !== SEMAPHORE) {
                yield y;
            }
            return;
        }
        if (y !== SEMAPHORE) {
            yield y;
        }
    }
}
/**
 * Helper function used by various transducers to wrap themselves as
 * transforming iterators. Delegates to {@link iterator1} by default.
 *
 * @param xform -
 * @param args -
 * @param impl -
 *
 * @internal
 */
const $iter = (xform, args, impl = iterator1) => {
    const n = args.length - 1;
    return (0,is_iterable/* isIterable */.T)(args[n])
        ? args.length > 1
            ? impl(xform.apply(null, args.slice(0, n)), args[n])
            : impl(xform(), args[0])
        : undefined;
};


/***/ }),

/***/ 48287:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u4": () => (/* binding */ reduce),
/* harmony export */   "I6": () => (/* binding */ reducer)
/* harmony export */ });
/* unused harmony exports reduceRight, $$reduce */
/* harmony import */ var _thi_ng_checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32287);
/* harmony import */ var _thi_ng_checks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87206);
/* harmony import */ var _thi_ng_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83813);
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23435);



const parseArgs = (args) => args.length === 2
    ? [undefined, args[1]]
    : args.length === 3
        ? [args[1], args[2]]
        : (0,_thi_ng_errors__WEBPACK_IMPORTED_MODULE_0__/* .illegalArity */ .N)(args.length);
function reduce(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce = rfn[2];
    args = parseArgs(args);
    const acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    return (0,_reduced__WEBPACK_IMPORTED_MODULE_1__/* .unreduced */ .Hw)(complete((0,_thi_ng_checks__WEBPACK_IMPORTED_MODULE_2__/* .implementsFunction */ .f)(xs, "$reduce")
        ? xs.$reduce(reduce, acc)
        : (0,_thi_ng_checks__WEBPACK_IMPORTED_MODULE_3__/* .isArrayLike */ .z)(xs)
            ? reduceArray(reduce, acc, xs)
            : reduceIterable(reduce, acc, xs)));
}
function reduceRight(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce = rfn[2];
    args = parseArgs(args);
    let acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    for (let i = xs.length; --i >= 0;) {
        acc = reduce(acc, xs[i]);
        if (isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return unreduced(complete(acc));
}
const reduceArray = (rfn, acc, xs) => {
    for (let i = 0, n = xs.length; i < n; i++) {
        acc = rfn(acc, xs[i]);
        if ((0,_reduced__WEBPACK_IMPORTED_MODULE_1__/* .isReduced */ .Vp)(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reduceIterable = (rfn, acc, xs) => {
    for (let x of xs) {
        acc = rfn(acc, x);
        if ((0,_reduced__WEBPACK_IMPORTED_MODULE_1__/* .isReduced */ .Vp)(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
/**
 * Convenience helper for building a full {@link Reducer} using the identity
 * function (i.e. `(x) => x`) as completion step (true for 90% of all
 * bundled transducers).
 *
 * @param init - init step of reducer
 * @param rfn - reduction step of reducer
 */
const reducer = (init, rfn) => [init, (acc) => acc, rfn];
const $$reduce = (rfn, args) => {
    const n = args.length - 1;
    return isIterable(args[n])
        ? args.length > 1
            ? reduce(rfn.apply(null, args.slice(0, n)), args[n])
            : reduce(rfn(), args[0])
        : undefined;
};


/***/ }),

/***/ 23435:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vp": () => (/* binding */ isReduced),
/* harmony export */   "Hw": () => (/* binding */ unreduced)
/* harmony export */ });
/* unused harmony exports Reduced, reduced, ensureReduced */
class Reduced {
    constructor(val) {
        this.value = val;
    }
    deref() {
        return this.value;
    }
}
const reduced = (x) => new Reduced(x);
const isReduced = (x) => x instanceof Reduced;
const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);
const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);


/***/ }),

/***/ 56589:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "V": () => (/* binding */ push)
/* harmony export */ });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48287);

function push(xs) {
    return xs
        ? [...xs]
        : (0,_reduce__WEBPACK_IMPORTED_MODULE_0__/* .reducer */ .I6)(() => [], (acc, x) => (acc.push(x), acc));
}


/***/ }),

/***/ 75335:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (/* binding */ keep)
/* harmony export */ });
/* harmony import */ var _thi_ng_compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94249);
/* harmony import */ var _func_compr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48008);
/* harmony import */ var _iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46171);



function keep(...args) {
    return ((0,_iterator__WEBPACK_IMPORTED_MODULE_0__/* .$iter */ .ps)(keep, args) ||
        ((rfn) => {
            const r = rfn[2];
            const pred = args[0] || _thi_ng_compose__WEBPACK_IMPORTED_MODULE_1__/* .identity */ .y;
            return (0,_func_compr__WEBPACK_IMPORTED_MODULE_2__/* .compR */ .w)(rfn, (acc, x) => pred(x) != null ? r(acc, x) : acc);
        }));
}


/***/ }),

/***/ 84900:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _thi_ng_checks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55157);
/* harmony import */ var _func_compr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48008);
/* harmony import */ var _iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46171);



function map(fn, src) {
    return (0,_thi_ng_checks__WEBPACK_IMPORTED_MODULE_0__/* .isIterable */ .T)(src)
        ? (0,_iterator__WEBPACK_IMPORTED_MODULE_1__/* .iterator1 */ .Vc)(map(fn), src)
        : (rfn) => {
            const r = rfn[2];
            return (0,_func_compr__WEBPACK_IMPORTED_MODULE_2__/* .compR */ .w)(rfn, (acc, x) => r(acc, fn(x)));
        };
}


/***/ }),

/***/ 14848:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": () => (/* binding */ pluck)
/* harmony export */ });
/* harmony import */ var _thi_ng_checks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55157);
/* harmony import */ var _iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46171);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84900);



function pluck(key, src) {
    return (0,_thi_ng_checks__WEBPACK_IMPORTED_MODULE_0__/* .isIterable */ .T)(src)
        ? (0,_iterator__WEBPACK_IMPORTED_MODULE_1__/* .iterator1 */ .Vc)(pluck(key), src)
        : (0,_map__WEBPACK_IMPORTED_MODULE_2__/* .map */ .U)((x) => x[key]);
}


/***/ }),

/***/ 9572:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": () => (/* binding */ sideEffect)
/* harmony export */ });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84900);

/**
 * Helper transducer. Applies given `fn` to each input value, presumably
 * for side effects. Discards function's result and yields original
 * inputs.
 *
 * @param fn - side effect
 */
const sideEffect = (fn) => (0,_map__WEBPACK_IMPORTED_MODULE_0__/* .map */ .U)((x) => (fn(x), x));


/***/ }),

/***/ 97358:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyState = exports.verifyIdentifier = exports.verifyType = exports.checkModifier = void 0;
var Logger_1 = __webpack_require__(98154);
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        Logger_1.logger.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
exports.checkModifier = checkModifier;
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
exports.verifyType = verifyType;
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        Logger_1.logger.throwArgumentError("invalid identifier \"" + value + "\"", "value", value);
    }
    return value;
}
exports.verifyIdentifier = verifyIdentifier;
function verifyState(value) {
    var result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                Logger_1.logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                Logger_1.logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            Logger_1.logger.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            Logger_1.logger.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        Logger_1.logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
exports.verifyState = verifyState;
//# sourceMappingURL=Checkers.js.map

/***/ }),

/***/ 6659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractABI = exports.parseABIFromString = void 0;
var Format_1 = __webpack_require__(93060);
var Fragments_1 = __webpack_require__(81864);
var Logger_1 = __webpack_require__(98154);
var Utils_1 = __webpack_require__(25011);
/**
 *
 * @param fragments string representation of contract abi, could either be array or string
 * @returns
 */
function parseABIFromString(fragments) {
    var c = new ContractABI(fragments);
    return JSON.parse(c.format("json"));
}
exports.parseABIFromString = parseABIFromString;
var ContractABI = /** @class */ (function () {
    function ContractABI(fragments) {
        var _newTarget = this.constructor;
        var _this = this;
        Logger_1.logger.checkNew(_newTarget, ContractABI);
        var abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        (0, Utils_1.defineReadOnly)(this, "fragments", abi.map(function (fragment) {
            return (0, Fragments_1.parseFragment)(fragment);
        }).filter(function (fragment) { return (fragment != null); }));
        (0, Utils_1.defineReadOnly)(this, "functions", {});
        (0, Utils_1.defineReadOnly)(this, "errors", {});
        (0, Utils_1.defineReadOnly)(this, "events", {});
        (0, Utils_1.defineReadOnly)(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach(function (fragment) {
            var bucket = null;
            switch (fragment.type) {
                case "constructor":
                    // if (this.deploy) {
                    //   logger.warn("duplicate definition - constructor");
                    //   return;
                    // }
                    //checkNames(fragment, "input", fragment.inputs);
                    // defineReadOnly(this, "deploy", <ConstructorFragment>fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = _this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = _this.events;
                    break;
                case "error":
                    bucket = _this.errors;
                    break;
                default:
                    return;
            }
            var signature = fragment.format();
            if (bucket[signature]) {
                Logger_1.logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        // if (!this.deploy) {
        //   defineReadOnly(this, "deploy", ConstructorFragment.from({
        //     payable: false,
        //     type: "constructor"
        //   }));
        // }
        // defineReadOnly(this, "_isInterface", true);
    }
    ContractABI.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.full;
        }
        if (format === Format_1.FormatTypes.sighash) {
            Logger_1.logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });
        // We need to re-bundle the JSON fragments a bit
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));
        }
        return abi;
    };
    return ContractABI;
}());
exports.ContractABI = ContractABI;
//# sourceMappingURL=ContractABI.js.map

/***/ }),

/***/ 93060:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormatTypes = void 0;
exports.FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
//# sourceMappingURL=Format.js.map

/***/ }),

/***/ 53534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstructorFragment = void 0;
var Logger_1 = __webpack_require__(98154);
var ParamType_1 = __webpack_require__(3671);
var Fragments_1 = __webpack_require__(55585);
var Checkers_1 = __webpack_require__(97358);
var Utils_1 = __webpack_require__(25011);
var Format_1 = __webpack_require__(93060);
var ConstructorFragment = /** @class */ (function (_super) {
    __extends(ConstructorFragment, _super);
    function ConstructorFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // gas?: BigNumber;
    ConstructorFragment.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability,
                // payable: this.payable,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })
            });
        }
        if (format === Format_1.FormatTypes.sighash) {
            Logger_1.logger.throwError("cannot format a constructor for sighash", Logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        var result = "constructor(" + this.inputs.map(function (input) { return input.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    };
    ConstructorFragment.from = function (value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    };
    ConstructorFragment.fromObject = function (value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            Logger_1.logger.throwArgumentError("invalid constructor object", "value", value);
        }
        var state = (0, Checkers_1.verifyState)(value);
        if (state.constant) {
            Logger_1.logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        var params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType_1.ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            // gas: (value.gas ? BigNumber.from(value.gas): null)
        };
        return new ConstructorFragment(Utils_1._constructorGuard, params);
    };
    ConstructorFragment.fromString = function (value) {
        var params = { type: "constructor" };
        // value = parseGas(value, params);
        var parens = value.match(Fragments_1.regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            Logger_1.logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = (0, ParamType_1.parseParams)(parens[2].trim(), false);
        (0, Fragments_1.parseModifiers)(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    };
    ConstructorFragment.isConstructorFragment = function (value) {
        return (value && value._isFragment && value.type === "constructor");
    };
    return ConstructorFragment;
}(Fragments_1.Fragment));
exports.ConstructorFragment = ConstructorFragment;
//# sourceMappingURL=ConstructorFragment.js.map

/***/ }),

/***/ 20102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorFragment = void 0;
var Logger_1 = __webpack_require__(98154);
var ParamType_1 = __webpack_require__(3671);
var Fragments_1 = __webpack_require__(55585);
var Checkers_1 = __webpack_require__(97358);
var Utils_1 = __webpack_require__(25011);
var Format_1 = __webpack_require__(93060);
var ErrorFragment = /** @class */ (function (_super) {
    __extends(ErrorFragment, _super);
    function ErrorFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ErrorFragment.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),
            });
        }
        var result = "";
        if (format !== Format_1.FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map(function (input) { return input.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    };
    ErrorFragment.from = function (value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    };
    ErrorFragment.fromObject = function (value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            Logger_1.logger.throwArgumentError("invalid error object", "value", value);
        }
        var params = {
            type: value.type,
            name: (0, Checkers_1.verifyIdentifier)(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType_1.ParamType.fromObject) : [])
        };
        return new ErrorFragment(Utils_1._constructorGuard, params);
    };
    ErrorFragment.fromString = function (value) {
        var params = { type: "error" };
        var parens = value.match(Fragments_1.regexParen);
        if (!parens) {
            Logger_1.logger.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            (0, Checkers_1.verifyIdentifier)(params.name);
        }
        params.inputs = (0, ParamType_1.parseParams)(parens[2], false);
        return ErrorFragment.fromObject(params);
    };
    ErrorFragment.isErrorFragment = function (value) {
        return (value && value._isFragment && value.type === "error");
    };
    return ErrorFragment;
}(Fragments_1.Fragment));
exports.ErrorFragment = ErrorFragment;
//# sourceMappingURL=ErrorFragment.js.map

/***/ }),

/***/ 17523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventFragment = void 0;
var Logger_1 = __webpack_require__(98154);
var ParamType_1 = __webpack_require__(3671);
var Fragments_1 = __webpack_require__(55585);
var Checkers_1 = __webpack_require__(97358);
var Utils_1 = __webpack_require__(25011);
var Format_1 = __webpack_require__(93060);
var EventFragment = /** @class */ (function (_super) {
    __extends(EventFragment, _super);
    function EventFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EventFragment.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })
            });
        }
        var result = "";
        if (format !== Format_1.FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map(function (input) { return input.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== Format_1.FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    };
    EventFragment.from = function (value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    };
    EventFragment.fromObject = function (value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            Logger_1.logger.throwArgumentError("invalid event object", "value", value);
        }
        var params = {
            name: (0, Checkers_1.verifyIdentifier)(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType_1.ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(Utils_1._constructorGuard, params);
    };
    EventFragment.fromString = function (value) {
        var match = value.match(Fragments_1.regexParen);
        if (!match) {
            Logger_1.logger.throwArgumentError("invalid event string", "value", value);
        }
        var anonymous = false;
        match[3].split(" ").forEach(function (modifier) {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    Logger_1.logger.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: (0, ParamType_1.parseParams)(match[2], true),
            type: "event"
        });
    };
    EventFragment.isEventFragment = function (value) {
        return (value && value._isFragment && value.type === "event");
    };
    return EventFragment;
}(Fragments_1.Fragment));
exports.EventFragment = EventFragment;
//# sourceMappingURL=EventFragment.js.map

/***/ }),

/***/ 55585:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseModifiers = exports.Fragment = exports.regexParen = void 0;
var Logger_1 = __webpack_require__(98154);
var Utils_1 = __webpack_require__(25011);
exports.regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
var Fragment = /** @class */ (function () {
    function Fragment(constructorGuard, params) {
        if (constructorGuard !== Utils_1._constructorGuard) {
            Logger_1.logger.throwError("use a static from method", Logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        (0, Utils_1.populate)(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    Fragment.isFragment = function (value) {
        return !!(value && value._isFragment);
    };
    return Fragment;
}());
exports.Fragment = Fragment;
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach(function (modifier) {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
exports.parseModifiers = parseModifiers;
//# sourceMappingURL=Fragments.js.map

/***/ }),

/***/ 73001:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionFragment = void 0;
var Logger_1 = __webpack_require__(98154);
var ParamType_1 = __webpack_require__(3671);
var Fragments_1 = __webpack_require__(55585);
var ConstructorFragment_1 = __webpack_require__(53534);
var Checkers_1 = __webpack_require__(97358);
var Utils_1 = __webpack_require__(25011);
var Format_1 = __webpack_require__(93060);
var FunctionFragment = /** @class */ (function (_super) {
    __extends(FunctionFragment, _super);
    function FunctionFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionFragment.from = function (value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    };
    FunctionFragment.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability,
                payable: this.payable,
                // gas: (this.gas ? this.gas.toNumber(): undefined),
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),
                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),
            });
        }
        var result = "";
        if (format !== Format_1.FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map(function (input) { return input.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== Format_1.FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map(function (output) { return output.format(format); }).join(", ") + ") ";
            }
            // if (this.gas != null) {
            //     result += "@" + this.gas.toString() + " ";
            // }
        }
        return result.trim();
    };
    FunctionFragment.fromObject = function (value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            Logger_1.logger.throwArgumentError("invalid function object", "value", value);
        }
        var state = (0, Checkers_1.verifyState)(value);
        var params = {
            type: value.type,
            name: (0, Checkers_1.verifyIdentifier)(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType_1.ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType_1.ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
        };
        return new FunctionFragment(Utils_1._constructorGuard, params);
    };
    FunctionFragment.fromString = function (value) {
        var params = { type: "function" };
        var comps = value.split(" returns ");
        if (comps.length > 2) {
            Logger_1.logger.throwArgumentError("invalid function string", "value", value);
        }
        var parens = comps[0].match(Fragments_1.regexParen);
        if (!parens) {
            Logger_1.logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            (0, Checkers_1.verifyIdentifier)(params.name);
        }
        params.inputs = (0, ParamType_1.parseParams)(parens[2], false);
        (0, Fragments_1.parseModifiers)(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            var returns = comps[1].match(Fragments_1.regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                Logger_1.logger.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = (0, ParamType_1.parseParams)(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    };
    FunctionFragment.isFunctionFragment = function (value) {
        return (value && value._isFragment && value.type === "function");
    };
    return FunctionFragment;
}(ConstructorFragment_1.ConstructorFragment));
exports.FunctionFragment = FunctionFragment;
//# sourceMappingURL=FunctionFragment.js.map

/***/ }),

/***/ 81864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseFragment = exports.Fragment = exports.EventFragment = exports.FunctionFragment = exports.ErrorFragment = exports.ConstructorFragment = void 0;
var ConstructorFragment_1 = __webpack_require__(53534);
Object.defineProperty(exports, "ConstructorFragment", ({ enumerable: true, get: function () { return ConstructorFragment_1.ConstructorFragment; } }));
var ErrorFragment_1 = __webpack_require__(20102);
Object.defineProperty(exports, "ErrorFragment", ({ enumerable: true, get: function () { return ErrorFragment_1.ErrorFragment; } }));
var FunctionFragment_1 = __webpack_require__(73001);
Object.defineProperty(exports, "FunctionFragment", ({ enumerable: true, get: function () { return FunctionFragment_1.FunctionFragment; } }));
var EventFragment_1 = __webpack_require__(17523);
Object.defineProperty(exports, "EventFragment", ({ enumerable: true, get: function () { return EventFragment_1.EventFragment; } }));
var Fragments_1 = __webpack_require__(55585);
Object.defineProperty(exports, "Fragment", ({ enumerable: true, get: function () { return Fragments_1.Fragment; } }));
var Logger_1 = __webpack_require__(98154);
function parseFragmentFromObject(value) {
    if (Fragments_1.Fragment.isFragment(value)) {
        return value;
    }
    switch (value.type) {
        case "function":
            return FunctionFragment_1.FunctionFragment.fromObject(value);
        case "event":
            return EventFragment_1.EventFragment.fromObject(value);
        case "constructor":
            return ConstructorFragment_1.ConstructorFragment.fromObject(value);
        case "error":
            return ErrorFragment_1.ErrorFragment.fromObject(value);
        case "fallback":
        case "receive":
            // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
            return null;
    }
    return Logger_1.logger.throwArgumentError("invalid fragment object", "value", value);
}
function parseFragmentFromString(value) {
    // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
        return EventFragment_1.EventFragment.fromString(value.substring(5).trim());
    }
    else if (value.split(" ")[0] === "function") {
        return FunctionFragment_1.FunctionFragment.fromString(value.substring(8).trim());
    }
    else if (value.split("(")[0].trim() === "constructor") {
        return ConstructorFragment_1.ConstructorFragment.fromString(value.trim());
    }
    else if (value.split(" ")[0] === "error") {
        return ErrorFragment_1.ErrorFragment.fromString(value.substring(5).trim());
    }
    return Logger_1.logger.throwArgumentError("unsupported fragment", "value", value);
}
function parseFragment(value) {
    if (Fragments_1.Fragment.isFragment(value)) {
        return value;
    }
    if (typeof (value) === "string") {
        // throw new Error("not supported")
        return parseFragmentFromString(value);
    }
    return parseFragmentFromObject(value);
}
exports.parseFragment = parseFragment;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 98154:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = exports.logger = void 0;
var logger_1 = __webpack_require__(93688);
Object.defineProperty(exports, "Logger", ({ enumerable: true, get: function () { return logger_1.Logger; } }));
var _version_1 = __webpack_require__(97972);
var logger = new logger_1.Logger(_version_1.version);
exports.logger = logger;
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ 3671:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParamType = exports.parseParams = void 0;
var Checkers_1 = __webpack_require__(97358);
var Logger_1 = __webpack_require__(98154);
var Utils_1 = __webpack_require__(25011);
var Format_1 = __webpack_require__(93060);
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
function parseParams(value, allowIndex) {
    return (0, Utils_1.splitNesting)(value).map(function (param) { return ParamType.fromString(param, allowIndex); });
}
exports.parseParams = parseParams;
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    var originalParam = param;
    function throwError(i) {
        Logger_1.logger.throwArgumentError("unexpected character at position " + i, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        var node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    var parent = { type: "", name: "", state: { allowType: true } };
    var node = parent;
    for (var i = 0; i < param.length; i++) {
        var c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = (0, Checkers_1.verifyType)(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if ((0, Checkers_1.checkModifier)(node.type, node.name)) {
                    node.name = "";
                }
                node.type = (0, Checkers_1.verifyType)(node.type);
                var child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if ((0, Checkers_1.checkModifier)(node.type, node.name)) {
                    node.name = "";
                }
                node.type = (0, Checkers_1.verifyType)(node.type);
                var sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = (0, Checkers_1.verifyType)(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if ((0, Checkers_1.checkModifier)(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        Logger_1.logger.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if ((0, Checkers_1.checkModifier)(node.type, node.name)) {
        node.name = "";
    }
    parent.type = (0, Checkers_1.verifyType)(parent.type);
    return parent;
}
var ParamType = /** @class */ (function () {
    function ParamType(constructorGuard, params) {
        if (constructorGuard !== Utils_1._constructorGuard) {
            Logger_1.logger.throwError("use fromString");
        }
        (0, Utils_1.populate)(this, params);
        var match = this.type.match(paramTypeArray);
        if (match) {
            (0, Utils_1.populate)(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            (0, Utils_1.populate)(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    ParamType.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            var result_1 = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result_1.indexed = this.indexed;
            }
            if (this.components) {
                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });
            }
            return JSON.stringify(result_1);
        }
        var result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== Format_1.FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map(function (comp) { return comp.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== Format_1.FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === Format_1.FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    };
    ParamType.fromObject = function (value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(Utils_1._constructorGuard, {
            name: (value.name || null),
            type: (0, Checkers_1.verifyType)(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    };
    ParamType.fromString = function (value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    };
    ParamType.isParamType = function (value) {
        return !!(value != null && value._isParamType);
    };
    return ParamType;
}());
exports.ParamType = ParamType;
;
//# sourceMappingURL=ParamType.js.map

/***/ }),

/***/ 25011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitNesting = exports._constructorGuard = exports.populate = exports.defineReadOnly = void 0;
var Logger_1 = __webpack_require__(98154);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
exports.defineReadOnly = defineReadOnly;
function populate(object, params) {
    for (var key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
exports.populate = populate;
exports._constructorGuard = {};
function splitNesting(value) {
    value = value.trim();
    var result = [];
    var accum = "";
    var depth = 0;
    for (var offset = 0; offset < value.length; offset++) {
        var c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    Logger_1.logger.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}
exports.splitNesting = splitNesting;
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ 97972:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
// forked from @ethersproject/abi 5.5.0
exports.version = "abi-util-lite/0.1.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 35215:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseABIFromString = exports.parseFragment = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.ContractABI = exports.ParamType = void 0;
// import { ErrorFragment } from './Fragments'
var ParamType_1 = __webpack_require__(3671);
Object.defineProperty(exports, "ParamType", ({ enumerable: true, get: function () { return ParamType_1.ParamType; } }));
var ContractABI_1 = __webpack_require__(6659);
Object.defineProperty(exports, "ContractABI", ({ enumerable: true, get: function () { return ContractABI_1.ContractABI; } }));
Object.defineProperty(exports, "parseABIFromString", ({ enumerable: true, get: function () { return ContractABI_1.parseABIFromString; } }));
var Fragments_1 = __webpack_require__(81864);
Object.defineProperty(exports, "ConstructorFragment", ({ enumerable: true, get: function () { return Fragments_1.ConstructorFragment; } }));
Object.defineProperty(exports, "ErrorFragment", ({ enumerable: true, get: function () { return Fragments_1.ErrorFragment; } }));
Object.defineProperty(exports, "EventFragment", ({ enumerable: true, get: function () { return Fragments_1.EventFragment; } }));
Object.defineProperty(exports, "Fragment", ({ enumerable: true, get: function () { return Fragments_1.Fragment; } }));
Object.defineProperty(exports, "FunctionFragment", ({ enumerable: true, get: function () { return Fragments_1.FunctionFragment; } }));
Object.defineProperty(exports, "parseFragment", ({ enumerable: true, get: function () { return Fragments_1.parseFragment; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 93688:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ErrorCode": () => (/* binding */ ErrorCode),
  "LogLevel": () => (/* binding */ LogLevel),
  "Logger": () => (/* binding */ Logger)
});

;// CONCATENATED MODULE: ../../node_modules/abi-util-lite/node_modules/@ethersproject/logger/lib.esm/_version.js
const version = "logger/5.5.0";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/abi-util-lite/node_modules/@ethersproject/logger/lib.esm/index.js

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];

let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
;
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8202:
/***/ (function(module) {

"use strict";


(function(root) {

    function checkInt(value) {
        return (parseInt(value) === value);
    }

    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) { return false; }

        for (var i = 0; i < arrayish.length; i++) {
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                return false;
            }
        }

        return true;
    }

    function coerceArray(arg, copy) {

        // ArrayBuffer view
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {

            if (copy) {
                if (arg.slice) {
                    arg = arg.slice();
                } else {
                    arg = Array.prototype.slice.call(arg);
                }
            }

            return arg;
        }

        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
                throw new Error('Array contains invalid value: ' + arg);
            }

            return new Uint8Array(arg);
        }

        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
        }

        throw new Error('unsupported array-like object');
    }

    function createArray(length) {
        return new Uint8Array(length);
    }

    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
        }
        targetArray.set(sourceArray, targetStart);
    }



    var convertUtf8 = (function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while (i < text.length) {
                var c = text.charCodeAt(i++);

                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16))
                    i += 2;

                // otherwise, just the actual byte
                } else {
                    result.push(c)
                }
            }

            return coerceArray(result);
        }

        function fromBytes(bytes) {
            var result = [], i = 0;

            while (i < bytes.length) {
                var c = bytes[i];

                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                    i += 2;
                } else {
                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                    i += 3;
                }
            }

            return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();

    var convertHex = (function() {
        function toBytes(text) {
            var result = [];
            for (var i = 0; i < text.length; i += 2) {
                result.push(parseInt(text.substr(i, 2), 16));
            }

            return result;
        }

        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = '0123456789abcdef';

        function fromBytes(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i++) {
                    var v = bytes[i];
                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                }
                return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();


    // Number of rounds by keysize
    var numberOfRounds = {16: 10, 24: 12, 32: 14}

    // Round constant words
    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

    // S-box and Inverse S-box (S is for Substitution)
    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

    // Transformations for encryption
    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

    // Transformations for decryption
    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

    // Transformations for decryption key expansion
    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

    function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
            result.push(
                (bytes[i    ] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] <<  8) |
                 bytes[i + 3]
            );
        }
        return result;
    }

    var AES = function(key) {
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }

        Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
        });

        this._prepare();
    }


    AES.prototype._prepare = function() {

        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
        }

        // encryption round keys
        this._Ke = [];

        // decryption round keys
        this._Kd = [];

        for (var i = 0; i <= rounds; i++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
        }

        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;

        // convert the key into ints
        var tk = convertToInt32(this.key);

        // copy values into round key arrays
        var index;
        for (var i = 0; i < KC; i++) {
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }

        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                      (S[(tt >>  8) & 0xFF] << 16) ^
                      (S[ tt        & 0xFF] <<  8) ^
                       S[(tt >> 24) & 0xFF]        ^
                      (rcon[rconpointer] << 24));
            rconpointer += 1;

            // key expansion (for non-256 bit)
            if (KC != 8) {
                for (var i = 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }

            // key expansion for 256-bit keys is "slightly different" (fips-197)
            } else {
                for (var i = 1; i < (KC / 2); i++) {
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[(KC / 2) - 1];

                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                              (S[(tt >>  8) & 0xFF] <<  8) ^
                              (S[(tt >> 16) & 0xFF] << 16) ^
                              (S[(tt >> 24) & 0xFF] << 24));

                for (var i = (KC / 2) + 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
            }

            // copy values into round key arrays
            var i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }

        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for (var r = 1; r < rounds; r++) {
            for (var c = 0; c < 4; c++) {
                tt = this._Kd[r][c];
                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                                  U2[(tt >> 16) & 0xFF] ^
                                  U3[(tt >>  8) & 0xFF] ^
                                  U4[ tt        & 0xFF]);
            }
        }
    }

    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
        }

        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Ke[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T4[ t[(i + 3) % 4]        & 0xff] ^
                        this._Ke[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Ke[rounds][i];
            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }

    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
        }

        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Kd[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T8[ t[(i + 1) % 4]        & 0xff] ^
                        this._Kd[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Kd[rounds][i];
            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }


    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */
    var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Electronic Code Block";
        this.name = "ecb";

        this._aes = new AES(key);
    }

    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */
    var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Block Chaining";
        this.name = "cbc";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastCipherblock = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);

            for (var j = 0; j < 16; j++) {
                block[j] ^= this._lastCipherblock[j];
            }

            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);

            for (var j = 0; j < 16; j++) {
                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }

            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */
    var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Feedback";
        this.name = "cfb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
        }

        if (!segmentSize) { segmentSize = 1; }

        this.segmentSize = segmentSize;

        this._shiftRegister = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if ((plaintext.length % this.segmentSize) != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
        }

        var encrypted = coerceArray(plaintext, true);

        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j = 0; j < this.segmentSize; j++) {
                encrypted[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return encrypted;
    }

    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if ((ciphertext.length % this.segmentSize) != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        }

        var plaintext = coerceArray(ciphertext, true);

        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
                plaintext[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return plaintext;
    }

    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */
    var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Output Feedback";
        this.name = "ofb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


    /**
     *  Counter object for CTR common mode of operation
     */
    var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
        }

        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

        if (typeof(initialValue) === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);

        } else {
            this.setBytes(initialValue);
        }
    }

    Counter.prototype.setValue = function(value) {
        if (typeof(value) !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
        }

        for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = value >> 8;
        }
    }

    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);

        if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
        }

        this._counter = bytes;
    };

    Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            } else {
                this._counter[i]++;
                break;
            }
        }
    }


    /**
     *  Mode Of Operation - Counter (CTR)
     */
    var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Counter";
        this.name = "ctr";

        if (!(counter instanceof Counter)) {
            counter = new Counter(counter)
        }

        this._counter = counter;

        this._remainingCounter = null;
        this._remainingCounterIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


    ///////////////////////
    // Padding

    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - (data.length % 16);
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
            result[i] = padder;
        }
        return result;
    }

    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

        var padder = data[data.length - 1];
        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
                throw new Error('PKCS#7 invalid padding byte');
            }
        }

        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }

    ///////////////////////
    // Exporting


    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,

        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },

        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },

        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },

        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray,
        }
    };


    // node.js
    if (true) {
        module.exports = aesjs

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}


})(this);


/***/ }),

/***/ 29954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(68197),
  serial        : __webpack_require__(88967),
  serialOrdered : __webpack_require__(80982)
};


/***/ }),

/***/ 10190:
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ 1307:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(38765);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ 38765:
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ 55798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(1307)
  , abort = __webpack_require__(10190)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ 37379:
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ 33797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(10190)
  , async = __webpack_require__(1307)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ 68197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(55798)
  , initState  = __webpack_require__(37379)
  , terminator = __webpack_require__(33797)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ 88967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(80982);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ 80982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(55798)
  , initState  = __webpack_require__(37379)
  , terminator = __webpack_require__(33797)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ 57353:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var fs = __webpack_require__(57147),
  path = __webpack_require__(71017),
  fileURLToPath = __webpack_require__(23049),
  join = path.join,
  dirname = path.dirname,
  exists =
    (fs.accessSync &&
      function(path) {
        try {
          fs.accessSync(path);
        } catch (e) {
          return false;
        }
        return true;
      }) ||
    fs.existsSync ||
    path.existsSync,
  defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || '  ',
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',
    platform: process.platform,
    arch: process.arch,
    nodePreGyp:
      'node-v' +
      process.versions.modules +
      '-' +
      process.platform +
      '-' +
      process.arch,
    version: process.versions.node,
    bindings: 'bindings.node',
    try: [
      // node-gyp's linked version in the "build" dir
      ['module_root', 'build', 'bindings'],
      // node-waf and gyp_addon (a.k.a node-gyp)
      ['module_root', 'build', 'Debug', 'bindings'],
      ['module_root', 'build', 'Release', 'bindings'],
      // Debug files, for development (legacy behavior, remove for node v0.9)
      ['module_root', 'out', 'Debug', 'bindings'],
      ['module_root', 'Debug', 'bindings'],
      // Release files, but manually compiled (legacy behavior, remove for node v0.9)
      ['module_root', 'out', 'Release', 'bindings'],
      ['module_root', 'Release', 'bindings'],
      // Legacy from node-waf, node <= 0.4.x
      ['module_root', 'build', 'default', 'bindings'],
      // Production "Release" buildtype binary (meh...)
      ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'],
      // node-qbs builds
      ['module_root', 'addon-build', 'release', 'install-root', 'bindings'],
      ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'],
      ['module_root', 'addon-build', 'default', 'install-root', 'bindings'],
      // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
      ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']
    ]
  };

/**
 * The main `bindings()` function loads the compiled bindings for a given module.
 * It uses V8's Error API to determine the parent filename that this function is
 * being invoked from, which is then used to find the root directory.
 */

function bindings(opts) {
  // Argument surgery
  if (typeof opts == 'string') {
    opts = { bindings: opts };
  } else if (!opts) {
    opts = {};
  }

  // maps `defaults` onto `opts` object
  Object.keys(defaults).map(function(i) {
    if (!(i in opts)) opts[i] = defaults[i];
  });

  // Get the module root
  if (!opts.module_root) {
    opts.module_root = exports.getRoot(exports.getFileName());
  }

  // Ensure the given bindings name ends with .node
  if (path.extname(opts.bindings) != '.node') {
    opts.bindings += '.node';
  }

  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035
  var requireFunc =
     true
      ? require
      : 0;

  var tries = [],
    i = 0,
    l = opts.try.length,
    n,
    b,
    err;

  for (; i < l; i++) {
    n = join.apply(
      null,
      opts.try[i].map(function(p) {
        return opts[p] || p;
      })
    );
    tries.push(n);
    try {
      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
      if (!opts.path) {
        b.path = n;
      }
      return b;
    } catch (e) {
      if (e.code !== 'MODULE_NOT_FOUND' &&
          e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' &&
          !/not find/i.test(e.message)) {
        throw e;
      }
    }
  }

  err = new Error(
    'Could not locate the bindings file. Tried:\n' +
      tries
        .map(function(a) {
          return opts.arrow + a;
        })
        .join('\n')
  );
  err.tries = tries;
  throw err;
}
module.exports = exports = bindings;

/**
 * Gets the filename of the JavaScript file that invokes this function.
 * Used to help find the root directory of a module.
 * Optionally accepts an filename argument to skip when searching for the invoking filename
 */

exports.getFileName = function getFileName(calling_file) {
  var origPST = Error.prepareStackTrace,
    origSTL = Error.stackTraceLimit,
    dummy = {},
    fileName;

  Error.stackTraceLimit = 10;

  Error.prepareStackTrace = function(e, st) {
    for (var i = 0, l = st.length; i < l; i++) {
      fileName = st[i].getFileName();
      if (fileName !== __filename) {
        if (calling_file) {
          if (fileName !== calling_file) {
            return;
          }
        } else {
          return;
        }
      }
    }
  };

  // run the 'prepareStackTrace' function above
  Error.captureStackTrace(dummy);
  dummy.stack;

  // cleanup
  Error.prepareStackTrace = origPST;
  Error.stackTraceLimit = origSTL;

  // handle filename that starts with "file://"
  var fileSchema = 'file://';
  if (fileName.indexOf(fileSchema) === 0) {
    fileName = fileURLToPath(fileName);
  }

  return fileName;
};

/**
 * Gets the root directory of a module, given an arbitrary filename
 * somewhere in the module tree. The "root directory" is the directory
 * containing the `package.json` file.
 *
 *   In:  /home/nate/node-native-module/lib/index.js
 *   Out: /home/nate/node-native-module
 */

exports.getRoot = function getRoot(file) {
  var dir = dirname(file),
    prev;
  while (true) {
    if (dir === '.') {
      // Avoids an infinite loop in rare cases, like the REPL
      dir = process.cwd();
    }
    if (
      exists(join(dir, 'package.json')) ||
      exists(join(dir, 'node_modules'))
    ) {
      // Found the 'package.json' file or 'node_modules' dir; we're done
      return dir;
    }
    if (prev === dir) {
      // Got to the top
      throw new Error(
        'Could not find module root given file: "' +
          file +
          '". Do you have a `package.json` file? '
      );
    }
    // Try the parent dir next
    prev = dir;
    dir = join(dir, '..');
  }
};


/***/ }),

/***/ 49419:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
const wordlists = {};
exports.wordlists = wordlists;
let _default;
exports._default = _default;
try {
    exports._default = _default = __webpack_require__(31955);
    wordlists.czech = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(94556);
    wordlists.chinese_simplified = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(69095);
    wordlists.chinese_traditional = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(17428);
    wordlists.korean = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(48004);
    wordlists.french = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(70061);
    wordlists.italian = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(95565);
    wordlists.spanish = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(99148);
    wordlists.japanese = _default;
    wordlists.JA = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(58930);
    wordlists.portuguese = _default;
}
catch (err) { }
try {
    exports._default = _default = __webpack_require__(32308);
    wordlists.english = _default;
    wordlists.EN = _default;
}
catch (err) { }


/***/ }),

/***/ 36832:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];

__webpack_unused_export__ = ({ value: true });
const createHash = __webpack_require__(49373);
const pbkdf2_1 = __webpack_require__(81239);
const randomBytes = __webpack_require__(91249);
const _wordlists_1 = __webpack_require__(49419);
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = 'Invalid mnemonic';
const INVALID_ENTROPY = 'Invalid entropy';
const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
    'Please pass a 2048 word array explicitly.';
function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
    return Promise.resolve().then(() => new Promise((resolve, reject) => {
        const callback = (err, derivedKey) => {
            if (err) {
                return reject(err);
            }
            else {
                return resolve(derivedKey);
            }
        };
        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);
    }));
}
function normalize(str) {
    return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
}
function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = createHash('sha256')
        .update(entropyBuffer)
        .digest();
    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
    return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
}
__webpack_unused_export__ = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
    return Promise.resolve().then(() => {
        const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
        const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
    });
}
__webpack_unused_export__ = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(' ');
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), '0', 11);
    })
        .join('');
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString('hex');
}
__webpack_unused_export__ = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, 'hex');
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
        ? words.join('\u3000')
        : words.join(' ');
}
__webpack_unused_export__ = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || randomBytes;
    return entropyToMnemonic(rng(strength / 8), wordlist);
}
exports.OF = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports._I = validateMnemonic;
function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
        DEFAULT_WORDLIST = result;
    }
    else {
        throw new Error('Could not find wordlist for language "' + language + '"');
    }
}
__webpack_unused_export__ = setDefaultWordlist;
function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
        throw new Error('No Default Wordlist set');
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === 'JA' || lang === 'EN') {
            return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
}
__webpack_unused_export__ = getDefaultWordlist;
var _wordlists_2 = __webpack_require__(49419);
exports.ET = _wordlists_2.wordlists;


/***/ }),

/***/ 39875:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use

var Buffer = (__webpack_require__(77834).Buffer)

function check (buffer) {
  if (buffer.length < 8) return false
  if (buffer.length > 72) return false
  if (buffer[0] !== 0x30) return false
  if (buffer[1] !== buffer.length - 2) return false
  if (buffer[2] !== 0x02) return false

  var lenR = buffer[3]
  if (lenR === 0) return false
  if (5 + lenR >= buffer.length) return false
  if (buffer[4 + lenR] !== 0x02) return false

  var lenS = buffer[5 + lenR]
  if (lenS === 0) return false
  if ((6 + lenR + lenS) !== buffer.length) return false

  if (buffer[4] & 0x80) return false
  if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) return false

  if (buffer[lenR + 6] & 0x80) return false
  if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) return false
  return true
}

function decode (buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short')
  if (buffer.length > 72) throw new Error('DER sequence length is too long')
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence')
  if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid')
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer')

  var lenR = buffer[3]
  if (lenR === 0) throw new Error('R length is zero')
  if (5 + lenR >= buffer.length) throw new Error('R length is too long')
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)')

  var lenS = buffer[5 + lenR]
  if (lenS === 0) throw new Error('S length is zero')
  if ((6 + lenR + lenS) !== buffer.length) throw new Error('S length is invalid')

  if (buffer[4] & 0x80) throw new Error('R value is negative')
  if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) throw new Error('R value excessively padded')

  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative')
  if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded')

  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR)
  }
}

/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
function encode (r, s) {
  var lenR = r.length
  var lenS = s.length
  if (lenR === 0) throw new Error('R length is zero')
  if (lenS === 0) throw new Error('S length is zero')
  if (lenR > 33) throw new Error('R length is too long')
  if (lenS > 33) throw new Error('S length is too long')
  if (r[0] & 0x80) throw new Error('R value is negative')
  if (s[0] & 0x80) throw new Error('S value is negative')
  if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) throw new Error('R value excessively padded')
  if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) throw new Error('S value excessively padded')

  var signature = Buffer.allocUnsafe(6 + lenR + lenS)

  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30
  signature[1] = signature.length - 2
  signature[2] = 0x02
  signature[3] = r.length
  r.copy(signature, 4)
  signature[4 + lenR] = 0x02
  signature[5 + lenR] = s.length
  s.copy(signature, 6 + lenR)

  return signature
}

module.exports = {
  check: check,
  decode: decode,
  encode: encode
}


/***/ }),

/***/ 62197:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__webpack_require__(14300).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 82745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(6113);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ 89620:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Unibabel = __webpack_require__(48119)

module.exports = {

  // Simple encryption methods:
  encrypt,
  decrypt,

  // More advanced encryption methods:
  keyFromPassword,
  encryptWithKey,
  decryptWithKey,

  // Buffer <-> Hex string methods
  serializeBufferForStorage,
  serializeBufferFromStorage,

  generateSalt,
}

// Takes a Pojo, returns cypher text.
function encrypt (password, dataObj) {
  var salt = generateSalt()

  return keyFromPassword(password, salt)
  .then(function (passwordDerivedKey) {
    return encryptWithKey(passwordDerivedKey, dataObj)
  })
  .then(function (payload) {
    payload.salt = salt
    return JSON.stringify(payload)
  })
}

function encryptWithKey (key, dataObj) {
  var data = JSON.stringify(dataObj)
  var dataBuffer = Unibabel.utf8ToBuffer(data)
  var vector = global.crypto.getRandomValues(new Uint8Array(16))
  return global.crypto.subtle.encrypt({
    name: 'AES-GCM',
    iv: vector,
  }, key, dataBuffer).then(function (buf) {
    var buffer = new Uint8Array(buf)
    var vectorStr = Unibabel.bufferToBase64(vector)
    var vaultStr = Unibabel.bufferToBase64(buffer)
    return {
      data: vaultStr,
      iv: vectorStr,
    }
  })
}

// Takes encrypted text, returns the restored Pojo.
function decrypt (password, text) {
  const payload = JSON.parse(text)
  const salt = payload.salt
  return keyFromPassword(password, salt)
  .then(function (key) {
    return decryptWithKey(key, payload)
  })
}

function decryptWithKey (key, payload) {
  const encryptedData = Unibabel.base64ToBuffer(payload.data)
  const vector = Unibabel.base64ToBuffer(payload.iv)
  return crypto.subtle.decrypt({name: 'AES-GCM', iv: vector}, key, encryptedData)
  .then(function (result) {
    const decryptedData = new Uint8Array(result)
    const decryptedStr = Unibabel.bufferToUtf8(decryptedData)
    const decryptedObj = JSON.parse(decryptedStr)
    return decryptedObj
  })
  .catch(function (reason) {
    throw new Error('Incorrect password')
  })
}

function keyFromPassword (password, salt) {
  var passBuffer = Unibabel.utf8ToBuffer(password)
  var saltBuffer = Unibabel.base64ToBuffer(salt)

  return global.crypto.subtle.importKey(
    'raw',
    passBuffer,
    { name: 'PBKDF2' },
    false,
    ['deriveBits', 'deriveKey']
  ).then(function (key) {

    return global.crypto.subtle.deriveKey(
      { name: 'PBKDF2',
        salt: saltBuffer,
        iterations: 10000,
        hash: 'SHA-256',
      },
      key,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    )
  })
}

function serializeBufferFromStorage (str) {
  var stripStr = (str.slice(0, 2) === '0x') ? str.slice(2) : str
  var buf = new Uint8Array(stripStr.length / 2)
  for (var i = 0; i < stripStr.length; i += 2) {
    var seg = stripStr.substr(i, 2)
    buf[i / 2] = parseInt(seg, 16)
  }
  return buf
}

// Should return a string, ready for storage, in hex format.
function serializeBufferForStorage (buffer) {
  var result = '0x'
  var len = buffer.length || buffer.byteLength
  for (var i = 0; i < len; i++) {
    result += unprefixedHex(buffer[i])
  }
  return result
}

function unprefixedHex (num) {
  var hex = num.toString(16)
  while (hex.length < 2) {
    hex = '0' + hex
  }
  return hex
}

function generateSalt (byteCount = 32) {
  var view = new Uint8Array(byteCount)
  global.crypto.getRandomValues(view)
  var b64encoded = btoa(String.fromCharCode.apply(null, view))
  return b64encoded
}


/***/ }),

/***/ 48119:
/***/ ((module) => {

"use strict";


function utf8ToBinaryString(str) {
  var escstr = encodeURIComponent(str);
  // replaces any uri escape sequence, such as %0A,
  // with binary escape, such as 0x0A
  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function(match, p1) {
    return String.fromCharCode(parseInt(p1, 16));
  });

  return binstr;
}

function utf8ToBuffer(str) {
  var binstr = utf8ToBinaryString(str);
  var buf = binaryStringToBuffer(binstr);
  return buf;
}

function utf8ToBase64(str) {
  var binstr = utf8ToBinaryString(str);
  return btoa(binstr);
}

function binaryStringToUtf8(binstr) {
  var escstr = binstr.replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = '0' + code;
    }
    return '%' + code;
  });

  return decodeURIComponent(escstr);
}

function bufferToUtf8(buf) {
  var binstr = bufferToBinaryString(buf);

  return binaryStringToUtf8(binstr);
}

function base64ToUtf8(b64) {
  var binstr = atob(b64);

  return binaryStringToUtf8(binstr);
}

function bufferToBinaryString(buf) {
  var binstr = Array.prototype.map.call(buf, function (ch) {
    return String.fromCharCode(ch);
  }).join('');

  return binstr;
}

function bufferToBase64(arr) {
  var binstr = bufferToBinaryString(arr);
  return btoa(binstr);
}

function binaryStringToBuffer(binstr) {
  var buf;

  if ('undefined' !== typeof Uint8Array) {
    buf = new Uint8Array(binstr.length);
  } else {
    buf = [];
  }

  Array.prototype.forEach.call(binstr, function (ch, i) {
    buf[i] = ch.charCodeAt(0);
  });

  return buf;
}

function base64ToBuffer(base64) {
  var binstr = atob(base64);
  var buf = binaryStringToBuffer(binstr);
  return buf;
}

module.exports = {
  utf8ToBinaryString: utf8ToBinaryString
, utf8ToBuffer: utf8ToBuffer
, utf8ToBase64: utf8ToBase64
, binaryStringToUtf8: binaryStringToUtf8
, bufferToUtf8: bufferToUtf8
, base64ToUtf8: base64ToUtf8
, bufferToBinaryString: bufferToBinaryString
, bufferToBase64: bufferToBase64
, binaryStringToBuffer: binaryStringToBuffer
, base64ToBuffer: base64ToBuffer

// compat
, strToUtf8Arr: utf8ToBuffer
, utf8ArrToStr: bufferToUtf8
, arrToBase64: bufferToBase64
, base64ToArr: base64ToBuffer
};


/***/ }),

/***/ 62680:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(67286);

var callBind = __webpack_require__(89429);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 89429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(4090);
var GetIntrinsic = __webpack_require__(67286);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 26160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
var util = __webpack_require__(73837);
var Stream = (__webpack_require__(12781).Stream);
var DelayedStream = __webpack_require__(78178);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ 29392:
/***/ ((__unused_webpack_module, exports) => {

/* jshint node: true */
(function () {
    "use strict";

    function CookieAccessInfo(domain, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
            this.domain = domain || undefined;
            this.path = path || "/";
            this.secure = !!secure;
            this.script = !!script;
            return this;
        }
        return new CookieAccessInfo(domain, path, secure, script);
    }
    CookieAccessInfo.All = Object.freeze(Object.create(null));
    exports.CookieAccessInfo = CookieAccessInfo;

    function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
            return cookiestr;
        }
        if (this instanceof Cookie) {
            this.name = null;
            this.value = null;
            this.expiration_date = Infinity;
            this.path = String(request_path || "/");
            this.explicit_path = false;
            this.domain = request_domain || null;
            this.explicit_domain = false;
            this.secure = false; //how to define default?
            this.noscript = false; //httponly
            if (cookiestr) {
                this.parse(cookiestr, request_domain, request_path);
            }
            return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
    }
    exports.Cookie = Cookie;

    Cookie.prototype.toString = function toString() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
            str.push("expires=" + (new Date(this.expiration_date)).toGMTString());
        }
        if (this.domain) {
            str.push("domain=" + this.domain);
        }
        if (this.path) {
            str.push("path=" + this.path);
        }
        if (this.secure) {
            str.push("secure");
        }
        if (this.noscript) {
            str.push("httponly");
        }
        return str.join("; ");
    };

    Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
    };

    var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
    Cookie.prototype.parse = function parse(str, request_domain, request_path) {
        if (this instanceof Cookie) {
            var parts = str.split(";").filter(function (value) {
                    return !!value;
                });
            var i;

            var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
            if (!pair) {
                console.warn("Invalid cookie header encountered. Header: '"+str+"'");
                return;
            }

            var key = pair[1];
            var value = pair[2];
            if ( typeof key !== 'string' || key.length === 0 || typeof value !== 'string' ) {
                console.warn("Unable to extract values from cookie header. Cookie: '"+str+"'");
                return;
            }

            this.name = key;
            this.value = value;

            for (i = 1; i < parts.length; i += 1) {
                pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
                key = pair[1].trim().toLowerCase();
                value = pair[2];
                switch (key) {
                case "httponly":
                    this.noscript = true;
                    break;
                case "expires":
                    this.expiration_date = value ?
                            Number(Date.parse(value)) :
                            Infinity;
                    break;
                case "path":
                    this.path = value ?
                            value.trim() :
                            "";
                    this.explicit_path = true;
                    break;
                case "domain":
                    this.domain = value ?
                            value.trim() :
                            "";
                    this.explicit_domain = !!this.domain;
                    break;
                case "secure":
                    this.secure = true;
                    break;
                }
            }

            if (!this.explicit_path) {
               this.path = request_path || "/";
            }
            if (!this.explicit_domain) {
               this.domain = request_domain;
            }

            return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
    };

    Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script ||
                this.secure && !access_info.secure ||
                !this.collidesWith(access_info)) {
            return false;
        }
        return true;
    };

    Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if ((this.path && !access_info.path) || (this.domain && !access_info.domain)) {
            return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
            return false;
        }
        if (this.explicit_path && access_info.path.indexOf( this.path ) !== 0) {
           return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/,'');
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/,'');
        if (cookie_domain === access_domain) {
            return true;
        }
        if (cookie_domain) {
            if (!this.explicit_domain) {
                return false; // we already checked if the domains were exactly the same
            }
            var wildcard = access_domain.indexOf(cookie_domain);
            if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
                return false;
            }
            return true;
        }
        return true;
    };

    function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
            cookies = Object.create(null); //name: [Cookie]

            this.setCookie = function setCookie(cookie, request_domain, request_path) {
                var remove, i;
                cookie = new Cookie(cookie, request_domain, request_path);
                //Delete the cookie if the set is past the current time
                remove = cookie.expiration_date <= Date.now();
                if (cookies[cookie.name] !== undefined) {
                    cookies_list = cookies[cookie.name];
                    for (i = 0; i < cookies_list.length; i += 1) {
                        collidable_cookie = cookies_list[i];
                        if (collidable_cookie.collidesWith(cookie)) {
                            if (remove) {
                                cookies_list.splice(i, 1);
                                if (cookies_list.length === 0) {
                                    delete cookies[cookie.name];
                                }
                                return false;
                            }
                            cookies_list[i] = cookie;
                            return cookie;
                        }
                    }
                    if (remove) {
                        return false;
                    }
                    cookies_list.push(cookie);
                    return cookie;
                }
                if (remove) {
                    return false;
                }
                cookies[cookie.name] = [cookie];
                return cookies[cookie.name];
            };
            //returns a cookie
            this.getCookie = function getCookie(cookie_name, access_info) {
                var cookie, i;
                cookies_list = cookies[cookie_name];
                if (!cookies_list) {
                    return;
                }
                for (i = 0; i < cookies_list.length; i += 1) {
                    cookie = cookies_list[i];
                    if (cookie.expiration_date <= Date.now()) {
                        if (cookies_list.length === 0) {
                            delete cookies[cookie.name];
                        }
                        continue;
                    }

                    if (cookie.matches(access_info)) {
                        return cookie;
                    }
                }
            };
            //returns a list of cookies
            this.getCookies = function getCookies(access_info) {
                var matches = [], cookie_name, cookie;
                for (cookie_name in cookies) {
                    cookie = this.getCookie(cookie_name, access_info);
                    if (cookie) {
                        matches.push(cookie);
                    }
                }
                matches.toString = function toString() {
                    return matches.join(":");
                };
                matches.toValueString = function toValueString() {
                    return matches.map(function (c) {
                        return c.toValueString();
                    }).join(';');
                };
                return matches;
            };

            return this;
        }
        return new CookieJar();
    }
    exports.CookieJar = CookieJar;

    //returns list of cookies that were set correctly. Cookies that are expired and removed are not returned.
    CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ?
                cookies :
                cookies.split(cookie_str_splitter);
        var successful = [],
            i,
            cookie;
        cookies = cookies.map(function(item){
            return new Cookie(item, request_domain, request_path);
        });
        for (i = 0; i < cookies.length; i += 1) {
            cookie = cookies[i];
            if (this.setCookie(cookie, request_domain, request_path)) {
                successful.push(cookie);
            }
        }
        return successful;
    };
}());


/***/ }),

/***/ 49373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6113).createHash


/***/ }),

/***/ 16245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6113).createHmac


/***/ }),

/***/ 65881:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 25130:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(87123)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 87123:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(65881);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(25130);
} else {
	module.exports = __webpack_require__(48414);
}


/***/ }),

/***/ 48414:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(76224);
const util = __webpack_require__(73837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(31896);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(87123)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 78178:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(12781).Stream);
var util = __webpack_require__(73837);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ 87554:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var elliptic = exports;

elliptic.version = (__webpack_require__(40763)/* .version */ .i8);
elliptic.utils = __webpack_require__(18288);
elliptic.rand = __webpack_require__(82745);
elliptic.curve = __webpack_require__(48610);
elliptic.curves = __webpack_require__(41479);

// Protocols
elliptic.ec = __webpack_require__(38596);
elliptic.eddsa = __webpack_require__(39208);


/***/ }),

/***/ 48919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(62197);
var utils = __webpack_require__(18288);
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ 37105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(18288);
var BN = __webpack_require__(62197);
var inherits = __webpack_require__(98874);
var Base = __webpack_require__(48919);

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ 48610:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curve = exports;

curve.base = __webpack_require__(48919);
curve.short = __webpack_require__(27715);
curve.mont = __webpack_require__(95125);
curve.edwards = __webpack_require__(37105);


/***/ }),

/***/ 95125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(62197);
var inherits = __webpack_require__(98874);
var Base = __webpack_require__(48919);

var utils = __webpack_require__(18288);

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ 27715:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(18288);
var BN = __webpack_require__(62197);
var inherits = __webpack_require__(98874);
var Base = __webpack_require__(48919);

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ 41479:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curves = exports;

var hash = __webpack_require__(34485);
var curve = __webpack_require__(48610);
var utils = __webpack_require__(18288);

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = __webpack_require__(47983);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});


/***/ }),

/***/ 38596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(62197);
var HmacDRBG = __webpack_require__(78873);
var utils = __webpack_require__(18288);
var curves = __webpack_require__(41479);
var rand = __webpack_require__(82745);
var assert = utils.assert;

var KeyPair = __webpack_require__(22307);
var Signature = __webpack_require__(71798);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ 22307:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(62197);
var utils = __webpack_require__(18288);
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ 71798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(62197);

var utils = __webpack_require__(18288);
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ 39208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(34485);
var curves = __webpack_require__(41479);
var utils = __webpack_require__(18288);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(851);
var Signature = __webpack_require__(6117);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ 851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(18288);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ 6117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(62197);
var utils = __webpack_require__(18288);
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ 47983:
/***/ ((module) => {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};


/***/ }),

/***/ 18288:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = exports;
var BN = __webpack_require__(62197);
var minAssert = __webpack_require__(79561);
var minUtils = __webpack_require__(43022);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ 77847:
/***/ ((module) => {

module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var arr = []
var replacerStack = []

// Regular stringify
function stringify (obj, replacer, spacer) {
  decirc(obj, '', [], undefined)
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer)
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}
function decirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
        if (propertyDescriptor.get !== undefined) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, { value: '[Circular]' })
            arr.push([parent, k, val, propertyDescriptor])
          } else {
            replacerStack.push([val, k])
          }
        } else {
          parent[k] = '[Circular]'
          arr.push([parent, k, val])
        }
        return
      }
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, stack, val)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, stack, val)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer) {
  var tmp = deterministicDecirc(obj, '', [], undefined) || obj
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer)
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
        if (propertyDescriptor.get !== undefined) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, { value: '[Circular]' })
            arr.push([parent, k, val, propertyDescriptor])
          } else {
            replacerStack.push([val, k])
          }
        } else {
          parent[k] = '[Circular]'
          arr.push([parent, k, val])
        }
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, stack, val)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, stack, val)
        tmp[key] = val[key]
      }
      if (parent !== undefined) {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as [Circular]
function replaceGetterValues (replacer) {
  replacer = replacer !== undefined ? replacer : function (k, v) { return v }
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i]
        if (part[1] === key && part[0] === val) {
          val = '[Circular]'
          replacerStack.splice(i, 1)
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}


/***/ }),

/***/ 23049:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module dependencies.
 */

var sep = (__webpack_require__(71017).sep) || '/';

/**
 * Module exports.
 */

module.exports = fileUriToPath;

/**
 * File URI to Path function.
 *
 * @param {String} uri
 * @return {String} path
 * @api public
 */

function fileUriToPath (uri) {
  if ('string' != typeof uri ||
      uri.length <= 7 ||
      'file://' != uri.substring(0, 7)) {
    throw new TypeError('must pass in a file:// URI to convert to a file path');
  }

  var rest = decodeURI(uri.substring(7));
  var firstSlash = rest.indexOf('/');
  var host = rest.substring(0, firstSlash);
  var path = rest.substring(firstSlash + 1);

  // 2.  Scheme Definition
  // As a special case, <host> can be the string "localhost" or the empty
  // string; this is interpreted as "the machine from which the URL is
  // being interpreted".
  if ('localhost' == host) host = '';

  if (host) {
    host = sep + sep + host;
  }

  // 3.2  Drives, drive letters, mount points, file system root
  // Drive letters are mapped into the top of a file URI in various ways,
  // depending on the implementation; some applications substitute
  // vertical bar ("|") for the colon after the drive letter, yielding
  // "file:///c|/tmp/test.txt".  In some cases, the colon is left
  // unchanged, as in "file:///c:/tmp/test.txt".  In other cases, the
  // colon is simply omitted, as in "file:///c/tmp/test.txt".
  path = path.replace(/^(.+)\|/, '$1:');

  // for Windows, we need to invert the path separators from what a URI uses
  if (sep == '\\') {
    path = path.replace(/\//g, '\\');
  }

  if (/^.+\:/.test(path)) {
    // has Windows drive at beginning of path
  } else {
    // unix path
    path = sep + path;
  }

  return host + path;
}


/***/ }),

/***/ 21191:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
var CombinedStream = __webpack_require__(26160);
var util = __webpack_require__(73837);
var path = __webpack_require__(71017);
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var parseUrl = (__webpack_require__(57310).parse);
var fs = __webpack_require__(57147);
var mime = __webpack_require__(6856);
var asynckit = __webpack_require__(29954);
var populate = __webpack_require__(25183);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity > read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ 25183:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 20880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var require;if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(78822));

var util = __webpack_require__(73837),
    fs = __webpack_require__(57147),
    EventEmitter = (__webpack_require__(82361).EventEmitter),
    crypto = __webpack_require__(6113);

function File(properties) {
  EventEmitter.call(this);

  this.size = 0;
  this.path = null;
  this.name = null;
  this.type = null;
  this.hash = null;
  this.lastModifiedDate = null;

  this._writeStream = null;
  
  for (var key in properties) {
    this[key] = properties[key];
  }

  if(typeof this.hash === 'string') {
    this.hash = crypto.createHash(properties.hash);
  } else {
    this.hash = null;
  }
}
module.exports = File;
util.inherits(File, EventEmitter);

File.prototype.open = function() {
  this._writeStream = new fs.WriteStream(this.path);
};

File.prototype.toJSON = function() {
  var json = {
    size: this.size,
    path: this.path,
    name: this.name,
    type: this.type,
    mtime: this.lastModifiedDate,
    length: this.length,
    filename: this.filename,
    mime: this.mime
  };
  if (this.hash && this.hash != "") {
    json.hash = this.hash;
  }
  return json;
};

File.prototype.write = function(buffer, cb) {
  var self = this;
  if (self.hash) {
    self.hash.update(buffer);
  }

  if (this._writeStream.closed) {
    return cb();
  }

  this._writeStream.write(buffer, function() {
    self.lastModifiedDate = new Date();
    self.size += buffer.length;
    self.emit('progress', self.size);
    cb();
  });
};

File.prototype.end = function(cb) {
  var self = this;
  if (self.hash) {
    self.hash = self.hash.digest('hex');
  }
  this._writeStream.end(function() {
    self.emit('end');
    cb();
  });
};


/***/ }),

/***/ 6655:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
var require;if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(78822));

var crypto = __webpack_require__(6113);
var fs = __webpack_require__(57147);
var util = __webpack_require__(73837),
    path = __webpack_require__(71017),
    File = __webpack_require__(20880),
    MultipartParser = (__webpack_require__(60608).MultipartParser),
    QuerystringParser = (__webpack_require__(13381)/* .QuerystringParser */ .l),
    OctetParser       = (__webpack_require__(72009)/* .OctetParser */ .h),
    JSONParser = (__webpack_require__(24024)/* .JSONParser */ .c),
    StringDecoder = (__webpack_require__(71576).StringDecoder),
    EventEmitter = (__webpack_require__(82361).EventEmitter),
    Stream = (__webpack_require__(12781).Stream),
    os = __webpack_require__(22037);

function IncomingForm(opts) {
  if (!(this instanceof IncomingForm)) return new IncomingForm(opts);
  EventEmitter.call(this);

  opts=opts||{};

  this.error = null;
  this.ended = false;

  this.maxFields = opts.maxFields || 1000;
  this.maxFieldsSize = opts.maxFieldsSize || 20 * 1024 * 1024;
  this.maxFileSize = opts.maxFileSize || 200 * 1024 * 1024;
  this.keepExtensions = opts.keepExtensions || false;
  this.uploadDir = opts.uploadDir || (os.tmpdir && os.tmpdir()) || os.tmpDir();
  this.encoding = opts.encoding || 'utf-8';
  this.headers = null;
  this.type = null;
  this.hash = opts.hash || false;
  this.multiples = opts.multiples || false;

  this.bytesReceived = null;
  this.bytesExpected = null;

  this._parser = null;
  this._flushing = 0;
  this._fieldsSize = 0;
  this._fileSize = 0;
  this.openedFiles = [];

  return this;
}
util.inherits(IncomingForm, EventEmitter);
exports.c = IncomingForm;

IncomingForm.prototype.parse = function(req, cb) {
  this.pause = function() {
    try {
      req.pause();
    } catch (err) {
      // the stream was destroyed
      if (!this.ended) {
        // before it was completed, crash & burn
        this._error(err);
      }
      return false;
    }
    return true;
  };

  this.resume = function() {
    try {
      req.resume();
    } catch (err) {
      // the stream was destroyed
      if (!this.ended) {
        // before it was completed, crash & burn
        this._error(err);
      }
      return false;
    }

    return true;
  };

  // Setup callback first, so we don't miss anything from data events emitted
  // immediately.
  if (cb) {
    var fields = {}, files = {};
    this
      .on('field', function(name, value) {
        fields[name] = value;
      })
      .on('file', function(name, file) {
        if (this.multiples) {
          if (files[name]) {
            if (!Array.isArray(files[name])) {
              files[name] = [files[name]];
            }
            files[name].push(file);
          } else {
            files[name] = file;
          }
        } else {
          files[name] = file;
        }
      })
      .on('error', function(err) {
        cb(err, fields, files);
      })
      .on('end', function() {
        cb(null, fields, files);
      });
  }

  // Parse headers and setup the parser, ready to start listening for data.
  this.writeHeaders(req.headers);

  // Start listening for data.
  var self = this;
  req
    .on('error', function(err) {
      self._error(err);
    })
    .on('aborted', function() {
      self.emit('aborted');
      self._error(new Error('Request aborted'));
    })
    .on('data', function(buffer) {
      self.write(buffer);
    })
    .on('end', function() {
      if (self.error) {
        return;
      }

      var err = self._parser.end();
      if (err) {
        self._error(err);
      }
    });

  return this;
};

IncomingForm.prototype.writeHeaders = function(headers) {
  this.headers = headers;
  this._parseContentLength();
  this._parseContentType();
};

IncomingForm.prototype.write = function(buffer) {
  if (this.error) {
    return;
  }
  if (!this._parser) {
    this._error(new Error('uninitialized parser'));
    return;
  }

  this.bytesReceived += buffer.length;
  this.emit('progress', this.bytesReceived, this.bytesExpected);

  var bytesParsed = this._parser.write(buffer);
  if (bytesParsed !== buffer.length) {
    this._error(new Error('parser error, '+bytesParsed+' of '+buffer.length+' bytes parsed'));
  }

  return bytesParsed;
};

IncomingForm.prototype.pause = function() {
  // this does nothing, unless overwritten in IncomingForm.parse
  return false;
};

IncomingForm.prototype.resume = function() {
  // this does nothing, unless overwritten in IncomingForm.parse
  return false;
};

IncomingForm.prototype.onPart = function(part) {
  // this method can be overwritten by the user
  this.handlePart(part);
};

IncomingForm.prototype.handlePart = function(part) {
  var self = this;

  // This MUST check exactly for undefined. You can not change it to !part.filename.
  if (part.filename === undefined) {
    var value = ''
      , decoder = new StringDecoder(this.encoding);

    part.on('data', function(buffer) {
      self._fieldsSize += buffer.length;
      if (self._fieldsSize > self.maxFieldsSize) {
        self._error(new Error('maxFieldsSize exceeded, received '+self._fieldsSize+' bytes of field data'));
        return;
      }
      value += decoder.write(buffer);
    });

    part.on('end', function() {
      self.emit('field', part.name, value);
    });
    return;
  }

  this._flushing++;

  var file = new File({
    path: this._uploadPath(part.filename),
    name: part.filename,
    type: part.mime,
    hash: self.hash
  });

  this.emit('fileBegin', part.name, file);

  file.open();
  this.openedFiles.push(file);

  part.on('data', function(buffer) {
    self._fileSize += buffer.length;
    if (self._fileSize > self.maxFileSize) {
      self._error(new Error('maxFileSize exceeded, received '+self._fileSize+' bytes of file data'));
      return;
    }
    if (buffer.length == 0) {
      return;
    }
    self.pause();
    file.write(buffer, function() {
      self.resume();
    });
  });

  part.on('end', function() {
    file.end(function() {
      self._flushing--;
      self.emit('file', part.name, file);
      self._maybeEnd();
    });
  });
};

function dummyParser(self) {
  return {
    end: function () {
      self.ended = true;
      self._maybeEnd();
      return null;
    }
  };
}

IncomingForm.prototype._parseContentType = function() {
  if (this.bytesExpected === 0) {
    this._parser = dummyParser(this);
    return;
  }

  if (!this.headers['content-type']) {
    this._error(new Error('bad content-type header, no content-type'));
    return;
  }

  if (this.headers['content-type'].match(/octet-stream/i)) {
    this._initOctetStream();
    return;
  }

  if (this.headers['content-type'].match(/urlencoded/i)) {
    this._initUrlencoded();
    return;
  }

  if (this.headers['content-type'].match(/multipart/i)) {
    var m = this.headers['content-type'].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
    if (m) {
      this._initMultipart(m[1] || m[2]);
    } else {
      this._error(new Error('bad content-type header, no multipart boundary'));
    }
    return;
  }

  if (this.headers['content-type'].match(/json/i)) {
    this._initJSONencoded();
    return;
  }

  this._error(new Error('bad content-type header, unknown content-type: '+this.headers['content-type']));
};

IncomingForm.prototype._error = function(err) {
  if (this.error || this.ended) {
    return;
  }

  this.error = err;
  this.emit('error', err);

  if (Array.isArray(this.openedFiles)) {
    this.openedFiles.forEach(function(file) {
      file._writeStream.destroy();
      setTimeout(fs.unlink, 0, file.path, function(error) { });
    });
  }
};

IncomingForm.prototype._parseContentLength = function() {
  this.bytesReceived = 0;
  if (this.headers['content-length']) {
    this.bytesExpected = parseInt(this.headers['content-length'], 10);
  } else if (this.headers['transfer-encoding'] === undefined) {
    this.bytesExpected = 0;
  }

  if (this.bytesExpected !== null) {
    this.emit('progress', this.bytesReceived, this.bytesExpected);
  }
};

IncomingForm.prototype._newParser = function() {
  return new MultipartParser();
};

IncomingForm.prototype._initMultipart = function(boundary) {
  this.type = 'multipart';

  var parser = new MultipartParser(),
      self = this,
      headerField,
      headerValue,
      part;

  parser.initWithBoundary(boundary);

  parser.onPartBegin = function() {
    part = new Stream();
    part.readable = true;
    part.headers = {};
    part.name = null;
    part.filename = null;
    part.mime = null;

    part.transferEncoding = 'binary';
    part.transferBuffer = '';

    headerField = '';
    headerValue = '';
  };

  parser.onHeaderField = function(b, start, end) {
    headerField += b.toString(self.encoding, start, end);
  };

  parser.onHeaderValue = function(b, start, end) {
    headerValue += b.toString(self.encoding, start, end);
  };

  parser.onHeaderEnd = function() {
    headerField = headerField.toLowerCase();
    part.headers[headerField] = headerValue;

    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)
    var m = headerValue.match(/\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i);
    if (headerField == 'content-disposition') {
      if (m) {
        part.name = m[2] || m[3] || '';
      }

      part.filename = self._fileName(headerValue);
    } else if (headerField == 'content-type') {
      part.mime = headerValue;
    } else if (headerField == 'content-transfer-encoding') {
      part.transferEncoding = headerValue.toLowerCase();
    }

    headerField = '';
    headerValue = '';
  };

  parser.onHeadersEnd = function() {
    switch(part.transferEncoding){
      case 'binary':
      case '7bit':
      case '8bit':
      parser.onPartData = function(b, start, end) {
        part.emit('data', b.slice(start, end));
      };

      parser.onPartEnd = function() {
        part.emit('end');
      };
      break;

      case 'base64':
      parser.onPartData = function(b, start, end) {
        part.transferBuffer += b.slice(start, end).toString('ascii');

        /*
        four bytes (chars) in base64 converts to three bytes in binary
        encoding. So we should always work with a number of bytes that
        can be divided by 4, it will result in a number of buytes that
        can be divided vy 3.
        */
        var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
        part.emit('data', new Buffer(part.transferBuffer.substring(0, offset), 'base64'));
        part.transferBuffer = part.transferBuffer.substring(offset);
      };

      parser.onPartEnd = function() {
        part.emit('data', new Buffer(part.transferBuffer, 'base64'));
        part.emit('end');
      };
      break;

      default:
      return self._error(new Error('unknown transfer-encoding'));
    }

    self.onPart(part);
  };


  parser.onEnd = function() {
    self.ended = true;
    self._maybeEnd();
  };

  this._parser = parser;
};

IncomingForm.prototype._fileName = function(headerValue) {
  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)
  var m = headerValue.match(/\bfilename=("(.*?)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))($|;\s)/i);
  if (!m) return;

  var match = m[2] || m[3] || '';
  var filename = match.substr(match.lastIndexOf('\\') + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#([\d]{4});/g, function(m, code) {
    return String.fromCharCode(code);
  });
  return filename;
};

IncomingForm.prototype._initUrlencoded = function() {
  this.type = 'urlencoded';

  var parser = new QuerystringParser(this.maxFields)
    , self = this;

  parser.onField = function(key, val) {
    self.emit('field', key, val);
  };

  parser.onEnd = function() {
    self.ended = true;
    self._maybeEnd();
  };

  this._parser = parser;
};

IncomingForm.prototype._initOctetStream = function() {
  this.type = 'octet-stream';
  var filename = this.headers['x-file-name'];
  var mime = this.headers['content-type'];

  var file = new File({
    path: this._uploadPath(filename),
    name: filename,
    type: mime
  });

  this.emit('fileBegin', filename, file);
  file.open();
  this.openedFiles.push(file);
  this._flushing++;

  var self = this;

  self._parser = new OctetParser();

  //Keep track of writes that haven't finished so we don't emit the file before it's done being written
  var outstandingWrites = 0;

  self._parser.on('data', function(buffer){
    self.pause();
    outstandingWrites++;

    file.write(buffer, function() {
      outstandingWrites--;
      self.resume();

      if(self.ended){
        self._parser.emit('doneWritingFile');
      }
    });
  });

  self._parser.on('end', function(){
    self._flushing--;
    self.ended = true;

    var done = function(){
      file.end(function() {
        self.emit('file', 'file', file);
        self._maybeEnd();
      });
    };

    if(outstandingWrites === 0){
      done();
    } else {
      self._parser.once('doneWritingFile', done);
    }
  });
};

IncomingForm.prototype._initJSONencoded = function() {
  this.type = 'json';

  var parser = new JSONParser(this)
    , self = this;

  parser.onField = function(key, val) {
    self.emit('field', key, val);
  };

  parser.onEnd = function() {
    self.ended = true;
    self._maybeEnd();
  };

  this._parser = parser;
};

IncomingForm.prototype._uploadPath = function(filename) {
  var buf = crypto.randomBytes(16);
  var name = 'upload_' + buf.toString('hex');

  if (this.keepExtensions) {
    var ext = path.extname(filename);
    ext     = ext.replace(/(\.[a-z0-9]+).*/i, '$1');

    name += ext;
  }

  return path.join(this.uploadDir, name);
};

IncomingForm.prototype._maybeEnd = function() {
  if (!this.ended || this._flushing || this.error) {
    return;
  }

  this.emit('end');
};


/***/ }),

/***/ 71341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IncomingForm = (__webpack_require__(6655)/* .IncomingForm */ .c);
IncomingForm.IncomingForm = IncomingForm;
module.exports = IncomingForm;


/***/ }),

/***/ 24024:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var require;if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(78822));

var Buffer = (__webpack_require__(14300).Buffer);

function JSONParser(parent) {
  this.parent = parent;
  this.chunks = [];
  this.bytesWritten = 0;
}
exports.c = JSONParser;

JSONParser.prototype.write = function(buffer) {
  this.bytesWritten += buffer.length;
  this.chunks.push(buffer);
  return buffer.length;
};

JSONParser.prototype.end = function() {
  try {
    var fields = JSON.parse(Buffer.concat(this.chunks));
    for (var field in fields) {
      this.onField(field, fields[field]);
    }
  } catch (e) {
    this.parent.emit('error', e);
  }
  this.data = null;

  this.onEnd();
};


/***/ }),

/***/ 60608:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(14300).Buffer),
    s = 0,
    S =
    { PARSER_UNINITIALIZED: s++,
      START: s++,
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      PART_END: s++,
      END: s++
    },

    f = 1,
    F =
    { PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    },

    LF = 10,
    CR = 13,
    SPACE = 32,
    HYPHEN = 45,
    COLON = 58,
    A = 97,
    Z = 122,

    lower = function(c) {
      return c | 0x20;
    };

for (s in S) {
  exports[s] = S[s];
}

function MultipartParser() {
  this.boundary = null;
  this.boundaryChars = null;
  this.lookbehind = null;
  this.state = S.PARSER_UNINITIALIZED;

  this.index = null;
  this.flags = 0;
}
exports.MultipartParser = MultipartParser;

MultipartParser.stateToString = function(stateNumber) {
  for (var state in S) {
    var number = S[state];
    if (number === stateNumber) return state;
  }
};

MultipartParser.prototype.initWithBoundary = function(str) {
  this.boundary = new Buffer(str.length+4);
  this.boundary.write('\r\n--', 0);
  this.boundary.write(str, 4);
  this.lookbehind = new Buffer(this.boundary.length+8);
  this.state = S.START;

  this.boundaryChars = {};
  for (var i = 0; i < this.boundary.length; i++) {
    this.boundaryChars[this.boundary[i]] = true;
  }
};

MultipartParser.prototype.write = function(buffer) {
  var self = this,
      i = 0,
      len = buffer.length,
      prevIndex = this.index,
      index = this.index,
      state = this.state,
      flags = this.flags,
      lookbehind = this.lookbehind,
      boundary = this.boundary,
      boundaryChars = this.boundaryChars,
      boundaryLength = this.boundary.length,
      boundaryEnd = boundaryLength - 1,
      bufferLength = buffer.length,
      c,
      cl,

      mark = function(name) {
        self[name+'Mark'] = i;
      },
      clear = function(name) {
        delete self[name+'Mark'];
      },
      callback = function(name, buffer, start, end) {
        if (start !== undefined && start === end) {
          return;
        }

        var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);
        if (callbackSymbol in self) {
          self[callbackSymbol](buffer, start, end);
        }
      },
      dataCallback = function(name, clear) {
        var markSymbol = name+'Mark';
        if (!(markSymbol in self)) {
          return;
        }

        if (!clear) {
          callback(name, buffer, self[markSymbol], buffer.length);
          self[markSymbol] = 0;
        } else {
          callback(name, buffer, self[markSymbol], i);
          delete self[markSymbol];
        }
      };

  for (i = 0; i < len; i++) {
    c = buffer[i];
    switch (state) {
      case S.PARSER_UNINITIALIZED:
        return i;
      case S.START:
        index = 0;
        state = S.START_BOUNDARY;
      case S.START_BOUNDARY:
        if (index == boundary.length - 2) {
          if (c == HYPHEN) {
            flags |= F.LAST_BOUNDARY;
          } else if (c != CR) {
            return i;
          }
          index++;
          break;
        } else if (index - 1 == boundary.length - 2) {
          if (flags & F.LAST_BOUNDARY && c == HYPHEN){
            callback('end');
            state = S.END;
            flags = 0;
          } else if (!(flags & F.LAST_BOUNDARY) && c == LF) {
            index = 0;
            callback('partBegin');
            state = S.HEADER_FIELD_START;
          } else {
            return i;
          }
          break;
        }

        if (c != boundary[index+2]) {
          index = -2;
        }
        if (c == boundary[index+2]) {
          index++;
        }
        break;
      case S.HEADER_FIELD_START:
        state = S.HEADER_FIELD;
        mark('headerField');
        index = 0;
      case S.HEADER_FIELD:
        if (c == CR) {
          clear('headerField');
          state = S.HEADERS_ALMOST_DONE;
          break;
        }

        index++;
        if (c == HYPHEN) {
          break;
        }

        if (c == COLON) {
          if (index == 1) {
            // empty header field
            return i;
          }
          dataCallback('headerField', true);
          state = S.HEADER_VALUE_START;
          break;
        }

        cl = lower(c);
        if (cl < A || cl > Z) {
          return i;
        }
        break;
      case S.HEADER_VALUE_START:
        if (c == SPACE) {
          break;
        }

        mark('headerValue');
        state = S.HEADER_VALUE;
      case S.HEADER_VALUE:
        if (c == CR) {
          dataCallback('headerValue', true);
          callback('headerEnd');
          state = S.HEADER_VALUE_ALMOST_DONE;
        }
        break;
      case S.HEADER_VALUE_ALMOST_DONE:
        if (c != LF) {
          return i;
        }
        state = S.HEADER_FIELD_START;
        break;
      case S.HEADERS_ALMOST_DONE:
        if (c != LF) {
          return i;
        }

        callback('headersEnd');
        state = S.PART_DATA_START;
        break;
      case S.PART_DATA_START:
        state = S.PART_DATA;
        mark('partData');
      case S.PART_DATA:
        prevIndex = index;

        if (index === 0) {
          // boyer-moore derrived algorithm to safely skip non-boundary data
          i += boundaryEnd;
          while (i < bufferLength && !(buffer[i] in boundaryChars)) {
            i += boundaryLength;
          }
          i -= boundaryEnd;
          c = buffer[i];
        }

        if (index < boundary.length) {
          if (boundary[index] == c) {
            if (index === 0) {
              dataCallback('partData', true);
            }
            index++;
          } else {
            index = 0;
          }
        } else if (index == boundary.length) {
          index++;
          if (c == CR) {
            // CR = part boundary
            flags |= F.PART_BOUNDARY;
          } else if (c == HYPHEN) {
            // HYPHEN = end boundary
            flags |= F.LAST_BOUNDARY;
          } else {
            index = 0;
          }
        } else if (index - 1 == boundary.length)  {
          if (flags & F.PART_BOUNDARY) {
            index = 0;
            if (c == LF) {
              // unset the PART_BOUNDARY flag
              flags &= ~F.PART_BOUNDARY;
              callback('partEnd');
              callback('partBegin');
              state = S.HEADER_FIELD_START;
              break;
            }
          } else if (flags & F.LAST_BOUNDARY) {
            if (c == HYPHEN) {
              callback('partEnd');
              callback('end');
              state = S.END;
              flags = 0;
            } else {
              index = 0;
            }
          } else {
            index = 0;
          }
        }

        if (index > 0) {
          // when matching a possible boundary, keep a lookbehind reference
          // in case it turns out to be a false lead
          lookbehind[index-1] = c;
        } else if (prevIndex > 0) {
          // if our boundary turned out to be rubbish, the captured lookbehind
          // belongs to partData
          callback('partData', lookbehind, 0, prevIndex);
          prevIndex = 0;
          mark('partData');

          // reconsider the current character even so it interrupted the sequence
          // it could be the beginning of a new sequence
          i--;
        }

        break;
      case S.END:
        break;
      default:
        return i;
    }
  }

  dataCallback('headerField');
  dataCallback('headerValue');
  dataCallback('partData');

  this.index = index;
  this.state = state;
  this.flags = flags;

  return len;
};

MultipartParser.prototype.end = function() {
  var callback = function(self, name) {
    var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);
    if (callbackSymbol in self) {
      self[callbackSymbol]();
    }
  };
  if ((this.state == S.HEADER_FIELD_START && this.index === 0) ||
      (this.state == S.PART_DATA && this.index == this.boundary.length)) {
    callback(this, 'partEnd');
    callback(this, 'end');
  } else if (this.state != S.END) {
    return new Error('MultipartParser.end(): stream ended unexpectedly: ' + this.explain());
  }
};

MultipartParser.prototype.explain = function() {
  return 'state = ' + MultipartParser.stateToString(this.state);
};


/***/ }),

/***/ 72009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var EventEmitter = (__webpack_require__(82361).EventEmitter)
	, util = __webpack_require__(73837);

function OctetParser(options){
	if(!(this instanceof OctetParser)) return new OctetParser(options);
	EventEmitter.call(this);
}

util.inherits(OctetParser, EventEmitter);

exports.h = OctetParser;

OctetParser.prototype.write = function(buffer) {
    this.emit('data', buffer);
	return buffer.length;
};

OctetParser.prototype.end = function() {
	this.emit('end');
};


/***/ }),

/***/ 13381:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var require;if (global.GENTLY) require = GENTLY.hijack(__webpack_require__(78822));

// This is a buffering parser, not quite as nice as the multipart one.
// If I find time I'll rewrite this to be fully streaming as well
var querystring = __webpack_require__(63477);

function QuerystringParser(maxKeys) {
  this.maxKeys = maxKeys;
  this.buffer = '';
}
exports.l = QuerystringParser;

QuerystringParser.prototype.write = function(buffer) {
  this.buffer += buffer.toString('ascii');
  return buffer.length;
};

QuerystringParser.prototype.end = function() {
  var fields = querystring.parse(this.buffer, '&', '=', { maxKeys: this.maxKeys });
  for (var field in fields) {
    this.onField(field, fields[field]);
  }
  this.buffer = '';

  this.onEnd();
};



/***/ }),

/***/ 78822:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 78822;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 37795:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 4090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(37795);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 67286:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(32636)();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(4090);
var hasOwn = __webpack_require__(23198);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 32636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(66679);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 66679:
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 23198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(4090);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ 34485:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var hash = exports;

hash.utils = __webpack_require__(50212);
hash.common = __webpack_require__(74495);
hash.sha = __webpack_require__(45530);
hash.ripemd = __webpack_require__(91396);
hash.hmac = __webpack_require__(15047);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ 74495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var assert = __webpack_require__(79561);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ 15047:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var assert = __webpack_require__(79561);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ 91396:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var common = __webpack_require__(74495);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ 45530:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.sha1 = __webpack_require__(35079);
exports.sha224 = __webpack_require__(63823);
exports.sha256 = __webpack_require__(68032);
exports.sha384 = __webpack_require__(25328);
exports.sha512 = __webpack_require__(20168);


/***/ }),

/***/ 35079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var common = __webpack_require__(74495);
var shaCommon = __webpack_require__(40713);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 63823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var SHA256 = __webpack_require__(68032);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ 68032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var common = __webpack_require__(74495);
var shaCommon = __webpack_require__(40713);
var assert = __webpack_require__(79561);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 25328:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);

var SHA512 = __webpack_require__(20168);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ 20168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var common = __webpack_require__(74495);
var assert = __webpack_require__(79561);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ 40713:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(50212);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ 50212:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(79561);
var inherits = __webpack_require__(98874);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ 78873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(34485);
var utils = __webpack_require__(43022);
var assert = __webpack_require__(79561);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ 98874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(73837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(91285);
}


/***/ }),

/***/ 91285:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 38320:
/***/ ((module) => {

/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
module.exports = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
}


/***/ }),

/***/ 30775:
/***/ ((module) => {

module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}


/***/ }),

/***/ 68144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(47391)(__webpack_require__(57353)('keccak'))


/***/ }),

/***/ 88562:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

try {
  module.exports = __webpack_require__(68144)
} catch (err) {
  if (process.env.DEBUG) {
    console.error('Keccak bindings are not compiled. Pure JS implementation will be used.')
  }

  module.exports = __webpack_require__(1932)
}


/***/ }),

/***/ 1932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(47391)(__webpack_require__(75117))


/***/ }),

/***/ 47391:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const createKeccak = __webpack_require__(34194)
const createShake = __webpack_require__(33365)

module.exports = function (KeccakState) {
  const Keccak = createKeccak(KeccakState)
  const Shake = createShake(KeccakState)

  return function (algorithm, options) {
    const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}


/***/ }),

/***/ 34194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Buffer = (__webpack_require__(77834).Buffer)
const Transform = (__webpack_require__(12781).Transform)
const inherits = __webpack_require__(98874)

module.exports = function (KeccakState) {
  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Keccak, Transform)

  Keccak.prototype._transform = function (chunk, encoding, callback) {
    let error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype._flush = function (callback) {
    let error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Keccak.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
    let digest = this._state.squeeze(this._hashBitLength / 8)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
  Keccak.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
  Keccak.prototype._clone = function () {
    const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Keccak
}


/***/ }),

/***/ 33365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Buffer = (__webpack_require__(77834).Buffer)
const Transform = (__webpack_require__(12781).Transform)
const inherits = __webpack_require__(98874)

module.exports = function (KeccakState) {
  function Shake (rate, capacity, delimitedSuffix, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Shake, Transform)

  Shake.prototype._transform = function (chunk, encoding, callback) {
    let error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Shake.prototype._flush = function () {}

  Shake.prototype._read = function (size) {
    this.push(this.squeeze(size))
  }

  Shake.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Squeeze already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Shake.prototype.squeeze = function (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true
      this._state.absorbLastFewBits(this._delimitedSuffix)
    }

    let data = this._state.squeeze(dataByteLength)
    if (encoding !== undefined) data = data.toString(encoding)

    return data
  }

  Shake.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  Shake.prototype._clone = function () {
    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Shake
}


/***/ }),

/***/ 27710:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]

exports.p1600 = function (s) {
  for (let round = 0; round < 24; ++round) {
    // theta
    const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
    const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
    const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
    const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
    const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
    const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
    const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
    const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
    const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
    const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)
    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)
    const t1slo0 = s[0] ^ lo
    const t1shi0 = s[1] ^ hi
    const t1slo5 = s[10] ^ lo
    const t1shi5 = s[11] ^ hi
    const t1slo10 = s[20] ^ lo
    const t1shi10 = s[21] ^ hi
    const t1slo15 = s[30] ^ lo
    const t1shi15 = s[31] ^ hi
    const t1slo20 = s[40] ^ lo
    const t1shi20 = s[41] ^ hi
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)
    const t1slo1 = s[2] ^ lo
    const t1shi1 = s[3] ^ hi
    const t1slo6 = s[12] ^ lo
    const t1shi6 = s[13] ^ hi
    const t1slo11 = s[22] ^ lo
    const t1shi11 = s[23] ^ hi
    const t1slo16 = s[32] ^ lo
    const t1shi16 = s[33] ^ hi
    const t1slo21 = s[42] ^ lo
    const t1shi21 = s[43] ^ hi
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)
    const t1slo2 = s[4] ^ lo
    const t1shi2 = s[5] ^ hi
    const t1slo7 = s[14] ^ lo
    const t1shi7 = s[15] ^ hi
    const t1slo12 = s[24] ^ lo
    const t1shi12 = s[25] ^ hi
    const t1slo17 = s[34] ^ lo
    const t1shi17 = s[35] ^ hi
    const t1slo22 = s[44] ^ lo
    const t1shi22 = s[45] ^ hi
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)
    const t1slo3 = s[6] ^ lo
    const t1shi3 = s[7] ^ hi
    const t1slo8 = s[16] ^ lo
    const t1shi8 = s[17] ^ hi
    const t1slo13 = s[26] ^ lo
    const t1shi13 = s[27] ^ hi
    const t1slo18 = s[36] ^ lo
    const t1shi18 = s[37] ^ hi
    const t1slo23 = s[46] ^ lo
    const t1shi23 = s[47] ^ hi
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)
    const t1slo4 = s[8] ^ lo
    const t1shi4 = s[9] ^ hi
    const t1slo9 = s[18] ^ lo
    const t1shi9 = s[19] ^ hi
    const t1slo14 = s[28] ^ lo
    const t1shi14 = s[29] ^ hi
    const t1slo19 = s[38] ^ lo
    const t1shi19 = s[39] ^ hi
    const t1slo24 = s[48] ^ lo
    const t1shi24 = s[49] ^ hi

    // rho & pi
    const t2slo0 = t1slo0
    const t2shi0 = t1shi0
    const t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)
    const t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)
    const t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)
    const t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)
    const t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)
    const t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)
    const t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)
    const t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)
    const t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)
    const t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)
    const t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)
    const t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)
    const t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)
    const t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)
    const t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)
    const t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)
    const t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)
    const t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)
    const t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)
    const t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)
    const t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)
    const t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)
    const t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)
    const t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)
    const t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)
    const t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)
    const t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)
    const t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)
    const t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)
    const t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)
    const t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)
    const t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)
    const t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)
    const t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)
    const t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)
    const t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)
    const t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)
    const t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)
    const t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)
    const t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)
    const t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)
    const t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)
    const t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)
    const t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)
    const t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)
    const t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)
    const t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)
    const t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)

    // chi
    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
  }
}


/***/ }),

/***/ 75117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Buffer = (__webpack_require__(77834).Buffer)
const keccakState = __webpack_require__(27710)

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (let i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (let i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  const output = Buffer.alloc(length)
  for (var i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak


/***/ }),

/***/ 60505:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLength = exports.decode = exports.encode = void 0;
const bn_js_1 = __importDefault(__webpack_require__(62197));
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
    }
    else {
        const inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128
            ? inputBuf
            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
}
exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
    if (v[0] === '0' && v[1] === '0') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Buffer.from([len + offset]);
    }
    else {
        const hexLength = intToHex(len);
        const lLength = hexLength.length / 2;
        const firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    const inputBuffer = toBuffer(input);
    const decoded = _decode(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    const inputBuffer = toBuffer(input);
    const firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    }
    else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    }
    else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    }
    else {
        // a list  over 55 bytes long
        const llength = firstByte - 0xf6;
        const length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length;
    }
}
exports.getLength = getLength;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        }
        else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP: not enough bytes for string');
        }
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
    const hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed(v)) {
                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
            }
            else {
                return Buffer.from(v);
            }
        }
        else if (typeof v === 'number' || typeof v === 'bigint') {
            if (!v) {
                return Buffer.from([]);
            }
            else {
                return intToBuffer(v);
            }
        }
        else if (v === null || v === undefined) {
            return Buffer.from([]);
        }
        else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        }
        else if (bn_js_1.default.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 46057:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const JSBI = __webpack_require__(31629);

/**
 * @see https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt
 */
JSBI.prototype.toJSON = function () {
  return this.toString();
};

/** @constant {number} */
const WORD_BYTES = 32; // byte number pre abi word

/** @constant {number} */
const WORD_CHARS = WORD_BYTES * 2;

/** @constant {BigInt} */
const UINT_BOUND = JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(WORD_BYTES * 8)); // 2**256

/** @constant {BigInt} */
const MAX_UINT = JSBI.subtract(UINT_BOUND, JSBI.BigInt(1)); // 2**256-1

/**
 * Enum for epochNumber tag
 * @readonly
 * @enum {string}
 *
 * - `LATEST_MINED` 'latest_mined': latest epoch.
 * - `LATEST_STATE` 'latest_state': latest state, about 5 epoch less then `LATEST_MINED`
 * - `LATEST_FINALIZED` 'latest_finalized': latest epoch which finalized by PoS chain.
 * - `LATEST_CONFIRMED` 'latest_confirmed': latest epoch which confirmation risk less 1e-8.
 * - `LATEST_CHECKPOINT` 'latest_checkpoint': latest check point epoch.
 * - `EARLIEST` 'earliest': earliest epoch number, same as 0.
 */
const EPOCH_NUMBER = {
  LATEST_MINED: 'latest_mined',
  LATEST_STATE: 'latest_state',
  LATEST_FINALIZED: 'latest_finalized',
  LATEST_CONFIRMED: 'latest_confirmed',
  LATEST_CHECKPOINT: 'latest_checkpoint',
  EARLIEST: 'earliest',
};

/**
 * Min gas price for transaction
 * @constant {number}
 * @example
 * > CONST.MIN_GAS_PRICE
 1000000000
 */
const MIN_GAS_PRICE = 1000000000; // 1Gdrip

/**
 * Gas use for pure transfer transaction
 * @constant {number}
 * @example
 * > CONST.TRANSACTION_GAS
 21000
 */
const TRANSACTION_GAS = 21000;

/**
 * Storage limit for pure transfer transaction
 * @constant {number}
 * @example
 * > CONST.TRANSACTION_STORAGE_LIMIT
 0
 */
const TRANSACTION_STORAGE_LIMIT = 0;

/**
 * Mainnet chainId
 * @constant {number}
 * @example
 * > CONST.MAINNET_ID
 1029
 */
const MAINNET_ID = 1029;

/**
 * Testnet chainId
 * @constant {number}
 * @example
 * > CONST.TESTNET_ID
 1
 */
const TESTNET_ID = 1;

/**
 * Zero address
 * @constant {string}
 * @example
 * > ZERO_ADDRESS
 0x0000000000000000000000000000000000000000
 */
const ZERO_ADDRESS_HEX = '0x0000000000000000000000000000000000000000';

/** @constant {string} */
const ZERO_HASH = '0x0000000000000000000000000000000000000000000000000000000000000000';

/**
 * Pending transaction status
 * @readonly
 * @enum {string}
 *
 * - `FUTURE_NONCE` 'futureNonce': pending because future nonce
 * - `NOT_ENOUGH_CASH` 'notEnoughCash': pending because insufficient balance
 */
const PENDING_TX_STATUS = {
  FUTURE_NONCE: 'futureNonce',
  NOT_ENOUGH_CASH: 'notEnoughCash',
};

/**
 * Enum for trace action types
 * @readonly
 * @enum {string}
 */
const ACTION_TYPES = {
  CALL: 'call',
  CREATE: 'create',
  CALL_RESULT: 'call_result',
  CREATE_RESULT: 'create_result',
  INTERNAL_TRANSFER_ACTION: 'internal_transfer_action',
};

/**
 * Enum for trace pocket types
 * @readonly
 * @enum {string}
 */
const POCKET_ENUM = {
  BALANCE: 'balance',
  STAKING_BALANCE: 'staking_balance',
  STORAGE_COLLATERAL: 'storage_collateral',
  SPONSOR_BALANCE_FOR_GAS: 'sponsor_balance_for_gas',
  SPONSOR_BALANCE_FOR_COLLATERAL: 'sponsor_balance_for_collateral',
  MINT_BURN: 'mint_burn',
  GAS_PAYMENT: 'gas_payment',
};

/**
 * Enum for trace call types
 * @readonly
 * @enum {string}
 */
const CALL_TYPES = {
  NONE: 'none',
  CALL: 'call',
  CALL_CODE: 'callcode',
  DELEGATE_CALL: 'delegatecall',
  STATIC_CALL: 'staticcall',
};

/**
 * Enum for trace create types
 * @readonly
 * @enum {string}
 */
const CREATE_TYPES = {
  NONE: 'none',
  CREATE: 'create',
  CREATE2: 'create2',
};

/**
 * Enum for space type
 * @readonly
 * @enum {string}
 */
const SPACE_ENUM = {
  NONE: 'none',
  NATIVE: 'native',
  EVM: 'evm',
};

/**
 * Enum for trace call status
 * @readonly
 * @enum {string}
 */
const CALL_STATUS = {
  SUCCESS: 'success',
  REVERTED: 'reverted',
  FAIL: 'fail',
};

/**
 * Enum for transaction.status and receipt.outcomeStatus
 * @readonly
 * @enum {number}
 */
const TX_STATUS = {
  UNEXECUTE: null, // If tx is not packed or in the defer state or executed in other block
  SUCCESS: 0,
  FAIL: 1,
  SKIP: 2,
};

/**
 * Enum for address types
 * @readonly
 * @enum {string}
 */
const ADDRESS_TYPES = {
  USER: 'user',
  CONTRACT: 'contract',
  BUILTIN: 'builtin',
  NULL: 'null',
};

/**
 * KECCAK (i.e. Keccak) hash of the empty bytes string.
 * @constant {string}
 * */
const KECCAK_EMPTY = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';

module.exports = {
  WORD_BYTES,
  WORD_CHARS,
  UINT_BOUND,
  MAX_UINT,
  EPOCH_NUMBER,
  MIN_GAS_PRICE,
  TRANSACTION_GAS,
  TRANSACTION_STORAGE_LIMIT,
  TESTNET_ID,
  MAINNET_ID,
  ZERO_ADDRESS_HEX,
  PENDING_TX_STATUS,
  ACTION_TYPES,
  CALL_TYPES,
  CALL_STATUS,
  POCKET_ENUM,
  TX_STATUS,
  CREATE_TYPES,
  SPACE_ENUM,
  KECCAK_EMPTY,
  ZERO_HASH,
  ADDRESS_TYPES,
};


/***/ }),

/***/ 91665:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CONST = __webpack_require__(46057);
const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const cfxFormat = __webpack_require__(77466);
const providerFactory = __webpack_require__(6632);
const Wallet = __webpack_require__(97033);
const Contract = __webpack_require__(69350);
const INTERNAL_CONTRACTS = __webpack_require__(54433);
const { CRC20_ABI } = __webpack_require__(80446);
const PendingTransaction = __webpack_require__(54727);
const Subscription = __webpack_require__(86420);
const pkg = __webpack_require__(42156);
const PoS = __webpack_require__(67946);
const CFX = __webpack_require__(40856);
const Trace = __webpack_require__(48562);
const TxPool = __webpack_require__(47401);
const BatchRequester = __webpack_require__(29719);
const AdvancedRPCUtilities = __webpack_require__(46789);

/**
 * @typedef {Object} ConfluxOption
 * @property {string|number} [options.defaultGasPrice] - The default gas price in drip to use for transactions.
 * @property {number} [options.defaultGasRatio=1.1] - The ratio to multiply by gas.
 * @property {number} [options.defaultStorageRatio=1.1] - The ratio to multiply by storageLimit.
 * @property {string} [options.url] - Url of Conflux node to connect.
 * @property {number} [options.retry] - Retry times if request error occurs.
 * @property {number} [options.timeout] - Request time out in ms
 * @property {Object} [options.logger] - Logger object with 'info' and 'error' method.
 * @property {number} [options.networkId] - Connected RPC's networkId
 * @property {boolean} [options.useWechatProvider] - Use wechat provider
 * @property {boolean} [options.useHexAddressInParameter] - Use hex address in parameter
 * @property {boolean} [options.useVerboseAddress] - Use verbose address
 */

/**
 * The Client class that provides an interface to the Conflux network.
 */
class Conflux {
  /**
   * Create a Conflux instance with networdId set up
   * @param {ConfluxOption} options
   * @return {Conflux}
   */
  static async create(options) {
    const cfx = new Conflux(options);
    if (options.networkId) return cfx;
    await cfx.updateNetworkId();
    return cfx;
  }

  /**
   * @param {ConfluxOption} [options] - Conflux and Provider constructor options.
   * @return {Conflux}
   * @example
   * > const { Conflux } = require('js-conflux-sdk');
   * > const conflux = new Conflux({url:'https://test.confluxrpc.com', networkId: 1});
   *
   * @example
   * > const conflux = new Conflux({
     url: 'http://localhost:8000',
     defaultGasPrice: 100,
     logger: console,
   });
   */
  constructor({
    defaultGasPrice,
    defaultGasRatio = 1.1,
    defaultStorageRatio = 1.1,
    networkId,
    useHexAddressInParameter = false,
    useVerboseAddress = false,
    ...rest
  } = {}) {
    /** @type {string} */
    this.version = pkg.version;

    /**
     * Provider for rpc call
     *
     * @type {import('./provider/BaseProvider')|import('./provider/WechatProvider')|import('./provider/HttpProvider')|import('./provider/WebsocketProvider')}
     */
    this.provider = providerFactory(rest);

    /**
     * Wallet for `sendTransaction` to get `Account` by `from` field
     *
     * @type {import("./wallet/Wallet")}
     */
    this.wallet = new Wallet();

    /**
     * Default gas price for following methods:
     * - `Conflux.sendTransaction`
     *
     * @deprecated
     * @type {number|string}
     */
    this.defaultGasPrice = defaultGasPrice;

    /**
     * If transaction.gas is undefined, gas will be set by estimate,
     * cause gas used might be change during `estimateGasAndCollateral` and `sendTransaction`,
     * estimate value need to multiply by defaultGasRatio (>1.0) in case of gas not enough.
     *
     * > transaction.gas = estimate.gasUsed * defaultGasRatio
     *
     * Default gas price for following methods:
     * - `Conflux.sendTransaction`
     *
     * @type {number}
     */
    this.defaultGasRatio = defaultGasRatio;

    /**
     * If transaction.storageLimit is undefined, storageLimit will be set by estimate,
     * cause storage limit might be change during `estimateGasAndCollateral` and `sendTransaction`,
     * estimate value need to multiply by defaultStorageRatio (>1.0) in case of storageLimit not enough.
     *
     * > transaction.storageLimit = estimate.storageCollateralized * defaultStorageRatio
     *
     * Default gas price for following methods:
     * - `Conflux.sendTransaction`
     *
     * @type {number}
     */
    this.defaultStorageRatio = defaultStorageRatio;

    this.sendRawTransaction = this._decoratePendingTransaction(this.sendRawTransaction);
    this.sendTransaction = this._decoratePendingTransaction(this.sendTransaction);

    if (networkId) {
      this.networkId = networkId;
      this.wallet.setNetworkId(networkId);
    }

    this.useHexAddressInParameter = useHexAddressInParameter;
    this.useVerboseAddress = useVerboseAddress;

    /**
     * pos RPC methods
     * @type {import('./rpc/pos')}
     */
    this.pos = new PoS(this);
    /**
     * trace RPC methods
     * @type {import('./rpc/trace')}
     */
    this.trace = new Trace(this);
    /**
     * txpool RPC methods
     * @type {import('./rpc/txpool')}
     */
    this.txpool = new TxPool(this);
    /**
     * cfx RPC methods
     * @type {import('./rpc/cfx')}
     */
    this.cfx = new CFX(this);
    /**
     * Advanced RPC compose methods
     * @type {import('./rpc/Advanced')}
     */
    this.advanced = new AdvancedRPCUtilities(this);
  }

  /**
   * Different kind provider API wrapper
   */
  request(req) {
    if (this.provider.request) {
      return this.provider.request(req);
    }
    if (this.provider.call) {
      return this.provider.call(req.method, ...req.params);
    }
    if (this.provider.send) {
      return this.provider.send(req.method, req.params);
    }
    throw new Error('Provider does not support request');
  }

  /**
   * @private
   */
  _decoratePendingTransaction(func) {
    const conflux = this;
    return function (...args) {
      return new PendingTransaction(conflux, func.bind(this), args);
    };
  }

  /**
   * @private
   */
  _formatAddress(address) {
    if (!this.networkId) {
      console.warn('Conflux address: networkId is not set properly, please set it');
    }
    return this.useHexAddressInParameter ? format.hexAddress(address) : format.address(address, this.networkId, this.useVerboseAddress);
  }

  /**
   * @private
   */
  _formatCallTx(options) {
    return cfxFormat.callTxAdvance(this.networkId, this.useHexAddressInParameter, this.useVerboseAddress)(options);
  }

  /**
   * @private
   */
  _formatGetLogs(options) {
    return cfxFormat.getLogsAdvance(this.networkId, this.useHexAddressInParameter, this.useVerboseAddress)(options);
  }

  /**
   * A shout cut for `new Contract(options, conflux);`
   *
   * @param {object} options - See [Contract.constructor](Contract.md#Contract.js/constructor)
   * @return {import('./contract')}
   */
  Contract(options) {
    return new Contract(options, this);
  }

  /**
   * Create internal contract by default abi and address
   *
   * - [AdminControl](https://github.com/Conflux-Chain/conflux-rust/blob/master/internal_contract/contracts/AdminControl.sol)
   * - [SponsorWhitelistControl](https://github.com/Conflux-Chain/conflux-rust/blob/master/internal_contract/contracts/SponsorWhitelistControl.sol)
   * - [Staking](https://github.com/Conflux-Chain/conflux-rust/blob/master/internal_contract/contracts/Staking.sol)
   *
   * @param {"AdminControl"|"SponsorWhitelistControl"|"Staking"|"ConfluxContext"|"PoSRegister"|"CrossSpaceCall"} name - Internal contract name
   * @return {import('./contract')}
   *
   * @example
   * > conflux.InternalContract('AdminControl')
   {
    constructor: [Function: bound call],
    abi: ContractABI { * },
    address: '0x0888000000000000000000000000000000000000',
    destroy: [Function: bound call],
    getAdmin: [Function: bound call],
    setAdmin: [Function: bound call],
    'destroy(address)': [Function: bound call],
    '0x00f55d9d': [Function: bound call],
    'getAdmin(address)': [Function: bound call],
    '0x64efb22b': [Function: bound call],
    'setAdmin(address,address)': [Function: bound call],
    '0xc55b6bb7': [Function: bound call]
  }
   */
  InternalContract(name) {
    const options = INTERNAL_CONTRACTS[name];
    assert(options, `can not find internal contract named "${name}"`);
    return this.Contract(options);
  }

  /**
   * Create an token CRC20 contract with standard CRC20 abi
   *
   * @param {string} address
   * @returns  {import('./contract')} A token contract instance
   */
  CRC20(address) {
    return this.Contract({ address, abi: CRC20_ABI });
  }

  /**
   * Return a BatchRequester instance which can used to build batch request and decode response data
   * @returns {import('./rpc/BatchRequester')} - A BatchRequester instance
   */
  BatchRequest() {
    return new BatchRequester(this);
  }

  /**
   * close connection.
   *
   * @example
   * > conflux.close();
   */
  close() {
    this.provider.close();
  }

  // --------------------------------------------------------------------------
  /**
   * Update conflux networkId from RPC
   */
  async updateNetworkId() {
    const { networkId } = await this.getStatus();
    this.networkId = networkId;
    this.wallet.setNetworkId(this.networkId);
  }

  /**
   * Get node client version
   * @return {Promise<string>}
   */
  async getClientVersion() {
    return this.cfx.clientVersion();
  }

  /**
   * Get supply info
   *
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<import('./rpc/types/formatter').SupplyInfo>} Return supply info
   * - totalIssued `BigInt`: Total issued balance in `Drip`
   * - totalStaking `BigInt`: Total staking balance in `Drip`
   * - totalCollateral `BigInt`: Total collateral balance in `Drip`
   *
   * @example
   * > await conflux.getSupplyInfo()
   {
     totalCirculating: 28953062500000000000000n,
     totalCollateral: 28953062500000000000000n,
     totalIssued: 5033319899279074765657343554n,
     totalStaking: 25026010834970490328077641n
   }
   */
  async getSupplyInfo(epochNumber) {
    return this.cfx.getSupplyInfo(epochNumber);
  }

  /**
   * Get status
   * @return {Promise<import('./rpc/types/formatter').ChainStatus>} Status information object
   * - chainId `number`: Chain id
   * - epochNumber `number`: Epoch number
   * - blockNumber `number`: Block number
   * - pendingTxNumber `number`: Pending transaction number
   * - bestHash `string`: The block hash of best pivot block
   *
   * @example
   * > await conflux.getStatus()
   {
      chainId: 1029,
      networkId: 1029,
      epochNumber: 1117476,
      blockNumber: 2230973,
      pendingTxNumber: 4531,
      bestHash: '0x8d581f13fa0548f2751450a7dabd871777875c9ccdf0d8bd629e07a7a5a7917a'
   }
   */
  async getStatus() {
    return this.cfx.getStatus();
  }

  /**
   * Returns the current price per gas in Drip.
   *
   * @return {Promise<BigInt>} Gas price in drip.
   *
   * @example
   * > await conflux.getGasPrice();
   1n
   */
  async getGasPrice() {
    return this.cfx.gasPrice();
  }

  /**
   * Returns the interest rate of given parameter.
   *
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<BigInt>} The interest rate of given parameter.
   *
   * @example
   * > await conflux.getInterestRate();
   2522880000000n
   */
  async getInterestRate(epochNumber) {
    return this.cfx.getInterestRate(epochNumber);
  }

  /**
   * Returns the accumulate interest rate of given parameter.
   *
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<BigInt>} The accumulate interest rate of given parameter.
   *
   * @example
   * > await conflux.getAccumulateInterestRate()
   76357297457647044505744908994993n
   */
  async getAccumulateInterestRate(epochNumber) {
    return this.cfx.getAccumulateInterestRate(epochNumber);
  }

  // ------------------------------- address ----------------------------------
  /**
   * Return account related states of the given account
   *
   * @param {string} address - address to get account.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<import('./rpc/types/Account')>} Return the states of the given account:
   * - balance `BigInt`: the balance of the account.
   * - nonce `BigInt`: the nonce of the account's next transaction.
   * - codeHash `string`: the code hash of the account.
   * - stakingBalance `BigInt`: the staking balance of the account.
   * - collateralForStorage `BigInt`: the collateral storage of the account.
   * - accumulatedInterestReturn `BigInt`: accumulated unterest return of the account.
   * - admin `string`: admin of the account.
   *
   * @example
   > await conflux.getAccount('cfxtest:aasb661u2r60uzn5h0c4h63hj76wtgf552r9ghu7a4');
   {
      accumulatedInterestReturn: 0n,
      balance: 824812401057514588670n,
      collateralForStorage: 174187500000000000000n,
      nonce: 1449n,
      stakingBalance: 0n,
      admin: 'CFXTEST:TYPE.NULL:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6F0VRCSW',
      codeHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
   }
   */
  async getAccount(address, epochNumber) {
    return this.cfx.getAccount(address, epochNumber);
  }

  /**
   * Returns the balance of the account of given address.
   *
   * @param {string} address - The address to get the balance of.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<BigInt>} The balance in Drip.
   *
   * @example
   * > await conflux.getBalance("cfxtest:aasb661u2r60uzn5h0c4h63hj76wtgf552r9ghu7a4");
   824812401057514588670n
   */
  async getBalance(address, epochNumber) {
    return this.cfx.getBalance(address, epochNumber);
  }

  /**
   * Returns the balance of the staking account of given address.
   *
   * @param {string} address - Address to check for staking balance.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<BigInt>} The staking balance in Drip.
   *
   * @example
   * > await conflux.getStakingBalance('cfxtest:aasb661u2r60uzn5h0c4h63hj76wtgf552r9ghu7a4', 'latest_state');
   0n
   */
  async getStakingBalance(address, epochNumber) {
    return this.cfx.getStakingBalance(address, epochNumber);
  }

  /**
   * Returns the next nonce should be used by given address.
   *
   * @param {string} address - The address to get the numbers of transactions from.
   * @param {string|number} [epochNumber] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<BigInt>} The next nonce should be used by given address.
   *
   * @example
   * > await conflux.getNextNonce("cfxtest:aasb661u2r60uzn5h0c4h63hj76wtgf552r9ghu7a4");
   1449n
   */
  async getNextNonce(address, epochNumber) {
    return this.cfx.getNextNonce(address, epochNumber);
  }

  /**
   * Returns the admin of given contract.
   *
   * @param {string} address - Address to contract.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<string>} Address to admin, or `null` if the contract does not exist.
   *
   * @example
   * > conflux.getAdmin('cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw')
   "CFXTEST:TYPE.USER:AASB661U2R60UZN5H0C4H63HJ76WTGF552R9GHU7A4"
   */
  async getAdmin(address, epochNumber) {
    return this.cfx.getAdmin(address, epochNumber);
  }

  /**
   * Returns vote list of the given account.
   *
   * @param {string} address - Address to contract.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<object[]>} Vote list
   * - `array`:
   *   - amount `BigInt`: This is the number of tokens should be locked before
   *   - unlockBlockNumber `number`: This is the timestamp when the vote right will be invalid, measured in, the number of past blocks.
   */
  async getVoteList(address, epochNumber) {
    return this.cfx.getVoteList(address, epochNumber);
  }

  /**
   * Returns deposit list of the given account.
   * @param {string} address - Address to contract.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<object[]>} Deposit list
   * - `array`:
   *   - amount `BigInt`: the number of tokens deposited
   *   - accumulatedInterestRate: `BigInt`: the accumulated interest rate at the time of the deposit
   *   - depositTime `number`: the time of the deposit
   */
  async getDepositList(address, epochNumber) {
    return this.cfx.getDepositList(address, epochNumber);
  }

  // -------------------------------- epoch -----------------------------------
  /**
   * Returns the epoch number of given parameter.
   *
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<number>} integer of the current epoch number of given parameter.
   *
   * @example
   * > await conflux.getEpochNumber();
   443
   */
  async getEpochNumber(epochNumber) {
    return this.cfx.epochNumber(epochNumber);
  }

  /**
   * Returns information about a block by epoch number.
   *
   * @param {string|number} epochNumber - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @param {boolean} [detail=false] - If `true` it returns the full transaction objects, if `false` only the hashes of the transactions.
   * @return {Promise<import('./rpc/types/formatter').Block|null>} See `getBlockByHash`
   *
   * @example
   * > await conflux.getBlockByEpochNumber('latest_mined', true);
   {...}
   */
  async getBlockByEpochNumber(epochNumber, detail = false) {
    return this.cfx.getBlockByEpochNumber(epochNumber, detail);
  }

  /**
   * Returns information about a block by block number.
   *
   * @param {string|number} blockNumber
   * @param {boolean} [detail=false] - If `true` it returns the full transaction objects, if `false` only the hashes of the transactions.
   * @return {Promise<import('./rpc/types/formatter').Block|null>} See `getBlockByHash`
   *
   * @example
   * > await conflux.getBlockByBlockNumber('0x123', true);
   {...}
   */
  async getBlockByBlockNumber(blockNumber, detail = false) {
    return this.cfx.getBlockByBlockNumber(blockNumber, detail);
  }

  /**
   * Returns hashes of blocks located in some epoch.
   *
   * @param {string|number} epochNumber - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<string[]>} Array of block hashes, sorted by execution(topological) order.
   *
   * @example
   * > await conflux.getBlocksByEpochNumber(0);
   ['0xe677ae5206a5d67d9efa183d867b4b986ed82a3e62174a1488cf8364d58534ec']
   */
  async getBlocksByEpochNumber(epochNumber) {
    return this.cfx.getBlocksByEpoch(epochNumber);
  }

  /**
   * Get epoch blocks reward info
   *
   * @private
   * @param {string|number} epochNumber - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<import('./rpc/types/formatter').RewardInfo[]>} List of block reward info
   * - blockHash `string`: Hash of the block.
   * - author `string`: The address of the beneficiary to whom the mining rewards were given.
   * - baseReward `BigInt`: Block base reward in `Drip`
   * - totalReward `BigInt`: Block total reward in `Drip`
   * - txFee `BigInt`: Total gas fee of block transaction
   *
   * @example
   * > await conflux.getBlockRewardInfo(6);
   [
   {
      baseReward: 6993700000000000000n,
      totalReward: 6993700031741486703n,
      txFee: 0n,
      author: 'CFXTEST:TYPE.USER:AATXETSP0KDARPDB5STDYEX11DR3X6SB0J2XZETSG6',
      blockHash: '0x73cd891aea310e2c0b8644de91746c7353cebfffb780126bc06101b20689c893'
    },
   {
      baseReward: 6997200000000000000n,
      totalReward: 6997200031760371742n,
      txFee: 3000000n,
      author: 'CFXTEST:TYPE.USER:AATXETSP0KDARPDB5STDYEX11DR3X6SB0J2XZETSG6',
      blockHash: '0xaf4136d04e9e2cc470703251ec46f5913ab7955d526feed43771705e89c77390'
    }
   ]
   */
  async getBlockRewardInfo(epochNumber) {
    return this.cfx.getBlockRewardInfo(epochNumber);
  }

  // -------------------------------- block -----------------------------------
  /**
   * Returns the hash of best block.
   *
   * @return {Promise<string>} hash of the best block.
   *
   * @example
   * > await conflux.getBestBlockHash();
   "0xb8bb355bfeaf055a032d5b7df719917c090ee4fb6fee42383004dfe8911d7daf"
   */
  async getBestBlockHash() {
    return this.cfx.getBestBlockHash();
  }

  /**
   * Returns information about a block by hash.
   *
   * @param {string} blockHash - hash of a block.
   * @param {boolean} [detail=false] - If `true` it returns the full transaction objects, if `false` only the hashes of the transactions.
   * @return {Promise<import('./rpc/types/formatter').Block|null>} A block object, or null when no block was found:
   * - adaptive `boolean`: If `true` the weight of the block is adaptive under GHAST rule, if `false` otherwise.
   * - blame `number`: If 0, then no blocks are blamed on its parent path, If greater than 0, then the nearest blamed block on the parent path is blame steps away.
   * - deferredLogsBloomHash `string`: The bloom hash of deferred logs.
   * - deferredReceiptsRoot `string`: The hash of the receipts of the block after deferred execution.
   * - deferredStateRoot `string`: The root of the final state trie of the block after deferred execution.
   * - difficulty `string`: Integer string of the difficulty for this block.
   * - epochNumber `number|null`: The current block epoch number in the client's view. null when it's not in best block's past set and the epoch number is not determined.
   * - gasLimit `BigInt`: The maximum gas allowed in this block.
   * - hash `string|null`: Hash of the block. `null` when its pending block.
   * - height `number`: The block heights. `null` when its pending block.
   * - miner `string`: The address of the beneficiary to whom the mining rewards were given.
   * - nonce `string`: Hash of the generated proof-of-work. `null` when its pending block.
   * - parentHash `string`: Hash of the parent block.
   * - powQuality `string`:Hash of the generated proof-of-work. `null` when its pending block.
   * - refereeHashes `string[]`: Array of referee hashes.
   * - size `number`: Integer the size of this block in bytes.
   * - timestamp `number`: The unix timestamp for when the block was collated.
   * - transactions `string[]|object[]`: Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter.
   * - transactionsRoot `string`: The hash of the transactions of the block.
   *
   * @example
   * > await conflux.getBlockByHash('0xaf4136d04e9e2cc470703251ec46f5913ab7955d526feed43771705e89c77390');
   {
      epochNumber: 6,
      blame: 0,
      height: 6,
      size: 352,
      timestamp: 1603901780,
      gasLimit: 30000000n,
      gasUsed: 61118n,
      difficulty: 20000000000n,
      transactions: [
        '0xaad69c8c814aec3e418b68f60917c607920a531e7082dd2c642323b43ecadb94',
        '0xbf7110474779ba2404433ef39a24cb5b277186ef1e6cb199b0b60907b029a1ce'
      ],
      adaptive: false,
      deferredLogsBloomHash: '0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5',
      deferredReceiptsRoot: '0x09f8709ea9f344a810811a373b30861568f5686e649d6177fd92ea2db7477508',
      deferredStateRoot: '0x50c0fcbc5bafa7d1dba7b19c87629830106a6be8d0adf505cdc656bb43535d69',
      hash: '0xaf4136d04e9e2cc470703251ec46f5913ab7955d526feed43771705e89c77390',
      miner: 'CFXTEST:TYPE.USER:AATXETSP0KDARPDB5STDYEX11DR3X6SB0J2XZETSG6',
      nonce: '0x17d86f2f6',
      parentHash: '0xc8a412b4b77b48d61f694975f032d109f26bb0f9fc02e4b221d67a382fab386b',
      powQuality: '0x5a0f86a6f4',
      refereeHashes: [
        '0x73cd891aea310e2c0b8644de91746c7353cebfffb780126bc06101b20689c893'
      ],
      transactionsRoot: '0xd2f08676484ba2a3738194f44542eb29fb290b8ed74bf007f132fe51d89b2e7c'
    }
   */
  async getBlockByHash(blockHash, detail = false) {
    return this.cfx.getBlockByHash(blockHash, detail);
  }

  /**
   * Get block by `blockHash` if pivot block of `epochNumber` is `pivotBlockHash`.
   *
   * @private
   * @param {string} blockHash - Block hash which epochNumber expect to be `epochNumber`.
   * @param {string} pivotBlockHash - Block hash which expect to be the pivot block of `epochNumber`.
   * @param {number} epochNumber - Epoch number
   * @return {Promise<import('./rpc/types/formatter').Block|null>} See `getBlockByHash`
   */
  async getBlockByHashWithPivotAssumption(blockHash, pivotBlockHash, epochNumber) {
    return this.cfx.getBlockByHashWithPivotAssumption(blockHash, pivotBlockHash, epochNumber);
  }

  /**
   * Get the risk of the block could be reverted.
   * All block in one same epoch returned same risk number
   *
   * @param {string} blockHash - Hash of a block
   * @return {Promise<number|null>} Number >0 and <1
   *
   * @example
   * > await conflux.getConfirmationRiskByHash('0xaf4136d04e9e2cc470703251ec46f5913ab7955d526feed43771705e89c77390')
   1e-8
   */
  async getConfirmationRiskByHash(blockHash) {
    return this.cfx.getConfirmationRiskByHash(blockHash);
  }

  // ----------------------------- transaction --------------------------------
  /**
   * Returns the information about a transaction requested by transaction hash.
   *
   * @param {string} transactionHash - hash of a transaction
   * @return {Promise<import('./rpc/types/formatter').Transaction|null>} transaction object, or `null` when no transaction was found:
   * - blockHash `string`: hash of the block where this transaction was in and got executed. `null` when its pending.
   * - contractCreated `string|null`: address of created contract. `null` when it's not a contract creating transaction
   * - data `string`: the data send along with the transaction.
   * - epochHeight `number`: epoch height
   * - from `string`: address of the sender.
   * - gas `BigInt`: gas provided by the sender.
   * - gasPrice `number`: gas price provided by the sender in Drip.
   * - hash `string`: hash of the transaction.
   * - nonce `BigInt`: the number of transactions made by the sender prior to this one.
   * - r `string`: ECDSA signature r
   * - s `string`: ECDSA signature s
   * - status `number`: 0 for success, 1 for error occured, `null` when the transaction is skipped or not packed.
   * - storageLimit `BigInt`: storage limit in bytes
   * - chainId `number`: chain id
   * - to `string`: address of the receiver. null when its a contract creation transaction.
   * - transactionIndex `number`: integer of the transactions's index position in the block. `null` when its pending.
   * - v `string`: ECDSA recovery id
   * - value `BigInt`: value transferred in Drip.
   *
   * @example
   * > await conflux.getTransactionByHash('0xbf7110474779ba2404433ef39a24cb5b277186ef1e6cb199b0b60907b029a1ce');
   {
      nonce: 0n,
      gasPrice: 10n,
      gas: 200000n,
      value: 0n,
      storageLimit: 1024n,
      epochHeight: 0,
      chainId: 1029,
      v: 1,
      status: 0,
      transactionIndex: 1,
      blockHash: '0xaf4136d04e9e2cc470703251ec46f5913ab7955d526feed43771705e89c77390',
      contractCreated: null,
      data: '0xfebe49090000000000000000000000000000000000000000000000000000000000000000000000000000000000000000162788589c8e386863f217faef78840919fb2854',
      from: 'CFXTEST:TYPE.USER:AATXETSP0KDARPDB5STDYEX11DR3X6SB0J2XZETSG6',
      hash: '0xbf7110474779ba2404433ef39a24cb5b277186ef1e6cb199b0b60907b029a1ce',
      r: '0x495da01ae9f445847022a8bc7df0198577ba75f88b26699f61afb435bb9c50bc',
      s: '0x2291051b1c53db1d6bfe2fb29be1bf512d063e726dc6b98aaf0f2259b7456be0',
      to: 'CFXTEST:TYPE.USER:AATXETSP0KDARPDB5STDYEX11DR3X6SB0J2XZETSG6'
    }
   */
  async getTransactionByHash(transactionHash) {
    return this.cfx.getTransactionByHash(transactionHash);
  }

  /**
   * Returns the information about a transaction receipt requested by transaction hash.
   *
   * @param {string} transactionHash - Hash of a transaction
   * @return {Promise<import('./rpc/types/formatter').TransactionReceipt|null>} A transaction receipt object, or null when no transaction was found or the transaction was not executed yet:
   * - transactionHash `string`: Hash of the given transaction.
   * - index `number`: Transaction index within the block.
   * - blockHash `string`: Hash of the block where this transaction was in and got executed.
   * - epochNumber `number`: Epoch number of the block where this transaction was in and got executed.
   * - from `string`: Address of the sender.
   * - to `string`: Address of the receiver. `null` when its a contract creation transaction.
   * - gasUsed `number`: Gas used the transaction.
   * - contractCreated `string|null`: Address of created contract. `null` when it's not a contract creating transaction.
   * - stateRoot `string`: Hash of the state root.
   * - outcomeStatus `number`:  the outcome status code, 0 was successful, 1 for an error occurred in the execution.
   * - logsBloom `string`: Bloom filter for light clients to quickly retrieve related logs.
   * - logs `object[]`: Array of log objects, which this transaction generated.
   * - gasCoveredBySponsor `boolean`: `true` if this transaction's gas fee was covered by the sponsor.
   * - storageCoveredBySponsor `boolean`: `true` if this transaction's storage collateral was covered by the sponsor.
   * - storageCollateralized `BigInt`: the amount of storage collateral this transaction required.
   * - storageReleased `array`: array of storage change objects, each specifying an address and the corresponding amount of storage collateral released
   *   - address `string`: address released
   *   - collaterals `BigInt`: corresponding amount of storage collateral released
   *
   * @example
   * > await conflux.getTransactionReceipt('0xbf7110474779ba2404433ef39a24cb5b277186ef1e6cb199b0b60907b029a1ce');
   {
      index: 1,
      epochNumber: 6,
      outcomeStatus: 0,
      gasUsed: 30559n,
      gasFee: 1500000n,
      blockHash: '0xaf4136d04e9e2cc470703251ec46f5913ab7955d526feed43771705e89c77390',
      contractCreated: null,
      from: 'CFXTEST:TYPE.USER:AAJJ1C2XGRKDY8RPG2828UPAN4A5BBSZNYB28K0PHS',
      logs: [],
      logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
      stateRoot: '0xd6a7c2c14cb0d1233010acca98e114db5a10e0b94803d23b01a6777b7fd3b2fd',
      to: 'CFXTEST:TYPE.CONTRACT:ACB59FK6VRYH8DJ5VYVEHJ9APZHPD72RDP2FVP77R9',
      transactionHash: '0xbf7110474779ba2404433ef39a24cb5b277186ef1e6cb199b0b60907b029a1ce',
      txExecErrorMsg: null,
      gasCoveredBySponsor: false,
      storageCoveredBySponsor: false,
      storageCollateralized: 0n,
      storageReleased: [
        address: '0x0000000000000000000000000000000000000001',
        collaterals: 640n,
      ],
    }
   */
  async getTransactionReceipt(transactionHash) {
    return this.cfx.getTransactionReceipt(transactionHash);
  }

  /**
   * Creates new message call transaction or a contract creation for signed transactions.
   *
   * @param {string|Buffer} hex - The signed transaction data.
   * @return {Promise<import('./subscribe/PendingTransaction')>} The transaction hash, or the zero hash if the transaction is not yet available.
   *
   * @example
   * > await conflux.sendRawTransaction('0xf85f800382520894bbd9e9b...');
   "0xbe007c3eca92d01f3917f33ae983f40681182cf618defe75f490a65aac016914"
   */
  async sendRawTransaction(hex) {
    return this.request({
      method: 'cfx_sendRawTransaction',
      params: [format.hex(hex)],
    });
  }

  /**
   * Sign and send transaction
   * if `from` field in `conflux.wallet`, sign by local account and send raw transaction,
   * else call `cfx_sendTransaction` and sign by remote wallet
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @param {string} [password] - Password for remote node.
   * @return {Promise<import('./subscribe/PendingTransaction')>} The PendingTransaction object.
   *
   * @example
   * > txHash = await conflux.sendTransaction({from:account, to:address, value:0}); // send and get transaction hash
   "0xb2ba6cca35f0af99a9601d09ee19c1949d8130312550e3f5413c520c6d828f88"

   * @example
   * > packedTx = await conflux.sendTransaction({from:account, to:address, value:0}).get(); // await till transaction packed
   {
    "nonce": 8n,
    "value": 0n,
    "gasPrice": 1000000000n,
    "gas": 21000n,
    "v": 0,
    "transactionIndex": null,
    "status": null,
    "storageLimit": 0n,
    "chainId": 1,
    "epochHeight": 791394,
    "blockHash": null,
    "contractCreated": null,
    "data": "0x",
    "from": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76",
    "hash": "0xb2ba6cca35f0af99a9601d09ee19c1949d8130312550e3f5413c520c6d828f88",
    "r": "0x245a1a86ae405eb72c1eaf98f5e22baa326fcf8262abad2c4a3e5bdcf2e912b5",
    "s": "0x4df8058887a4dd8aaf60208accb3e57292a50ff06a117df6e54f7f56176248c0",
    "to": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76"
   }

   * @example
   * > minedTx = await conflux.sendTransaction({from:account, to:address, value:0}).mined(); // await till transaction mined
   {
    "nonce": 8n,
    "value": 0n,
    "gasPrice": 1000000000n,
    "gas": 21000n,
    "v": 0,
    "transactionIndex": 0,
    "status": 0,
    "storageLimit": 0n,
    "chainId": 1,
    "epochHeight": 791394,
    "blockHash": "0xdb2d2d438dcdee8d61c6f495bd363b1afb68cb0fdff16582c08450a9ca487852",
    "contractCreated": null,
    "data": "0x",
    "from": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76",
    "hash": "0xb2ba6cca35f0af99a9601d09ee19c1949d8130312550e3f5413c520c6d828f88",
    "r": "0x245a1a86ae405eb72c1eaf98f5e22baa326fcf8262abad2c4a3e5bdcf2e912b5",
    "s": "0x4df8058887a4dd8aaf60208accb3e57292a50ff06a117df6e54f7f56176248c0",
    "to": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76"
   }

   * @example
   * > executedReceipt = await conflux.sendTransaction({from:account, to:address, value:0}).executed(); // await till transaction executed
   {
    "index": 0,
    "epochNumber": 791402,
    "outcomeStatus": 0,
    "gasUsed": 21000n,
    "gasFee": 21000000000000n,
    "blockHash": "0xdb2d2d438dcdee8d61c6f495bd363b1afb68cb0fdff16582c08450a9ca487852",
    "contractCreated": null,
    "from": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76",
    "logs": [],
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "stateRoot": "0x510d680cdbf60d34bcd987b3bf9925449c0839a7381dc8fd8222d2c7ee96122d",
    "to": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76",
    "transactionHash": "0xb2ba6cca35f0af99a9601d09ee19c1949d8130312550e3f5413c520c6d828f88"
   }

   * @example
   * > confirmedReceipt = await conflux.sendTransaction({from:account, to:address, value:0}).confirmed(); // await till risk coefficient < threshold (default 1e-8)
   {
    "index": 0,
    "epochNumber": 791402,
    "outcomeStatus": 0,
    "gasUsed": 21000n,
    "gasFee": 21000000000000n,
    "blockHash": "0xdb2d2d438dcdee8d61c6f495bd363b1afb68cb0fdff16582c08450a9ca487852",
    "contractCreated": null,
    "from": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76",
    "logs": [],
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "stateRoot": "0x510d680cdbf60d34bcd987b3bf9925449c0839a7381dc8fd8222d2c7ee96122d",
    "to": "CFXTEST:TYPE.USER:AAR7X4R8MKRNW39GGS8RZ40J1ZNWH5MRRPUFPR2U76",
    "transactionHash": "0xb2ba6cca35f0af99a9601d09ee19c1949d8130312550e3f5413c520c6d828f88"
   }
   */
  async sendTransaction(options, ...extra) {
    if (this.wallet.has(`${options.from}`)) {
      const rawTx = await this.cfx.populateAndSignTransaction(options);
      return this.sendRawTransaction(rawTx);
    }

    return this.request({
      method: 'cfx_sendTransaction',
      params: [
        this._formatCallTx(options),
        ...extra,
      ],
    });
  }

  // ------------------------------ contract ----------------------------------
  /**
   * Returns the code of given contract.
   *
   * @param {string} address - Address to contract.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<string>} Byte code of contract, or 0x if the contract does not exist.
   *
   * @example
   * > await conflux.getCode('cfxtest:acb2nsctbanb9ezbw0mx1gapve60thyurjmxkage0f');
   "0x6080604052348015600f57600080fd5b506004361060325760003560e01c806306661abd1460375780638..."
   */
  async getCode(address, epochNumber) {
    return this.cfx.getCode(address, epochNumber);
  }

  /**
   * Returns storage entries from a given contract.
   *
   * @param {string} address - Address to contract.
   * @param {string} position - The given position.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<string|null>} Storage entry of given query, or null if the it does not exist.
   *
   * @example
   * > await conflux.getStorageAt('cfxtest:acdgzwyh9634bnuf4jne0tp3xmae80bwej1w4hr66c', '0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9')
   "0x000000000000000000000000000000000000000000000000000000000000162e"
   */
  async getStorageAt(address, position, epochNumber) {
    return this.cfx.getStorageAt(address, position, epochNumber);
  }

  /**
   * Returns the storage root of a given contract.
   *
   * @param {string} address - Address to contract.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<object>} A storage root object, or `null` if the contract does not exist
   * - delta `string`: storage root in the delta trie.
   * - intermediate `string`: storage root in the intermediate trie.
   * - snapshot `string`: storage root in the snapshot.
   *
   * @example
   * > await conflux.getStorageRoot('cfxtest:acdgzwyh9634bnuf4jne0tp3xmae80bwej1w4hr66c')
   {
      "delta": "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
      "intermediate": "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
      "snapshot": "0x7bb7d43152e56f529fbef709aab7371b0672f2332ae0fb4786da350f664df5b4"
   }
   */
  async getStorageRoot(address, epochNumber) {
    return this.cfx.getStorageRoot(address, epochNumber);
  }

  /**
   * Returns the sponsor info of given contract.
   *
   * @param {string} address - Address to contract.
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<import('./rpc/types/formatter').SponsorInfo>} A sponsor info object, if the contract doesn't have a sponsor, then the all fields in returned object will be 0:
   * - sponsorBalanceForCollateral `BigInt`: the sponsored balance for storage.
   * - sponsorBalanceForGas `BigInt`: the sponsored balance for gas.
   * - sponsorGasBound `BigInt`: the max gas could be sponsored for one transaction.
   * - sponsorForCollateral `string`: the address of the storage sponsor.
   * - sponsorForGas `string`: the address of the gas sponsor.
   *
   * @example
   * > await conflux.getSponsorInfo('cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw')
   {
      sponsorBalanceForCollateral: 410625000000000000000n,
      sponsorBalanceForGas: 9999999993626232440n,
      sponsorGasBound: 10000000000n,
      sponsorForCollateral: 'CFXTEST:TYPE.CONTRACT:ACGZZ08M8Z2YWKEDA0JZU52FGAZ9U95Y1YV785YANX',
      sponsorForGas: 'CFXTEST:TYPE.CONTRACT:ACGZZ08M8Z2YWKEDA0JZU52FGAZ9U95Y1YV785YANX'
   }
   */
  async getSponsorInfo(address, epochNumber) {
    return this.cfx.getSponsorInfo(address, epochNumber);
  }

  /**
   * Return pending info of an account
   *
   * @param {string} address - Address to account
   * @returns {Promise<object>} An account pending info object.
   * - localNonce `BigInt`: then next nonce can use in the transaction pool
   * - nextPendingTx `string`: the hash of next pending transaction
   * - pendingCount `BigInt`: the count of pending transactions
   * - pendingNonce `BigInt`: the nonce of pending transaction
   *
   */
  async getAccountPendingInfo(address) {
    return this.cfx.getAccountPendingInfo(address);
  }

  /**
   * Return pending transactions of one account
   *
   * @param {string} address - base32 address
   * @returns {Promise<object>} An account's pending transactions and info.
   * - pendingTransactions `Array`: pending transactions
   * - firstTxStatus `Object`: the status of first pending tx
   * - pendingCount `BigInt`: the count of pending transactions
   */
  async getAccountPendingTransactions(address, startNonce, limit) {
    return this.cfx.getAccountPendingTransactions(address, startNonce, limit);
  }

  /**
   * Returns the size of the collateral storage of given address, in Byte.
   *
   * @param {string} address - Address to check for collateral storage.
   * @param [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<BigInt>} - The collateral storage in Byte.
   *
   * @example
   * > await conflux.getCollateralForStorage('cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw')
   89375000000000000000n
   */
  async getCollateralForStorage(address, epochNumber) {
    return this.cfx.getCollateralForStorage(address, epochNumber);
  }

  /**
   * Virtually call a contract, return the output data.
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<string>} The output data.
   */
  async call(options, epochNumber) {
    try {
      return await this.request({
        method: 'cfx_call',
        params: [
          this._formatCallTx(options),
          format.epochNumber.$or(undefined)(epochNumber),
        ],
      });
    } catch (e) {
      throw Contract.decodeError(e);
    }
  }

  /**
   * Virtually call a contract, return the estimate gas used and storage collateralized.
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber)
   * @return {Promise<import('./rpc/types/formatter').EstimateResult>} A estimate result object:
   * - `BigInt` gasUsed: The gas used.
   * - `BigInt` gasLimit: The gas limit.
   * - `BigInt` storageCollateralized: The storage collateralized in Byte.
   */
  async estimateGasAndCollateral(options, epochNumber) {
    try {
      const result = await this.request({
        method: 'cfx_estimateGasAndCollateral',
        params: [
          this._formatCallTx(options),
          format.epochNumber.$or(undefined)(epochNumber),
        ],
      });
      return cfxFormat.estimate(result);
    } catch (e) {
      throw Contract.decodeError(e);
    }
  }

  /**
   * Estimate a transaction's gas and storageCollateralize, check whether user's balance is enough for fee and value
   * @param {object} options - See [estimateGasAndCollateral](#Conflux.js/Conflux/estimateGasAndCollateral)
   * @param {string|number} [epochNumber='latest_state'] - See [estimateGasAndCollateral](#Conflux.js/Conflux/estimateGasAndCollateral)
   * @return {Promise<object>} A estimate result with advance info object:
   * - `BigInt` gasUsed: The gas used.
   * - `BigInt` gasLimit: The gas limit.
   * - `BigInt` storageCollateralized: The storage collateralized in Byte.
   * - `BigInt` balance: The balance of the options.from.
   * - `Boolean` isBalanceEnough: indicate balance is enough for gas and storage fee
   * - `Boolean` isBalanceEnoughForValueAndFee: indicate balance is enough for gas and storage fee plus value
   * - `Boolean` willPayCollateral: false if the transaction is eligible for storage collateral sponsorship, true otherwise
   * - `Boolean` willPayTxFee: false if the transaction is eligible for gas sponsorship, true otherwise
   */
  async estimateGasAndCollateralAdvance(options, epochNumber) {
    return this.cfx.estimateGasAndCollateralAdvance(options, epochNumber);
  }

  /**
   * Check whether transaction sender's balance is enough for gas and storage fee
   * @param {string} from - sender address
   * @param {string} to - target address
   * @param {string|number} gas - gas limit (in drip)
   * @param {string|number} gasPrice - gas price (in drip)
   * @param {string|number} storageLimit - storage limit (in byte)
   * @param {string|number} [epochNumber] - optional epoch number
   * @return {Promise<object>} A check result object:
   * - `Boolean` isBalanceEnough: indicate balance is enough for gas and storage fee
   * - `Boolean` willPayCollateral: false if the transaction is eligible for storage collateral sponsorship, true otherwise
   * - `Boolean` willPayTxFee: false if the transaction is eligible for gas sponsorship, true otherwise
   */
  async checkBalanceAgainstTransaction(from, to, gas, gasPrice, storageLimit, epochNumber) {
    return this.cfx.checkBalanceAgainstTransaction(from, to, gas, gasPrice, storageLimit, epochNumber);
  }

  /**
   * Returns logs matching the filter provided.
   *
   * @param {object} [options]
   * @param {string|number} [options.fromEpoch='latest_checkpoint'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber). Search will be applied from this epoch number.
   * @param {string|number} [options.toEpoch='latest_state'] - See [format.epochNumber](utils.md#util/format.js/format/(static)epochNumber). Search will be applied up until (and including) this epoch number.
   * @param {string[]} [options.blockHashes] -  Array of up to 128 block hashes that the search will be applied to. This will override from/to epoch fields if it's not null
   * @param {string|string[]} [options.address] - Search contract addresses. If null, match all. If specified, log must be produced by one of these addresses.
   * @param {array} [options.topics] - Search topics. Logs can have 4 topics: the function signature and up to 3 indexed event arguments. The elements of topics match the corresponding log topics. Example: ["0xA", null, ["0xB", "0xC"], null] matches logs with "0xA" as the 1st topic AND ("0xB" OR "0xC") as the 3rd topic. If null, match all.
   * @param {number} [options.limit] - Return the last limit logs
   * @return {Promise<import('./rpc/types/formatter').Log[]>} Array of log, that the logs matching the filter provided:
   * - address `string`: Address this event originated from.
   * - topics `string[]`: Array of topics.
   * - data `string`: The data containing non-indexed log parameter.
   * - blockHash `string`: Hash of the block where the log in.
   * - epochNumber `number`: Epoch number of the block where the log in.
   * - transactionHash `string`: Hash of the transaction where the log in.
   * - transactionIndex `string`: Transaction index in the block.
   * - logIndex `number`: Log index in block.
   * - transactionLogIndex `number`: Log index in transaction.
   *
   * @example
   * > await conflux.getLogs({
      address: 'cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw',
      fromEpoch: 39802,
      toEpoch: 39802,
      limit: 1,
      topics: ['0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d'],
    });
   [
   {
      epochNumber: 39802,
      logIndex: 2,
      transactionIndex: 0,
      transactionLogIndex: 2,
      address: 'CFXTEST:TYPE.CONTRACT:ACHC8NXJ7R451C223M18W2DWJNMHKD6RXA2GC31EUW',
      blockHash: '0xca00158a2a508170278d5bdc5ca258b6698306dd8c30fdba32266222c79e57e6',
      data: '0x',
      topics: [
        '0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d',
        '0x0000000000000000000000000000000000000000000000000000000000000000',
        '0x0000000000000000000000001c1e72f0c37968557b3d85a3f32747792798bbde',
        '0x0000000000000000000000001c1e72f0c37968557b3d85a3f32747792798bbde'
      ],
      transactionHash: '0xeb75f47002720311f1709e36d7f7e9a91ee4aaa469a1de892839cb1ef66a9939'
    }
   ]
   */
  async getLogs(options) {
    if (options.blockHashes !== undefined && (options.fromEpoch !== undefined || options.toEpoch !== undefined)) {
      throw new Error('OverrideError, do not use `blockHashes` with `fromEpoch` or `toEpoch`, cause only `blockHashes` will take effect');
    }

    const result = await this.request({ method: 'cfx_getLogs', params: [this._formatGetLogs(options)] });

    return cfxFormat.logs(result);
  }

  /**
   * Return block's execution trace.
   *
   * > Note: need RPC server open trace_block method
   *
   * @param {string}blockHash - block hash
   * @return {Promise<object[]>} Array of transaction traces.
   *
   * @example
   * > await conflux.traceBlock('0xaf0e1d773dee28c95bcfa5480ed663fcc695b32c8c1dd81f57ff61ff09f55f88')
   {
        "transactionTraces": [
            {
                "traces": [
                    {
                        "action": {
                            "callType": "call",
                            "from": "CFXTEST:TYPE.USER:AAP6SU0S2UZ36X19HSCP55SR6N42YR1YK6HX8D8SD1",
                            "gas": "311592",
                            "input": "0x",
                            "to": "CFXTEST:TYPE.CONTRACT:ACCKUCYY5FHZKNBXMEEXWTAJ3BXMEG25B2NUF6KM25",
                            "value": "0"
                        },
                        "type": "call"
                    }
                ]
            },
            {
                "traces": [
                    {
                        "action": {
                            "from": "CFXTEST:TYPE.USER:AAR75DU3V36MG4U2DHAG44B40H6K4M2ARY46G0ECMB",
                            "gas": "83962",
                            "init": "0x",
                            "value": "0"
                        },
                        "type": "create"
                    }
                ]
            }
        ]
    }
   *
   */
  async traceBlock(blockHash) {
    return this.trace.block(format.blockHash(blockHash));
  }

  /**
   * Return transaction's trace
   * @param {string} txHash - transaction hash
   * @returns {Promise<object[]>} Array of traces.
   *
   * @example
   * > await conflux.traceTransaction('0xaf0e1d773dee28c95bcfa5480ed663fcc695b32c8c1dd81f57ff61ff09f55f88')
   */
  async traceTransaction(txHash) {
    return this.trace.transaction(format.transactionHash(txHash));
  }

  /**
   * Return traces that satisfy an filter
   * @param {object} options - trace filters
   * @returns {Promise<object[]>} Array of traces.
   *
   * @example
   * > await conflux.traceFilter({
      fromEpoch: 1,
      toEpoch: 100,
      count: 100,
      after: 100,
      blockHashes: ['0xaf0e1d773dee28c95bcfa5480ed663fcc695b32c8c1dd81f57ff61ff09f55f88'],
      actionTypes: ['call_result']
    })
   */
  async traceFilter(options) {
    return this.trace.filter(format.traceFilter(options));
  }

  /**
   * Return one epoch's all receipts
   * @param {number|string} epochNumber - epoch number
   * @returns {Promise<object[][]>} Array of array receipts.
   *
   * @example
   * > await conflux.getEpochReceipts('0x6')
   */
  async getEpochReceipts(epochNumber) {
    return this.cfx.getEpochReceipts(epochNumber);
  }

  /**
   * Return one epoch's all receipts by pivot block hash
   * @param {string} pivotBlockHash - epoch pivot block hash
   * @returns {Promise<object[][]>} Array of array receipts.
   *
   * @example
   * > await conflux.getEpochReceiptsByPivotBlockHash('0x12291776d632d966896b6c580f3201cd2e2a3fd672378fc7965aa7f7058282b2')
   */
  async getEpochReceiptsByPivotBlockHash(pivotBlockHash) {
    return this.cfx.getEpochReceiptsByPivotBlockHash(pivotBlockHash);
  }

  /**
   * Return PoS summary info
   * @returns {Promise<import('./rpc/types/formatter').PoSEconomics>} PoS summary info
   * - distributablePosInterest `number`: Currently total distributable PoS interest (Drip)
   * - lastDistributeBlock `number`: Last distribute block number
   * - totalPosStakingTokens `number`: Total token amount (Drip) staked in PoS
   *
   */
  async getPoSEconomics() {
    return this.cfx.getPoSEconomics();
  }

  // ----------------------------- subscription -------------------------------
  /**
   * Subscribe event by name and got id, and provider will emit event by id
   *
   * > Note: suggest use `conflux.subscribeXXX` to subscribe
   *
   * @param {string} name - Subscription name
   * @param {array} args - Subscription arguments
   * @return {Promise<string>} Id of subscription
   *
   * @example
   * > conflux = new Conflux({url:'ws://127.0.0.1:12535'})
   * > id = await conflux.subscribe('epochs');
   "0x8fe7879a1681e9b9"
   * > conflux.provider.on(id, data=>console.log(data));
   {
     epochHashesOrdered: [
       '0x0eff33578346b8e8347af3bae948eb7f4f5c27add9dbcfeb55eaf7cb3640088f',
       '0xb0cedac34a06ebcb42c3446a6bb2df1f0dcd9d83061f550460e387d19a4d8e91'
     ],
     epochNumber: '0x8cb32'
   }
   */
  async subscribe(name, ...args) {
    return this.request({ method: 'cfx_subscribe', params: [name, ...args] });
  }

  /**
   * The epochs topic streams consensus results: the total order of blocks, as expressed by a sequence of epochs.
   * The returned series of epoch numbers is monotonically increasing with an increment of one.
   * If you see the same epoch twice, this suggests a pivot chain reorg has happened (this might happen for recent epochs).
   * For each epoch, the last hash in epochHashesOrdered is the hash of the pivot block.
   *
   * @param {string} [sub_epoch] - Available values are latest_mined(default value) and latest_state
   *
   * @return {Promise<Subscription>} EventEmitter instance with the follow events:
   * - 'data':
   *   - epochNumber `number`: epoch number
   *   - epochHashesOrdered `array`: epoch block hash in order
   *     - `string`: block hash
   *
   * @example
   * > subscription = await conflux.subscribeEpochs()
   * > subscription.on('data', data=>console.log(data))
   {
     epochNumber: 566031,
     epochHashesOrdered: [
       '0x2820dbb5c4126455ad37bc88c635ae1f35e0d4f85c74300c01828f57ea1e5969',
       '0xd66b801335ba01e2448df52e59da584b54fc7ee7c2f8160943c097e1ebd23038'
     ]
    }
   {
     epochNumber: 566032,
     epochHashesOrdered: [
       '0x899606b462f0141d672aaea8497c82aebbd7b16d266fad71e9d5093b5c6d392e',
       '0xf6093d19c4df3645cd972e9f791fe0db3a1ab70881023a8aee63f64e0c3ca152'
     ]
   }
   */
  async subscribeEpochs(sub_epoch = CONST.EPOCH_NUMBER.LATEST_MINED) {
    const id = await this.subscribe('epochs', sub_epoch);
    const subscription = new Subscription(id);

    this.provider.on(id, data => {
      subscription.emit('data', cfxFormat.epoch(data));
    });

    return subscription;
  }

  /**
   * The newHeads topic streams all new block headers participating in the consensus.
   *
   * @return {Promise<Subscription>} EventEmitter instance with the follow events:
   * - 'data': see `getBlockByHash`
   *
   * @example
   * > subscription = await conflux.subscribeNewHeads()
   * > subscription.on('data', data=>console.log(data))
   {
      difficulty: 368178587115n,
      epochNumber: null,
      gasLimit: 30000000n,
      height: 1118247,
      timestamp: 1605005752,
      adaptive: false,
      blame: 0,
      deferredLogsBloomHash: '0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5',
      deferredReceiptsRoot: '0x7ae0d5716513206755b6f7c95272b79dbc225759b6e17727e19c2f15c3166bda',
      deferredStateRoot: '0x3cf5deba77c8aa9072f1e972d6a97db487a0ce88455f371eb8ac8fa77321cb9d',
      hash: '0x194675173abbc5aab50326136008774eea1a289e6722c973dfed12b703ee5f2a',
      miner: 'CFXTEST:TYPE.USER:AAPKCJR28DG976FZR43C5HF1RWN5XV8T1U8V8JW8A4',
      nonce: '0x799d35f695950fd6',
      parentHash: '0x4af3cf8cb358e75acad282ffa4b578b6211ea9eeb7cf87c282f120d8a1c809df',
      powQuality: '0xe7ac17feab',
      refereeHashes: [],
      transactionsRoot: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
    }
   */
  async subscribeNewHeads() {
    const id = await this.subscribe('newHeads');
    const subscription = new Subscription(id);

    this.provider.on(id, data => {
      subscription.emit('data', cfxFormat.head(data));
    });

    return subscription;
  }

  /**
   * The logs topic streams all logs matching a certain filter, in order.
   * In case of a pivot chain reorg (which might affect recent logs), a special revert message is sent.
   * All logs received previously that belong to epochs larger than the one in this message should be considered invalid.
   *
   * @param {object} [options]
   * @param {string|string[]} [options.address] - Search contract addresses. If null, match all. If specified, log must be produced by one of these addresses.
   * @param {array} [options.topics] - Search topics. Logs can have 4 topics: the function signature and up to 3 indexed event arguments. The elements of topics match the corresponding log topics. Example: ["0xA", null, ["0xB", "0xC"], null] matches logs with "0xA" as the 1st topic AND ("0xB" OR "0xC") as the 3rd topic. If null, match all.
   * @return {Promise<Subscription>} EventEmitter instance with the follow events:
   * - 'data': see `getLogs`
   * - 'revert':
   *   - revertTo 'number': epoch number
   *
   * @example
   * > subscription = await conflux.subscribeLogs()
   * > subscription.on('data', data=>console.log(data))
   {
     epochNumber: 568224,
     logIndex: 0,
     transactionIndex: 0,
     transactionLogIndex: 0,
     address: 'CFXTEST:TYPE.CONTRACT:ACCS4PG151C99AZPE6RSK37R40YNEMYRSE9P475E82',
     blockHash: '0xc02689eea6a507250838463c13e6b633479e2757dfb7e9b2593d5c31b54adb63',
     data: '0x0000000000000000000000000000000000000000000000000000000000000001',
     topics: [
       '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
       '0x0000000000000000000000001bd9e9be525ab967e633bcdaeac8bd5723ed4d6b',
       '0x0000000000000000000000001bd9e9be525ab967e633bcdaeac8bd5723ed4d6b'
     ],
     transactionHash: '0x950ddec9ce3b42c4d8ca120722fa318ae64dc2e24553201f55f68c00bfd9cc4c'
   }
   * @example
   * > subscription.on('revert', data=>console.log(data))
   { revertTo: 568230 }
   { revertTo: 568231 }
   */
  async subscribeLogs({ address, topics } = {}) {
    const id = await this.subscribe('logs', this._formatGetLogs({ address, topics }));

    const subscription = new Subscription(id);
    this.provider.on(id, data => {
      if (data.revertTo) {
        subscription.emit('revert', cfxFormat.revert(data));
      } else {
        subscription.emit('data', cfxFormat.log(data));
      }
    });

    return subscription;
  }

  /**
   * Unsubscribe subscription.
   *
   * @param {string|Subscription} id - Subscription id
   * @return {Promise<boolean>} Is success
   *
   * @example
   * > id = await conflux.subscribe('epochs');
   * > await conflux.unsubscribe(id);
   true
   * > await conflux.unsubscribe(id);
   false

   * @example
   * > subscription = await conflux.subscribeLogs();
   * > await conflux.unsubscribe(subscription);
   true
   */
  async unsubscribe(id) {
    return this.request({ method: 'cfx_unsubscribe', params: [`${id}`] });
  }
}

module.exports = Conflux;


/***/ }),

/***/ 30067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const format = __webpack_require__(52519);

/**
 * Positive decimal integer string in `Drip`
 */
class Drip extends String {
  /**
   * Get `Drip` string from `CFX`
   *
   * @param {string|number} value
   * @return {Drip}
   *
   * @example
   * > Drip.fromCFX(3.14)
   [String (Drip): '3140000000000000000']
   * > Drip.fromCFX('0xab')
   [String (Drip): '171000000000000000000']
   */
  static fromCFX(value) {
    return new this(format.big(value).times(1e18).toFixed());
  }

  /**
   * Get `Drip` string from `GDrip`
   *
   * @param {string|number} value
   * @return {Drip}
   *
   * @example
   * > Drip.fromGDrip(3.14)
   [String (Drip): '3140000000']
   * > Drip.fromGDrip('0xab')
   [String (Drip): '171000000000']
   */
  static fromGDrip(value) {
    return new this(format.big(value).times(1e9).toFixed());
  }

  /**
   * @param {number|string} value
   * @return {Drip}
   *
   * @example
   * > new Drip(1.00)
   [String (Drip): '1']
   * > new Drip('0xab')
   [String (Drip): '171']
   */
  constructor(value) {
    super(format.bigUInt(value).toString(10));
  }

  /**
   * Get `CFX` number string
   * @return {string}
   *
   * @example
   * > Drip(1e9).toCFX()
   "0.000000001"
   */
  toCFX() {
    return format.big(this).div(1e18).toFixed();
  }

  /**
   * Get `GDrip` number string
   * @return {string}
   *
   * @example
   * > Drip(1e9).toGDrip()
   "1"
   */
  toGDrip() {
    return format.big(this).div(1e9).toFixed();
  }
}

module.exports = new Proxy(Drip, {
  apply(target, thisArg, argArray) {
    return new Drip(...argArray);
  },
});


/***/ }),

/***/ 95056:
/***/ ((module) => {

module.exports = {
  // Parser parse data failed
  PARSER_ERROR: 5200,
};


/***/ }),

/***/ 90282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const { keccak256, ecdsaSign, ecdsaRecover, publicKeyToAddress } = __webpack_require__(43089);
const format = __webpack_require__(52519);

/** Class provide message sign utilities. */
class Message {
  /**
   * Signs the hash with the privateKey.
   *
   * @param {string|Buffer} privateKey - Private key used to sign message
   * @param {string|Buffer} messageHash - The message hash need to be signed
   * @return {string} The signature as hex string.
   *
   * @example
   * > Message.sign(
   '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', // privateKey
   '0x592fa743889fc7f92ac2a37bb1f5ba1daf2a5c84741ca0e0061d243a2e6707ba',
   )
   "0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f01"
   */
  static sign(privateKey, messageHash) {
    const { r, s, v } = ecdsaSign(format.hexBuffer(messageHash), format.hexBuffer(privateKey));
    const buffer = Buffer.concat([r, s, format.hexBuffer(v)]);
    return format.hex(buffer);
  }

  /**
   * Recovers the signers publicKey from the signature.
   *
   * @param {string|Buffer} signature
   * @param {string|Buffer} messageHash
   * @return {string} The publicKey as hex string.
   *
   * @example
   * > Message.recover(
   '0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f01',
   '0x592fa743889fc7f92ac2a37bb1f5ba1daf2a5c84741ca0e0061d243a2e6707ba',
   )
   "0x4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559"
   */
  static recover(signature, messageHash) {
    const signatureBuffer = format.hexBuffer(signature);
    const r = signatureBuffer.slice(0, 32);
    const s = signatureBuffer.slice(32, 64);
    const v = signatureBuffer[64];
    const buffer = ecdsaRecover(format.hexBuffer(messageHash), { r, s, v });
    return format.publicKey(buffer);
  }

  /**
   * @param {string} message
   * @return {Message}
   *
   * @example
   * > msg = new Message('Hello World');
   Message {
      message: 'Hello World',
    }
   * > msg.sign('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef');
   Message {
      message: 'Hello World',
      signature: '0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f01'
    }
   * > msg.signature
   "0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f01"
   * > msg.hash
   "0x592fa743889fc7f92ac2a37bb1f5ba1daf2a5c84741ca0e0061d243a2e6707ba"
   * > msg.from
   "cfxtest:aasm4c231py7j34fghntcfkdt2nm9xv1tu6jd3r1s7"
   * > msg.r
   "0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c"
   * > msg.s
   "0x29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f"
   * > msg.v
   1
   */
  constructor(message) {
    this.message = message;
  }

  /**
   * Getter of message hash include signature.
   *
   * > Note: calculate every time.
   *
   * @return {string}
   */
  get hash() {
    return format.hex(keccak256(Buffer.from(this.message)));
  }

  /**
   * Getter of sender address.
   *
   * > Note: calculate every time.
   *
   * @return {string|undefined} If ECDSA recover success return address, else return undefined.
   */
  get from() {
    try {
      const publicKey = Message.recover(this.signature, this.hash);
      return format.address(publicKeyToAddress(format.hexBuffer(publicKey)), this.networkId);
    } catch (e) {
      return undefined;
    }
  }

  /**
   * Sign message and set 'r','s','v' and 'hash'.
   *
   * @param {string} privateKey - Private key hex string.
   * @param {number} networkId - Network id of account
   * @return {Message}
   */
  sign(privateKey, networkId) {
    this.signature = Message.sign(privateKey, this.hash);
    this.networkId = networkId;
    return this;
  }

  /**
   * Get signatures r
   * @return {string}
   */
  get r() {
    try {
      return this.signature.slice(0, 2 + 64);
    } catch (e) {
      return undefined;
    }
  }

  /**
   * Get signatures s
   * @return {string}
   */
  get s() {
    try {
      return `0x${this.signature.slice(2 + 64, 2 + 128)}`;
    } catch (e) {
      return undefined;
    }
  }

  /**
   * Get signatures v
   * @return {number}
   */
  get v() {
    try {
      return parseInt(this.signature.slice(2 + 128, 2 + 130), 16);
    } catch (e) {
      return undefined;
    }
  }
}

module.exports = Message;


/***/ }),

/***/ 85341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const PREFIX = '\x19Conflux Signed Message:\n';
const format = __webpack_require__(52519);
const Message = __webpack_require__(90282);
const { keccak256 } = __webpack_require__(43089);
const { isHexString } = __webpack_require__(61069);

class PersonalMessage extends Message {
  /**
   * Assemble the personal message
   * @param {string|Buffer} message - The origin message
   * @return {string}
   */
  static personalMessage(message) {
    const msgBuf = isHexString(message) ? format.hexBuffer(message) : Buffer.from(message);
    return PREFIX + msgBuf.length + msgBuf.toString();
  }

  /**
   * Assemble the personal message hash
   * @param {string|Buffer} message - The origin message
   * @return {string} The personal message hash
   */
  static personalHash(message) {
    const personalMsg = this.personalMessage(message);
    return format.hex(keccak256(Buffer.from(personalMsg)));
  }

  /**
   * Signs the hash with the privateKey.
   *
   * @param {string|Buffer} privateKey
   * @param {string|Buffer} message
   * @return {string} The signature as hex string.
   *
   * @example
   * > PersonalMessage.sign(
   '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', // privateKey
   'Hello world!',
   )
   "0xa2d98c5d47b35ba4ebdf03e2d9496312355dccc609bf38c93f19cc9f970e131d0e95504eb3c786714ab703f6924876704bc44bb71680802a87b4c4d2599ac96a00"
   */
  static sign(privateKey, message) {
    return super.sign(privateKey, this.personalHash(message));
  }

  /**
   * Recovers the signers publicKey from the signature.
   *
   * @param {string|Buffer} signature
   * @param {string|Buffer} message
   * @return {string} The publicKey as hex string.
   *
   * @example
   * > PersonalMessage.recover(
   '0xa2d98c5d47b35ba4ebdf03e2d9496312355dccc609bf38c93f19cc9f970e131d0e95504eb3c786714ab703f6924876704bc44bb71680802a87b4c4d2599ac96a00',
   'Hello world!',
   )
   "0x5e3eb3a2fbe124c62b382f078a1766c5b0b1306c38a496aa49e3702024a06cffe9da86ab15e4d017b6ef12794e9fe1751ce261a7b7c03be0c5b81ab9b040668a"
   */
  static recover(signature, message) {
    return super.recover(signature, this.personalHash(message));
  }

  /**
   * Recovers the wallet signers publicKey from the signature.
   *
   * @param {string} signature
   * @param {string} message
   * @return {string} The publicKey as hex string.
   *
   * @example
   > PersonalMessage.recoverPortalPersonalSign(
   '0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f01',
   '0x592fa743889fc7f92ac2a37bb1f5ba1daf2a5c84741ca0e0061d243a2e6707ba',
   )
   "0x4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559"
   *
   > PersonalMessage.recoverPortalPersonalSign(
   '0x5f8499879ce281ff083f5716de68ab6d05b176edbb27b6c5882ab482dc00478e33679f15a30bc60510faab49c2bd0bf883ad0a45ad3160e424b35cddcc1ee85d1c',
   'Hello World',
   )
   "0x41f3b66efde8121599072d1c215c88682f491c4f9e3b2345667a3f9f4adb8449b3de23832f435f4d923872ed043449ee7843a0bfc3594c46c982ab5297009f78"
   */
  static recoverPortalPersonalSign(signature, message) {
    const v = parseInt(signature.slice(130), 16) - 27;
    signature = signature.slice(0, 130) + format.hex(v).slice(2);
    const messageHex = isHexString(message) ? message : format.hex(Buffer.from(message));
    const msg = new Message(PREFIX + messageHex.length + messageHex);
    return Message.recover(signature, msg.hash);
  }

  /**
   * Assemble the personal message hash
   * @param {string|Buffer} message - The origin message
   * @return {PersonalMessage}
   */
  constructor(message) {
    const personalMessage = PersonalMessage.personalMessage(message);
    super(personalMessage);
    this._originMsg = message;
    this._personalMsg = personalMessage;
    this._prefix = PREFIX;
  }
}

module.exports = PersonalMessage;


/***/ }),

/***/ 45550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { keccak256, ecdsaSign, ecdsaRecover, privateKeyToAddress, publicKeyToAddress } = __webpack_require__(43089);
const rlp = __webpack_require__(96814);
const format = __webpack_require__(52519);
const cfxFormat = __webpack_require__(77466);

class Transaction {
  /**
   * Decode rlp encoded raw transaction hex string
   *
   * @param {string} raw - rlp encoded transaction hex string
   * @returns {Transaction} A Transaction instance
   */
  static decodeRaw(raw) {
    const [
      [nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data],
      v,
      r,
      s,
    ] = rlp.decode(raw);

    const netId = format.uInt(chainId);
    const tx = new Transaction({
      nonce: format.bigIntFromBuffer(nonce),
      gasPrice: format.bigIntFromBuffer(gasPrice),
      gas: format.bigIntFromBuffer(gas),
      to: to.length === 0 ? null : format.address(to, netId),
      value: format.bigIntFromBuffer(value),
      storageLimit: format.bigIntFromBuffer(storageLimit),
      epochHeight: format.bigIntFromBuffer(epochHeight),
      chainId: format.uInt(chainId),
      data: format.hex(data),
      v: v.length === 0 ? 0 : format.uInt(v),
      r: format.hex(r),
      s: format.hex(s),
    });

    const publicKey = tx.recover();
    const hexAddress = publicKeyToAddress(format.hexBuffer(publicKey));
    tx.from = format.address(hexAddress, netId);
    return tx;
  }

  /**
   * Create a transaction.
   *
   * @param {object} options
   * @param {string} [options.from] - The sender address.
   * @param {string|number} [options.nonce] - This allows to overwrite your own pending transactions that use the same nonce.
   * @param {string|number} [options.gasPrice] - The price of gas for this transaction in drip.
   * @param {string|number} [options.gas]- The amount of gas to use for the transaction (unused gas is refunded).
   * @param {string} [options.to] - The destination address of the message, left undefined for a contract-creation transaction.
   * @param {string|number} [options.value] - The value transferred for the transaction in drip, also the endowment if its a contract-creation transaction.
   * @param {string|number} [options.storageLimit] - The storage limit specified by the sender.
   * @param {string|number} [options.epochHeight] - The epoch proposed by the sender. Note that this is NOT the epoch of the block containing this transaction.
   * @param {string|number} [options.chainId] - The chain ID specified by the sender.
   * @param {string|Buffer} [options.data]- Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code.
   * @param {string|Buffer} [options.r] - ECDSA signature r
   * @param {string|Buffer} [options.s] - ECDSA signature s
   * @param {number} [options.v] - ECDSA recovery id
   * @return {Transaction}
   */
  constructor({ from, nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data, v, r, s }) {
    this.from = from;
    this.nonce = nonce;
    this.gasPrice = gasPrice;
    this.gas = gas;
    this.to = to;
    this.value = value;
    this.storageLimit = storageLimit;
    this.epochHeight = epochHeight;
    this.chainId = chainId;
    this.data = data;
    this.v = v;
    this.r = r;
    this.s = s;
  }

  /**
   * Getter of transaction hash include signature.
   *
   * > Note: calculate every time.
   *
   * @return {string|undefined} If transaction has r,s,v return hex string, else return undefined.
   */
  get hash() {
    try {
      return format.hex(keccak256(this.encode(true)));
    } catch (e) {
      return undefined;
    }
  }

  /**
   * Sign transaction and set 'r','s','v'.
   *
   * @param {string} privateKey - Private key hex string.
   * @param {number} networkId - fullnode's network id.
   * @return {Transaction}
   */
  sign(privateKey, networkId) {
    const privateKeyBuffer = format.hexBuffer(privateKey);
    const addressBuffer = privateKeyToAddress(privateKeyBuffer);
    const { r, s, v } = ecdsaSign(keccak256(this.encode(false)), privateKeyBuffer);

    this.from = format.address(addressBuffer, networkId);
    this.r = format.hex(r);
    this.s = format.hex(s);
    this.v = v;

    return this;
  }

  /**
   * Recover public key from signed Transaction.
   *
   * @return {string}
   */
  recover() {
    const publicKey = ecdsaRecover(keccak256(this.encode(false)), {
      r: format.hexBuffer(this.r),
      s: format.hexBuffer(this.s),
      v: format.uInt(this.v),
    });
    return format.publicKey(publicKey);
  }

  /**
   * Encode rlp.
   *
   * @param {boolean} [includeSignature=false] - Whether or not to include the signature.
   * @return {Buffer}
   */
  encode(includeSignature) {
    const { nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data, v, r, s } = cfxFormat.signTx(this);

    const raw = includeSignature
      ? [[nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data], v, r, s]
      : [nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data];

    return rlp.encode(raw);
  }

  /**
   * Get the raw transaction hex string.
   *
   * @return {string} Hex string
   */
  serialize() {
    return format.hex(this.encode(true));
  }
}

module.exports = Transaction;


/***/ }),

/***/ 2283:
/***/ ((module) => {

class ContractABI {
  constructor(contract) {
    this.contract = contract;
  }

  decodeData(data) {
    const method = this.contract[data.slice(0, 10)] || this.contract.constructor;

    const tuple = method.decodeData(data);
    if (!tuple) {
      return undefined;
    }

    return {
      name: method.name,
      fullName: method.fullName,
      type: method.type,
      signature: method.signature,
      array: [...tuple],
      object: tuple.toObject(),
    };
  }

  decodeLog(log) {
    const event = this.contract[log.topics[0]];
    if (!event) {
      return undefined;
    }

    const tuple = event.decodeLog(log);
    return {
      name: event.name,
      fullName: event.fullName,
      type: event.type,
      signature: event.signature,
      array: [...tuple],
      object: tuple.toObject(),
    };
  }
}

module.exports = ContractABI;


/***/ }),

/***/ 22954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { alignBuffer } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const BaseCoder = __webpack_require__(84349);

class AddressCoder extends BaseCoder {
  static from({ type, ...options }) {
    if (type !== 'address') {
      return undefined;
    }
    return new this({ ...options, type });
  }

  constructor({ type, ...options }) {
    super({ ...options, type });
    this.networkId = options.networkId;
  }

  /**
   * @param {string} address
   * @return {Buffer}
   */
  encode(address) {
    return alignBuffer(format.hexBuffer(format.hexAddress(address)));
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {string}
   */
  decode(stream) {
    const hexAddress = stream.read(40);
    const isConfluxAddress = hexAddress.startsWith('1') || hexAddress.startsWith('0') || hexAddress.startsWith('8');
    return (isConfluxAddress && this.networkId) ? format.address(`0x${hexAddress}`, this.networkId) : format.hexAddress(`0x${hexAddress}`);
  }
}

module.exports = AddressCoder;


/***/ }),

/***/ 34088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const lodash = __webpack_require__(76635);
const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const BaseCoder = __webpack_require__(84349);
const { uIntCoder } = __webpack_require__(8962);
const { pack, unpack } = __webpack_require__(30377);

class ArrayCoder extends BaseCoder {
  static from({ type, components, ...options }, valueCoder) {
    const match = type.match(/^(.*)\[([0-9]*)]$/);
    if (!match) {
      return undefined;
    }

    const [, subType, size] = match;
    return new this({
      ...options,
      coder: valueCoder({ type: subType, components, ...options }),
      size: size ? parseInt(size, 10) : undefined,
    });
  }

  constructor({ name, coder, size }) {
    if (size !== undefined) {
      assert(Number.isInteger(size) && 0 < size, {
        message: 'invalid size',
        expect: 'integer && >0',
        got: size,
        coder: { name },
      });
    }

    super({ name });
    this.type = `${coder.type}[${size > 0 ? size : ''}]`;
    this.size = size;
    this.coder = coder;
    this.dynamic = Boolean(size === undefined) || coder.dynamic;
  }

  /**
   * @param {array} array
   * @return {Buffer}
   */
  encode(array) {
    assert(Array.isArray(array), {
      message: 'unexpected type',
      expect: 'array',
      got: typeof array,
      coder: this,
    });

    if (this.size !== undefined) {
      assert(array.length === this.size, {
        message: 'length not match',
        expect: this.size,
        got: array.length,
        coder: this,
      });
    }

    const coders = lodash.range(array.length).map(() => this.coder);
    let buffer = pack(coders, array);
    if (this.size === undefined) {
      buffer = Buffer.concat([uIntCoder.encode(array.length), buffer]);
    }
    return buffer;
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {array}
   */
  decode(stream) {
    let length = this.size;

    if (length === undefined) {
      length = format.uInt(uIntCoder.decode(stream)); // XXX: BigInt => Number, for length is enough.
    }

    const coders = lodash.range(length).map(() => this.coder);
    return unpack(coders, stream);
  }

  encodeTopic(value) {
    try {
      return format.hex64(value);
    } catch (e) {
      // TODO https://solidity.readthedocs.io/en/v0.7.4/abi-spec.html#encoding-of-indexed-event-parameters
      throw new Error('not supported encode array to index');
    }
  }

  decodeTopic(hex) {
    return hex;
  }
}

module.exports = ArrayCoder;


/***/ }),

/***/ 84349:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const HexStream = __webpack_require__(92808);

class BaseCoder {
  static from(component) {} // eslint-disable-line no-unused-vars

  constructor({ type, name }) {
    this.type = type;
    this.name = name;
    this.dynamic = false;
  }

  /**
   * @param {*} [value]
   * @return {Buffer}
   */
  encode(value) { // eslint-disable-line no-unused-vars
    throw new Error(`${this.constructor.name}.encode not implemented`);
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {*}
   */
  decode(stream) { // eslint-disable-line no-unused-vars
    throw new Error(`${this.constructor.name}.decode not implemented`);
  }

  encodeTopic(value) {
    return this.encode(value);
  }

  decodeTopic(hex) {
    const stream = new HexStream(hex);
    return this.decode(stream);
  }
}

module.exports = BaseCoder;


/***/ }),

/***/ 23143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);
const { assert } = __webpack_require__(61069);
const JSBI = __webpack_require__(31629);
const IntegerCoder = __webpack_require__(8962);

class BoolCoder extends IntegerCoder {
  static from({ type, ...options }) {
    if (type !== 'bool') {
      return undefined;
    }
    return new this({ ...options, type });
  }

  constructor({ type, name }) {
    super({ name });
    this.type = type;
  }

  /**
   * @param {*} value
   * @return {Buffer}
   */
  encode(value) {
    assert(lodash.isBoolean(value), {
      message: 'unexpected type',
      expect: 'boolean',
      got: value,
      coder: this,
    });

    return super.encode(value ? 1 : 0);
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {boolean}
   */
  decode(stream) {
    return JSBI.notEqual(super.decode(stream), JSBI.BigInt(0));
  }
}

module.exports = BoolCoder;


/***/ }),

/***/ 98864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const { WORD_BYTES } = __webpack_require__(46057);
const { assert, alignBuffer } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const sign = __webpack_require__(43089);
const BaseCoder = __webpack_require__(84349);
const { uIntCoder } = __webpack_require__(8962);

class BytesCoder extends BaseCoder {
  static from({ type, ...options }) {
    const match = type.match(/^bytes([0-9]*)$/);
    if (!match) {
      return undefined;
    }

    const [, size] = match;
    return new this({
      ...options,
      size: size ? parseInt(size, 10) : undefined,
    });
  }

  constructor({ name, size, _decodeToHex }) {
    if (size !== undefined) {
      assert(Number.isInteger(size) && size <= WORD_BYTES, {
        message: 'invalid size',
        expect: `integer && <=${WORD_BYTES}`,
        got: size,
        coder: { name },
      });
    }

    super({ name });
    this.type = `bytes${size > 0 ? size : ''}`;
    this.size = size;
    this.dynamic = Boolean(size === undefined);
    this._decodeToHex = _decodeToHex;
  }

  /**
   * @param {any[]|string} value
   * @return {Buffer}
   */
  encode(value) {
    value = format.bytes(value);

    if (this.size !== undefined && this.size !== value.length) {
      if (value.length < this.size) {
        // if short than the expect size, auto complete it
        value = Buffer.concat([value, Buffer.alloc(this.size - value.length)]);
      } else {
        assert(false, {
          message: 'length not match',
          expect: this.size,
          got: value.length,
          coder: this,
        });
      }
    }

    let buffer = alignBuffer(value, true);
    if (this.size === undefined) {
      buffer = Buffer.concat([uIntCoder.encode(value.length), buffer]);
    }
    return buffer;
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {Buffer}
   */
  decode(stream) {
    let length = this.size;
    if (length === undefined) {
      length = format.uInt(uIntCoder.decode(stream)); // XXX: BigInt => Number, for length is enough.
    }

    if (this._decodeToHex) {
      return `0x${stream.read(length * 2, true)}`;
    }

    return Buffer.from(stream.read(length * 2, true), 'hex');
  }

  encodeTopic(value) {
    assert(Buffer.isBuffer(value), {
      message: 'value type error',
      expect: Buffer.name,
      got: value.constructor.name,
      coder: this,
    });

    return sign.keccak256(value);
  }

  decodeTopic(hex) {
    return hex;
  }
}

module.exports = BytesCoder;


/***/ }),

/***/ 8962:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { UINT_BOUND } = __webpack_require__(46057);
const { assert, alignBuffer } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const JSBI = __webpack_require__(31629);
const BaseCoder = __webpack_require__(84349);

class IntegerCoder extends BaseCoder {
  static from({ type, ...options }) {
    const match = type.match(/^(int|uint)([0-9]*)$/);
    if (!match) {
      return undefined;
    }

    const [, label, bits] = match;
    return new this({
      ...options,
      type: label,
      signed: !label.startsWith('u'),
      bits: bits ? parseInt(bits, 10) : undefined,
    });
  }

  constructor({ name, type, signed = false, bits = 256 }) {
    assert(Number.isInteger(bits) && 0 < bits && bits <= 256 && (bits % 8 === 0), {
      message: 'invalid bits',
      expect: 'integer && 0<bits<=256 && bits%8==0',
      got: bits,
      coder: { name, type, signed },
    });

    super({ name });
    this.type = `${type}${bits}`;
    this.signed = signed;
    this.size = bits / 8;
    this.bound = JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(bits - (this.signed ? 1 : 0)));
  }

  /**
   * @param {number|JSBI|string} value - FIXME: it is not a good idea to accept string as number
   * @return {Buffer}
   */
  encode(value) {
    let number = format.bigInt(value);
    let twosComplement = number;

    if (this.signed && JSBI.LT(number, JSBI.BigInt(0))) {
      twosComplement = JSBI.add(number, this.bound);
      number = JSBI.add(number, UINT_BOUND);
    }

    assert(JSBI.LE(JSBI.BigInt(0), twosComplement) && JSBI.LT(twosComplement, this.bound), {
      message: 'bound error',
      expect: `0<= && <${this.bound}`,
      got: twosComplement.toString(),
      coder: this,
      value,
    });

    return alignBuffer(format.hexBuffer(number));
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {BigInt}
   */
  decode(stream) {
    let value = JSBI.BigInt(`0x${stream.read(this.size * 2)}`); // 16: read out naked hex string

    if (this.signed && JSBI.GE(value, this.bound)) {
      const mask = JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(this.size * 8));
      value = JSBI.subtract(value, mask);
    }

    return JSBI.BigInt(value);
  }
}

module.exports = IntegerCoder;
module.exports.uIntCoder = new IntegerCoder({ type: 'uint' });


/***/ }),

/***/ 34625:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const { assert } = __webpack_require__(61069);
const BaseCoder = __webpack_require__(84349);

class NullCoder extends BaseCoder {
  static from({ type, ...options }) {
    if (type !== '') {
      return undefined;
    }
    return new this({ ...options, type: 'null' });
  }

  /**
   * @param {null} value
   * @return {Buffer}
   */
  encode(value) {
    assert(value === null, {
      message: 'unexpected type',
      expect: null,
      got: value,
      coder: this,
    });

    return Buffer.from('');
  }

  /**
   * @return {null}
   */
  decode() {
    return null;
  }
}

module.exports = NullCoder;


/***/ }),

/***/ 57075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const lodash = __webpack_require__(76635);
const { assert } = __webpack_require__(61069);
const BytesCoder = __webpack_require__(98864);

class StringCoder extends BytesCoder {
  static from({ type, ...options }) {
    if (type !== 'string') {
      return undefined;
    }
    return new this({ ...options, type });
  }

  constructor({ type, name }) {
    super({ name, size: undefined });
    this.type = type;
  }

  /**
   * @param {string} value - string in utf8
   * @return {Buffer}
   */
  encode(value) {
    assert(lodash.isString(value), {
      message: 'value type error',
      expect: 'string',
      got: value.constructor.name,
      coder: this,
    });

    return super.encode(Buffer.from(value));
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {string}
   */
  decode(stream) {
    const bytes = super.decode(stream);
    return bytes.toString();
  }

  encodeTopic(value) {
    assert(lodash.isString(value), {
      message: 'value type error',
      expect: 'string',
      got: value.constructor.name,
      coder: this,
    });

    return super.encodeTopic(Buffer.from(value));
  }
}

module.exports = StringCoder;


/***/ }),

/***/ 30377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const lodash = __webpack_require__(76635);
const { WORD_BYTES } = __webpack_require__(46057);
const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const namedTuple = __webpack_require__(75689);
const BaseCoder = __webpack_require__(84349);
const { uIntCoder } = __webpack_require__(8962);

class Pointer extends Number {}

/**
 * @param {BaseCoder[]} coders
 * @param {array} array
 * @return {Buffer}
 */
function pack(coders, array) {
  let offset = 0;
  const staticList = [];
  const dynamicList = [];

  lodash.zip(coders, array)
    .forEach(([coder, value]) => {
      const buffer = coder.encode(value);

      if (coder.dynamic) {
        offset += WORD_BYTES;
        staticList.push(new Pointer(dynamicList.length)); // push index of dynamic to static
        dynamicList.push(buffer);
      } else {
        offset += buffer.length;
        staticList.push(buffer);
      }
    });

  // write back the dynamic address
  staticList.forEach((pointer, index) => {
    if (pointer instanceof Pointer) {
      staticList[index] = uIntCoder.encode(offset);
      offset += dynamicList[pointer].length;
    }
  });

  return Buffer.concat([...staticList, ...dynamicList]);
}

/**
 *
 * @param {BaseCoder[]} coders
 * @param {import('../../util/HexStream')} stream
 * @return {array}
 */
function unpack(coders, stream) {
  const startIndex = stream.index;

  const array = coders.map(coder => {
    if (coder.dynamic) {
      const offset = format.uInt(uIntCoder.decode(stream)); // XXX: BigInt => Number, for length is enough.
      return new Pointer(startIndex + offset * 2);
    } else {
      return coder.decode(stream);
    }
  });

  lodash.zip(coders, array)
    .forEach(([coder, value], index) => {
      if (value instanceof Pointer) {
        assert(Number(value) === stream.index, {
          message: 'stream.index error',
          expect: value,
          got: stream.index,
          coder,
          stream,
        });

        array[index] = coder.decode(stream);
      }
    });

  return array;
}

class TupleCoder extends BaseCoder {
  static from({ type, components, ...options }, valueCoder) {
    if (type !== 'tuple') {
      return undefined;
    }
    return new this({ ...options, coders: components.map(valueCoder) });
  }

  constructor({ name, coders }) {
    super({ name });
    this.type = `(${coders.map(coder => coder.type).join(',')})`;
    this.size = coders.length;
    this.coders = coders;
    this.dynamic = lodash.some(coders, coder => coder.dynamic);
    this.names = coders.map((coder, index) => coder.name || `${index}`);
    /** @type {object} */
    this.NamedTuple = namedTuple(...this.names);
  }

  /**
   * @param {array} array
   * @return {Buffer}
   */
  encode(array) {
    if (lodash.isPlainObject(array)) {
      array = this.NamedTuple.fromObject(array);
    }

    assert(Array.isArray(array), {
      message: 'unexpected type',
      expect: 'array',
      got: typeof array,
      coder: this,
    });

    assert(array.length === this.size, {
      message: 'length not match',
      expect: this.size,
      got: array.length,
      coder: this,
    });

    return pack(this.coders, array);
  }

  /**
   * @param {import('../../util/HexStream')} stream
   * @return {NamedTuple}
   */
  decode(stream) {
    const array = unpack(this.coders, stream);
    return new this.NamedTuple(...array);
  }

  encodeTopic(value) {
    try {
      return format.hex64(value);
    } catch (e) {
      // TODO https://solidity.readthedocs.io/en/v0.7.4/abi-spec.html#encoding-of-indexed-event-parameters
      throw new Error('not supported encode tuple to index');
    }
  }

  decodeTopic(hex) {
    return hex;
  }
}

module.exports = TupleCoder;
module.exports.pack = pack;
module.exports.unpack = unpack;


/***/ }),

/***/ 22110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 @see https://solidity.readthedocs.io/en/v0.5.13/abi-spec.html
 @see https://solidity.readthedocs.io/en/v0.5.13/abi-spec.html#encoding-of-indexed-event-parameters
 */

const { assert } = __webpack_require__(61069);
const BaseCoder = __webpack_require__(84349);
const NullCoder = __webpack_require__(34625);
const AddressCoder = __webpack_require__(22954);
const IntegerCoder = __webpack_require__(8962);
const BoolCoder = __webpack_require__(23143);
const BytesCoder = __webpack_require__(98864);
const StringCoder = __webpack_require__(57075);
const TupleCoder = __webpack_require__(30377);
const ArrayCoder = __webpack_require__(34088);
// TODO FixedCoder

/**
 * Get coder by abi component.
 *
 * @param {object} component
 * @param {string} component.type
 * @param {string} [component.name]
 * @param {array} [component.components] - For TupleCoder
 * @return {BaseCoder}
 */
function valueCoder(component) {
  // must parse ArrayCoder first, others sorted by probability
  const coder = ArrayCoder.from(component, valueCoder) // recursion
    || TupleCoder.from(component, valueCoder) // recursion
    || AddressCoder.from(component)
    || IntegerCoder.from(component)
    || StringCoder.from(component)
    || BytesCoder.from(component)
    || BoolCoder.from(component)
    || NullCoder.from(component);

  assert(coder instanceof BaseCoder, {
    message: 'can not found matched coder',
    component,
  });

  return coder;
}

function formatType({ name, inputs }) {
  return `${name}(${inputs.map(param => valueCoder(param).type).join(',')})`;
}

function formatFullName({ name, inputs }) {
  return `${name}(${inputs.map(param => `${valueCoder(param).type} ${param.indexed ? 'indexed ' : ''}${param.name}`).join(', ')})`;
}

module.exports = {
  valueCoder,
  formatType,
  formatFullName,
};


/***/ }),

/***/ 6262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const callable = __webpack_require__(19066);
const EventCoder = __webpack_require__(94745);
const LogFilter = __webpack_require__(74785);

class ContractEvent extends EventCoder {
  constructor(fragment, contract, conflux) {
    super(fragment);
    this.contract = contract;
    this.conflux = conflux;

    return callable(this, this.call.bind(this));
  }

  call(...args) {
    const address = this.contract.address; // dynamic get `contract.address`
    const topics = [this.signature, ...this.encodeTopics(args)];
    return new LogFilter({ address: [address], topics }, this);
  }
}

module.exports = ContractEvent;


/***/ }),

/***/ 30005:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);
const callable = __webpack_require__(19066);

class ContractEventOverride {
  constructor(events, contract, conflux) {
    this.signatureToEvent = lodash.keyBy(events, 'signature');
    this.contract = contract;
    this.conflux = conflux;

    return callable(this, this.call.bind(this));
  }

  call(...args) {
    const acceptArray = [];
    const rejectArray = [];

    let filter;
    for (const event of Object.values(this.signatureToEvent)) {
      try {
        filter = event(...args);
        acceptArray.push(event.type);
      } catch (e) {
        rejectArray.push(event.type);
      }
    }

    if (!acceptArray.length) {
      throw new Error(`can not match override "${rejectArray.join(',')}" with args (${args.join(',')})`);
    }
    if (acceptArray.length > 1) {
      throw new Error(`can not determine override "${acceptArray.join('|')}" with args (${args.join(',')})`);
    }

    return filter;
  }

  decodeLog(log) {
    const topic = log.topics[0];
    const event = this.signatureToEvent[topic];
    return event.decodeLog(log);
  }
}

module.exports = ContractEventOverride;


/***/ }),

/***/ 94745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const HexStream = __webpack_require__(92808);
const namedTuple = __webpack_require__(75689);
const { formatType, formatFullName, valueCoder } = __webpack_require__(22110);

class EventCoder {
  /**
   * Event coder
   *
   * @param {object} options
   * @param {boolean} options.anonymous
   * @param {string} options.name
   * @param {array} options.inputs
   * @return {EventCoder}
   *
   * @example
   * > abi = {
    name: 'EventName',
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: 'account',
        type: 'address',
      },
      {
        indexed: false,
        name: 'number',
        type: 'uint',
      },
    ],
   }
   * > coder = new EventCoder(abi)
   EventCoder {
      anonymous: false,
      name: 'EventName',
      inputs: [
        { indexed: true, name: 'account', type: 'address' },
        { indexed: false, name: 'number', type: 'uint' }
      ],
      type: 'EventName(address,uint256)',
      NamedTuple: [Function: NamedTuple(account,number)]
    }
   */
  constructor({ anonymous, name, inputs = [] }) {
    this.anonymous = anonymous;
    this.name = name; // example: "Event"
    this.fullName = formatFullName({ name, inputs }); // example: "Event(address indexed account)"
    this.type = formatType({ name, inputs }); // example: "Event(address)"
    this.signature = format.keccak256(this.type); // example: "0x50d7c806d0f7913f321946784dee176a42aa55b5dd83371fc57dcedf659085e0"

    this.inputs = inputs;
    this.inputCoders = inputs.map(valueCoder);
    this.dataCoder = valueCoder({ type: 'tuple', components: inputs.filter(component => !component.indexed) });

    /** @type {object} */
    this.NamedTuple = namedTuple(...inputs.map((input, index) => input.name || `${index}`));
  }

  /**
   * Encode topics by params
   *
   * @param {any[]} args
   * @return {string[]}
   * @example
   * > coder = new EventCoder(abi)
   * > coder.encodeTopics(['0x0123456789012345678901234567890123456789', null])
   ['0x0000000000000000000000000123456789012345678901234567890123456789']
   */
  encodeTopics(args) {
    assert(args.length === this.inputs.length, {
      message: 'length not match',
      expect: this.inputs.length,
      got: args.length,
      coder: this.fullName,
    });

    const topics = [];
    this.inputs.forEach((component, index) => {
      if (component.indexed) {
        const coder = this.inputCoders[index];
        const value = args[index];
        topics.push(value === null ? null : format.hex(coder.encodeTopic(value)));
      }
    });

    return topics;
  }

  /**
   * Decode log
   *
   * @param {array} topics - Array of hex sting
   * @param {string} data - Hex string
   * @return {array} NamedTuple
   *
   * @example
   * > coder = new EventCoder(abi)
   * > result = coder.decodeLog({
      data: '0x000000000000000000000000000000000000000000000000000000000000000a',
      topics: [
        '0xb0333e0e3a6b99318e4e2e0d7e5e5f93646f9cbf62da1587955a4092bf7df6e7',
        '0x0000000000000000000000000123456789012345678901234567890123456789',
      ],
    })
   NamedTuple(account,number) [ '0x0123456789012345678901234567890123456789', 10n ]
   * > console.log([...result])
   [ 0x0123456789012345678901234567890123456789, 10n ]
   * > console.log(result.account) // `account` a field name in abi
   "0x0123456789012345678901234567890123456789"
   * > console.log(result.number) // `number` a field name in abi
   10n
   */
  decodeLog({ topics, data }) {
    assert(this.anonymous || topics[0] === this.signature, {
      message: 'decodeLog unexpected topic',
      expect: this.signature,
      got: topics[0],
      coder: this.fullName,
    });

    const stream = new HexStream(data || '0x');
    const notIndexedNamedTuple = this.dataCoder.decode(stream);
    assert(stream.eof(), {
      message: 'hex length too large',
      expect: `${stream.string.length}`,
      got: stream.index,
      coder: this.fullName,
    });

    let offset = this.anonymous ? 0 : 1;
    const array = this.inputs.map((component, index) => {
      if (component.indexed) {
        const coder = this.inputCoders[index];
        const topic = topics[offset++]; // eslint-disable-line no-plusplus
        return coder.decodeTopic(topic);
      } else {
        return notIndexedNamedTuple[component.name || index];
      }
    });

    return new this.NamedTuple(...array);
  }
}

module.exports = EventCoder;


/***/ }),

/***/ 74785:
/***/ ((module) => {

class LogFilter {
  constructor({ address, topics }, event) {
    this.address = address;
    this.topics = topics;
    Reflect.defineProperty(this, 'event', { value: event }); // XXX: use defineProperty to avoid from JSON.stringify
  }

  async getLogs(options = {}) {
    const logs = await this.event.conflux.cfx.getLogs({ ...this, ...options });

    logs.forEach(log => {
      log.arguments = this.event.decodeLog(log);
    });

    return logs;
  }

  async subscribeLogs(options = {}) {
    const subscription = await this.event.conflux.subscribeLogs({ ...this, ...options });

    subscription.on('data', log => {
      log.arguments = this.event.decodeLog(log);
    });

    return subscription;
  }
}

module.exports = LogFilter;


/***/ }),

/***/ 69350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);
const { parseABIFromString } = __webpack_require__(35215);
const ContractABI = __webpack_require__(2283);
const ContractConstructor = __webpack_require__(20721);
const ContractMethod = __webpack_require__(63241);
const ContractMethodOverride = __webpack_require__(35854);
const ContractEvent = __webpack_require__(6262);
const ContractEventOverride = __webpack_require__(30005);
const ErrorCoder = __webpack_require__(62326);

/**
 * Contract with all its methods and events defined in its abi.
 */
class Contract {
  /**
   * > contract "code" definition:
   * ```
   * 6080................6080.................a264.........0033...............................
   * | <-                     create contract transaction `data`                          -> |
   * | <- deploy code -> | <- runtime code -> | <- metadata -> | <- constructor arguments -> |
   * | <-                contract `bytecode`                -> |
   *                     | <-       code as `getCode`       -> |
   * ```
   *
   * @param {object} options
   * @param {array} options.abi - The json interface for the contract to instantiate
   * @param {string} [options.address] - The address of the smart contract to call, can be added later using `contract.address = '0x1234...'`
   * @param {string} [options.bytecode] - The byte code of the contract, can be added later using `contract.constructor.code = '0x1234...'`
   * @param {boolean} [options.decodeByteToHex=false] - Whether decode bytes to hex string, default will decoe to Buffer.
   * @param {import('../Conflux')} conflux - Conflux instance.
   * @return {object}
   *
   * @example
   * > const contract = conflux.Contract({ abi, bytecode, address });
   {
      abi: ContractABI { contract: [Circular *1] },
      address: 'cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw',
      constructor: [Function: bound call],
      name: [Function: bound call],
      'name()': [Function: bound call],
      '0x06fdde03': [Function: bound call],
      balanceOf: [Function: bound call],
      'balanceOf(address)': [Function: bound call],
      '0x70a08231': [Function: bound call],
      send: [Function: bound call],
      'send(address,uint256,bytes)': [Function: bound call],
      '0x9bd9bbc6': [Function: bound call],
      Transfer: [Function: bound call],
      'Transfer(address,address,uint256)': [Function: bound call],
      '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef': [Function: bound call]
   }

   * > contract.constructor.bytecode; // input code
   "0x6080..."

   * @example
   * > const contract = conflux.Contract({
   address: 'cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw',
   abi: [
      {
        type: 'function',
        name: 'name',
        inputs: [],
        outputs: [{ type: 'string' }],
      },
      {
        type: 'function',
        name: 'balanceOf',
        inputs: [{ type: 'address' }],
        outputs: [{ type: 'uint256' }],
      },
      {
        name: 'send',
        type: 'function',
        inputs: [
          { type: 'address', name: 'recipient' },
          { type: 'uint256', name: 'amount' },
          { type: 'bytes', name: 'data' },
        ],
        outputs: [{ type: 'bool' }],
      },
    ]
   });
   * > contract.address
   "cfxtest:achc8nxj7r451c223m18w2dwjnmhkd6rxa2gc31euw"

   * > await contract.name(); // call a method without parameter, get decoded return value.
   "FansCoin"
   * > await contract.name().call({ to: '0x8b8689c7f3014a4d86e4d1d0daaf74a47f5e0f27' }); // call a method with options
   "conflux USDT"
   * > await contract.balanceOf('0x19c742cec42b9e4eff3b84cdedcde2f58a36f44f'); // call a method with parameters, get decoded return value.
   10000000000000000000n

   * Update contract state with sendTransaction
   * > await contract.transfer('0x19c742cec42b9e4eff3b84cdedcde2f58a36f44f', 10000).sendTransaction({
     from: 'cfxtest:aak2rra2njvd77ezwjvx04kkds9fzagfe6d5r8e957',
   });
   0x2055f3287f1a6ce77d91f5dfdf7517a531b3a560fee1265f27dc1ff92314530b

   * > transaction = await conflux.getTransactionByHash('0x2055f3287f1a6ce77d91f5dfdf7517a531b3a560fee1265f27dc1ff92314530b');
   * > contract.abi.decodeData(transaction.data)
   {
      name: 'send',
      fullName: 'send(address recipient, uint256 amount, bytes data)',
      type: 'send(address,uint256,bytes)',
      signature: '0x9bd9bbc6',
      array: [
        '0x80bb30efc5683758128b404fe5da03432eb16634',
        60000000000000000000n,
        <Buffer 1f 3c 6b 96 96 60 4c dc 3c e1 ca 27 7d 4c 69 a9 c2 77 0c 9f>
      ],
      object: {
        recipient: '0x80bb30efc5683758128b404fe5da03432eb16634',
        amount: 60000000000000000000n,
        data: <Buffer 1f 3c 6b 96 96 60 4c dc 3c e1 ca 27 7d 4c 69 a9 c2 77 0c 9f>
      }
    }

   * > receipt = await conflux.getTransactionReceipt('0x2055f3287f1a6ce77d91f5dfdf7517a531b3a560fee1265f27dc1ff92314530b');
   * > contract.abi.decodeLog(receipt.logs[1]);
   {
      name: 'Transfer',
      fullName: 'Transfer(address indexed from, address indexed to, uint256 value)',
      type: 'Transfer(address,address,uint256)',
      signature: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
      array: [
        '0x1f3c6b9696604cdc3ce1ca277d4c69a9c2770c9f',
        '0x80bb30efc5683758128b404fe5da03432eb16634',
        60000000000000000000n
      ],
      object: {
        from: '0x1f3c6b9696604cdc3ce1ca277d4c69a9c2770c9f',
        to: '0x80bb30efc5683758128b404fe5da03432eb16634',
        value: 60000000000000000000n
      }
    }
   */
  constructor({ abi, address, bytecode, decodeByteToHex }, conflux) {
    if (abi.length > 0 && typeof abi[0] === 'string') {
      abi = parseABIFromString(abi);
    }
    _feedAddressNetId(abi, conflux);
    _feedByteOption(abi, decodeByteToHex);
    const abiTable = lodash.groupBy(abi, 'type');
    this.abi = new ContractABI(this); // XXX: Create a method named `abi` in solidity is a `Warning`.

    this.address = address; // XXX: Create a method named `address` in solidity is a `ParserError`

    // constructor
    this.constructor = new ContractConstructor(lodash.first(abiTable.constructor), bytecode, this, conflux);

    // method
    const methodArray = lodash.map(abiTable.function, fragment => new ContractMethod(fragment, this, conflux));
    lodash.forEach(lodash.groupBy(methodArray, 'name'), (array, name) => {
      this[name] = array.length === 1 ? lodash.first(array) : new ContractMethodOverride(array, this, conflux);

      array.forEach(method => {
        this[method.type] = method;
        this[method.signature] = method; // signature for contract abi decoder to decode
      });
    });

    // event
    const eventArray = lodash.map(abiTable.event, fragment => new ContractEvent(fragment, this, conflux));
    lodash.forEach(lodash.groupBy(eventArray, 'name'), (array, name) => {
      this[name] = array.length === 1 ? lodash.first(array) : new ContractEventOverride(array, this, conflux);

      array.forEach(event => {
        this[event.type] = event;
        this[event.signature] = event; // signature for contract abi decoder to decode
      });
    });
  }
}

function _feedAddressNetId(abi, conflux) {
  if (!abi || !conflux || !conflux.networkId) return;

  for (const item of abi) {
    if (['function', 'event', 'constructor'].indexOf(item.type) >= 0) {
      _feedInfo(item.inputs);
      _feedInfo(item.outputs);
    }
  }

  function _feedInfo(items = []) {
    for (const meta of items) {
      if (meta.type === 'address') {
        meta.networkId = conflux.networkId;
      }
      if (meta.type === 'tuple') {
        _feedInfo(meta.components);
      }
    }
  }
}

function _feedByteOption(abi, decodeByteToHex = false) {
  if (!abi || !decodeByteToHex) return;

  for (const item of abi) {
    if (['function', 'event', 'constructor'].indexOf(item.type) >= 0) {
      _feedOption(item.inputs);
      _feedOption(item.outputs);
    }
  }

  function _feedOption(items = []) {
    for (const meta of items) {
      if (meta.type.startsWith('bytes')) {
        meta._decodeToHex = true;
      }
      if (meta.type === 'tuple') {
        _feedOption(meta.components);
      }
    }
  }
}

module.exports = Contract;

const errorCoder = new ErrorCoder();
module.exports.decodeError = e => errorCoder.decodeError(e);


/***/ }),

/***/ 54433:
/***/ ((module) => {

const AdminControl = {
  abi: [
    'function getAdmin(address contractAddr) public view returns (address)',
    'function setAdmin(address contractAddr, address newAdmin)',
    'function destroy(address contractAddr)',
  ],
  address: '0x0888000000000000000000000000000000000000',
};

const SponsorWhitelistControl = {
  abi: [
    'function getSponsorForGas(address contractAddr) public view returns (address)',
    'function getSponsoredBalanceForGas(address contractAddr) public view returns (uint256)',
    'function getSponsoredGasFeeUpperBound(address contractAddr) public view returns (uint256)',
    'function getSponsorForCollateral(address contractAddr) public view returns (address)',
    'function getSponsoredBalanceForCollateral(address contractAddr) public view returns (uint256)',
    'function isWhitelisted(address contractAddr, address user) public view returns (bool)',
    'function isAllWhitelisted(address contractAddr) public view returns (bool)',
    'function addPrivilegeByAdmin(address contractAddr, address[] memory addresses)',
    'function removePrivilegeByAdmin(address contractAddr, address[] memory addresses)',
    'function setSponsorForGas(address contractAddr, uint upperBound)',
    'function setSponsorForCollateral(address contractAddr)',
    // 'function addPrivilege(address[] memory)',
    // 'function removePrivilege(address[] memory)',
  ],
  address: '0x0888000000000000000000000000000000000001',
};

const Staking = {
  abi: [
    'function getStakingBalance(address user) public view returns (uint256)',
    'function getLockedStakingBalance(address user, uint256 blockNumber) public view returns (uint256)',
    'function getVotePower(address user, uint256 blockNumber) public view returns (uint256)',
    'function deposit(uint256 amount)',
    'function withdraw(uint256 amount)',
    'function voteLock(uint256 amount, uint256 unlockBlockNumber)',
  ],
  address: '0x0888000000000000000000000000000000000002',
};

const ConfluxContext = {
  abi: [
    'function epochNumber() public view returns (uint256)',
    'function posHeight() public view returns (uint256)',
    'function finalizedEpochNumber() public view returns (uint256)',
  ],
  address: '0x0888000000000000000000000000000000000004',
};

const PoSRegister = {
  abi: [
    'function register(bytes32 indentifier, uint64 votePower, bytes calldata blsPubKey, bytes calldata vrfPubKey, bytes[2] calldata blsPubKeyProof)',
    'function increaseStake(uint64 votePower)',
    'function retire(uint64 votePower)',
    'function getVotes(bytes32 identifier) external view returns (uint256, uint256)',
    'function identifierToAddress(bytes32 identifier) external view returns (address)',
    'function addressToIdentifier(address addr) external view returns (bytes32)',
    'event Register(bytes32 indexed identifier, bytes blsPubKey, bytes vrfPubKey)',
    'event IncreaseStake(bytes32 indexed identifier, uint64 votePower)',
    'event Retire(bytes32 indexed identifier, uint64 votePower)',
  ],
  address: '0x0888000000000000000000000000000000000005',
};

const CrossSpaceCall = {
  abi: [
    'event Call(bytes20 indexed sender, bytes20 indexed receiver, uint256 value, uint256 nonce, bytes data)',
    'event Create(bytes20 indexed sender, bytes20 indexed contract_address, uint256 value, uint256 nonce, bytes init)',
    'event Withdraw(bytes20 indexed sender, address indexed receiver, uint256 value, uint256 nonce)',
    'event Outcome(bool success)',
    'function createEVM(bytes calldata init) external payable returns (bytes20)',
    'function transferEVM(bytes20 to) external payable returns (bytes memory output)',
    'function callEVM(bytes20 to, bytes calldata data) external payable returns (bytes memory output)',
    'function staticCallEVM(bytes20 to, bytes calldata data) external view returns (bytes memory output)',
    'function withdrawFromMapped(uint256 value)',
    'function mappedBalance(address addr) external view returns (uint256)',
    'function mappedNonce(address addr) external view returns (uint256)',
  ],
  address: '0x0888000000000000000000000000000000000006',
};

module.exports = {
  AdminControl,
  SponsorWhitelistControl,
  Staking,
  ConfluxContext,
  PoSRegister,
  CrossSpaceCall,
};


/***/ }),

/***/ 20721:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);
const ContractMethod = __webpack_require__(63241);
const { WORD_CHARS } = __webpack_require__(46057);

class ContractConstructor extends ContractMethod {
  constructor(fragment, bytecode, contract, conflux) {
    super(lodash.defaults(fragment, { name: 'constructor', inputs: [] }), contract, conflux);

    this.signature = ''; // MUST be '' for `super.encodeData`
    this.bytecode = bytecode;
    this.decodeOutputs = hex => hex;
  }

  call(...args) {
    if (!this.bytecode) {
      throw new Error('bytecode is empty');
    }

    const transaction = super.call(...args);
    transaction.to = null;
    return transaction;
  }

  /**
   * Encode contract deploy data
   *
   * @param {array} args
   * @return {string}
   */
  encodeData(args) {
    return `${this.bytecode}${super.encodeData(args)}`;
  }

  /**
   * Reverse try to decode word by word
   *
   * @param {string} hex - Hex string
   * @return {array} NamedTuple
   */
  decodeData(hex) {
    for (let index = WORD_CHARS; index <= hex.length; index += WORD_CHARS) {
      try {
        return super.decodeData(hex.slice(-index));
      } catch (e) {
        // pass
      }
    }
    return undefined;
  }
}

module.exports = ContractConstructor;


/***/ }),

/***/ 63241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const callable = __webpack_require__(19066);
const MethodTransaction = __webpack_require__(17261);
const FunctionCoder = __webpack_require__(93689);

class ContractMethod extends FunctionCoder {
  constructor(fragment, contract, conflux) {
    super(fragment);
    this.contract = contract;
    this.conflux = conflux;

    return callable(this, this.call.bind(this));
  }

  call(...args) {
    const to = this.contract.address; // dynamic get `contract.address`
    const data = this.encodeData(args);
    return new MethodTransaction({ to, data }, this);
  }
}

module.exports = ContractMethod;


/***/ }),

/***/ 35854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);
const callable = __webpack_require__(19066);

class ContractMethodOverride {
  constructor(methods, contract, conflux) {
    this.signatureToMethod = lodash.keyBy(methods, 'signature');
    this.contract = contract;
    this.conflux = conflux;

    return callable(this, this.call.bind(this));
  }

  call(...args) {
    const acceptArray = [];
    const rejectArray = [];

    let transaction;
    for (const method of Object.values(this.signatureToMethod)) {
      try {
        transaction = method(...args);
        acceptArray.push(method.type);
      } catch (e) {
        rejectArray.push(method.type);
      }
    }

    if (!acceptArray.length) {
      throw new Error(`can not match override "${rejectArray.join('|')}" with args (${args.join(',')})`);
    }
    if (acceptArray.length > 1) {
      throw new Error(`can not determine override "${acceptArray.join('|')}" with args (${args.join(',')})`);
    }

    return transaction;
  }

  decodeData(hex) {
    const signature = hex.slice(0, 10); // '0x' + 8 hex
    const method = this.signatureToMethod[signature];
    return method.decodeData(hex);
  }
}

module.exports = ContractMethodOverride;


/***/ }),

/***/ 62326:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const FunctionCoder = __webpack_require__(93689);

class ErrorCoder extends FunctionCoder {
  constructor() {
    super({ name: 'Error', inputs: [{ type: 'string', name: 'message' }] });
  }

  decodeError(error) {
    try {
      const { message } = this.decodeData(error.data);
      return new Error(message);
    } catch (e) {
      return error;
    }
  }
}

module.exports = ErrorCoder;


/***/ }),

/***/ 93689:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const HexStream = __webpack_require__(92808);
const { formatType, formatFullName, valueCoder } = __webpack_require__(22110);

class FunctionCoder {
  /**
   * Function coder
   *
   * @param {object} options
   * @param {string} [options.name]
   * @param {array} [options.inputs]
   * @param {array} [options.outputs]
   * @param {string} [options.stateMutability='nonpayable']
   *
   * @example
   * > abi = { name: 'func', inputs: [{ type: 'int' }, { type: 'bool' }], outputs: [{ type: 'int' }] }
   * > coder = new FunctionCoder(abi)
   FunctionCoder {
      name: 'func',
      fullName: 'func(int256 , bool )',
      inputs: [ { type: 'int' }, { type: 'bool' } ],
      outputs: [ { type: 'int' } ],
      type: 'func(int256,bool)'
    }
   */
  constructor({ name, inputs = [], outputs = [], stateMutability = 'nonpayable' }) {
    this.name = name; // example: "add"
    this.fullName = formatFullName({ name, inputs }); // example: "add(uint number, uint count)"
    this.type = formatType({ name, inputs }); // example: "add(uint,uint)"
    this.signature = format.keccak256(this.type).slice(0, 10); // example: "0xb8966352"
    this.stateMutability = stateMutability;

    this.inputCoder = valueCoder({ type: 'tuple', components: inputs });
    this.outputCoder = valueCoder({ type: 'tuple', components: outputs });
  }

  /**
   * Get function signature by abi (json interface)
   *
   * @param {array} args
   * @return {string}
   *
   * @example
   * > abi = { name: 'func', inputs: [{ type: 'int' }, { type: 'bool' }], outputs: [{ type: 'int' }] }
   * > coder = new FunctionCoder(abi)
   * > coder.encodeData([100, true])
   "0x1eee72c100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001"
   */
  encodeData(args) {
    const hex = format.hex(this.inputCoder.encode(args));
    return `${this.signature}${hex.substring(2)}`;
  }

  /**
   * Decode data hex with inputs by abi (json interface)
   *
   * @param {string} hex  - Hex string
   * @return {array} NamedTuple
   *
   * @example
   * > abi = { name: 'func', inputs: [{ type: 'int' }, { type: 'bool' }], outputs: [{ type: 'int' }] }
   * > coder = new FunctionCoder(abi)
   * > result = coder.decodeData('0x15fb272000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001')
   NamedTuple(0,1) [ 100n, true ]
   * > console.log([...result])
   [ 100n, true ]
   * > console.log(result[0])
   100
   * > console.log(result[1])
   true
   */
  decodeData(hex) {
    const prefix = hex.slice(0, this.signature.length);
    assert(prefix === this.signature, {
      message: 'decodeData unexpected signature',
      expect: this.signature,
      got: prefix,
      coder: this.fullName,
    });

    const data = hex.slice(this.signature.length);
    const stream = new HexStream(data);
    const tuple = this.inputCoder.decode(stream);
    assert(stream.eof(), {
      message: 'hex length too large',
      expect: `${stream.string.length}`,
      got: stream.index,
      coder: this.fullName,
    });

    return tuple;
  }

  /**
   * Decode hex with outputs by abi (json interface)
   *
   * @param {string} hex - Hex string
   * @return {array} NamedTuple
   *
   * @example
   * > abi = { name: 'func', inputs: [{ type: 'int' }, { type: 'bool' }], outputs: [{ type: 'int' }] }
   * > coder = new FunctionCoder(abi)
   * > result = coder.decodeOutputs('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')
   NamedTuple(0) [ -1n ]
   * > console.log([...result])
   [-1n]
   * > console.log(result[0])
   -1n
   */
  decodeOutputs(hex) {
    const stream = new HexStream(hex);
    const tuple = this.outputCoder.decode(stream);

    assert(stream.eof(), {
      message: 'hex length too large',
      expect: `${stream.string.length}`,
      got: stream.index,
      coder: this.fullName,
    });

    return tuple.length <= 1 ? tuple[0] : tuple;
  }
}

module.exports = FunctionCoder;


/***/ }),

/***/ 17261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Transaction = __webpack_require__(45550);

class MethodTransaction extends Transaction {
  constructor(options, method) {
    super(options);
    Reflect.defineProperty(this, 'method', { value: method }); // XXX: use defineProperty to avoid from JSON.stringify
  }

  /**
   * Will send a transaction to the smart contract and execute its method.
   * set contract.address as `to`,
   * set contract method encode as `data`.
   *
   * > Note: This can alter the smart contract state.
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @param {string} [password] - See [conflux.sendTransaction](#Conflux.js/Conflux/sendTransaction)
   * @return {import('../../subscribe/PendingTransaction')} The PendingTransaction object.
   */
  sendTransaction(options, ...extra) {
    return this.method.conflux.cfx.sendTransaction({ ...this, ...options }, ...extra);
  }

  populateTransaction(options) {
    return this.method.conflux.cfx.populateTransaction({ ...this, ...options });
  }

  /**
   * Executes a message call or transaction and returns the amount of the gas used.
   * set contract.address as `to`,
   * set contract method encode as `data`.
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @param {string|number} epochNumber - See [Conflux.estimateGasAndCollateral](#Conflux.js/estimateGasAndCollateral)
   * @return {Promise<object>} The gas used and storage occupied for the simulated call/transaction.
   */
  async estimateGasAndCollateral(options, epochNumber) {
    return this.method.conflux.cfx.estimateGasAndCollateral({ ...this, ...options }, epochNumber);
  }

  /**
   * Executes a message call transaction,
   * set contract.address as `to`,
   * set contract method encode as `data`.
   *
   * > Note: Can not alter the smart contract state.
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @param {string|number} epochNumber - See [Conflux.call](#Conflux.js/call)
   * @return {Promise<*>} Decoded contact call return.
   */
  async call(options, epochNumber) {
    const hex = await this.method.conflux.cfx.call({ ...this, ...options }, epochNumber);
    return this.method.decodeOutputs(hex);
  }

  request(options, epochNumber) {
    const methodMeta = this.method.conflux.cfx.call.request({ ...this, ...options }, epochNumber);
    methodMeta.decoder = this.method.decodeOutputs.bind(this.method);
    return methodMeta;
  }

  async then(resolve, reject) {
    try {
      return resolve(await this.call());
    } catch (e) {
      return reject(e);
    }
  }

  async catch(callback) {
    return this.then(v => v, callback);
  }

  async finally(callback) {
    try {
      return await this;
    } finally {
      await callback();
    }
  }
}

module.exports = MethodTransaction;


/***/ }),

/***/ 80446:
/***/ ((module) => {

const CRC20_ABI = [
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address) view returns (uint256)',
  'function transfer(address to, uint256 amount)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)',
  'function transferFrom(address sender, address recipient, uint256 amount) returns (bool)',
  'function increaseAllowance(address spender, uint256 amount) returns (bool)',
  'function decreaseAllowance(address spender, uint256 amount) returns (bool)',
  'event Transfer(address indexed from, address indexed to, uint256 amount)',
  'event Approval(address indexed owner, address indexed spender, uint256 amount)',
];

const ERROR_ABI = [
  'function Error(string)',
];

module.exports = {
  CRC20_ABI,
  ERROR_ABI,
};


/***/ }),

/***/ 11293:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CONST = __webpack_require__(46057);
const ERROR_CODES = __webpack_require__(95056);
const Conflux = __webpack_require__(91665);
const Contract = __webpack_require__(69350);
const Wallet = __webpack_require__(97033);
const Transaction = __webpack_require__(45550);
const Message = __webpack_require__(90282);
const PersonalMessage = __webpack_require__(85341);
const Drip = __webpack_require__(30067);
const providerFactory = __webpack_require__(6632);
const sign = __webpack_require__(43089);
const format = __webpack_require__(52519);
const PrivateKeyAccount = __webpack_require__(98124);
const address = __webpack_require__(1318);

module.exports = {
  CONST,
  ERROR_CODES,
  Conflux,
  Contract,
  Wallet,
  Transaction,
  Message,
  PersonalMessage,
  Drip,
  providerFactory,
  sign,
  format,
  PrivateKeyAccount,
  address,
};


/***/ }),

/***/ 36278:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-unused-vars */
const EventEmitter = __webpack_require__(82361);
const RPCError = __webpack_require__(90886);

class BaseProvider extends EventEmitter {
  /**

   * @param {object} [options]
   * @param {string} options.url - Full json rpc http url
   * @param {number} [options.timeout=30*1000] - Request time out in ms
   * @param {number} [options.retry=1] - Retry number
   * @param {boolean} [options.keepAlive=false] - Whether open the http keep-alive option
   * @param {object} [options.logger] - Logger with `info` and `error`
   * @return {BaseProvider}
   */
  constructor({
    url,
    retry = 1,
    timeout = 30 * 1000,
    keepAlive = false,
    logger = { info: () => undefined, error: () => undefined },
  }) {
    super();
    this.url = url;
    this.retry = retry;
    this.timeout = timeout;
    this.logger = logger;
    this.keepAlive = keepAlive;
    const headers = {};
    if (keepAlive) {
      headers.Connection = 'Keep-Alive';
    }
    this.headers = headers;
  }

  /**
   * Gen a random json rpc id.
   * It is used in `call` method, overwrite it to gen your own id.
   *
   * @return {string}
   */
  requestId() {
    return `${Date.now().toString(16)}${Math.random().toString(16).slice(2)}`;
  }

  /**
   * @param {any}
   * @return {Promise<*>}
   */
  _request(_any) {
    throw new Error(`NotImplementError: ${this.constructor.name}.request not implement.`);
  }

  /**
   * @param {any}
   * @return {Promise<*>}
   */
  _requestBatch(_any) {
    throw new Error(`NotImplementError: ${this.constructor.name}.requestBatch not implement.`);
  }

  /**
   * Call a json rpc method with params
   *
   * @param {object} data
   * @param {string} data.method - Json rpc method name.
   * @param {array} [data.params] - Json rpc method params.
   * @return {Promise<*>} Json rpc method return value.
   *
   * @example
   * > await provider.request({method: 'cfx_epochNumber'});
   * > await provider.request({method: 'cfx_getBlockByHash', params: [blockHash]});
   */
  async request({ method, params = [] }) {
    const startTime = Date.now();
    const data = { jsonrpc: '2.0', id: this.requestId(), method, params };

    const { result, error } = await this._request(data);

    if (error) {
      this.logger.error({ data, error, duration: Date.now() - startTime });
      throw new RPCError(error, { method, params });
    } else {
      this.logger.info({ data, result, duration: Date.now() - startTime });
    }

    return result;
  }

  /**
   * Call a json rpc method with params
   *
   * @param {string} method - Json rpc method name.
   * @param {any[]} params - Json rpc method params.
   * @return {Promise<*>} Json rpc method return value.
   *
   * @example
   * > await provider.call('cfx_epochNumber');
   * > await provider.call('cfx_getBlockByHash', blockHash);
   */
  async call(method, ...params) {
    return this.request({ method, params });
  }

  /**
   * Send a json rpc method request
   *
   * @param {string} method - Json rpc method name.
   * @param {array} [params] - Json rpc method params.
   * @return {Promise<*>} Json rpc method return value.
   *
   * @example
   * > await provider.send('cfx_epochNumber');
   * > await provider.send('cfx_getBlockByHash', [blockHash]);
   */
  async send(method, params) {
    return this.request({ method, params });
  }

  /**
   * Batch call json rpc methods with params
   *
   * @param {object[]} array - Array of object with "method" and "params"
   * @return {Promise<Array>}
   *
   * @example
   * > await provider.batch([
   *   { method: 'cfx_epochNumber' },
   *   { method: 'cfx_getBalance', params: ['cfxtest:aaawgvnhveawgvnhveawgvnhveawgvnhvey1umfzwp'] },
   *   { method: 'InValidInput' },
   * ])
   [ '0x3b734d', '0x22374d959c622f74728', RPCError: Method not found ]
   */
  async batch(array) {
    if (!array.length) {
      return [];
    }

    const startTime = Date.now();
    const dataArray = array.map(data => ({ jsonrpc: '2.0', id: this.requestId(), ...data }));

    const returnArray = await this._requestBatch(dataArray);

    this.logger.info({ dataArray, returnArray, duration: Date.now() - startTime });
    return returnArray.map(({ result, error }, i) => (error ? new RPCError(error, array[i]) : result));
  }

  close() {}
}

module.exports = BaseProvider;
module.exports.RPCError = RPCError;


/***/ }),

/***/ 3649:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const superagent = __webpack_require__(32075);
const BaseProvider = __webpack_require__(36278);

/**
 * Http protocol json rpc provider.
 */
class HttpProvider extends BaseProvider {
  async _doRequest(data) {
    const { body } = await superagent
      .post(this.url)
      .retry(this.retry)
      .set(this.headers)
      .send(data)
      .timeout(this.timeout);
    return body;
  }

  async _request(data) {
    const body = await this._doRequest(data);
    return body || {};
  }

  async _requestBatch(dataArray) {
    const body = await this._doRequest(dataArray);
    return body || [];
  }
}

module.exports = HttpProvider;


/***/ }),

/***/ 90886:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { isHexString } = __webpack_require__(61069);
const format = __webpack_require__(52519);

class RPCError extends Error {
  constructor(object, payload = {}) {
    supplementErrorInfo(object, payload);
    super(object);
    Object.assign(this, object);
    Object.assign(this, payload);
  }
}

module.exports = RPCError;

function supplementErrorInfo(object, payload) {
  // If use base32 address with full node before v1.1.1, will encounter this error
  if (object.message.match('0x prefix is missing')) {
    object.data = 'You should connect a node with version 1.1.1 or pass a valid hex value';
    return;
  }
  if (object.message === 'Method not found' && payload.method === 'cfx_sendTransaction') {
    object.message = `${object.message} Can't find 'from' in cfx.wallet, check 'error.data' for detail`;
    object.data = 'Please use cfx.wallet.addPrivateKey() to add a account before call cfx.sendTransaction()';
  }
  // decode hex encoded error message
  if (isHexString(object.data)) {
    object.data = format.hexBuffer(object.data).toString();
  }
}


/***/ }),

/***/ 16601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Websocket = (__webpack_require__(98117).w3cwebsocket);
const BaseProvider = __webpack_require__(36278);
const { awaitTimeout } = __webpack_require__(61069);

/**
 * Websocket protocol json rpc provider.
 */
class WebSocketProvider extends BaseProvider {
  /**
   * @param {object} [options] - See [W3CWebSocket](https://github.com/theturtle32/WebSocket-Node/blob/c91a6cb8f0cf896edf0d2d49faa0c9e0a9985172/docs/W3CWebSocket.md)
   * @param {string} options.url - Full json rpc http url
   * @param {number} [options.timeout=30*1000] - Request time out in ms
   * @param {object} [options.logger] - Logger with `info` and `error`
   * @param {string[]} [options.protocols] - See [w3](https://www.w3.org/TR/websockets/)
   * @param {string} [options.origin]
   * @param {object} [options.headers]
   * @param {object} [options.requestOptions]
   * @param {object} [options.clientConfig] - See [websocket/lib/WebSocketClient](https://github.com/theturtle32/WebSocket-Node/blob/c91a6cb8f0cf896edf0d2d49faa0c9e0a9985172/docs/WebSocketClient.md)
   * @param {number} [options.clientConfig.maxReceivedFrameSize=0x100000] - 1MiB max frame size.
   * @param {number} [options.clientConfig.maxReceivedMessageSize=0x800000] - 8MiB max message size, only applicable if assembleFragments is true
   * @param {number} [options.clientConfig.closeTimeout=5000] - The number of milliseconds to wait after sending a close frame for an acknowledgement to come back before giving up and just closing the socket.
   * @return {WebSocketProvider}
   */
  constructor(options) {
    super(options);
    this.websocketOptions = options;

    this.client = null;

    this.on('message', json => {
      const data = JSON.parse(json);
      if (Array.isArray(data)) {
        data.forEach(each => this._onData(each));
      } else {
        this._onData(data);
      }
    });
  }

  _connect({ url, protocols, origin, headers, requestOptions, clientConfig }) {
    return new Promise((resolve, reject) => {
      const client = new Websocket(url, protocols, origin, headers, requestOptions, clientConfig);
      client.onopen = () => resolve(client);
      client.onerror = e => {
        this.emit('error', e);
        reject(new Error(`connect to "${url}" failed`));
      };
      client.onmessage = ({ data }) => this.emit('message', data);
      client.onclose = ({ code, reason }) => this.emit('close', code, reason);
    });
  }

  _onData(data = {}) {
    const { id, params: { subscription, result } = {} } = data;
    if (id) {
      this.emit(id, data);
    } else if (subscription) {
      this.emit(subscription, result);
    }
  }

  _awaitId(id) {
    return new Promise((resolve, reject) => {
      const onClose = (code, message) => {
        this.removeAllListeners(id);
        reject(new Error(message));
      };

      const onData = data => {
        this.removeListener('close', onClose);
        resolve(data);
      };

      this.once('close', onClose);
      this.once(id, onData);
    });
  }

  async _send(data) {
    if (this.client === null) { // init
      this.client = false;
      try {
        this.client = await this._connect(this.websocketOptions);
      } catch (e) {
        this.client = null;
        throw e;
      }
    }

    while (this.client === false) { // connecting
      await new Promise(resolve => setTimeout(resolve, 1));
    }

    return this.client.send(data);
  }

  async _request(data) {
    await this._send(JSON.stringify(data));

    return await awaitTimeout(this._awaitId(data.id), this.timeout) || {};
  }

  async _requestBatch(dataArray) {
    await this._send(JSON.stringify(dataArray));

    return Promise.all(dataArray.map(async data => {
      return awaitTimeout(this._awaitId(data.id), this.timeout); // timeout for each request
    }));
  }

  async close() {
    super.close();

    if (this.client === null) { // init
      return;
    }

    while (this.client === false) { // connecting
      await new Promise(resolve => setTimeout(resolve, 1));
    }

    this.client.close();
    await new Promise(resolve => this.once('close', resolve));
    this.client = null;
  }
}

module.exports = WebSocketProvider;


/***/ }),

/***/ 83512:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BaseProvider = __webpack_require__(36278);

/**
 * Wechat provider
 */
class WechatProvider extends BaseProvider {
  async _doRequest(data) {
    return new Promise((resolve, reject) => {
      let retryCount = this.retry;
      const sendRequest = () => {
        wx.request({
          method: 'POST',
          url: this.url,
          header: this.headers,
          data,
          timeout: this.timeout,
          success: res => {
            resolve(res.data);
          },
          fail: () => {
            if (retryCount > 0) {
              retryCount -= 1;
              sendRequest();
            } else {
              reject(new Error('SendWechatRequestError'));
            }
          },
        });
      };
      //
      sendRequest();
    });
  }

  async _request(data) {
    const body = await this._doRequest(data);
    return body || {};
  }

  async _requestBatch(dataArray) {
    const body = await this._doRequest(dataArray);
    return body || [];
  }
}

module.exports = WechatProvider;


/***/ }),

/***/ 6632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);
const BaseProvider = __webpack_require__(36278);
const HttpProvider = __webpack_require__(3649);
const WechatProvider = __webpack_require__(83512);
const WebsocketProvider = __webpack_require__(16601);

/**
 * @param {object} options
 * @param {string} options.url
 * @param {boolean} [options.useWechatProvider] - Whether use wechat provider.
 * @return {WebsocketProvider|HttpProvider|BaseProvider|WechatProvider}
 *
 * @example
 * > providerFactory()
 BaseProvider {
    url: undefined,
    timeout: 300000,
    logger: { info: [Function: info], error: [Function: error] }
  }
 * @example
 * > providerFactory({ url: 'http://localhost:12537' })
 HttpProvider {
    url: 'http://localhost:12537',
    timeout: 300000,
    logger: { info: [Function: info], error: [Function: error] }
  }

 * > providerFactory({
    url: 'http://main.confluxrpc.org',
    timeout: 60 * 60 * 1000,
    logger: console,
  }
 HttpProvider {
    url: 'http://main.confluxrpc.org',
    timeout: 3600000,
    logger: {...}
  }
 */
function providerFactory({ url, useWechatProvider, ...rest }) {
  if (!url) {
    return new BaseProvider(rest); // empty provider
  }

  if (lodash.startsWith(url, 'http')) {
    return useWechatProvider ? new WechatProvider({ url, ...rest }) : new HttpProvider({ url, ...rest });
  }

  if (lodash.startsWith(url, 'ws')) {
    return new WebsocketProvider({ url, ...rest }); // FIXME: support ws in browser
  }

  throw new Error('Invalid provider options');
}

module.exports = providerFactory;


/***/ }),

/***/ 46789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Big = __webpack_require__(89063);
const CONST = __webpack_require__(46057);
const format = __webpack_require__(52519);

class AdvancedRPCUtilities {
  constructor(conflux) {
    this.conflux = conflux;
  }

  /**
   * First try to use txpool_nextNonce method, if failed use cfx_getNextNonce
   *
   * @param {string} address - The address to get nonce
   * @returns {Promise<BigInt>}
   */
  async getNextUsableNonce(address) {
    address = this.conflux._formatAddress(address);
    let nonce;
    try {
      nonce = await this.conflux.txpool.nextNonce(address);
    } catch (e) {
      nonce = await this.conflux.cfx.getNextNonce(address);
    }
    return nonce;
  }

  /**
   * Get PoS interest rate
   *
   * @returns {Promise<string>} PoS interest rate
   */
  async getPoSInterestRate() {
    const RATIO = new Big(0.04);
    const batchRequest = this.conflux.BatchRequest();
    batchRequest.add(this.conflux.cfx.getSupplyInfo.request());
    batchRequest.add(this.conflux.cfx.getPoSEconomics.request());
    batchRequest.add(this.conflux.cfx.getBalance.request(CONST.ZERO_ADDRESS_HEX));
    const [
      { totalCirculating },
      { totalPosStakingTokens },
      balanceOfZeroAddress,
    ] = await batchRequest.execute();
    const bigTotalStaking = new Big(totalCirculating - balanceOfZeroAddress);
    const bigTotalPosStakingTokens = new Big(totalPosStakingTokens);
    const bigRatio = RATIO.div(bigTotalPosStakingTokens.div(bigTotalStaking).sqrt());
    return bigRatio.toString();
  }

  /**
   * A advance method to check whether user's balance is enough to pay one transaction
   *
   * @param {Object} options Transaction info
   * @param {string|number} [epochNumber] Optional epoch number
   * @returns {Promise<Object>} A object indicate whether user's balance is capable to pay the transaction.
   * - `BigInt` gasUsed: The gas used.
   * - `BigInt` gasLimit: The gas limit.
   * - `BigInt` storageCollateralized: The storage collateralized in Byte.
   * - `Boolean` isBalanceEnough: indicate balance is enough for gas and storage fee
   * - `Boolean` isBalanceEnoughForValueAndFee: indicate balance is enough for gas and storage fee plus value
   * - `Boolean` willPayCollateral: false if the transaction is eligible for storage collateral sponsorship, true otherwise
   * - `Boolean` willPayTxFee: false if the transaction is eligible for gas sponsorship, true otherwise
   */
  async estimateGasAndCollateralAdvance(options, epochNumber) {
    const estimateResult = await this.conflux.cfx.estimateGasAndCollateral(options, epochNumber);
    if (!options.from) {
      throw new Error('Can not check balance without `from`');
    }
    options = this.conflux._formatCallTx(options);
    const gasPrice = format.bigInt(options.gasPrice || BigInt(1));
    const txValue = format.bigInt(options.value || BigInt(0));
    const gasFee = gasPrice * estimateResult.gasLimit;
    const storageFee = estimateResult.storageCollateralized * (BigInt(1e18) / BigInt(1024));
    const balance = await this.conflux.cfx.getBalance(options.from);
    estimateResult.balance = balance;
    if (!options.to) {
      estimateResult.willPayCollateral = true;
      estimateResult.willPayTxFee = true;
      estimateResult.isBalanceEnough = balance > (gasFee + storageFee);
      estimateResult.isBalanceEnoughForValueAndFee = balance > (gasFee + storageFee + txValue);
    } else {
      const checkResult = await this.conflux.cfx.checkBalanceAgainstTransaction(
        options.from,
        options.to,
        estimateResult.gasLimit,
        gasPrice,
        estimateResult.storageCollateralized,
        epochNumber,
      );
      Object.assign(estimateResult, checkResult);
      let totalValue = txValue;
      totalValue += checkResult.willPayTxFee ? gasFee : BigInt(0);
      totalValue += checkResult.willPayCollateral ? storageFee : BigInt(0);
      estimateResult.isBalanceEnoughForValueAndFee = balance > totalValue;
    }
    return estimateResult;
  }
}

module.exports = AdvancedRPCUtilities;


/***/ }),

/***/ 29719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RPCError = __webpack_require__(90886);
const Transaction = __webpack_require__(45550);

const SEND_TX_METHOD = 'cfx_sendTransaction';
const SEND_RAW_TX_METHOD = 'cfx_sendRawTransaction';

class BatchRequester {
  /**
   * BatchRequester constructor.
   *
   * @param {import('../Conflux')} conflux - A Conflux instance
   */
  constructor(conflux) {
    this.conflux = conflux;
    this.requests = [];
    this.decoders = [];
    this.accountNextNonces = {};
    this.accountUsedNonces = {};
  }

  /**
   * Add RPC method request to batch builder
   * @param {object} A - request meta info object, include 'request' and 'decoder'
   * @param {object} A.request - JSON-RPC request object, include `method` and `params` array
   * @param {function} A.decoder - Response decoder
   * @example
   * Low level example:
   * batchRequester.add({
   *  "request": {
   *    "method": "cfx_getStatus",
   *    "params": []
   *  },
   *  "decoder": decoderFunction
   * });
   *
   * Use RPC method's request method to build request:
   * batchRequester.add(conflux.cfx.getBalance.request('cfxtest:aasm4c231py7j34fghntcfkdt2nm9xv1tu6jd3r1s7'));
   */
  add({ request, decoder = any => any }) {
    this.requests.push(request);
    this.decoders.push(decoder);
  }

  addTransaction(txOption) {
    this.add({
      request: {
        method: SEND_TX_METHOD,
        params: [txOption],
      },
    });
  }

  /**
   * Clear Batch requester's requests and decoders
   */
  clear() {
    this.requests = [];
    this.decoders = [];
    this.accountNextNonces = {};
    this.accountUsedNonces = {};
  }

  /**
   * Batch send the RPC requests, retrive the responses and decode
   * @returns {Array}
   * @example await batchRequester.execute();
   */
  async execute() {
    // prepare transaction nonce and sign it
    const _requests = [];
    await this._prepareTxCommonInfo();
    await this._prepareTxNonce();
    await this._prepareGasAndStorage();
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < this.requests.length; i++) {
      const req = this.requests[i];

      if (
        req.method === SEND_TX_METHOD
        && req.params[0]
        && req.params[0].from
        && this.conflux.wallet.has(req.params[0].from)
      ) {
        // sign transaction
        const from = req.params[0].from;
        const account = await this.conflux.wallet.get(`${from}`);
        const signedTx = await account.signTransaction(req.params[0]);
        // change method to cfx_sendRawTransaction
        req.method = SEND_RAW_TX_METHOD;
        req.params[0] = signedTx.serialize();
      }

      _requests[i] = req;
    }

    // decode response
    const results = await this.conflux.provider.batch(_requests);
    return results.map((data, i) => {
      if (data instanceof RPCError) { // If is error direct return
        return data;
      }
      return this.decoders[i](data);
    });
  }

  async _prepareTxNonce() {
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < this.requests.length; i++) {
      const req = this.requests[i];

      if (req.method === SEND_RAW_TX_METHOD) {
        const _tx = Transaction.decodeRaw(req.params[0]);
        this._markNonceUsed(_tx.from, _tx.nonce);
      }

      if (
        req.method === SEND_TX_METHOD
        && req.params[0]
        && req.params[0].from
        && this.conflux.wallet.has(req.params[0].from)
      ) {
        // prepare nonce
        const from = req.params[0].from;
        let _nonce = req.params[0].nonce;
        if (!_nonce || this._isNonceUsed(from, _nonce)) {
          _nonce = await this._getNextNonce(from);
          req.params[0].nonce = _nonce;
        }
        this._markNonceUsed(from, _nonce);
      }
    }
  }

  async _prepareTxCommonInfo() {
    const txCommon = await this._getTxCommonInfo();
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < this.requests.length; i++) {
      const req = this.requests[i];

      if (req.method === SEND_TX_METHOD && req.params[0]) {
        if (!req.params[0].gasPrice) {
          req.params[0].gasPrice = txCommon.gasPrice;
        }

        if (!req.params[0].chainId) {
          req.params[0].chainId = txCommon.chainId;
        }

        if (!req.params[0].epochHeight) {
          req.params[0].epochHeight = txCommon.epochHeight;
        }
      }
    }
  }

  async _prepareGasAndStorage() {
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < this.requests.length; i++) {
      const req = this.requests[i];

      if (req.method === SEND_TX_METHOD && req.params[0]) {
        if (!req.params[0].gas || !req.params[0].storageLimit) {
          const {
            gasLimit,
            storageCollateralized,
          } = await this.conflux.cfx.estimateGasAndCollateral(req.params[0]);
          req.params[0].gas = gasLimit;
          req.params[0].storageLimit = storageCollateralized;
        }
      }
    }
  }

  _markNonceUsed(from, nonce) {
    if (!this.accountUsedNonces[from]) {
      this.accountUsedNonces[from] = {};
    }
    this.accountUsedNonces[from][nonce] = true;
  }

  _isNonceUsed(from, nonce) {
    return this.accountUsedNonces[from] && this.accountUsedNonces[from][nonce];
  }

  async _getTxCommonInfo() {
    const epochHeight = await this.conflux.cfx.epochNumber();
    const gasPrice = await this.conflux.cfx.gasPrice();
    return {
      epochHeight,
      gasPrice,
      chainId: this.conflux.networkId,
    };
  }

  async _getNextNonce(from) {
    let _nonce = this.accountNextNonces[from];
    if (!_nonce) {
      _nonce = await this.conflux.advanced.getNextUsableNonce(from);
    }
    //
    while (this.accountUsedNonces[from] && this.accountUsedNonces[from][_nonce]) {
      _nonce += BigInt(1);
    }

    this.accountNextNonces[from] = _nonce + BigInt(1); // update next nonce

    return _nonce;
  }
}

module.exports = BatchRequester;


/***/ }),

/***/ 40856:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RPCMethodFactory = __webpack_require__(98173);
const format = __webpack_require__(52519);
const cfxFormat = __webpack_require__(77466);
const addressUtil = __webpack_require__(1318);
const CONST = __webpack_require__(46057);
const { assert } = __webpack_require__(61069);
const { decodeCfxAddress, ADDRESS_TYPES } = __webpack_require__(1318);
const PendingTransaction = __webpack_require__(54727);
const Contract = __webpack_require__(69350);
const RPCTypes = __webpack_require__(41043);

class CFX extends RPCMethodFactory {
  constructor(conflux) {
    super(conflux);
    this.conflux = conflux;
    this._formatAddress = conflux._formatAddress.bind(conflux);
    // add RPC methods
    super.addMethods(this.methods());
    // decorate methods;
    this.sendRawTransaction = this._decoratePendingTransaction(this.sendRawTransaction);
    this.sendTransaction = this._decoratePendingTransaction(this.sendTransaction);
    this._addRequestBuilderToCustomMethods();
  }

  methods() {
    const formatAddressWithNetworkId = this._formatAddress;
    return [
      {
        method: 'cfx_clientVersion',
      },
      {
        method: 'cfx_getSupplyInfo',
        requestFormatters: [
          format.epochNumberOrUndefined,
        ],
        responseFormatter: cfxFormat.supplyInfo,
      },
      {
        method: 'cfx_getStatus',
        responseFormatter: cfxFormat.status,
      },
      {
        method: 'cfx_gasPrice',
        alias: 'getGasPrice',
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_getInterestRate',
        requestFormatters: [
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_getAccumulateInterestRate',
        requestFormatters: [
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_getAccount',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: data => new RPCTypes.Account(data),
      },
      {
        method: 'cfx_getBalance',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_getStakingBalance',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_getNextNonce',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_getAdmin',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
      },
      {
        method: 'cfx_getVoteList',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: cfxFormat.voteList,
      },
      {
        method: 'cfx_getDepositList',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: cfxFormat.depositList,
      },
      {
        method: 'cfx_epochNumber',
        alias: 'getEpochNumber',
        requestFormatters: [
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.uInt,
      },
      {
        method: 'cfx_getBlockByEpochNumber',
        requestFormatters: [
          format.epochNumber,
          format.boolean, // TODO default false
        ],
        responseFormatter: cfxFormat.block.$or(null),
      },
      {
        method: 'cfx_getBlockByBlockNumber',
        requestFormatters: [
          format.bigUIntHex,
          format.boolean,
        ],
        responseFormatter: cfxFormat.block.$or(null),
      },
      {
        method: 'cfx_getBlocksByEpoch',
        alias: 'getBlocksByEpochNumber',
        requestFormatters: [
          format.epochNumber,
        ],
      },
      {
        method: 'cfx_getBlockRewardInfo',
        requestFormatters: [
          format.epochNumber,
        ],
        responseFormatter: cfxFormat.rewardInfo,
      },
      {
        method: 'cfx_getBestBlockHash',
      },
      {
        method: 'cfx_getBlockByHash',
        requestFormatters: [
          format.blockHash,
          format.boolean,
        ],
        responseFormatter: cfxFormat.block.$or(null),
      },
      {
        method: 'cfx_getBlockByHashWithPivotAssumption',
        requestFormatters: [
          format.blockHash,
          format.blockHash,
          format.epochNumber,
        ],
        responseFormatter: cfxFormat.block,
      },
      {
        method: 'cfx_getConfirmationRiskByHash',
        requestFormatters: [
          format.blockHash,
        ],
        responseFormatter: format.fixed64.$or(null),
      },
      {
        method: 'cfx_getTransactionByHash',
        requestFormatters: [
          format.transactionHash,
        ],
        responseFormatter: cfxFormat.transaction.$or(null),
      },
      {
        method: 'cfx_getTransactionReceipt',
        requestFormatters: [
          format.transactionHash,
        ],
        responseFormatter: cfxFormat.receipt.$or(null),
      },
      {
        method: 'cfx_sendRawTransaction',
        requestFormatters: [
          format.hex,
        ],
      },
      {
        method: 'cfx_getCode',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumber.$or(undefined),
        ],
        responseFormatter: format.any,
      },
      {
        method: 'cfx_getStorageAt',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.hex64,
          format.epochNumber.$or(undefined),
        ],
      },
      {
        method: 'cfx_getStorageRoot',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
      },
      {
        method: 'cfx_getSponsorInfo',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: cfxFormat.sponsorInfo,
      },
      {
        method: 'cfx_getAccountPendingInfo',
        requestFormatters: [
          formatAddressWithNetworkId,
        ],
        responseFormatter: cfxFormat.accountPendingInfo,
      },
      {
        method: 'cfx_getAccountPendingTransactions',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.bigUIntHex.$or(undefined),
          format.bigUIntHex.$or(undefined),
        ],
        responseFormatter: cfxFormat.accountPendingTransactions,
      },
      {
        method: 'cfx_getCollateralForStorage',
        requestFormatters: [
          formatAddressWithNetworkId,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.bigUInt,
      },
      {
        method: 'cfx_checkBalanceAgainstTransaction',
        requestFormatters: [
          formatAddressWithNetworkId,
          formatAddressWithNetworkId,
          format.bigUIntHex,
          format.bigUIntHex,
          format.bigUIntHex,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.any,
      },
      /* {
        method: 'cfx_call',
        requestFormatters: [
          this.conflux._formatCallTx,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: format.any, // TODO catch exception and decode error
      },
      {
        method: 'cfx_estimateGasAndCollateral',
        requestFormatters: [
          this.conflux._formatCallTx,
          format.epochNumberOrUndefined,
        ],
        responseFormatter: cfxFormat.estimate,
      }, */
      {
        method: 'cfx_getLogs',
        beforeHook(options) {
          if (options.blockHashes !== undefined && (options.fromEpoch !== undefined || options.toEpoch !== undefined)) {
            throw new Error('OverrideError, do not use `blockHashes` with `fromEpoch` or `toEpoch`, cause only `blockHashes` will take effect');
          }
        },
        requestFormatters: [
          this.conflux._formatGetLogs.bind(this.conflux),
        ],
        responseFormatter: cfxFormat.logs,
      },
      {
        method: 'cfx_getEpochReceipts',
        requestFormatters: [
          format.epochNumber,
        ],
        responseFormatter: cfxFormat.epochReceipts,
      },
      {
        method: 'cfx_getPoSEconomics',
        responseFormatter: cfxFormat.posEconomics,
      },
    ];
  }

  _decoratePendingTransaction(func) {
    const cfx = this;
    return function (...args) {
      return new PendingTransaction(cfx, func.bind(this), args);
    };
  }

  _addRequestBuilderToCustomMethods() {
    const self = this;

    this.call.request = function (options, epochNumber) {
      return {
        request: {
          method: 'cfx_call',
          params: [
            self.conflux._formatCallTx(options),
            format.epochNumber.$or(undefined)(epochNumber),
          ],
        },
      };
    };

    this.estimateGasAndCollateral.request = function (options, epochNumber) {
      return {
        request: {
          method: 'cfx_estimateGasAndCollateral',
          params: [
            self.conflux._formatCallTx(options),
            format.epochNumber.$or(undefined)(epochNumber),
          ],
        },
        decoder: cfxFormat.estimate,
      };
    };
  }

  /**
   * Auto populate transaction info (chainId, epochNumber, nonce, gas, gasPrice, storageLimit)
   *
   * @param {Object} options transaction info
   * @returns {Promise<Object>} Polulated complete transaction
   */
  async populateTransaction(options) {
    const {
      defaultGasPrice,
      defaultGasRatio,
      defaultStorageRatio,
    } = this.conflux;

    options.from = this._formatAddress(options.from);

    if (options.nonce === undefined) {
      options.nonce = await this.conflux.advanced.getNextUsableNonce(options.from);
    }

    if (options.chainId === undefined) {
      options.chainId = this.conflux.networkId;
    }

    if (options.chainId === undefined) {
      const status = await this.getStatus();
      options.chainId = status.chainId;
    }

    if (options.epochHeight === undefined) {
      options.epochHeight = await this.epochNumber();
    }

    if (options.gas === undefined || options.storageLimit === undefined) {
      let gas;
      let storageLimit;

      const isContract = decodeCfxAddress(options.from).type === ADDRESS_TYPES.CONTRACT;
      if (options.data || isContract) {
        const { gasUsed, storageCollateralized, gasLimit } = await this.estimateGasAndCollateral(options);
        if (defaultGasRatio) {
          gas = format.big(gasUsed).times(defaultGasRatio).toFixed(0);
        } else {
          gas = gasLimit;
        }
        storageLimit = format.big(storageCollateralized).times(defaultStorageRatio).toFixed(0);
      } else {
        gas = CONST.TRANSACTION_GAS;
        storageLimit = CONST.TRANSACTION_STORAGE_LIMIT;
      }

      if (options.gas === undefined) {
        options.gas = gas;
      }

      if (options.storageLimit === undefined) {
        options.storageLimit = storageLimit;
      }
    }

    if (options.gasPrice === undefined) {
      if (defaultGasPrice === undefined) {
        const gasPrice = await this.gasPrice();
        options.gasPrice = Number(gasPrice) === 0 ? CONST.MIN_GAS_PRICE : gasPrice;
      } else {
        options.gasPrice = defaultGasPrice;
      }
    }

    return options;
  }

  /**
   * Auto populate transaction and sign it with `from` 's privateKey in wallet
   *
   * @param {Object} options transaction info
   * @returns {Promise<string>} Hex encoded raw transaction
   */
  async populateAndSignTransaction(options) {
    await this.populateTransaction(options);
    const account = await this.conflux.wallet.get(`${options.from}`);
    const signedTx = await account.signTransaction(options);
    return signedTx.serialize();
  }

  /**
   * Auto populate transaction
   * if from's privateKey is in wallet, directly sign and encode it then send the rawTransaction with `cfx_sendRawTransaction` method
   * if not, sent the transaction with `cfx_sendTransaction` method
   *
   * @param {Object} options transaction info
   * @param {string} [password] Optional password to unlock account in fullnode
   * @return {Promise<string>} Transaction hash
   */
  async sendTransaction(options, ...extra) {
    if (this.conflux.wallet.has(`${options.from}`)) {
      const rawTx = await this.populateAndSignTransaction(options);
      return this.sendRawTransaction(rawTx);
    }

    return this.conflux.request({
      method: 'cfx_sendTransaction',
      params: [
        this.conflux._formatCallTx(options),
        ...extra,
      ],
    });
  }

  /**
   * Get epoch's receipt through pivot block's hash
   *
   * @param {string} pivotBlockHash Hash of pivot block
   * @returns {Promise<Array>} All receipts of one epoch
   */
  async getEpochReceiptsByPivotBlockHash(pivotBlockHash) {
    const result = await this.conflux.request({ method: 'cfx_getEpochReceipts', params: [`hash:${pivotBlockHash}`] });
    return cfxFormat.epochReceipts(result);
  }

  /**
   * Virtually call a contract, return the output data.
   *
   * @param {object} options - See [Transaction](#Transaction.js/Transaction/**constructor**)
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](#util/format.js/format/(static)epochNumber)
   * @return {Promise<string>} The output data.
   */
  async call(options, epochNumber) {
    try {
      if (options.to && addressUtil.hasNetworkPrefix(options.to) && this.conflux.networkId) {
        const { netId, type } = addressUtil.decodeCfxAddress(options.to);
        // check target address's networkId with current RPC's networkId
        assert(netId === this.conflux.networkId, '`to` address\'s networkId is not match current RPC\'s networkId');
        // check target contract is exist
        if (type === ADDRESS_TYPES.CONTRACT) {
          const code = await this.getCode(options.to);
          assert(code !== '0x', 'Contract not exist!');
        }
      }

      return await this.conflux.request({
        method: 'cfx_call',
        params: [
          this.conflux._formatCallTx(options),
          format.epochNumber.$or(undefined)(epochNumber),
        ],
      });
    } catch (e) {
      throw Contract.decodeError(e);
    }
  }

  /**
   * Virtually call a contract, return the estimate gas used and storage collateralized.
   *
   * @param {object} options - See [Transaction](#Transaction.js/Transaction/**constructor**)
   * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](#util/format.js/format/(static)epochNumber)
   * @return {Promise<import('./types/formatter').EstimateResult>} A estimate result object:
   * - `BigInt` gasUsed: The gas used.
   * - `BigInt` gasLimit: The gas limit.
   * - `BigInt` storageCollateralized: The storage collateralized in Byte.
   */
  async estimateGasAndCollateral(options, epochNumber) {
    try {
      const result = await this.conflux.request({
        method: 'cfx_estimateGasAndCollateral',
        params: [
          this.conflux._formatCallTx(options),
          format.epochNumber.$or(undefined)(epochNumber),
        ],
      });
      return cfxFormat.estimate(result);
    } catch (e) {
      throw Contract.decodeError(e);
    }
  }
}

module.exports = CFX;


/***/ }),

/***/ 98173:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const format = __webpack_require__(52519);

class RPCMethodFactory {
  constructor(conflux, methods = []) {
    this.conflux = conflux;
    this.addMethods(methods);
  }

  addMethods(methods) {
    for (const methodMeta of methods) {
      const method = methodMeta.method.split('_')[1];
      this[method] = this.createRPCMethod(methodMeta);
      // create method alias
      if (methodMeta.alias) {
        this[methodMeta.alias] = this[method];
      }
    }
  }

  createRPCMethod({ method, requestFormatters = [], responseFormatter = format.any, beforeHook }) {
    async function rpcMethod(...args) {
      if (beforeHook) {
        beforeHook(...args);
      }
      const params = Array.from(args).map((arg, i) => (requestFormatters[i] ? requestFormatters[i](arg) : arg));
      const result = await this.conflux.request({ method, params });
      return responseFormatter(result);
    }

    rpcMethod.request = function (...args) {
      const params = Array.from(args).map((arg, i) => (requestFormatters[i] ? requestFormatters[i](arg) : arg));
      return {
        request: {
          method,
          params,
        },
        decoder: responseFormatter,
      };
    };

    return rpcMethod;
  }
}

module.exports = RPCMethodFactory;


/***/ }),

/***/ 67946:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RPCMethodFactory = __webpack_require__(98173);
const format = __webpack_require__(52519);

const LATEST_COMMITTED = 'latest_committed';
const LATEST_VOTED = 'latest_voted';

format.posBlockNumber = format.bigUIntHex
  .$or(LATEST_COMMITTED)
  .$or(LATEST_VOTED);

/**
 * @typedef {Object} PivotDecision
 * @property {number} height
 * @property {string} blockHash
 */
format.decision = format({
  height: format.uInt,
});

/**
 * PoS status
 * @typedef {Object} PoSStatus
 * @property {number} latestCommitted
 * @property {number} epoch
 * @property {number} latestVoted
 * @property {number} latestTxNumber
 * @property {PivotDecision} pivotDecision
 */
format.posStatus = format({
  latestCommitted: format.uInt,
  epoch: format.uInt,
  pivotDecision: format.decision,
  latestTxNumber: format.uInt,
  latestVoted: format.uInt.$or(null),
});

/**
 * @typedef {Object} VotePowerState
 * @property {number} endBlockNumber
 * @property {number} power
 */
format.posVotePowerState = format({
  endBlockNumber: format.uInt,
  power: format.uInt,
});

/**
 * @typedef {Object} PoSAccountStatus
 * @property {number} availableVotes
 * @property {number} forfeited
 * @property {VotePowerState[]} inQueue
 * @property {VotePowerState[]} outQueue
 * @property {number} locked
 * @property {number} unlocked
 * @property {number|null} forceRetired
 */

/**
 * @typedef {Object} PoSAccount
 * @property {number} blockNumber
 * @property {PoSAccountStatus} status
 */
format.posAccount = format({
  blockNumber: format.uInt,
  status: {
    availableVotes: format.uInt,
    forfeited: format.uInt,
    forceRetired: format.uInt.$or(null),
    inQueue: [format.posVotePowerState],
    locked: format.uInt,
    outQueue: [format.posVotePowerState],
    unlocked: format.uInt,
  },
});

format.txPayload = format({
  targetTerm: format.uInt,
}).$or({
  votingPower: format.uInt,
}).$or({
  height: format.uInt,
});

/**
 * @typedef {Object} PoSTransaction
 * @property {string} hash
 * @property {string} blockHash
 * @property {string} from
 * @property {string} status
 * @property {string} type
 * @property {number} number
 * @property {number|null} timestamp
 * @property {number|null} blockNumber
 * @property {*} payload
 */
format.posTransaction = format({
  number: format.uInt,
  timestamp: format.uInt.$or(null),
  blockNumber: format.uInt.$or(null),
  payload: format.txPayload.$or(null),
}).$or(null);

/**
 * @typedef {Object} Signature
 * @property {number} votes
 * @property {string} account
 */

/**
 * @typedef {Object} PoSBlock
 * @property {number} epoch
 * @property {number} height
 * @property {PivotDecision} pivotDecision
 * @property {number} round
 * @property {number} timestamp
 * @property {number} lastTxNumber
 * @property {Signature} signatures
 */
format.posBlock = format({
  epoch: format.uInt,
  height: format.uInt,
  pivotDecision: format.decision.$or(null),
  round: format.uInt,
  timestamp: format.uInt,
  lastTxNumber: format.uInt,
  signatures: [format({ votes: format.uInt })],
}).$or(null);

/**
 * @typedef {Object} CommitteeNode
 * @property {number} votingPower
 * @property {string} address
 */
format.committeeNode = format({
  votingPower: format.uInt,
});

/**
 * @typedef {Object} Election
 * @property {boolean} isFinalized
 * @property {number} startBlockNumber
 * @property {CommitteeNode[]} topElectingNodes
 */
format.election = format({
  startBlockNumber: format.uInt,
  topElectingNodes: [format.committeeNode],
});

/**
 * @typedef {Object} CurrentCommittee
 * @property {number} epochNumber
 * @property {number} quorumVotingPower
 * @property {number} totalVotingPower
 * @property {CommitteeNode[]} nodes
 */

/**
 * @typedef {Object} PoSCommittee
 * @property {CurrentCommittee} currentCommittee
 * @property {Election[]} elections
 */
format.committee = format({
  currentCommittee: {
    epochNumber: format.uInt,
    quorumVotingPower: format.uInt,
    totalVotingPower: format.uInt,
    nodes: [format.committeeNode],
  },
  elections: [format.election],
});

/**
 * @typedef {Object} PoSReward
 * @property {number} reward
 * @property {string} posAddress
 * @property {string} powAddress
 */

/**
 * @typedef {Object} PoSEpochRewards
 * @property {string} powEpochHash
 * @property {PoSReward[]} accountRewards
 */
format.rewardsByEpoch = format({
  accountRewards: [format({
    reward: format.bigUInt,
  })],
}).$or(null);

/**
 * Class contains pos RPC methods
 * For the detail meaning of fields, please refer to the PoS RPC document:
 * @class
 */
class PoS extends RPCMethodFactory {
  /**
   * Create PoS instance
   * @param {import('../Conflux')} conflux The Conflux object
   * @return {PoS} The PoS instance
   */
  constructor(conflux) {
    super(conflux, PoS.methods());
    this.conflux = conflux;
  }

  static methods() {
    return [
      /**
       * @instance
       * @async
       * @name getStatus
       * @return {Promise<PoSStatus>} PoS status object
       * @example
       * await conflux.pos.getStatus();
       * // {
       * //   epoch: 138,
       * //   latestCommitted: 8235,
       * //   latestTxNumber: '0xa5e2',
       * //   latestVoted: 8238,
       * //   pivotDecision: {
       * //     blockHash: '0x97625d04ece6fe322ae38010ac877447927b4d5963af7eaea7db9befb615e510',
       * //     height: 394020
       * //   }
       * // }
       */
      {
        method: 'pos_getStatus',
        responseFormatter: format.posStatus,
      },
      /**
       * @instance
       * @async
       * @name getAccount
       * @param {Hash} account Account address
       * @param {number|hex} [blockNumber] Optional block number
       * @return {Promise<PoSAccount>}
       * @example
       * await conflux.pos.getAccount('0x0f0ccf5ee5276b102316acb3943a2750085f85ac7b94bdbf9d8901f03a7d7cc3');
       * {
       *   address: '0x0f0ccf5ee5276b102316acb3943a2750085f85ac7b94bdbf9d8901f03a7d7cc3',
       *   blockNumber: 8240,
       *   status: {
       *     availableVotes: 1525,
       *     forceRetired: null,
       *     forfeited: 0,
       *     inQueue: [],
       *     locked: 1525,
       *     outQueue: [],
       *     unlocked: 1
       *   }
       * }
       */
      {
        method: 'pos_getAccount',
        requestFormatters: [
          format.hex64,
          format.posBlockNumber.$or(undefined),
        ],
        responseFormatter: format.posAccount,
      },
      /**
       * @instance
       * @async
       * @name getBlockByHash
       * @param {string} hash The hash of PoS block
       * @return {Promise<PoSBlock>}
       * @example
       * await conflux.pos.getBlockByHash('0x97625d04ece6fe322ae38010ac877447927b4d5963af7eaea7db9befb615e510');
       */
      {
        method: 'pos_getBlockByHash',
        requestFormatters: [
          format.hex64,
        ],
        responseFormatter: format.posBlock,
      },
      /**
       * @instance
       * @async
       * @name getBlockByNumber
       * @param {number|hex} blockNumber The number of PoS block
       * @return {Promise<PoSBlock>}
       * @example
       * await conflux.pos.getBlockByNumber(8235);
       * {
       *   epoch: 138,
       *   hash: '0x1daf5443b7556cc39c3d4fe5e208fa77c3f5c053ea4bd637f5e43dfa7f0a95cb',
       *   height: 8235,
       *   miner: '0x0f0ccf5ee5276b102316acb3943a2750085f85ac7b94bdbf9d8901f03a7d7cc3',
       *   lastTxNumber: 42467,
       *   parentHash: '0x308699b307c81906ab97cbf213532c196f2d718f4641266aa444209349d9e31c',
       *   pivotDecision: {
       *     blockHash: '0x97625d04ece6fe322ae38010ac877447927b4d5963af7eaea7db9befb615e510',
       *     height: 394020
       *   },
       *   round: 15,
       *   signatures: [
       *     {
       *       account: '0x00f7c03318f8c4a7c6ae432e124b4a0474e973139a87f9ea6ae3efba66af7d8a',
       *       votes: 3
       *     }
       *   ],
       *   timestamp: 1638340165169041
       * }
       */
      {
        method: 'pos_getBlockByNumber',
        requestFormatters: [
          format.posBlockNumber,
        ],
        responseFormatter: format.posBlock,
      },
      /**
       * @instance
       * @async
       * @name getCommittee
       * @param {number|hex} [blockNumber] Optional block number
       * @return {Promise<PoSCommittee>}
       * @example
       * await conflux.pos.getCommittee();
       * {
       *   currentCommittee: {
       *     epochNumber: 138,
       *     nodes: [
       *      {
       *       address: "0xf92d8504fad118ddb5cf475180f5bcffaa967a9f9fa9c3c899ff9ad0de99694a",
       *       votingPower: 3
       *      }
       *     ],
       *     quorumVotingPower: 199,
       *     totalVotingPower: 297
       *   },
       *   elections: [
       *     {
       *       isFinalized: false,
       *       startBlockNumber: 8280,
       *       topElectingNodes: [
       *         {
       *           address: "0x0f0ccf5ee5276b102316acb3943a2750085f85ac7b94bdbf9d8901f03a7d7cc3",
       *           votingPower: 3
       *         }
       *       ]
       *     },
       *     {
       *       isFinalized: false,
       *       startBlockNumber: 8340,
       *       topElectingNodes: []
       *     }
       *   ]
       * }
       */
      {
        method: 'pos_getCommittee',
        requestFormatters: [
          format.posBlockNumber.$or(undefined),
        ],
        responseFormatter: format.committee,
      },
      /**
       * @instance
       * @async
       * @name getTransactionByNumber
       * @param {number|string} txNumber The number of transaction
       * @return {Promise<PoSTransaction>}
       * @example
       * await conflux.pos.getTransactionByNumber(8235);
       * {
       *   blockHash: '0xe684e88981b7ffe14741a2274e7b65b89ae2e133ebdd783d71ddeeacb4e957d6',
       *   blockNumber: 8243,
       *   from: '0x0000000000000000000000000000000000000000000000000000000000000000',
       *   hash: '0xaa92222b6a20342285ed56de2b77a05a6c1a9a3e4750e4952af8f908f7316b5d',
       *   number: 42480,
       *   payload: null,
       *   status: 'Executed',
       *   timestamp: 1638340649662468,
       *   type: 'BlockMetadata'
       * }
       */
      {
        method: 'pos_getTransactionByNumber',
        requestFormatters: [
          format.bigUIntHex,
        ],
        responseFormatter: format.posTransaction,
      },
      /**
       * @instance
       * @async
       * @method getRewardsByEpoch
       * @name getRewardsByEpoch
       * @param {number|string} epoch A PoS epoch number
       * @return {Promise<PoSEpochRewards>}
       * @example
       * await conflux.pos.getRewardsByEpoch(138);
       * {
       *   accountRewards: [
       *     {
       *       posAddress: '0x83ca56dd7b9d1222fff48565ed0261f42a17099061d905f9e743f89574dbd8e0',
       *       powAddress: 'NET8888:TYPE.USER:AAKFSH1RUYS4P040J5M7DJRJBGMX9ZV7HAJTFN2DKP',
       *       reward: 605265415757735647n
       *     },
       *     ... 122 more items
       *   ],
       *   powEpochHash: '0xd634c0a71c6197a6fad9f80439b31b4c7191b3ee42335b1548dad1160f7f628c'
       * }
       */
      {
        method: 'pos_getRewardsByEpoch',
        requestFormatters: [
          format.bigUIntHex,
        ],
        responseFormatter: format.rewardsByEpoch,
      },
    ];
  }
}

module.exports = PoS;


/***/ }),

/***/ 48562:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RPCMethodFactory = __webpack_require__(98173);
const format = __webpack_require__(52519);

format.actionCall = format({
  space: format.any,
  from: format.any,
  to: format.any,
  input: format.any,
  callType: format.any,
  value: format.bigUInt,
  gas: format.bigUInt,
});

format.actionCallResult = format({
  outcome: format.any,
  returnData: format.any,
  gasLeft: format.bigUInt,
});

format.actionCreate = format({
  space: format.any,
  from: format.any,
  value: format.bigUInt,
  gas: format.bigUInt,
  init: format.any,
  createType: format.any,
});

format.actionCreateResult = format({
  outcome: format.any,
  addr: format.any,
  gasLeft: format.bigUInt,
  returnData: format.any,
});

format.actionInternalTrace = format({
  from: format.any,
  fromPocket: format.any,
  fromSpace: format.any,
  to: format.any,
  toPocket: format.any,
  toSpace: format.any,
  value: format.bigUInt,
});

format.action = format({
  action: {
    from: format.any,
    to: format.any,
    fromPocket: format.any,
    toPocket: format.any,
    space: format.any, // From conflux v2.0, create/call trace will have this field
    fromSpace: format.any, // From conflux v2.0, internal_transfer_action will have this field
    toSpace: format.any, // From conflux v2.0, internal_transfer_action will have this field
    value: format.bigUInt,
    gas: format.bigUInt,
    gasLeft: format.bigUInt,
    input: format.hex,
    init: format.hex,
    returnData: format.hex,
    callType: format.any,
    createType: format.any,
    outcome: format.any,
    addr: format.any,
  },
  epochNumber: format.uInt,
  epochHash: format.hex,
  blockHash: format.hex,
  transactionHash: format.hex,
  transactionPosition: format.uInt,
  type: format.any,
  valid: format.any,
}, { pick: true });

// only used in block traces
format.txTraces = format({
  traces: [format.action],
  transactionPosition: format.uInt,
});

format.blockTraces = format({
  transactionTraces: [format.txTraces],
  epochNumber: format.uInt,
}).$or(null);

// trace array
format.traces = format([format.action]).$or(null);

format.traceFilter = format({
  fromEpoch: format.epochNumber.$or(null),
  toEpoch: format.epochNumber.$or(null),
  blockHashes: format([format.blockHash]).$or(null),
  after: format.bigUIntHex.$or(null),
  count: format.bigUIntHex.$or(null),
  actionTypes: format([format.any]).$or(null),
});

class Trace extends RPCMethodFactory {
  constructor(conflux) {
    super(conflux, Trace.methods());
    this.conflux = conflux;
  }

  static methods() {
    return [
      {
        method: 'trace_block',
        alias: 'traceBlock',
        requestFormatters: [
          format.blockHash,
        ],
        responseFormatter: format.blockTraces,
      },
      {
        method: 'trace_transaction',
        alias: 'traceTransaction',
        requestFormatters: [
          format.transactionHash,
        ],
        responseFormatter: format.traces,
      },
      {
        method: 'trace_filter',
        alias: 'traceFilter',
        requestFormatters: [
          format.traceFilter,
        ],
        responseFormatter: format.traces,
      },
    ];
  }
}

module.exports = Trace;


/***/ }),

/***/ 47401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RPCMethodFactory = __webpack_require__(98173);
const format = __webpack_require__(52519);

/**
 * Class contains txpool RPC methods
 * @class
 */
class TxPool extends RPCMethodFactory {
  /**
   * TxPool constructor.
   * @param {import('../Conflux')} conflux A Conflux instance
   * @return {TxPool} The TxPool instance
   */
  constructor(conflux) {
    super(conflux);
    this.conflux = conflux;
    super.addMethods(this.methods());
  }

  methods() {
    return [
      /**
       * Get user next nonce in transaction pool
       * @instance
       * @async
       * @name nextNonce
       * @param {string} address The address of the account
       * @return {Promise<number>} The next usable nonce
       * @example <caption>Example usage of txpool.nextNonce</caption>
       * await conflux.txpool.nextNonce('cfxtest:aak2rra2njvd77ezwjvx04kkds9fzagfe6d5r8e957');
       * // returns 100
       */
      {
        method: 'txpool_nextNonce',
        requestFormatters: [
          this.conflux._formatAddress.bind(this.conflux),
        ],
        responseFormatter: format.bigUInt,
      },
    ];
  }
}

module.exports = TxPool;


/***/ }),

/***/ 87807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const format = __webpack_require__(52519);
const CONST = __webpack_require__(46057);

const formatAccount = format({
  accumulatedInterestReturn: format.bigUInt,
  balance: format.bigUInt,
  collateralForStorage: format.bigUInt,
  nonce: format.bigUInt,
  stakingBalance: format.bigUInt,
}, {
  name: 'format.account',
});

class Account {
  static format(data) {
    return formatAccount(data);
  }

  constructor(accountMeta) {
    const {
      address,
      balance,
      nonce,
      codeHash,
      stakingBalance,
      collateralForStorage,
      accumulatedInterestReturn,
      admin,
    } = Account.format(accountMeta);
    /** @type {string} */
    this.address = address;
    /** @type {BigInt} */
    this.balance = balance;
    /** @type {BigInt} */
    this.nonce = nonce;
    /** @type {string} */
    this.codeHash = codeHash;
    /** @type {BigInt} */
    this.stakingBalance = stakingBalance;
    /** @type {BigInt} */
    this.collateralForStorage = collateralForStorage;
    /** @type {BigInt} */
    this.accumulatedInterestReturn = accumulatedInterestReturn;
    /** @type {string} */
    this.admin = admin;
    return this;
  }

  isExternalAccount() {
    return this.codeHash === CONST.KECCAK_EMPTY;
  }
}

module.exports = Account;


/***/ }),

/***/ 77466:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const format = __webpack_require__(52519);
const { validAddressPrefix } = __webpack_require__(61069);
const parser = __webpack_require__(47150);

const cfxFormat = new Proxy(() => undefined, {
  apply(target, thisArg, argArray) {
    return parser(...argArray);
  },
});

/**
 * @typedef {Object} LogFilter
 * @property {number} [limit]
 * @property {number} [offset]
 * @property {string|number} [fromEpoch]
 * @property {string|number} [toEpoch]
 * @property {string[]} [blockHashes]
 * @property {string[]|string} [address]
 * @property {string[]} [topics]
 */
cfxFormat.getLogs = format({
  limit: format.bigUIntHex,
  offset: format.bigUIntHex,
  fromEpoch: format.epochNumber,
  toEpoch: format.epochNumber,
  blockHashes: format([format.blockHash]).$or(null),
  address: format.address.$or([format.address]).$or(null),
  topics: format([format.hex64.$or([format.hex64]).$or(null)]),
}, {
  pick: true,
  name: 'format.getLogs',
});

// configure getLogs formatter with networkId and toHexAddress
cfxFormat.getLogsAdvance = function (networkId, toHexAddress = false, useVerboseAddress = false) {
  const fromatAddress = toHexAddress ? format.hexAddress : format.netAddress(networkId, useVerboseAddress);
  return format({
    limit: format.bigUIntHex,
    offset: format.bigUIntHex,
    fromEpoch: format.epochNumber,
    toEpoch: format.epochNumber,
    blockHashes: format([format.blockHash]).$or(null),
    address: format([fromatAddress]).$or(null),
    topics: format([format.hex64.$or([format.hex64]).$or(null)]),
  }, {
    pick: true,
    name: 'format.getLogsAdvance',
  });
};

cfxFormat.transactionToAddress = format(format.hexAddress.$or(null).$default(null))
  .$after(format.hexBuffer)
  .$validate(hBuf => hBuf.length === 0 || validAddressPrefix(hBuf), 'transactionToAddress');

cfxFormat.signTx = format({
  nonce: format.bigUInt.$after(format.hexBuffer),
  gasPrice: format.bigUInt.$after(format.hexBuffer),
  gas: format.bigUInt.$after(format.hexBuffer),
  to: cfxFormat.transactionToAddress,
  value: format.bigUInt.$default(0).$after(format.hexBuffer),
  storageLimit: format.bigUInt.$after(format.hexBuffer),
  epochHeight: format.bigUInt.$after(format.hexBuffer),
  chainId: format.uInt.$default(0).$after(format.hexBuffer),
  data: format.hex.$default('0x').$after(format.hexBuffer),
  r: (format.bigUInt.$after(format.hexBuffer)).$or(undefined),
  s: (format.bigUInt.$after(format.hexBuffer)).$or(undefined),
  v: (format.uInt.$after(format.hexBuffer)).$or(undefined),
}, {
  strict: true,
  pick: true,
  name: 'format.signTx',
});

/**
 * @typedef {Object} CallRequest
 * @property {string} [from]
 * @property {string} [to]
 * @property {string} [data]
 * @property {number} [value]
 * @property {number} [gas]
 * @property {number} [gasPrice]
 * @property {number} [nonce]
 * @property {number} [storageLimit]
 * @property {number} [epochHeight]
 * @property {number} [chainId]
 */
cfxFormat.callTx = format({
  from: format.address,
  nonce: format.bigUIntHex,
  gasPrice: format.bigUIntHex,
  gas: format.bigUIntHex,
  to: format.address.$or(null),
  value: format.bigUIntHex,
  storageLimit: format.bigUIntHex,
  epochHeight: format.bigUIntHex,
  chainId: format.bigUIntHex,
  data: format.hex,
}, {
  pick: true,
  name: 'format.callTx',
});

// configure callTx formatter with networkId and toHexAddress
cfxFormat.callTxAdvance = function (networkId, toHexAddress = false, useVerboseAddress = false) {
  const fromatAddress = toHexAddress ? format.hexAddress : format.netAddress(networkId, useVerboseAddress);
  return format({
    from: fromatAddress,
    nonce: format.bigUIntHex,
    gasPrice: format.bigUIntHex,
    gas: format.bigUIntHex,
    to: fromatAddress.$or(null),
    value: format.bigUIntHex,
    storageLimit: format.bigUIntHex,
    epochHeight: format.bigUIntHex,
    chainId: format.bigUIntHex,
    data: format.hex,
  }, {
    pick: true,
    name: 'format.callTxAdvance',
  });
};

// ----------------------------- parse rpc returned ---------------------------
/**
 * @typedef {Object} ChainStatus
 * @property {string} bestHash
 * @property {number} networkId
 * @property {number} chainId
 * @property {number} epochNumber
 * @property {number} blockNumber
 * @property {number} pendingTxNumber
 * @property {number} latestCheckpoint
 * @property {number} latestConfirmed
 * @property {number} latestFinalized
 * @property {number} latestState
 * @property {number} ethereumSpaceChainId
 */
cfxFormat.status = format({
  networkId: format.uInt,
  chainId: format.uInt,
  epochNumber: format.uInt,
  blockNumber: format.uInt,
  pendingTxNumber: format.uInt,
  latestCheckpoint: format.uInt.$or(null),
  latestConfirmed: format.uInt.$or(null),
  latestFinalized: format.uInt.$or(null),
  latestState: format.uInt.$or(null),
  ethereumSpaceChainId: format.uInt.$or(null),
}, {
  name: 'format.status',
});

/**
 * @typedef {Object} EstimateResult
 * @property {number} gasUsed
 * @property {number} gasLimit
 * @property {number} storageCollateralized
 */
cfxFormat.estimate = format({
  gasUsed: format.bigUInt,
  gasLimit: format.bigUInt,
  storageCollateralized: format.bigUInt,
}, {
  name: 'format.estimate',
});

/**
 * @typedef {Object} Transaction - Transaction
 * @prop {string} [blockHash=null] - hash of the block where this transaction was in and got executed. null when the transaction is pending.
 * @prop {number} chainId - the chain ID specified by the sender.
 * @prop {string} [contractCreated=null] - address of the contract created. null when it is not a contract deployment transaction.
 * @prop {string} data - the data sent along with the transaction.
 * @prop {number} epochHeight - the epoch proposed by the sender. Note that this is NOT the epoch of the block containing this transaction.
 * @prop {string} from - address of the sender.
 * @prop {number} gas - the gas limit specified by the sender.
 * @prop {number} gasPrice - the gas price specified by the sender.
 * @prop {string} hash - hash of the transaction.
 * @prop {number} nonce - the nonce specified by the sender.
 * @prop {string} [to=null] - address of the receiver. null when it is a contract creation transaction.
 * @prop {number} value - the value sent along with the transaction.
 * @prop {number} storageLimit - the storage limit specified by the sender.
 * @prop {string} r - ECDSA signature r
 * @prop {string} s - ECDSA signature s
 * @prop {number} v - ECDSA recovery v
 * @prop {number} [transactionIndex=null] - the transaction's position in the block. null when the transaction is pending.
 * @prop {number} [status=null] - 0 for success, 1 if an error occurred, 2 for skiped, null when the transaction is skipped or not packed.
 */
cfxFormat.transaction = format({
  nonce: format.bigUInt,
  gasPrice: format.bigUInt,
  gas: format.bigUInt,
  value: format.bigUInt,
  storageLimit: format.bigUInt,
  epochHeight: format.bigUInt,
  chainId: format.uInt,
  v: format.uInt,
  status: format.uInt.$or(null),
  transactionIndex: format.uInt.$or(null),
}, {
  name: 'format.transaction',
});

/**
 * @typedef {Object} Block - Block
 * @prop {boolean} adaptive - true if the weight of the block is adaptive under the GHAST rule.
 * @prop {number} blame - if 0, then this block does not blame any blocks on its parent path. If it is n > 0, then this block blames its n predecessors on its parent path, e.g. when n = 1, then the block blames its parent but not its parent's parent.
 * @prop {string} deferredLogsBloomHash - the hash of the logs bloom after deferred execution at the block's epoch (assuming it is the pivot block).
 * @prop {string} deferredReceiptsRoot - the Merkle root of the receipts after deferred execution at the block's epoch (assuming it is the pivot block).
 * @prop {string} deferredStateRoot - the hash of the state trie root triplet after deferred execution at the block's epoch (assuming it is the pivot block).
 * @prop {number} difficulty - the PoW difficulty of this block.
 * @prop {number} [epochNumber] - the number of the epoch containing this block in the node's view of the ledger. null when the epoch number is not determined (e.g. the block is not in the best block's past set).
 * @prop {number} gasLimit - the maximum gas allowed in this block.
 * @prop {number} [gasUsed=null] - the total gas used in this block. null when the block is pending.
 * @prop {string} hash - hash of the block.
 * @prop {number} height - the height of the block.
 * @prop {string} miner - the address of the beneficiary to whom the mining rewards were given.
 * @prop {number} nonce - the nonce of the block.
 * @prop {string} parentHash - hash of the parent block.
 * @prop {string} [powQuality] - the PoW quality. null when the block is pending.
 * @prop {string[]} refereeHashes - array of referee block hashes.
 * @prop {number} size - the size of this block in bytes, excluding the block header.
 * @prop {number} timestamp - the timestamp of the block.
 * @prop {string|Transaction[]} transactions - array of transaction objects, or 32-byte transaction hashes, depending on the second parameter.
 * @prop {string} transactionsRoot - the Merkle root of the transactions in this block.
 * @prop {string[]} custom - customized information. Note from v2.0 custom's type has changed from array of number array to array of hex string.
 * @prop {number} blockNumber - the number of this block's total order in the tree-graph. null when the order is not determined. Added from Conflux-rust v1.1.5
 * @prop {string} posReference - 32 Bytes - the hash of the PoS newest committed block. Added from Conflux-rust v2.0.0
 * @prop {string} prop1 - a string property of SpecialType
 * @prop {number} [prop5=42] - an optional number property of SpecialType with default
 */
cfxFormat.block = format({
  epochNumber: format.uInt.$or(null),
  blockNumber: format.uInt.$or(null),
  blame: format.uInt,
  height: format.uInt,
  size: format.uInt,
  timestamp: format.uInt,
  gasLimit: format.bigUInt,
  gasUsed: format.bigUInt.$or(null).$or(undefined), // XXX: undefined before main net upgrade
  difficulty: format.bigUInt,
  transactions: [(cfxFormat.transaction).$or(format.transactionHash)],
}, {
  name: 'format.block',
});

/**
 * @typedef {Object} TransactionReceipt - TransactionReceipt
 * @prop {string} blockHash - hash of the block where this transaction was in and got executed.
 * @prop {string} transactionHash - hash of the transaction.
 * @prop {number} index - transaction index within the block.
 * @prop {number} epochNumber - the number of the epoch containing this transaction in the node's view of the ledger.
 * @prop {string} from
 * @prop {string} [to=null] - address of the receiver. null when it is a contract deployment transaction.
 * @prop {number} gasUsed - gas used for executing the transaction.
 * @prop {number} gasFee - gas charged to the sender's account. If the provided gas (gas limit) is larger than the gas used, at most 1/4 of it is refunded.
 * @prop {boolean} gasCoveredBySponsor - true if this transaction's gas fee was covered by the sponsor.
 * @prop {number} storageCollateralized - the amount of storage collateral this transaction required.
 * @prop {boolean} storageCoveredBySponsor - true if this transaction's storage collateral was covered by the sponsor.
 * @prop {object[]} storageReleased - array of storage change objects, each specifying an address and the corresponding amount of storage collateral released, e.g., [{ 'address': 'CFX:TYPE.USER:AARC9ABYCUE0HHZGYRR53M6CXEDGCCRMMYYBJGH4XG', 'collaterals': '0x280' }]
 * @prop {string} [contractCreated=null] - address of the contract created. null when it is not a contract deployment transaction.
 * @prop {string} stateRoot - hash of the state root after the execution of the corresponding block. 0 if the state root is not available.
 * @prop {number} outcomeStatus - the outcome status code. 0x0 means success. 0x1 means failed. 0x2 means skipped
 * @prop {string} logsBloom - bloom filter for light clients to quickly retrieve related logs.
 * @prop {Log[]} logs - array of log objects that this transaction generated
 */
cfxFormat.receipt = format({
  index: format.uInt,
  epochNumber: format.uInt,
  outcomeStatus: format.uInt.$or(null),
  gasUsed: format.bigUInt,
  gasFee: format.bigUInt,
  storageCollateralized: format.bigUInt,
  storageReleased: [{
    collaterals: format.bigUInt,
  }],
}, {
  name: 'format.receipt',
});

cfxFormat.epochReceipts = format([[cfxFormat.receipt]]).$or(null);

/**
 * @typedef {Object} Log - Log
 * @prop {string} address
 * @prop {string[]} topics
 * @prop {string} data
 * @prop {string} blockHash
 * @prop {number} epochNumber
 * @prop {string} transactionHash
 * @prop {number} transactionIndex
 * @prop {number} logIndex
 * @prop {number} transactionLogIndex
 */
cfxFormat.log = format({
  epochNumber: format.uInt,
  logIndex: format.uInt,
  transactionIndex: format.uInt,
  transactionLogIndex: format.uInt,
}, {
  name: 'format.log',
});

cfxFormat.logs = format([cfxFormat.log]);

/**
 * @typedef {Object} SupplyInfo
 * @property {BigInt} totalCirculating
 * @property {BigInt} totalIssued
 * @property {BigInt} totalStaking
 * @property {BigInt} totalCollateral
 * @property {BigInt} [totalEspaceTokens]
 */
cfxFormat.supplyInfo = format({
  totalCirculating: format.bigUInt,
  totalIssued: format.bigUInt,
  totalStaking: format.bigUInt,
  totalCollateral: format.bigUInt,
  totalEspaceTokens: format.bigUInt.$or(null),
}, {
  name: 'format.supplyInfo',
});

/**
 * @typedef {Object} SponsorInfo
 * @property {BigInt} sponsorBalanceForCollateral
 * @property {BigInt} sponsorBalanceForGas
 * @property {BigInt} sponsorGasBound
 * @property {string} sponsorForCollateral
 * @property {string} sponsorForGas
 */
cfxFormat.sponsorInfo = format({
  sponsorBalanceForCollateral: format.bigUInt,
  sponsorBalanceForGas: format.bigUInt,
  sponsorGasBound: format.bigUInt,
}, {
  name: 'format.sponsorInfo',
});

/**
 * @typedef {Object} RewardInfo
 * @property {BigInt} baseReward
 * @property {BigInt} totalReward
 * @property {BigInt} txFee
 */
cfxFormat.rewardInfo = format([
  {
    baseReward: format.bigUInt,
    totalReward: format.bigUInt,
    txFee: format.bigUInt,
  },
]);

cfxFormat.voteList = format([
  {
    amount: format.bigUInt,
  },
]);

cfxFormat.depositList = format([
  {
    amount: format.bigUInt,
    accumulatedInterestRate: format.bigUInt,
  },
]);

// ---------------------------- parse subscribe event -------------------------
cfxFormat.head = format({
  difficulty: format.bigUInt,
  epochNumber: format.uInt.$or(null),
  gasLimit: format.bigUInt,
  height: format.uInt,
  timestamp: format.uInt,
}, {
  name: 'format.head',
});

cfxFormat.revert = format({
  revertTo: format.uInt,
}, {
  name: 'format.revert',
});

cfxFormat.epoch = format({
  epochNumber: format.uInt,
}, {
  name: 'format.epoch',
});

// --------------------------- accountPendingInfo & transactions --------------
cfxFormat.accountPendingInfo = format({
  localNonce: format.bigUInt,
  pendingCount: format.bigUInt,
  pendingNonce: format.bigUInt,
}, {
  name: 'format.accountPendingInfo',
});

cfxFormat.accountPendingTransactions = format({
  pendingCount: format.bigUInt,
  pendingTransactions: [cfxFormat.transaction],
}, {
  name: 'format.accountPendingTransactions',
});

/**
 * @typedef {Object} PoSEconomics
 * @property {BigInt} distributablePosInterest
 * @property {BigInt} lastDistributeBlock
 * @property {BigInt} totalPosStakingTokens
 */
cfxFormat.posEconomics = format({
  distributablePosInterest: format.bigUInt,
  lastDistributeBlock: format.bigUInt,
  totalPosStakingTokens: format.bigUInt,
}, {
  name: 'format.posEconomics',
});

module.exports = cfxFormat;


/***/ }),

/***/ 41043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.Account = __webpack_require__(87807);
exports.formatters = __webpack_require__(77466);


/***/ }),

/***/ 54727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { sleep } = __webpack_require__(61069);

class PendingTransaction {
  /**
   * PendingTransaction constructor.
   * @param {import('../Conflux')} conflux
   * @param {function} func
   * @param {array} args
   * @return {PendingTransaction}
   */
  constructor(conflux, func, args) {
    this.conflux = conflux;
    this.func = func;
    this.args = args;
    this.promise = undefined;
  }

  async then(resolve, reject) {
    this.promise = this.promise || this.func(...this.args);

    try {
      return resolve(await this.promise);
    } catch (e) {
      return reject(e);
    }
  }

  async catch(callback) {
    return this.then(v => v, callback);
  }

  async finally(callback) {
    try {
      return await this;
    } finally {
      await callback();
    }
  }

  // --------------------------------------------------------------------------
  /**
   * Get transaction by hash.
   *
   * @param {object} [options]
   * @param {number} [options.delay=0] - Defer execute after `delay` ms.
   * @return {Promise<import('../rpc/types/formatter').Transaction|null>} See [Conflux.getTransactionByHash](#Conflux.js/getTransactionByHash)
   */
  async get({ delay = 0 } = {}) {
    await sleep(delay);
    const transactionHash = await this;
    return this.conflux.getTransactionByHash(transactionHash);
  }

  /**
   * Async wait till transaction been mined.
   *
   * - blockHash !== null
   *
   * @param {object} [options]
   * @param {number} [options.delta=1000] - Loop transaction interval in ms.
   * @param {number} [options.timeout=60*1000] - Loop timeout in ms.
   * @return {Promise<import('../rpc/types/formatter').Transaction>} See [Conflux.getTransactionByHash](#Conflux.js/getTransactionByHash)
   */
  async mined({ delta = 1000, timeout = 60 * 1000 } = {}) {
    const startTime = Date.now();

    const transactionHash = await this;
    for (let lastTime = startTime; lastTime < startTime + timeout; lastTime = Date.now()) {
      const transaction = await this.get();
      if (transaction && transaction.blockHash) {
        return transaction;
      }

      await sleep(lastTime + delta - Date.now());
    }

    throw new Error(`wait transaction "${transactionHash}" mined timeout after ${Date.now() - startTime} ms`);
  }

  /**
   * Async wait till transaction been executed.
   *
   * - mined
   * - receipt !== null
   * - receipt.outcomeStatus === 0
   *
   * @param {object} [options]
   * @param {number} [options.delta=1000] - Loop transaction interval in ms.
   * @param {number} [options.timeout=5*60*1000] - Loop timeout in ms.
   * @return {Promise<import('../rpc/types/formatter').TransactionReceipt>} See [Conflux.getTransactionReceipt](#Conflux.js/getTransactionReceipt)
   */
  async executed({ delta = 1000, timeout = 5 * 60 * 1000 } = {}) {
    const startTime = Date.now();

    const transactionHash = await this;
    for (let lastTime = startTime; lastTime < startTime + timeout; lastTime = Date.now()) {
      const receipt = await this.conflux.getTransactionReceipt(transactionHash);
      if (receipt) {
        if (receipt.outcomeStatus !== 0) {
          throw new Error(`transaction "${transactionHash}" executed failed, outcomeStatus ${receipt.outcomeStatus}`);
        }
        return receipt;
      }

      await sleep(lastTime + delta - Date.now());
    }

    throw new Error(`wait transaction "${transactionHash}" executed timeout after ${Date.now() - startTime} ms`);
  }

  /**
   * Async wait till transaction been confirmed.
   *
   * - executed
   * - transaction block risk coefficient < threshold
   *
   * @param {object} [options]
   * @param {number} [options.delta=1000] - Loop transaction interval in ms.
   * @param {number} [options.timeout=30*60*1000] - Loop timeout in ms.
   * @param {number} [options.threshold=1e-8] - Number in range (0,1)
   * @return {Promise<import('../rpc/types/formatter').TransactionReceipt>} See [Conflux.getTransactionReceipt](#Conflux.js/getTransactionReceipt)
   */
  async confirmed({ delta = 1000, timeout = 30 * 60 * 1000, threshold = 1e-8 } = {}) {
    const startTime = Date.now();

    const transactionHash = await this;
    for (let lastTime = startTime; lastTime < startTime + timeout; lastTime = Date.now()) {
      const receipt = await this.executed({ delta, timeout }); // must get receipt every time, cause blockHash might change
      const risk = await this.conflux.getConfirmationRiskByHash(receipt.blockHash);
      if (risk <= threshold) {
        return receipt;
      }

      await sleep(lastTime + delta - Date.now());
    }

    throw new Error(`wait transaction "${transactionHash}" confirmed timeout after ${Date.now() - startTime} ms`);
  }
}

module.exports = PendingTransaction;


/***/ }),

/***/ 86420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const EventEmitter = __webpack_require__(82361);

/**
 * Subscription event emitter
 */
class Subscription extends EventEmitter {
  constructor(id) {
    super();
    this.id = id;
  }

  toString() {
    return this.id;
  }
}

module.exports = Subscription;


/***/ }),

/***/ 92808:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { assert } = __webpack_require__(61069);
const { WORD_CHARS } = __webpack_require__(46057);

class HexStream {
  constructor(hex) {
    this.string = hex;
    this.index = hex.startsWith('0x') ? 2 : 0;
  }

  eof() {
    return this.index >= this.string.length;
  }

  read(length, alignLeft = false) {
    assert(Number.isInteger(length) && 0 <= length, {
      message: 'invalid length',
      expect: 'integer && >= 0',
      got: length,
      stream: this,
    });

    const size = Math.ceil(length / WORD_CHARS) * WORD_CHARS;
    const string = alignLeft
      ? this.string.substr(this.index, length)
      : this.string.substr(this.index + (size - length), length);

    assert(string.length === length, {
      message: 'length not match',
      expect: length,
      got: string.length,
      stream: this,
    });

    this.index += size;
    return string;
  }
}

module.exports = HexStream;


/***/ }),

/***/ 1318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  encode,
  decode,
  isValidCfxAddress,
  verifyCfxAddress,
  hasNetworkPrefix,
  simplifyCfxAddress,
  shortenCfxAddress,
  isZeroAddress,
  isInternalContractAddress,
  isValidHexAddress,
  isValidCfxHexAddress,
} = __webpack_require__(40376);
const { checksumAddress, keccak256 } = __webpack_require__(43089);
const { ADDRESS_TYPES } = __webpack_require__(46057);

/**
 * Makes a ethereum checksum address
 *
 * > Note: support [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md)
 * > Note: not support [RSKIP60](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP60.md) yet
 *
 * @param {string} address - Hex string
 * @return {string}
 *
 * @example
 * > ethChecksumAddress('0x1b716c51381e76900ebaa7999a488511a4e1fd0a')
 "0x1B716c51381e76900EBAA7999A488511A4E1fD0a"
 */
function ethChecksumAddress(address) {
  return checksumAddress(address);
}

/**
 * Convert an ethereum address to conflux hex address by replace it's first letter to 1
 * @param {string} address
 * @return {string}
 */
function ethAddressToCfxAddress(address) {
  return `0x1${address.toLowerCase().slice(3)}`;
}

/**
 * Calculate CFX space address's mapped EVM address
 * @param {string} address - base32 string
 * @returns {string}
 *
 * @example
 * > cfxMappedEVMSpaceAddress(cfx:aak2rra2njvd77ezwjvx04kkds9fzagfe6ku8scz91)
 * "0x12Bf6283CcF8Ad6ffA63f7Da63EDc217228d839A"
 */
function cfxMappedEVMSpaceAddress(address) {
  const { hexAddress } = decode(address);
  const mappedBuf = keccak256(hexAddress).slice(-20);
  return checksumAddress(`0x${mappedBuf.toString('hex')}`);
}

module.exports = {
  encodeCfxAddress: encode,
  decodeCfxAddress: decode,
  ethChecksumAddress,
  ethAddressToCfxAddress,
  cfxMappedEVMSpaceAddress,
  ADDRESS_TYPES,
  isValidCfxAddress,
  verifyCfxAddress,
  hasNetworkPrefix,
  simplifyCfxAddress,
  shortenCfxAddress,
  isZeroAddress,
  isInternalContractAddress,
  isValidHexAddress,
  isValidCfxHexAddress,
};


/***/ }),

/***/ 19066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const lodash = __webpack_require__(76635);

function callable(object, func) {
  if (!lodash.isFunction(func)) {
    throw new Error('except to be function');
  }

  return new Proxy(func, {
    getPrototypeOf: () => Object.getPrototypeOf(object),
    // setPrototypeOf
    // isExtensible
    // preventExtensions
    getOwnPropertyDescriptor: (_, key) => Object.getOwnPropertyDescriptor(object, key),
    has: (_, key) => (Reflect.has(object, key) || Reflect.has(func, key)),
    get: (_, key) => (Reflect.has(object, key) ? Reflect.get(object, key) : Reflect.get(func, key)),
    set: (_, key, value) => Reflect.set(object, key, value),
    deleteProperty: (_, key) => Reflect.deleteProperty(object, key),
    defineProperty: (_, key, attributes) => Reflect.defineProperty(object, key, attributes),
    ownKeys: () => Reflect.ownKeys(object),
    // apply
    // construct
  });
}

module.exports = callable;


/***/ }),

/***/ 52519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const Big = __webpack_require__(89063);
const lodash = __webpack_require__(76635);
const CONST = __webpack_require__(46057);
const JSBI = __webpack_require__(31629);
const parser = __webpack_require__(47150);
const sign = __webpack_require__(43089);
const addressUtil = __webpack_require__(1318);
const { isHexString, isBytes } = __webpack_require__(61069);

// ----------------------------------------------------------------------------
function toHex(value) {
  let hex;

  if (lodash.isString(value)) {
    hex = value.toLowerCase(); // XXX: lower case for support checksum address
  } else if (Number.isInteger(value) || (typeof value === 'bigint') || (value instanceof JSBI)) {
    hex = `0x${value.toString(16)}`;
  } else if (Buffer.isBuffer(value)) {
    hex = `0x${value.toString('hex')}`;
  } else if (lodash.isBoolean(value)) {
    hex = value ? '0x01' : '0x00';
  } else if (value === null) {
    hex = '0x';
  } else {
    hex = `${value}`;
  }

  if (!/^0x[0-9a-f]*$/.test(hex)) {
    throw new Error(`${value} not match "hex"`);
  }
  return hex.length % 2 ? `0x0${hex.slice(2)}` : hex;
}

function toNumber(value) {
  if (value === null) {
    throw new Error(`${value} not match "number"`);
  } else if (Buffer.isBuffer(value)) {
    value = `0x${value.toString('hex')}`;
  }
  return Number(value);
}

function toBigInt(value) {
  if (Number.isInteger(value) || (typeof value === 'bigint') || (value instanceof JSBI)) {
    return JSBI.BigInt(value);
  }
  if (lodash.isBoolean(value)) {
    throw new Error(`${value} not match "BigInt"`);
  }
  if (Buffer.isBuffer(value)) {
    throw new Error(`${value} not match "BigInt"`);
  }

  value = `${value}`.replace(/^(-?\d+)(.0+)?$/, '$1'); // replace "number.000" to "number"
  return JSBI.BigInt(value);
}

function toBig(value) {
  if (/^0[xob]/i.test(value)) {
    value = JSBI.BigInt(value);
  }
  return new Big(value);
}

// ----------------------------------------------------------------------------
const format = new Proxy(() => undefined, {
  apply(target, thisArg, argArray) {
    return parser(...argArray);
  },
});

/**
 * @param {any} arg
 * @return {any} arg
 *
 * @example
 * > format.any(1)
 1
 */
format.any = format(v => v, { name: 'format.any' });

/**
 * @param {number|BigInt|string|boolean} arg
 * @return {Number}
 *
 * @example
 * > format.uInt(-3.14)
 Error("not match uint")
 * > format.uInt(null)
 Error("not match number")
 * > format.uInt('0')
 0
 * > format.uInt(1)
 1
 * > format.uInt(BigInt(100))
 100
 * > format.uInt('0x10')
 16
 * > format.uInt('')
 0
 * > format.uInt(true)
 1
 * > format.uInt(false)
 0
 * > format.uInt(Number.MAX_SAFE_INTEGER + 1) // unsafe integer
 Error("not match uint")
 */
format.uInt = format(toNumber, { name: 'format.uInt' }).$validate(v => Number.isSafeInteger(v) && v >= 0, 'uint');

/**
 * @param {number|string|BigInt} arg
 * @return {BigInt}
 *
 * @example
 * > format.bigInt(-3.14)
 Error("Cannot convert -3.14 to a BigInt")
 * > format.bigInt('0.0')
 0n
 * > format.bigInt('-1')
 -1n
 * > format.bigInt(1)
 1n
 * > format.bigInt(BigInt(100))
 100n
 * > format.bigInt('0x10')
 16n
 * > format.bigInt(Number.MAX_SAFE_INTEGER + 1) // unsafe integer
 9007199254740992n
 */
format.bigInt = format(toBigInt, { name: 'format.bigInt' });

format.bigIntFromBuffer = format.bigInt.$before(v => (v.length === 0 ? '0x0' : format.hex(v)));

/**
 * @param {number|string|BigInt} arg
 * @return {BigInt}
 *
 * @example
 * > format.bigUInt('0.0')
 0n
 * > format.bigUInt('-1')
 Error("not match bigUInt")
 */
format.bigUInt = format.bigInt.$validate(v => v >= 0, 'bigUInt');

/**
 * When encoding QUANTITIES (integers, numbers): encode as hex, prefix with "0x", the most compact representation (slight exception: zero should be represented as "0x0")
 *
 * @param {number|string|BigInt} arg
 * @return {string} Hex string
 *
 * @example
 * > format.bigUIntHex(100)
 "0x64"
 * > format.bigUIntHex('0x0a')
 "0xa"
 * > format.bigUIntHex(-1))
 Error("not match uintHex")
 */
format.bigUIntHex = format.bigUInt.$after(v => `0x${v.toString(16)}`);

/**
 * @param {number|string|BigInt} arg
 * @return {Big} Big instance
 *
 * @example
 * > format.big('0b10').toString()
 '2'
 * > format.big('0O10').toString()
 '8'
 * > format.big('010').toString()
 '10'
 * > format.big('0x10').toString()
 '16'
 * > format.big(3.14).toString()
 '3.14'
 * > format.big('-03.140').toString()
 '-3.14'
 * > format.big(null)
 Error('Invalid number')
 */
format.big = format(toBig, { name: 'format.big' });

/**
 * @param {string|number|BigInt|Big} arg
 * @return {Number}
 *
 * @example
 * > format.fixed64('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')
 1
 * > format.fixed64('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')
 0.5
 */
format.fixed64 = format.big.$after(v => Number(v.div(CONST.MAX_UINT)));

/**
 * @param {number|string} arg - number or label, See [EPOCH_NUMBER](Misc.md#CONST.js/EPOCH_NUMBER)
 * @return {string}
 *
 * @example
 * > format.epochNumber(10)
 "0xa"
 * > format.epochNumber(EPOCH_NUMBER.LATEST_STATE)
 "latest_state"
 * > format.epochNumber('latest_mined')
 "latest_mined"
 */
format.epochNumber = format.bigUIntHex
  .$or(CONST.EPOCH_NUMBER.LATEST_MINED)
  .$or(CONST.EPOCH_NUMBER.LATEST_STATE)
  .$or(CONST.EPOCH_NUMBER.LATEST_FINALIZED)
  .$or(CONST.EPOCH_NUMBER.LATEST_CONFIRMED)
  .$or(CONST.EPOCH_NUMBER.LATEST_CHECKPOINT)
  .$or(CONST.EPOCH_NUMBER.EARLIEST);

format.epochNumberOrUndefined = format.epochNumber.$or(undefined);

/**
 * When encoding UNFORMATTED DATA (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with "0x", two hex digits per byte.
 *
 * @param {number|BigInt|string|Buffer|boolean|null} arg
 * @return {string} Hex string
 *
 * @example
 * > format.hex(null)
 '0x'
 * > format.hex(1)
 "0x01"
 * > format.hex(256)
 "0x0100"
 * > format.hex(true)
 "0x01"
 * > format.hex(Buffer.from([1,10,255]))
 "0x010aff"
 * > format.hex("0x0a")
 "0x0a"
 */
format.hex = format(toHex, { name: 'format.hex' });

format.hex40 = format.hex.$validate(v => v.length === 2 + 40, 'hex40');

function toAddress(address, networkId, verbose = false) {
  // if is an (Account) object, convert it to string (address)
  if (lodash.isObject(address) && addressUtil.hasNetworkPrefix(address.toString())) {
    address = address.toString();
  }
  if (lodash.isString(address) && addressUtil.hasNetworkPrefix(address)) {
    const _decodedAddress = addressUtil.decodeCfxAddress(address);
    address = _decodedAddress.hexAddress;
    networkId = networkId || _decodedAddress.netId;
  }
  address = format.hexBuffer(address);
  if (address.length !== 20) {
    throw new Error('not match "hex40"');
  }
  if (typeof networkId === 'undefined') {
    throw new Error('expected parameter: networkId');
  }
  return addressUtil.encodeCfxAddress(address, networkId, verbose);
}

/**
 * Checks if a given string is a valid address.
 *
 * @param {string|Buffer} address
 * @param {number} networkId
 * @param {boolean} [verbose=false] - if you want a address with type info, pass true
 * @return {string} Hex string
 *
 * @example
 * > format.address('0x0123456789012345678901234567890123456789', 1)
 "cfxtest:aaawgvnhveawgvnhveawgvnhveawgvnhvey1umfzwp"
 * > format.address('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 Error("not match address")
 */
format.address = format(toAddress, { name: 'format.address' });

/**
 * create a address formatter with networkId info
 */
format.netAddress = (networkId, verbose = false) => format(address => toAddress(address, networkId, verbose));

/**
 * Checks if a given string is a valid hex address.
 * It will also check the checksum, if the address has upper and lowercase letters.
 *
 * @param {string|Buffer} address
 * @return {string} Hex string
 *
 * @example
 * > format.hexAddress('0x0123456789012345678901234567890123456789')
 "0x0123456789012345678901234567890123456789"
 * > format.hexAddress('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 Error("not match address")
 * > format.hexAddress('cfxtest:aaawgvnhveawgvnhveawgvnhveawgvnhvey1umfzwp')
 0x0123456789012345678901234567890123456789
 */
format.hexAddress = format.hex40.$before(address => {
  if (lodash.isString(address) && addressUtil.hasNetworkPrefix(address)) {
    address = addressUtil.decodeCfxAddress(address).hexAddress;
  }

  if (isHexString(address) && address.length !== 2 + 40) {
    throw new Error('not match "hex40"');
  }

  if (isHexString(address)
    && address !== address.toLowerCase()
    && address !== address.toUpperCase()
    && address !== sign.checksumAddress(address)
  ) {
    throw new Error(`address "${address}" checksum error`);
  }

  return address;
});

/**
 * Will convert an upper or lowercase address to a checksum address.
 *
 * @deprecated Please use address.ethChecksumAddress
 * @param {string|Buffer} arg
 * @return {string} Checksum address hex string
 *
 * @example
 * > format.checksumAddress('0x1b716c51381e76900ebaa7999a488511a4e1fd0a')
 "0x1B716c51381e76900EBAA7999A488511A4E1fD0a"
 * > format.checksumAddress('0X1B716C51381E76900EBAA7999A488511A4E1FD0A')
 "0x1B716c51381e76900EBAA7999A488511A4E1fD0a"
 * > format.checksumAddress('0x1B716c51381e76900EBAA7999A488511A4E1fD0A')
 "0x1B716c51381e76900EBAA7999A488511A4E1fD0a"
 */
format.checksumAddress = format.hex40.$after(sign.checksumAddress);

/** @type {(a: string|Buffer) => string} */
format.hex64 = format.hex.$validate(v => v.length === 2 + 64, 'hex64');

/**
 * @param {string|Buffer} arg
 * @return {string} Hex string
 *
 * @example
 * > format.privateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
 * > format.privateKey('0x0123456789012345678901234567890123456789')
 Error("not match hex64")
 */
format.blockHash = v => format.hex64(v); // alias

/**
 * @param {string|Buffer} arg
 * @return {string} Hex string
 *
 * @example
 * > format.privateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
 * > format.privateKey('0x0123456789012345678901234567890123456789')
 Error("not match hex64")
 */
format.transactionHash = v => format.hex64(v); // alias

/**
 * @param {string|Buffer} arg
 * @return {string} Hex string
 *
 * @example
 * > format.privateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
 * > format.privateKey('0x0123456789012345678901234567890123456789')
 Error("not match hex64")
 */
format.privateKey = v => format.hex64(v); // alias

/**
 * @param {string|Buffer} arg
 * @return {string} Hex string
 *
 * @example
 * > format.publicKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
 * > format.publicKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
 Error("not match publicKey")
 */
format.publicKey = format.hex.$validate(v => v.length === 2 + 128, 'publicKey');

/**
 * @param {number|string|BigInt|Buffer|boolean|null} arg
 * @return {Buffer}
 *
 * @example
 * > format.hexBuffer(Buffer.from([0, 1]))
 <Buffer 00 01>
 * > format.hexBuffer(null)
 <Buffer >
 * > format.hexBuffer(1024)
 <Buffer 04 00>
 * > format.hexBuffer('0x0a')
 <Buffer 0a>
 * > format.hexBuffer(true)
 <Buffer 01>
 * > format.hexBuffer(3.14)
 Error("not match hex")
 */
format.hexBuffer = format.hex.$after(v => Buffer.from(v.substr(2), 'hex'));

/**
 * It can only be in hex format If want to pass a string
 *
 * @param {string|Buffer|array} arg
 * @return {Buffer}
 *
 * @example
 * > format.bytes('0xabcd')
 <Buffer ab cd>
 * > format.bytes([0, 1])
 <Buffer 00 01>
 * > format.bytes(Buffer.from([0, 1]))
 <Buffer 00 01>
 */
format.bytes = format(v => {
  if (isHexString(v)) return format.hexBuffer(v);
  if (Buffer.isBuffer(v) || isBytes(v)) return Buffer.from(v);
  throw new Error('invalid arrayify value');
}, { name: 'format.bytes' });

/**
 * @param {boolean} arg
 * @return {boolean}
 *
 * @example
 * > format.boolean(true)
 true
 * > format.boolean(false)
 false
 */
format.boolean = format.any.$validate(lodash.isBoolean, 'boolean');

/**
 * Compute the keccak256 cryptographic hash of a value, returned as a hex string.
 *
 * @param {string|Buffer} arg
 * @return {string}
 *
 * @example
 * > format.keccak256('Transfer(address,address,uint256)')
 "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"

 * > format.keccak256(Buffer.from([0x42]))
 "0x1f675bff07515f5df96737194ea945c36c41e7b4fcef307b7cd4d0e602a69111"
 * > format.keccak256(format.hexBuffer('0x42'))
 "0x1f675bff07515f5df96737194ea945c36c41e7b4fcef307b7cd4d0e602a69111"
 * > format.keccak256('0x42') // "0x42" as string and transfer to <Buffer 30 78 34 32> by ascii
 "0x3c1b2d38851281e9a7b59d10973b0c87c340ff1e76bde7d06bf6b9f28df2b8c0"
 */
format.keccak256 = format.bytes.$before(v => (lodash.isString(v) && !isHexString(v) ? Buffer.from(v) : v)).$after(sign.keccak256).$after(format.hex);

module.exports = format;


/***/ }),

/***/ 61069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const lodash = __webpack_require__(76635);
const { WORD_BYTES } = __webpack_require__(46057);

function assert(bool, value) {
  if (!bool) {
    if (lodash.isPlainObject(value)) {
      value = JSON.stringify(value);
    }
    throw new Error(value);
  }
}

/**
 * @param {Buffer} buffer
 * @param {boolean} alignLeft
 * @return {Buffer}
 */
function alignBuffer(buffer, alignLeft = false) {
  const count = WORD_BYTES - (buffer.length % WORD_BYTES);
  if (0 < count && count < WORD_BYTES) {
    buffer = alignLeft
      ? Buffer.concat([buffer, Buffer.alloc(count)])
      : Buffer.concat([Buffer.alloc(count), buffer]);
  }

  return buffer;
}

function awaitTimeout(promise, timeout) {
  return new Promise((resolve, reject) => {
    const error = new Error(`Timeout after ${timeout} ms`);
    const timer = setTimeout(() => reject(error), timeout);
    promise.then(resolve).catch(reject).finally(() => clearTimeout(timer));
  });
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function decodeHexEncodedStr(hexEncodedStr) {
  return Buffer.from(hexEncodedStr.slice(2), 'hex').toString();
}

function isHexString(v) {
  return lodash.isString(v) && v.match(/^0x[0-9A-Fa-f]*$/);
}

function isBytes(value) {
  if (value == null) { return false; }
  if (value.constructor === Uint8Array) { return true; }
  if (typeof value === 'string') { return false; }
  if (value.length == null) { return false; }

  // eslint-disable-next-line no-plusplus
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (typeof v !== 'number' || v < 0 || v >= 256 || (v % 1)) {
      return false;
    }
  }
  return true;
}

function validAddressPrefix(addressBuf) {
  // eslint-disable-next-line no-bitwise
  const prefix = addressBuf[0] & 0xf0;
  return prefix === 0x10 || prefix === 0x80 || prefix === 0x00;
}

module.exports = {
  assert,
  alignBuffer,
  awaitTimeout,
  decodeHexEncodedStr,
  isHexString,
  isBytes,
  validAddressPrefix,
  sleep,
};


/***/ }),

/***/ 31629:
/***/ ((module) => {

/**
 * support interface of [jsbi](https://github.com/GoogleChromeLabs/jsbi#readme)
 * - for node.js using native BigInt as JSBI.BigInt
 * - for browser using browserify to replace with jsbi
 */

/* eslint-disable no-bitwise */
module.exports = BigInt;
module.exports.BigInt = BigInt;

module.exports.toNumber = x => Number(x);

module.exports.unaryMinus = x => -x;
module.exports.bitwiseNot = x => ~x;

module.exports.exponentiate = (x, y) => x ** y;
module.exports.multiply = (x, y) => x * y;
module.exports.divide = (x, y) => x / y;
module.exports.remainder = (x, y) => x % y;
module.exports.add = (x, y) => x + y;
module.exports.subtract = (x, y) => x - y;
module.exports.leftShift = (x, y) => x << y;
module.exports.signedRightShift = (x, y) => x >> y;

module.exports.lessThan = (x, y) => x < y;
module.exports.lessThanOrEqual = (x, y) => x <= y;
module.exports.greaterThan = (x, y) => x > y;
module.exports.greaterThanOrEqual = (x, y) => x >= y;
module.exports.equal = (x, y) => x === y;
module.exports.notEqual = (x, y) => x !== y;

module.exports.bitwiseAnd = (x, y) => x & y;
module.exports.bitwiseXor = (x, y) => x ^ y;
module.exports.bitwiseOr = (x, y) => x | y;

module.exports.ADD = (x, y) => x + y;
module.exports.LT = (x, y) => x < y;
module.exports.LE = (x, y) => x <= y;
module.exports.GT = (x, y) => x > y;
module.exports.GE = (x, y) => x >= y;
module.exports.EQ = (x, y) => x === y;
module.exports.NE = (x, y) => x !== y;


/***/ }),

/***/ 75689:
/***/ ((module) => {

/**
 * Make a NamedTuple Class
 * @typedef {Object} NamedTuple
 * @template NamedTuple
 * @param {string[]} names
 * @returns {NamedTuple}
 *
 * @example
 * > Student = namedTuple('name', 'age')
 * > student = new Student('Tom', 18)
 * > Array.isArray(student)
 true
 * > student
 NamedTuple(name,age) [ 'Tom', 18 ]
 * > student.toObject()
 { name: 'Tom', age: 18 }
 * > student.name
 "Tom"
 * > student.age
 18
 * > student.age = 19
 Error: can not change element to a NamedTuple
 */
function namedTuple(...names) {
  const _nameToIndex = {};
  names.forEach((name, index) => {
    _nameToIndex[name] = index;
  });

  class NamedTuple extends Array {
    constructor(...args) {
      super(args.length);
      args.forEach((v, i) => Reflect.set(this, i, v)); // XXX: new Array(0) === []

      return new Proxy(this, {
        has: (_, key) => {
          const index = _nameToIndex[key];
          return index !== undefined ? true : (key in this);
        },
        get: (_, key) => {
          const index = _nameToIndex[key];
          return index === undefined ? this[key] : this[index];
        },
        set: () => {
          throw new Error('can not change element to a NamedTuple');
        },
        deleteProperty: () => {
          throw new Error('can not delete element to a NamedTuple');
        },
      });
    }

    static get name() {
      return `NamedTuple(${names.join(',')})`;
    }

    static fromObject(object) {
      return new this(...names.map(name => object[name]));
    }

    toObject() {
      const obj = {};
      names.forEach(name => {
        obj[name] = this[name];
      });
      return obj;
    }
  }

  return NamedTuple;
}

module.exports = namedTuple;


/***/ }),

/***/ 47150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* copy from koaflow@0.6.2/lib/parser */
const lodash = __webpack_require__(76635);
const { PARSER_ERROR } = __webpack_require__(95056);

class ParserError extends Error {
  constructor(message, options = {}) {
    super();
    this.message = message;
    this.code = PARSER_ERROR;
    Object.assign(this, options);
  }
}

class ParserContext {
  constructor(origin) {
    this.arguments = origin;
    this.path = [];
  }

  child(key) {
    const context = new ParserContext(this.arguments);
    context.path = [...this.path, key];
    return context;
  }

  error(message, options = {}) {
    message = `(Invalid input|args) ${message}`;
    if (this.path.length > 0) {
      message = `${message}; path="${this.path.join('.')}"`;
    }
    return new ParserError(message, { ...this, ...options });
  }
}

// ----------------------------------------------------------------------------
function Parser(func) {
  function parser(...args) {
    // eslint-disable-next-line prefer-rest-params
    const context = (this instanceof ParserContext) ? this : new ParserContext(arguments);
    return func.call(context, ...args);
    /* try {
      return func.call(context, ...args);
    } catch (e) {
      throw new ParserError(e.message, e); // create Error here for shallow stack
    } */
  }

  parser.constructor = Parser;
  parser.$before = $before;
  parser.$parse = $parse;
  parser.$default = $default;
  parser.$after = $after;
  parser.$validate = $validate;
  parser.$or = $or;
  return parser;
}

function $before(func) {
  const parser = this;
  return Parser(function (...args) {
    let value;
    try {
      value = func(...args);
    } catch (e) {
      throw this.error(e.message);
    }
    return parser.call(this, value);
  });
}

function $default(data) {
  return $before.call(this, value => (value === undefined ? data : value));
}

function $parse(func, condition = lodash.isString) {
  return $before.call(this, value => (condition(value) ? func(value) : value));
}

function $after(func) {
  const parser = this;
  return Parser(function (...args) {
    const value = parser.call(this, ...args);
    try {
      return func(value);
    } catch (e) {
      throw this.error(e.message);
    }
  });
}

function $validate(func, name) {
  return $after.call(this, value => {
    if (!func(value)) {
      throw new Error(`${value} do not match "${name || func.name || '$validate'}"`);
    }
    return value;
  });
}

function $or(schema) {
  const parserArray = [this, Parser.from(schema)];

  return Parser(function (value) {
    const errorArray = [];
    for (const parser of parserArray) {
      try {
        return parser.call(this, value);
      } catch (e) {
        errorArray.push(e);
      }
    }

    const or = errorArray.map(e => (e.or ? e.or : e));
    const message = lodash.flattenDeep(or).map(e => `(${e.message})`).join(' or ');
    throw new ParserError(`not match any ${message}`, { or });
  });
}

// ----------------------------------------------------------------------------
Parser.fromArray = function (schema, options) {
  const parser = Parser.from(schema.length ? schema[0] : v => v, options);

  return Parser(function (array) {
    if (!Array.isArray(array)) {
      throw this.error(`expected array, got ${typeof array}`);
    }

    return array.map((v, i) => parser.call(this.child(i), v));
  });
};

Parser.fromObject = function (schema, options) {
  const { strict, pick } = options;

  const keyToParser = lodash.mapValues(schema, s => Parser.from(s, options));

  return Parser(function (object) {
    if (!lodash.isObject(object)) {
      const errMsg = `"${options.name ? options.name : ''}" expected plain object, got "${typeof object}"`;
      throw this.error(errMsg);
    }

    const result = lodash.mapValues(keyToParser, (parser, k) => {
      const v = lodash.get(object, k);
      if (v === undefined && !strict) {
        return undefined;
      }
      return parser.call(this.child(k), v);
    });

    return pick ? lodash.pickBy(result, v => v !== undefined) : { ...object, ...result };
  });
};

Parser.fromFunction = function (func, options) {
  if (func.constructor === Parser) {
    return func;
  }
  return Parser(function (...args) {
    try {
      return func(...args);
    } catch (e) {
      const errMsg = `formatter: "${options.name || func.name}"; args: (${stringifyArgs(args)}) ; errorMessage: ${e.message}`;
      throw this.error(errMsg, { stack: e.stack });
    }
  });
};

Parser.fromValue = function (schema) {
  return Parser(function (value) {
    if (value !== schema) {
      throw this.error(`expected to be ${schema}, got ${value}`);
    }
    return value;
  });
};

Parser.from = function (schema, options = {}) {
  if (Array.isArray(schema)) {
    return Parser.fromArray(schema, options);
  }
  if (lodash.isPlainObject(schema)) {
    return Parser.fromObject(schema, options);
  }
  if (lodash.isFunction(schema)) {
    return Parser.fromFunction(schema, options);
  }
  return Parser.fromValue(schema);
};

function stringifyArgs(args) {
  function stringifyNullOrUndefined(v) {
    // eslint-disable-next-line no-nested-ternary
    return v === null ? 'null' : v === undefined ? 'undefined' : v;
  }
  return args.map(stringifyNullOrUndefined).join(',');
}

module.exports = Parser.from;


/***/ }),

/***/ 96814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const { decode } = __webpack_require__(60505);
/*
  prefix    | delta | note          | code
  ----------|-------|---------------|--------------------------------------------------------------
  0x00~0x7f |   127 | single buffer | <buffer[0]>
  0x80~0xb7 |    55 | short buffer  | <0x80+length(buffer)>, ...<buffer>
  0xb8~0xbf |     7 | long buffer   | <0xb8+length(length(buffer))>, ...<length(buffer)>, ...<buffer>
  0xc0~0xf7 |    55 | short array   | <0xc0+length(array.bytes)>, ...<array.bytes>
  0xf8~0xff |     7 | long array    | <0xf8+length(length(array.bytes))>, ...<length(array.bytes)>, ...<array.bytes>
 */

const SHORT_RANGE = 55;
const BUFFER_OFFSET = 0x80;
const ARRAY_OFFSET = 0xc0;

function concat(...args) {
  return Buffer.concat(args.map(value => {
    if (Buffer.isBuffer(value)) {
      return value;
    }

    if (Number.isSafeInteger(value) && value >= 0) {
      const hex = value.toString(16);
      return Buffer.from(hex.length % 2 ? `0${hex}` : hex, 'hex');
    }

    throw new Error(`invalid value, expect unsigned integer or buffer, got ${value}`);
  }));
}

// ----------------------------------------------------------------------------
/**
 * @param {Array|Buffer} value
 * @return {Buffer}
 */
function encode(value) {
  if (Buffer.isBuffer(value)) {
    return encodeBuffer(value);
  }

  if (Array.isArray(value)) {
    return encodeArray(value);
  }

  throw new Error(`invalid value, expect buffer or array, got ${value}`);
}

/**
 * @param {number} length
 * @param {number} offset - Enum of [BUFFER_OFFSET=0x80, ARRAY_OFFSET=0xc0]
 * @return {Buffer}
 */
function encodeLength(length, offset) {
  if (length <= SHORT_RANGE) {
    return concat(length + offset);
  } else {
    const lengthBuffer = concat(length);
    return concat(offset + SHORT_RANGE + lengthBuffer.length, lengthBuffer);
  }
}

/**
 * @param {Buffer} buffer
 * @return {Buffer}
 */
function encodeBuffer(buffer) {
  if (buffer.length === 1 && buffer[0] === 0) {
    buffer = Buffer.from('');
  }

  return buffer.length === 1 && buffer[0] < BUFFER_OFFSET
    ? buffer
    : concat(encodeLength(buffer.length, BUFFER_OFFSET), buffer);
}

/**
 * @param {Array} array
 * @return {Buffer}
 */
function encodeArray(array) {
  const buffer = concat(...array.map(encode));
  return concat(encodeLength(buffer.length, ARRAY_OFFSET), buffer);
}

// TODO decode

module.exports = { encode, decode };


/***/ }),

/***/ 43089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const crypto = __webpack_require__(6113);
const keccak = __webpack_require__(88562);
const secp256k1 = __webpack_require__(62970);
const { syncScrypt: scrypt } = __webpack_require__(14689);
const { isHexString } = __webpack_require__(61069);

// ----------------------------------------------------------------------------
/**
 * keccak 256
 *
 * @param {Buffer} buffer
 * @return {Buffer}
 *
 * @example
 * > keccak256(Buffer.from(''))
 <Buffer c5 d2 46 01 86 f7 23 3c 92 7e 7d b2 dc c7 03 c0 e5 00 b6 53 ca 82 27 3b 7b fa d8 04 5d 85 a4 70>
 */
function keccak256(buffer) {
  return keccak('keccak256').update(buffer).digest();
}

/**
 * Makes a checksum address
 *
 * > Note: support [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md)
 * > Note: not support [RSKIP60](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP60.md) yet
 *
 * @deprecated Please use address.ethChecksumAddress
 * @param {string} address - Hex string
 * @return {string}
 *
 * @example
 * > checksumAddress('0x1b716c51381e76900ebaa7999a488511a4e1fd0a')
 "0x1B716c51381e76900EBAA7999A488511A4E1fD0a"
 */
function checksumAddress(address) {
  const string = address.toLowerCase().replace('0x', '');

  const hash = keccak256(Buffer.from(string)).toString('hex');
  const sequence = Object.entries(string).map(([index, char]) => {
    return parseInt(hash[index], 16) >= 8 ? char.toUpperCase() : char;
  });
  return `0x${sequence.join('')}`;
}

// ----------------------------------------------------------------------------
/**
 * gen a random buffer with `size` bytes.
 *
 * > Note: call `crypto.randomBytes`
 *
 * @param {number} size
 * @return {Buffer}
 *
 * @example
 * > randomBuffer(0)
 <Buffer >
 * > randomBuffer(1)
 <Buffer 33>
 * > randomBuffer(1)
 <Buffer 5a>
 */
function randomBuffer(size) {
  return crypto.randomBytes(size);
}

/**
 * Gen a random PrivateKey buffer.
 *
 * @param {Buffer} entropy
 * @return {Buffer}
 *
 * @example
 * > randomPrivateKey()
 <Buffer 23 fb 3b 2b 1f c9 36 8c a4 8e 5b dc c7 a9 e2 bd 67 81 43 3b f2 3a cc da da ff a9 dd dd b6 08 d4>
 * > randomPrivateKey()
 <Buffer e7 5b 68 fb f9 50 19 94 07 80 d5 13 2e 40 a7 f9 a1 b0 5d 72 c8 86 ca d1 c6 59 cd a6 bf 37 cb 73>

 * @example
 * > entropy = randomBuffer(32)
 * > randomPrivateKey(entropy)
 <Buffer 57 90 e8 3d 16 10 02 b9 a4 33 87 e1 6b cd 40 7e f7 22 b1 d8 94 ae 98 bf 76 a4 56 fb b6 0c 4b 4a>
 * > randomPrivateKey(entropy) // same `entropy`
 <Buffer 89 44 ef 31 d4 9c d0 25 9f b0 de 61 99 12 4a 21 57 43 d4 4b af ae ef ae e1 3a ba 05 c3 e6 ad 21>
 */
function randomPrivateKey(entropy = randomBuffer(32)) {
  if (!(Buffer.isBuffer(entropy) && entropy.length === 32)) {
    throw new Error(`entropy must be 32 length Buffer, got "${typeof entropy}"`);
  }

  const inner = keccak256(Buffer.concat([randomBuffer(32), entropy]));
  const middle = Buffer.concat([randomBuffer(32), inner, randomBuffer(32)]);
  return keccak256(middle);
}

/**
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
function privateKeyToPublicKey(privateKey) {
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
}

/**
 * Get account address by public key.
 *
 * > Account address hex starts with '0x1'
 *
 * @param {Buffer|string} publicKey
 * @return {Buffer}
 *
 * @example
 * > publicKeyToAddress(Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]))
 <Buffer 4c 6f a3 22 12 5f a3 1a 42 cb dd a8 73 0d 4c f0 20 0d 72 db>
 */
function publicKeyToAddress(publicKey) {
  if (isHexString(publicKey)) publicKey = Buffer.from(publicKey.slice(2), 'hex');
  if (!Buffer.isBuffer(publicKey)) throw new Error('publicKey should be a buffer');
  if (publicKey.length === 65) publicKey = publicKey.slice(1);
  if (publicKey.length !== 64) throw new Error('publicKey length should be 64 or 65');
  const buffer = keccak256(publicKey).slice(-20);
  buffer[0] = (buffer[0] & 0x0f) | 0x10; // eslint-disable-line no-bitwise
  return buffer;
}

/**
 * Get address by private key.
 *
 * @param {Buffer} privateKey
 * @return {Buffer}
 *
 * @example
 * > privateKeyToAddress(Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]))
 <Buffer 0d b9 e0 02 85 67 52 28 8b ef 47 60 fa 67 94 ec 83 a8 53 b9>
 */
function privateKeyToAddress(privateKey) {
  return publicKeyToAddress(privateKeyToPublicKey(privateKey));
}

/**
 * Sign ecdsa
 *
 * @param {Buffer} hash
 * @param {Buffer} privateKey
 * @return {object} ECDSA signature object.
 * - r {Buffer}
 * - s {Buffer}
 * - v {number}
 *
 * @example
 * > privateKey = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);
 * > buffer32 = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])
 * > ecdsaSign(buffer32, privateKey)
 {
  r: <Buffer 21 ab b4 c3 fd 51 75 81 e6 c7 e7 e0 7f 40 4f a2 2c ba 8d 8f 71 27 0b 29 58 42 b8 3c 44 b5 a4 c6>,
  s: <Buffer 08 59 7b 69 8f 8f 3c c2 ba 0b 45 ee a7 7f 55 29 ad f9 5c a5 51 41 e7 9b 56 53 77 3d 00 5d 18 58>,
  v: 0
 }
 */
function ecdsaSign(hash, privateKey) {
  const sig = secp256k1.sign(hash, privateKey);
  return {
    r: sig.signature.slice(0, 32),
    s: sig.signature.slice(32, 64),
    v: sig.recovery,
  };
}

/**
 * Recover ecdsa
 *
 * @param {Buffer} hash
 * @param {object} options
 * @param {Buffer} options.r
 * @param {Buffer} options.s
 * @param {number} options.v
 * @return {Buffer} publicKey
 *
 * @example
 * > privateKey = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1])
 * > buffer32 = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])
 * > privateKeyToAddress(privateKey)
 <Buffer 0d b9 e0 02 85 67 52 28 8b ef 47 60 fa 67 94 ec 83 a8 53 b9>
 * > publicKeyToAddress(ecdsaRecover(buffer32, ecdsaSign(buffer32, privateKey)))
 <Buffer 0d b9 e0 02 85 67 52 28 8b ef 47 60 fa 67 94 ec 83 a8 53 b9>
 */
function ecdsaRecover(hash, { r, s, v }) {
  const senderPublic = secp256k1.recover(hash, Buffer.concat([r, s]), v);
  return secp256k1.publicKeyConvert(senderPublic, false).slice(1);
}

// ----------------------------------------------------------------------------
function uuidV4() {
  return [4, 2, 2, 2, 6].map(randomBuffer).map(v => v.toString('hex')).join('-');
}

/**
 *
 * @param {Buffer} privateKey
 * @param {string|Buffer} password
 * @return {object} - keystoreV3 object
 *
 * @example
 * > encrypt(Buffer.from('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', 'hex'), 'password')
 {
    version: 3,
    id: '0bb47ee0-aac3-a006-2717-03877afa15f0',
    address: '1cad0b19bb29d4674531d6f115237e16afce377c',
    crypto: {
      ciphertext: 'a8ec41d2440311ce897bacb6f7942f3235113fa17c4ae6732e032336038a8f73',
      cipherparams: { iv: '85b5e092c1c32129e3d27df8c581514d' },
      cipher: 'aes-128-ctr',
      kdf: 'scrypt',
      kdfparams: {
        dklen: 32,
        salt: 'b662f09bdf6751ac599219732609dceac430bc0629a7906eaa1451555f051ebc',
        n: 8192,
        r: 8,
        p: 1
      },
      mac: 'cc89df7ef6c27d284526a65cabf8e5042cdf1ec1aa4ee36dcf65b965fa34843d'
    }
  }
 */
function encrypt(privateKey, password) {
  const cipher = 'aes-128-ctr';
  const n = 8192;
  const r = 8;
  const p = 1;
  const dklen = 32;
  const salt = randomBuffer(32);
  const iv = randomBuffer(16);

  password = Buffer.from(password);
  const derived = scrypt(password, salt, n, r, p, dklen);
  const ciphertext = crypto.createCipheriv(cipher, derived.slice(0, 16), iv).update(privateKey);
  const mac = keccak256(Buffer.concat([derived.slice(16, 32), ciphertext]));
  const publicKey = privateKeyToPublicKey(privateKey);
  const address = keccak256(publicKey).slice(-20);

  return {
    version: 3,
    id: uuidV4(),
    address: address.toString('hex'),
    crypto: {
      ciphertext: ciphertext.toString('hex'),
      cipherparams: { iv: iv.toString('hex') },
      cipher,
      kdf: 'scrypt',
      kdfparams: { dklen, salt: salt.toString('hex'), n, r, p },
      mac: mac.toString('hex'),
    },
  };
}

/**
 * Decrypt account encrypt info.
 *
 * @param {object} keystoreV3
 * @param {number} keystoreV3.version
 * @param {object} keystoreV3.crypto
 * @param {string} keystoreV3.crypto.ciphertext
 * @param {object} keystoreV3.crypto.cipherparams
 * @param {string} keystoreV3.crypto.cipherparams.iv
 * @param {string} keystoreV3.crypto.cipher
 * @param {string} keystoreV3.crypto.kdf
 * @param {object} keystoreV3.crypto.kdfparams
 * @param {number} keystoreV3.crypto.kdfparams.dklen
 * @param {string} keystoreV3.crypto.kdfparams.salt
 * @param {number} keystoreV3.crypto.kdfparams.n
 * @param {number} keystoreV3.crypto.kdfparams.r
 * @param {number} keystoreV3.crypto.kdfparams.p
 * @param {string} keystoreV3.crypto.mac
 * @param {string|Buffer} password
 * @return {Buffer} Buffer of private key
 *
 * @example
 * > decrypt({
    version: 3,
    id: '0bb47ee0-aac3-a006-2717-03877afa15f0',
    address: '1cad0b19bb29d4674531d6f115237e16afce377c',
    crypto: {
      ciphertext: 'a8ec41d2440311ce897bacb6f7942f3235113fa17c4ae6732e032336038a8f73',
      cipherparams: { iv: '85b5e092c1c32129e3d27df8c581514d' },
      cipher: 'aes-128-ctr',
      kdf: 'scrypt',
      kdfparams: {
        dklen: 32,
        salt: 'b662f09bdf6751ac599219732609dceac430bc0629a7906eaa1451555f051ebc',
        n: 8192,
        r: 8,
        p: 1
      },
      mac: 'cc89df7ef6c27d284526a65cabf8e5042cdf1ec1aa4ee36dcf65b965fa34843d'
    }
  }, 'password')
 <Buffer 01 23 45 67 89 ab cd ef 01 23 45 67 89 ab cd ef 01 23 45 67 89 ab cd ef 01 23 45 67 89 ab cd ef>
 */
function decrypt({
  version,
  crypto: {
    ciphertext,
    cipherparams: { iv },
    cipher,
    kdf,
    kdfparams: { dklen, salt, n, r, p },
    mac,
  },
}, password) {
  if (version !== 3) {
    throw new Error('Not a valid V3 wallet');
  }
  if (kdf !== 'scrypt') {
    throw new Error(`Unsupported kdf "${kdf}", only support "scrypt"`);
  }

  password = Buffer.from(password);
  ciphertext = Buffer.from(ciphertext, 'hex');
  iv = Buffer.from(iv, 'hex');
  salt = Buffer.from(salt, 'hex');
  mac = Buffer.from(mac, 'hex');

  const derived = scrypt(password, salt, n, r, p, dklen);
  if (!keccak256(Buffer.concat([derived.slice(16, 32), ciphertext])).equals(mac)) {
    throw new Error('Key derivation failed, possibly wrong password!');
  }
  return crypto.createDecipheriv(cipher, derived.slice(0, 16), iv).update(ciphertext);
}

module.exports = {
  keccak256,
  checksumAddress,

  randomBuffer,
  randomPrivateKey,
  privateKeyToPublicKey,
  publicKeyToAddress,
  privateKeyToAddress,
  ecdsaSign,
  ecdsaRecover,

  encrypt,
  decrypt,
};


/***/ }),

/***/ 43563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Transaction = __webpack_require__(45550);
const Message = __webpack_require__(90282);

/**
 * Account abstract class
 */
class Account {
  /**
   * @param {string} address
   */
  constructor(address) {
    this.address = address;
  }

  /**
   * @param {object} options
   * @return {Promise<typeof import('../Transaction')>}
   */
  async signTransaction(options) {
    return new Transaction(options);
  }

  /**
   * @param {string} message
   * @return {Promise<typeof import('../Message')>}
   */
  async signMessage(message) {
    return new Message(message);
  }

  /**
   * @return {string} Address as string.
   */
  toString() {
    return this.address;
  }

  /**
   * @return {string} Address as JSON string.
   */
  toJSON() {
    return this.address;
  }
}

module.exports = Account;


/***/ }),

/***/ 98124:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const sign = __webpack_require__(43089);
const Account = __webpack_require__(43563);

class PrivateKeyAccount extends Account {
  /**
   * Create a new PrivateKeyAccount with random privateKey.
   *
   * @param {string|Buffer} entropy - Entropy of random account, if pass undefined will random generate a buffer
   * @param {number} networkId - network id of account
   * @return {PrivateKeyAccount}
   *
   * @example
   * > PrivateKeyAccount.random(undefined, 1)
   PrivateKeyAccount {
      privateKey: '0xd28edbdb7bbe75787b84c5f525f47666a3274bb06561581f00839645f3c26f66',
      publicKey: '0xc42b53ae2ef95fee489948d33df391c4a9da31b7a3e29cf772c24eb42f74e94ab3bfe00bf29a239c17786a5b921853b7c5344d36694db43aa849e401f91566a5',
      address: 'cfxtest:aass3rfcwjz1ab9cg5rtbv61531fmwnsuuy8c26f20'
    }
   * > PrivateKeyAccount.random(undefined, 1) // gen a different account from above
   PrivateKeyAccount {
      privateKey: '0x1b67150f56f49556ef7e3899024d83c125d84990d311ec08fa98aa1433bc0f53',
      publicKey: '0xd442207828ffd4dad918fea0d75d42dbea1fe5e3789c00a82e18ce8229714eae3f70b12f2f1abd795ad3e5c52a5a597289eb5096548438c233431f498b47b9a6',
      address: 'cfxtest:aanpezyvznsdg29zu20wpudwnbhx7t4gcpzcnkzjd2'
    }
   * > PrivateKeyAccount.random('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 1);
   PrivateKeyAccount {
      privateKey: '0x1d41e006afd28ea339922d8ab4be93154a14d4f1b6d0ad4e7aabf807e7536a5f',
      publicKey: '0x4c07c75d3fdc5b1d6afef6ec374b0eaac86bcaa771a1d536bc4ce6f111b1c60e414b370e4cf31bf7770ae6818a3518c485398a43857d9053153f6eb4f5644a90',
      address: 'cfxtest:aajx4wn2kwarr8h71uf880w40dp6x91feac1n6ur3s'
    }
   * > PrivateKeyAccount.random('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 1);
   * // gen a different account from above, even use same entropy
   PrivateKeyAccount {
      privateKey: '0x5a34ff3318674c33209ce856218890e9a6ee3811e8a51e3094ed1e6a94bf58ef',
      publicKey: '0xe530d77c3ed6115cb46ba79821085bf67d2a7a8c808c1d52dec03fd7a82e569c2136dba84b21d40f46d90484722b21a9d5a8038495adf93f2eed564ababa2422',
      address: 'cfxtest:aat0h9htkmzjvub61rsk9p4n64s863suza6zu7d2rr'
    }
   */
  static random(entropy, networkId) {
    const privateKeyBuffer = sign.randomPrivateKey(entropy === undefined ? undefined : format.hexBuffer(entropy));
    return new this(privateKeyBuffer, networkId);
  }

  /**
   * Decrypt account encrypt info.
   *
   * @param {object} keystore - Keystore version 3 object.
   * @param {string|Buffer} password - Password for keystore to decrypt with.
   * @param {number} networkId - Network id of account
   * @return {PrivateKeyAccount}
   *
   * @example
   * > PrivateKeyAccount.decrypt({
    version: 3,
    id: '0bb47ee0-aac3-a006-2717-03877afa15f0',
    address: '1cad0b19bb29d4674531d6f115237e16afce377c',
    crypto: {
      ciphertext: 'a8ec41d2440311ce897bacb6f7942f3235113fa17c4ae6732e032336038a8f73',
      cipherparams: { iv: '85b5e092c1c32129e3d27df8c581514d' },
      cipher: 'aes-128-ctr',
      kdf: 'scrypt',
      kdfparams: {
        dklen: 32,
        salt: 'b662f09bdf6751ac599219732609dceac430bc0629a7906eaa1451555f051ebc',
        n: 8192,
        r: 8,
        p: 1
      },
      mac: 'cc89df7ef6c27d284526a65cabf8e5042cdf1ec1aa4ee36dcf65b965fa34843d'
    }
  }, 'password');
   PrivateKeyAccount {
    address: '0x1cad0b19bb29d4674531d6f115237e16afce377c',
    publicKey: '0x4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559',
    privateKey: '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
  }
   */
  static decrypt(keystore, password, networkId) {
    const privateKeyBuffer = sign.decrypt(keystore, password);
    return new this(privateKeyBuffer, networkId);
  }

  /**
   * Create a account by privateKey.
   *
   * @param {string|Buffer} privateKey - Private key of account
   * @param {number} networkId - Network id of account
   * @return {PrivateKeyAccount}
   *
   * @example
   * > new PrivateKeyAccount('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
   PrivateKeyAccount {
    address: 'cfxtest:aasm4c231py7j34fghntcfkdt2nm9xv1tu6jd3r1s7',
    publicKey: '0x4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559',
    privateKey: '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
  }
   */
  constructor(privateKey, networkId) {
    const privateKeyBuffer = format.hexBuffer(privateKey);
    const publicKeyBuffer = sign.privateKeyToPublicKey(privateKeyBuffer);
    const addressBuffer = sign.publicKeyToAddress(publicKeyBuffer);

    super(format.address(addressBuffer, networkId));
    this.publicKey = format.publicKey(publicKeyBuffer);
    this.privateKey = format.privateKey(privateKeyBuffer);
    this.networkId = networkId;
  }

  /**
   * Encrypt account privateKey to object.
   *
   * @param {string} password
   * @return {object} - keystoreV3 object
   *
   * @example
   * > account = new PrivateKeyAccount('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
   * > account.encrypt('password')
   {version:3, id:..., address:..., crypto:...}
   */
  encrypt(password) {
    return sign.encrypt(format.hexBuffer(this.privateKey), password);
  }

  /**
   * Sign a transaction.
   *
   * @param {object} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
   * @return {Promise<typeof import('../Transaction')>}
   *
   * @example
   * > account = new PrivateKeyAccount('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
   * > transaction = account.signTransaction({
      nonce: 0,
      gasPrice: 100,
      gas: 10000,
      storageLimit: 10000,
      epochHeight: 100,
      chainId: 0,
    })

   Transaction {
      from: 'cfxtest:aasm4c231py7j34fghntcfkdt2nm9xv1tu6jd3r1s7',
      nonce: 0,
      gasPrice: 100,
      gas: 10000,
      to: undefined,
      value: undefined,
      storageLimit: 10000,
      epochHeight: 100,
      chainId: 0,
      data: undefined,
      v: 0,
      r: '0x096f4e00ac15f6bd6e09937e99f0e54aaa2dd0f4c6bd8421e1e81b0e8bd30723',
      s: '0x41e63a41ede0cbb8ccfaa827423c654dcdc09fb1aa1c3a7233566544aff4cd9a'
    }
   */
  async signTransaction(options) {
    const transaction = await super.signTransaction(options);
    transaction.sign(this.privateKey, this.networkId); // sign will cover r,s,v fields

    assert(transaction.from === this.address, {
      message: 'Invalid sign transaction.from',
      expected: this.address,
      got: transaction.from,
    });

    return transaction;
  }

  /**
   * Sign a string.
   *
   * @param {string} options
   * @return {Promise<typeof import('../Message')>}
   *
   * @example
   * > account = new PrivateKeyAccount('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')
   * > message = account.signMessage('Hello World')
   Message {
      message: 'Hello World',
      signature: '0x6e913e2b76459f19ebd269b82b51a70e912e909b2f5c002312efc27bcc280f3c29134d382aad0dbd3f0ccc9f0eb8f1dbe3f90141d81574ebb6504156b0d7b95f01'
    }
   */
  async signMessage(options) {
    const message = await super.signMessage(options);
    message.sign(this.privateKey, this.networkId); // sign will cover r,s,v fields

    assert(message.from === this.address, {
      message: 'Invalid sign message.from',
      expected: this.address,
      got: message.from,
    });

    return message;
  }
}

module.exports = PrivateKeyAccount;


/***/ }),

/***/ 84684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { assert } = __webpack_require__(61069);
const format = __webpack_require__(52519);
const Account = __webpack_require__(43563);
const PrivateKeyAccount = __webpack_require__(98124);

/**
 * Wallet to manager accounts.
 */
class Wallet extends Map {
  /**
   * @param {number} networkId
   * @return {Wallet}
   */
  constructor(networkId) {
    super();
    this.networkId = networkId;
  }

  /**
   * Set network id
   * @param {number} networkId
   */
  setNetworkId(networkId) {
    this.networkId = networkId;
  }

  /**
   * Check if address exist
   *
   * @param {string} address
   * @return {boolean}
   */
  has(address) {
    try {
      address = format.address(address, this.networkId);
      return super.has(address);
    } catch (e) {
      return false;
    }
  }

  /**
   * Drop one account by address
   *
   * @param {string} address
   * @return {boolean}
   */
  delete(address) {
    try {
      address = format.address(address, this.networkId);
      return super.delete(address);
    } catch (e) {
      return false;
    }
  }

  /**
   * Drop all account in wallet
   */
  clear() {
    return super.clear();
  }

  /**
   * @param {any} address - Key of account, usually is `address`
   * @param {any} account - Account instance
   * @return {any}
   */
  set(address, account) {
    address = format.address(address, this.networkId);

    assert(!this.has(address), `Wallet already has account "${address}"`);
    assert(account instanceof Account, `value not instance of Account, got ${account}`);
    return super.set(address, account);
  }

  /**
   * @param {string} address
   * @return {Account}
   */
  get(address) {
    address = format.address(address, this.networkId);

    const account = super.get(address);
    assert(account instanceof Account, `can not found Account by "${address}"`);
    return account;
  }

  /**
   * @param {string|Buffer} privateKey - Private key of account
   * @return {PrivateKeyAccount}
   */
  addPrivateKey(privateKey) {
    if (!this.networkId) {
      console.warn('wallet.addPrivateKey: networkId is not set properly, please set it');
    }
    const account = new PrivateKeyAccount(privateKey, this.networkId);
    this.set(account.address, account);
    return account;
  }

  /**
   * @param {string|Buffer} [entropy] - Entropy of random account
   * @return {PrivateKeyAccount}
   */
  addRandom(entropy) {
    const account = PrivateKeyAccount.random(entropy, this.networkId);
    this.set(account.address, account);
    return account;
  }

  /**
   * @param {object} keystore - Keystore version 3 object.
   * @param {string|Buffer} password - Password for keystore to decrypt with.
   * @return {PrivateKeyAccount}
   */
  addKeystore(keystore, password) {
    const account = PrivateKeyAccount.decrypt(keystore, password, this.networkId);
    this.set(account.address, account);
    return account;
  }
}

module.exports = Wallet;


/***/ }),

/***/ 97033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(84684);


/***/ }),

/***/ 83669:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return methods;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ 29034:
/***/ ((module) => {

"use strict";
class JSBI extends Array{constructor(i,_){if(super(i),this.sign=_,i>JSBI.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded")}static BigInt(i){var _=Math.floor,t=Number.isFinite;if("number"==typeof i){if(0===i)return JSBI.__zero();if(JSBI.__isOneDigitInt(i))return 0>i?JSBI.__oneDigit(-i,!0):JSBI.__oneDigit(i,!1);if(!t(i)||_(i)!==i)throw new RangeError("The number "+i+" cannot be converted to BigInt because it is not an integer");return JSBI.__fromDouble(i)}if("string"==typeof i){const _=JSBI.__fromString(i);if(null===_)throw new SyntaxError("Cannot convert "+i+" to a BigInt");return _}if("boolean"==typeof i)return!0===i?JSBI.__oneDigit(1,!1):JSBI.__zero();if("object"==typeof i){if(i.constructor===JSBI)return i;const _=JSBI.__toPrimitive(i);return JSBI.BigInt(_)}throw new TypeError("Cannot convert "+i+" to a BigInt")}toDebugString(){const i=["BigInt["];for(const _ of this)i.push((_?(_>>>0).toString(16):_)+", ");return i.push("]"),i.join("")}toString(i=10){if(2>i||36<i)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(i&i-1)?JSBI.__toStringBasePowerOfTwo(this,i):JSBI.__toStringGeneric(this,i,!1)}static toNumber(i){const _=i.length;if(0===_)return 0;if(1===_){const _=i.__unsignedDigit(0);return i.sign?-_:_}const t=i.__digit(_-1),e=JSBI.__clz30(t),n=30*_-e;if(1024<n)return i.sign?-Infinity:1/0;let g=n-1,o=t,s=_-1;const l=e+3;let r=32===l?0:o<<l;r>>>=12;const a=l-12;let u=12<=l?0:o<<20+l,d=20+l;for(0<a&&0<s&&(s--,o=i.__digit(s),r|=o>>>30-a,u=o<<a+2,d=a+2);0<d&&0<s;)s--,o=i.__digit(s),u|=30<=d?o<<d-30:o>>>30-d,d-=30;const h=JSBI.__decideRounding(i,d,s,o);if((1===h||0===h&&1==(1&u))&&(u=u+1>>>0,0===u&&(r++,0!=r>>>20&&(r=0,g++,1023<g))))return i.sign?-Infinity:1/0;const m=i.sign?-2147483648:0;return g=g+1023<<20,JSBI.__kBitConversionInts[1]=m|g|r,JSBI.__kBitConversionInts[0]=u,JSBI.__kBitConversionDouble[0]}static unaryMinus(i){if(0===i.length)return i;const _=i.__copy();return _.sign=!i.sign,_}static bitwiseNot(i){return i.sign?JSBI.__absoluteSubOne(i).__trim():JSBI.__absoluteAddOne(i,!0)}static exponentiate(i,_){if(_.sign)throw new RangeError("Exponent must be positive");if(0===_.length)return JSBI.__oneDigit(1,!1);if(0===i.length)return i;if(1===i.length&&1===i.__digit(0))return i.sign&&0==(1&_.__digit(0))?JSBI.unaryMinus(i):i;if(1<_.length)throw new RangeError("BigInt too big");let t=_.__unsignedDigit(0);if(1===t)return i;if(t>=JSBI.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===i.length&&2===i.__digit(0)){const _=1+(0|t/30),e=i.sign&&0!=(1&t),n=new JSBI(_,e);n.__initializeDigits();const g=1<<t%30;return n.__setDigit(_-1,g),n}let e=null,n=i;for(0!=(1&t)&&(e=i),t>>=1;0!==t;t>>=1)n=JSBI.multiply(n,n),0!=(1&t)&&(null===e?e=n:e=JSBI.multiply(e,n));return e}static multiply(_,t){if(0===_.length)return _;if(0===t.length)return t;let i=_.length+t.length;30<=_.__clzmsd()+t.__clzmsd()&&i--;const e=new JSBI(i,_.sign!==t.sign);e.__initializeDigits();for(let n=0;n<_.length;n++)JSBI.__multiplyAccumulate(t,_.__digit(n),e,n);return e.__trim()}static divide(i,_){if(0===_.length)throw new RangeError("Division by zero");if(0>JSBI.__absoluteCompare(i,_))return JSBI.__zero();const t=i.sign!==_.sign,e=_.__unsignedDigit(0);let n;if(1===_.length&&32767>=e){if(1===e)return t===i.sign?i:JSBI.unaryMinus(i);n=JSBI.__absoluteDivSmall(i,e,null)}else n=JSBI.__absoluteDivLarge(i,_,!0,!1);return n.sign=t,n.__trim()}static remainder(i,_){if(0===_.length)throw new RangeError("Division by zero");if(0>JSBI.__absoluteCompare(i,_))return i;const t=_.__unsignedDigit(0);if(1===_.length&&32767>=t){if(1===t)return JSBI.__zero();const _=JSBI.__absoluteModSmall(i,t);return 0===_?JSBI.__zero():JSBI.__oneDigit(_,i.sign)}const e=JSBI.__absoluteDivLarge(i,_,!1,!0);return e.sign=i.sign,e.__trim()}static add(i,_){const t=i.sign;return t===_.sign?JSBI.__absoluteAdd(i,_,t):0<=JSBI.__absoluteCompare(i,_)?JSBI.__absoluteSub(i,_,t):JSBI.__absoluteSub(_,i,!t)}static subtract(i,_){const t=i.sign;return t===_.sign?0<=JSBI.__absoluteCompare(i,_)?JSBI.__absoluteSub(i,_,t):JSBI.__absoluteSub(_,i,!t):JSBI.__absoluteAdd(i,_,t)}static leftShift(i,_){return 0===_.length||0===i.length?i:_.sign?JSBI.__rightShiftByAbsolute(i,_):JSBI.__leftShiftByAbsolute(i,_)}static signedRightShift(i,_){return 0===_.length||0===i.length?i:_.sign?JSBI.__leftShiftByAbsolute(i,_):JSBI.__rightShiftByAbsolute(i,_)}static unsignedRightShift(){throw new TypeError("BigInts have no unsigned right shift; use >> instead")}static lessThan(i,_){return 0>JSBI.__compareToBigInt(i,_)}static lessThanOrEqual(i,_){return 0>=JSBI.__compareToBigInt(i,_)}static greaterThan(i,_){return 0<JSBI.__compareToBigInt(i,_)}static greaterThanOrEqual(i,_){return 0<=JSBI.__compareToBigInt(i,_)}static equal(_,t){if(_.sign!==t.sign)return!1;if(_.length!==t.length)return!1;for(let e=0;e<_.length;e++)if(_.__digit(e)!==t.__digit(e))return!1;return!0}static notEqual(i,_){return!JSBI.equal(i,_)}static bitwiseAnd(i,_){var t=Math.max;if(!i.sign&&!_.sign)return JSBI.__absoluteAnd(i,_).__trim();if(i.sign&&_.sign){const e=t(i.length,_.length)+1;let n=JSBI.__absoluteSubOne(i,e);const g=JSBI.__absoluteSubOne(_);return n=JSBI.__absoluteOr(n,g,n),JSBI.__absoluteAddOne(n,!0,n).__trim()}return i.sign&&([i,_]=[_,i]),JSBI.__absoluteAndNot(i,JSBI.__absoluteSubOne(_)).__trim()}static bitwiseXor(i,_){var t=Math.max;if(!i.sign&&!_.sign)return JSBI.__absoluteXor(i,_).__trim();if(i.sign&&_.sign){const e=t(i.length,_.length),n=JSBI.__absoluteSubOne(i,e),g=JSBI.__absoluteSubOne(_);return JSBI.__absoluteXor(n,g,n).__trim()}const e=t(i.length,_.length)+1;i.sign&&([i,_]=[_,i]);let n=JSBI.__absoluteSubOne(_,e);return n=JSBI.__absoluteXor(n,i,n),JSBI.__absoluteAddOne(n,!0,n).__trim()}static bitwiseOr(i,_){var t=Math.max;const e=t(i.length,_.length);if(!i.sign&&!_.sign)return JSBI.__absoluteOr(i,_).__trim();if(i.sign&&_.sign){let t=JSBI.__absoluteSubOne(i,e);const n=JSBI.__absoluteSubOne(_);return t=JSBI.__absoluteAnd(t,n,t),JSBI.__absoluteAddOne(t,!0,t).__trim()}i.sign&&([i,_]=[_,i]);let n=JSBI.__absoluteSubOne(_,e);return n=JSBI.__absoluteAndNot(n,i,n),JSBI.__absoluteAddOne(n,!0,n).__trim()}static asIntN(_,t){var i=Math.floor;if(0===t.length)return t;if(_=i(_),0>_)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===_)return JSBI.__zero();if(_>=JSBI.__kMaxLengthBits)return t;const e=0|(_+29)/30;if(t.length<e)return t;const g=t.__unsignedDigit(e-1),o=1<<(_-1)%30;if(t.length===e&&g<o)return t;if(!((g&o)===o))return JSBI.__truncateToNBits(_,t);if(!t.sign)return JSBI.__truncateAndSubFromPowerOfTwo(_,t,!0);if(0==(g&o-1)){for(let n=e-2;0<=n;n--)if(0!==t.__digit(n))return JSBI.__truncateAndSubFromPowerOfTwo(_,t,!1);return t.length===e&&g===o?t:JSBI.__truncateToNBits(_,t)}return JSBI.__truncateAndSubFromPowerOfTwo(_,t,!1)}static asUintN(i,_){var t=Math.floor;if(0===_.length)return _;if(i=t(i),0>i)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===i)return JSBI.__zero();if(_.sign){if(i>JSBI.__kMaxLengthBits)throw new RangeError("BigInt too big");return JSBI.__truncateAndSubFromPowerOfTwo(i,_,!1)}if(i>=JSBI.__kMaxLengthBits)return _;const e=0|(i+29)/30;if(_.length<e)return _;const g=i%30;if(_.length==e){if(0===g)return _;const i=_.__digit(e-1);if(0==i>>>g)return _}return JSBI.__truncateToNBits(i,_)}static ADD(i,_){if(i=JSBI.__toPrimitive(i),_=JSBI.__toPrimitive(_),"string"==typeof i)return"string"!=typeof _&&(_=_.toString()),i+_;if("string"==typeof _)return i.toString()+_;if(i=JSBI.__toNumeric(i),_=JSBI.__toNumeric(_),JSBI.__isBigInt(i)&&JSBI.__isBigInt(_))return JSBI.add(i,_);if("number"==typeof i&&"number"==typeof _)return i+_;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")}static LT(i,_){return JSBI.__compare(i,_,0)}static LE(i,_){return JSBI.__compare(i,_,1)}static GT(i,_){return JSBI.__compare(i,_,2)}static GE(i,_){return JSBI.__compare(i,_,3)}static EQ(i,_){for(;;){if(JSBI.__isBigInt(i))return JSBI.__isBigInt(_)?JSBI.equal(i,_):JSBI.EQ(_,i);if("number"==typeof i){if(JSBI.__isBigInt(_))return JSBI.__equalToNumber(_,i);if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_)}else if("string"==typeof i){if(JSBI.__isBigInt(_))return i=JSBI.__fromString(i),null!==i&&JSBI.equal(i,_);if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_)}else if("boolean"==typeof i){if(JSBI.__isBigInt(_))return JSBI.__equalToNumber(_,+i);if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_)}else if("symbol"==typeof i){if(JSBI.__isBigInt(_))return!1;if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_)}else if("object"==typeof i){if("object"==typeof _&&_.constructor!==JSBI)return i==_;i=JSBI.__toPrimitive(i)}else return i==_}}static NE(i,_){return!JSBI.EQ(i,_)}static __zero(){return new JSBI(0,!1)}static __oneDigit(i,_){const t=new JSBI(1,_);return t.__setDigit(0,i),t}__copy(){const _=new JSBI(this.length,this.sign);for(let t=0;t<this.length;t++)_[t]=this[t];return _}__trim(){let i=this.length,_=this[i-1];for(;0===_;)i--,_=this[i-1],this.pop();return 0===i&&(this.sign=!1),this}__initializeDigits(){for(let _=0;_<this.length;_++)this[_]=0}static __decideRounding(i,_,t,e){if(0<_)return-1;let n;if(0>_)n=-_-1;else{if(0===t)return-1;t--,e=i.__digit(t),n=29}let g=1<<n;if(0==(e&g))return-1;if(g-=1,0!=(e&g))return 1;for(;0<t;)if(t--,0!==i.__digit(t))return 1;return 0}static __fromDouble(i){JSBI.__kBitConversionDouble[0]=i;const _=2047&JSBI.__kBitConversionInts[1]>>>20,t=_-1023,e=(0|t/30)+1,n=new JSBI(e,0>i);let g=1048575&JSBI.__kBitConversionInts[1]|1048576,o=JSBI.__kBitConversionInts[0];const s=20,l=t%30;let r,a=0;if(l<20){const i=s-l;a=i+32,r=g>>>i,g=g<<32-i|o>>>i,o<<=32-i}else if(l===20)a=32,r=g,g=o,o=0;else{const i=l-s;a=32-i,r=g<<i|o>>>32-i,g=o<<i,o=0}n.__setDigit(e-1,r);for(let _=e-2;0<=_;_--)0<a?(a-=30,r=g>>>2,g=g<<30|o>>>2,o<<=30):r=0,n.__setDigit(_,r);return n.__trim()}static __isWhitespace(i){return!!(13>=i&&9<=i)||(159>=i?32==i:131071>=i?160==i||5760==i:196607>=i?(i&=131071,10>=i||40==i||41==i||47==i||95==i||4096==i):65279==i)}static __fromString(i,_=0){let t=0;const e=i.length;let n=0;if(n===e)return JSBI.__zero();let g=i.charCodeAt(n);for(;JSBI.__isWhitespace(g);){if(++n===e)return JSBI.__zero();g=i.charCodeAt(n)}if(43===g){if(++n===e)return null;g=i.charCodeAt(n),t=1}else if(45===g){if(++n===e)return null;g=i.charCodeAt(n),t=-1}if(0===_){if(_=10,48===g){if(++n===e)return JSBI.__zero();if(g=i.charCodeAt(n),88===g||120===g){if(_=16,++n===e)return null;g=i.charCodeAt(n)}else if(79===g||111===g){if(_=8,++n===e)return null;g=i.charCodeAt(n)}else if(66===g||98===g){if(_=2,++n===e)return null;g=i.charCodeAt(n)}}}else if(16===_&&48===g){if(++n===e)return JSBI.__zero();if(g=i.charCodeAt(n),88===g||120===g){if(++n===e)return null;g=i.charCodeAt(n)}}if(0!=t&&10!==_)return null;for(;48===g;){if(++n===e)return JSBI.__zero();g=i.charCodeAt(n)}const o=e-n;let s=JSBI.__kMaxBitsPerChar[_],l=JSBI.__kBitsPerCharTableMultiplier-1;if(o>1073741824/s)return null;const r=s*o+l>>>JSBI.__kBitsPerCharTableShift,a=new JSBI(0|(r+29)/30,!1),u=10>_?_:10,h=10<_?_-10:0;if(0==(_&_-1)){s>>=JSBI.__kBitsPerCharTableShift;const _=[],t=[];let o=!1;do{let l=0,r=0;for(;;){let _;if(g-48>>>0<u)_=g-48;else if((32|g)-97>>>0<h)_=(32|g)-87;else{o=!0;break}if(r+=s,l=l<<s|_,++n===e){o=!0;break}if(g=i.charCodeAt(n),30<r+s)break}_.push(l),t.push(r)}while(!o);JSBI.__fillFromParts(a,_,t)}else{a.__initializeDigits();let t=!1,o=0;do{let r=0,b=1;for(;;){let s;if(g-48>>>0<u)s=g-48;else if((32|g)-97>>>0<h)s=(32|g)-87;else{t=!0;break}const l=b*_;if(1073741823<l)break;if(b=l,r=r*_+s,o++,++n===e){t=!0;break}g=i.charCodeAt(n)}l=30*JSBI.__kBitsPerCharTableMultiplier-1;const D=0|(s*o+l>>>JSBI.__kBitsPerCharTableShift)/30;a.__inplaceMultiplyAdd(b,r,D)}while(!t)}if(n!==e){if(!JSBI.__isWhitespace(g))return null;for(n++;n<e;n++)if(g=i.charCodeAt(n),!JSBI.__isWhitespace(g))return null}return a.sign=-1==t,a.__trim()}static __fillFromParts(_,t,e){let n=0,g=0,o=0;for(let s=t.length-1;0<=s;s--){const i=t[s],l=e[s];g|=i<<o,o+=l,30===o?(_.__setDigit(n++,g),o=0,g=0):30<o&&(_.__setDigit(n++,1073741823&g),o-=30,g=i>>>l-o)}if(0!==g){if(n>=_.length)throw new Error("implementation bug");_.__setDigit(n++,g)}for(;n<_.length;n++)_.__setDigit(n,0)}static __toStringBasePowerOfTwo(_,i){const t=_.length;let e=i-1;e=(85&e>>>1)+(85&e),e=(51&e>>>2)+(51&e),e=(15&e>>>4)+(15&e);const n=e,g=i-1,o=_.__digit(t-1),s=JSBI.__clz30(o);let l=0|(30*t-s+n-1)/n;if(_.sign&&l++,268435456<l)throw new Error("string too long");const r=Array(l);let a=l-1,u=0,d=0;for(let e=0;e<t-1;e++){const i=_.__digit(e),t=(u|i<<d)&g;r[a--]=JSBI.__kConversionChars[t];const o=n-d;for(u=i>>>o,d=30-o;d>=n;)r[a--]=JSBI.__kConversionChars[u&g],u>>>=n,d-=n}const h=(u|o<<d)&g;for(r[a--]=JSBI.__kConversionChars[h],u=o>>>n-d;0!==u;)r[a--]=JSBI.__kConversionChars[u&g],u>>>=n;if(_.sign&&(r[a--]="-"),-1!=a)throw new Error("implementation bug");return r.join("")}static __toStringGeneric(_,i,t){const e=_.length;if(0===e)return"";if(1===e){let e=_.__unsignedDigit(0).toString(i);return!1===t&&_.sign&&(e="-"+e),e}const n=30*e-JSBI.__clz30(_.__digit(e-1)),g=JSBI.__kMaxBitsPerChar[i],o=g-1;let s=n*JSBI.__kBitsPerCharTableMultiplier;s+=o-1,s=0|s/o;const l=s+1>>1,r=JSBI.exponentiate(JSBI.__oneDigit(i,!1),JSBI.__oneDigit(l,!1));let a,u;const d=r.__unsignedDigit(0);if(1===r.length&&32767>=d){a=new JSBI(_.length,!1),a.__initializeDigits();let t=0;for(let e=2*_.length-1;0<=e;e--){const i=t<<15|_.__halfDigit(e);a.__setHalfDigit(e,0|i/d),t=0|i%d}u=t.toString(i)}else{const t=JSBI.__absoluteDivLarge(_,r,!0,!0);a=t.quotient;const e=t.remainder.__trim();u=JSBI.__toStringGeneric(e,i,!0)}a.__trim();let h=JSBI.__toStringGeneric(a,i,!0);for(;u.length<l;)u="0"+u;return!1===t&&_.sign&&(h="-"+h),h+u}static __unequalSign(i){return i?-1:1}static __absoluteGreater(i){return i?-1:1}static __absoluteLess(i){return i?1:-1}static __compareToBigInt(i,_){const t=i.sign;if(t!==_.sign)return JSBI.__unequalSign(t);const e=JSBI.__absoluteCompare(i,_);return 0<e?JSBI.__absoluteGreater(t):0>e?JSBI.__absoluteLess(t):0}static __compareToNumber(i,_){if(JSBI.__isOneDigitInt(_)){const t=i.sign,e=0>_;if(t!==e)return JSBI.__unequalSign(t);if(0===i.length){if(e)throw new Error("implementation bug");return 0===_?0:-1}if(1<i.length)return JSBI.__absoluteGreater(t);const n=Math.abs(_),g=i.__unsignedDigit(0);return g>n?JSBI.__absoluteGreater(t):g<n?JSBI.__absoluteLess(t):0}return JSBI.__compareToDouble(i,_)}static __compareToDouble(i,_){if(_!==_)return _;if(_===1/0)return-1;if(_===-Infinity)return 1;const t=i.sign;if(t!==0>_)return JSBI.__unequalSign(t);if(0===_)throw new Error("implementation bug: should be handled elsewhere");if(0===i.length)return-1;JSBI.__kBitConversionDouble[0]=_;const e=2047&JSBI.__kBitConversionInts[1]>>>20;if(2047==e)throw new Error("implementation bug: handled elsewhere");const n=e-1023;if(0>n)return JSBI.__absoluteGreater(t);const g=i.length;let o=i.__digit(g-1);const s=JSBI.__clz30(o),l=30*g-s,r=n+1;if(l<r)return JSBI.__absoluteLess(t);if(l>r)return JSBI.__absoluteGreater(t);let a=1048576|1048575&JSBI.__kBitConversionInts[1],u=JSBI.__kBitConversionInts[0];const d=20,h=29-s;if(h!==(0|(l-1)%30))throw new Error("implementation bug");let m,b=0;if(20>h){const i=d-h;b=i+32,m=a>>>i,a=a<<32-i|u>>>i,u<<=32-i}else if(20===h)b=32,m=a,a=u;else{const i=h-d;b=32-i,m=a<<i|u>>>32-i,a=u<<i}if(o>>>=0,m>>>=0,o>m)return JSBI.__absoluteGreater(t);if(o<m)return JSBI.__absoluteLess(t);for(let e=g-2;0<=e;e--){0<b?(b-=30,m=a>>>2,a=a<<30|u>>>2,u<<=30):m=0;const _=i.__unsignedDigit(e);if(_>m)return JSBI.__absoluteGreater(t);if(_<m)return JSBI.__absoluteLess(t)}if(0!==a||0!==u){if(0===b)throw new Error("implementation bug");return JSBI.__absoluteLess(t)}return 0}static __equalToNumber(i,_){var t=Math.abs;return JSBI.__isOneDigitInt(_)?0===_?0===i.length:1===i.length&&i.sign===0>_&&i.__unsignedDigit(0)===t(_):0===JSBI.__compareToDouble(i,_)}static __comparisonResultToBool(i,_){return 0===_?0>i:1===_?0>=i:2===_?0<i:3===_?0<=i:void 0}static __compare(i,_,t){if(i=JSBI.__toPrimitive(i),_=JSBI.__toPrimitive(_),"string"==typeof i&&"string"==typeof _)switch(t){case 0:return i<_;case 1:return i<=_;case 2:return i>_;case 3:return i>=_;}if(JSBI.__isBigInt(i)&&"string"==typeof _)return _=JSBI.__fromString(_),null!==_&&JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i,_),t);if("string"==typeof i&&JSBI.__isBigInt(_))return i=JSBI.__fromString(i),null!==i&&JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i,_),t);if(i=JSBI.__toNumeric(i),_=JSBI.__toNumeric(_),JSBI.__isBigInt(i)){if(JSBI.__isBigInt(_))return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i,_),t);if("number"!=typeof _)throw new Error("implementation bug");return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i,_),t)}if("number"!=typeof i)throw new Error("implementation bug");if(JSBI.__isBigInt(_))return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_,i),2^t);if("number"!=typeof _)throw new Error("implementation bug");return 0===t?i<_:1===t?i<=_:2===t?i>_:3===t?i>=_:void 0}__clzmsd(){return JSBI.__clz30(this.__digit(this.length-1))}static __absoluteAdd(_,t,e){if(_.length<t.length)return JSBI.__absoluteAdd(t,_,e);if(0===_.length)return _;if(0===t.length)return _.sign===e?_:JSBI.unaryMinus(_);let n=_.length;(0===_.__clzmsd()||t.length===_.length&&0===t.__clzmsd())&&n++;const g=new JSBI(n,e);let o=0,s=0;for(;s<t.length;s++){const i=_.__digit(s)+t.__digit(s)+o;o=i>>>30,g.__setDigit(s,1073741823&i)}for(;s<_.length;s++){const i=_.__digit(s)+o;o=i>>>30,g.__setDigit(s,1073741823&i)}return s<g.length&&g.__setDigit(s,o),g.__trim()}static __absoluteSub(_,t,e){if(0===_.length)return _;if(0===t.length)return _.sign===e?_:JSBI.unaryMinus(_);const n=new JSBI(_.length,e);let g=0,o=0;for(;o<t.length;o++){const i=_.__digit(o)-t.__digit(o)-g;g=1&i>>>30,n.__setDigit(o,1073741823&i)}for(;o<_.length;o++){const i=_.__digit(o)-g;g=1&i>>>30,n.__setDigit(o,1073741823&i)}return n.__trim()}static __absoluteAddOne(_,i,t=null){const e=_.length;null===t?t=new JSBI(e,i):t.sign=i;let n=1;for(let g=0;g<e;g++){const i=_.__digit(g)+n;n=i>>>30,t.__setDigit(g,1073741823&i)}return 0!=n&&t.__setDigitGrow(e,1),t}static __absoluteSubOne(_,t){const e=_.length;t=t||e;const n=new JSBI(t,!1);let g=1;for(let o=0;o<e;o++){const i=_.__digit(o)-g;g=1&i>>>30,n.__setDigit(o,1073741823&i)}if(0!=g)throw new Error("implementation bug");for(let g=e;g<t;g++)n.__setDigit(g,0);return n}static __absoluteAnd(_,t,e=null){let n=_.length,g=t.length,o=g;if(n<g){o=n;const i=_,e=n;_=t,n=g,t=i,g=e}let s=o;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)&t.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteAndNot(_,t,e=null){const n=_.length,g=t.length;let o=g;n<g&&(o=n);let s=n;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)&~t.__digit(l));for(;l<n;l++)e.__setDigit(l,_.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteOr(_,t,e=null){let n=_.length,g=t.length,o=g;if(n<g){o=n;const i=_,e=n;_=t,n=g,t=i,g=e}let s=n;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)|t.__digit(l));for(;l<n;l++)e.__setDigit(l,_.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteXor(_,t,e=null){let n=_.length,g=t.length,o=g;if(n<g){o=n;const i=_,e=n;_=t,n=g,t=i,g=e}let s=n;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)^t.__digit(l));for(;l<n;l++)e.__setDigit(l,_.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteCompare(_,t){const e=_.length-t.length;if(0!=e)return e;let n=_.length-1;for(;0<=n&&_.__digit(n)===t.__digit(n);)n--;return 0>n?0:_.__unsignedDigit(n)>t.__unsignedDigit(n)?1:-1}static __multiplyAccumulate(_,t,e,n){if(0===t)return;const g=32767&t,o=t>>>15;let s=0,l=0;for(let r,a=0;a<_.length;a++,n++){r=e.__digit(n);const i=_.__digit(a),t=32767&i,u=i>>>15,d=JSBI.__imul(t,g),h=JSBI.__imul(t,o),m=JSBI.__imul(u,g),b=JSBI.__imul(u,o);r+=l+d+s,s=r>>>30,r&=1073741823,r+=((32767&h)<<15)+((32767&m)<<15),s+=r>>>30,l=b+(h>>>15)+(m>>>15),e.__setDigit(n,1073741823&r)}for(;0!=s||0!==l;n++){let i=e.__digit(n);i+=s+l,l=0,s=i>>>30,e.__setDigit(n,1073741823&i)}}static __internalMultiplyAdd(_,t,e,g,o){let s=e,l=0;for(let n=0;n<g;n++){const i=_.__digit(n),e=JSBI.__imul(32767&i,t),g=JSBI.__imul(i>>>15,t),a=e+((32767&g)<<15)+l+s;s=a>>>30,l=g>>>15,o.__setDigit(n,1073741823&a)}if(o.length>g)for(o.__setDigit(g++,s+l);g<o.length;)o.__setDigit(g++,0);else if(0!==s+l)throw new Error("implementation bug")}__inplaceMultiplyAdd(i,_,t){t>this.length&&(t=this.length);const e=32767&i,n=i>>>15;let g=0,o=_;for(let s=0;s<t;s++){const i=this.__digit(s),_=32767&i,t=i>>>15,l=JSBI.__imul(_,e),r=JSBI.__imul(_,n),a=JSBI.__imul(t,e),u=JSBI.__imul(t,n);let d=o+l+g;g=d>>>30,d&=1073741823,d+=((32767&r)<<15)+((32767&a)<<15),g+=d>>>30,o=u+(r>>>15)+(a>>>15),this.__setDigit(s,1073741823&d)}if(0!=g||0!==o)throw new Error("implementation bug")}static __absoluteDivSmall(_,t,e=null){null===e&&(e=new JSBI(_.length,!1));let n=0;for(let g,o=2*_.length-1;0<=o;o-=2){g=(n<<15|_.__halfDigit(o))>>>0;const i=0|g/t;n=0|g%t,g=(n<<15|_.__halfDigit(o-1))>>>0;const s=0|g/t;n=0|g%t,e.__setDigit(o>>>1,i<<15|s)}return e}static __absoluteModSmall(_,t){let e=0;for(let n=2*_.length-1;0<=n;n--){const i=(e<<15|_.__halfDigit(n))>>>0;e=0|i%t}return e}static __absoluteDivLarge(i,_,t,e){const g=_.__halfDigitLength(),n=_.length,o=i.__halfDigitLength()-g;let s=null;t&&(s=new JSBI(o+2>>>1,!1),s.__initializeDigits());const l=new JSBI(g+2>>>1,!1);l.__initializeDigits();const r=JSBI.__clz15(_.__halfDigit(g-1));0<r&&(_=JSBI.__specialLeftShift(_,r,0));const a=JSBI.__specialLeftShift(i,r,1),u=_.__halfDigit(g-1);let d=0;for(let r,h=o;0<=h;h--){r=32767;const i=a.__halfDigit(h+g);if(i!==u){const t=(i<<15|a.__halfDigit(h+g-1))>>>0;r=0|t/u;let e=0|t%u;const n=_.__halfDigit(g-2),o=a.__halfDigit(h+g-2);for(;JSBI.__imul(r,n)>>>0>(e<<16|o)>>>0&&(r--,e+=u,!(32767<e)););}JSBI.__internalMultiplyAdd(_,r,0,n,l);let e=a.__inplaceSub(l,h,g+1);0!==e&&(e=a.__inplaceAdd(_,h,g),a.__setHalfDigit(h+g,32767&a.__halfDigit(h+g)+e),r--),t&&(1&h?d=r<<15:s.__setDigit(h>>>1,d|r))}if(e)return a.__inplaceRightShift(r),t?{quotient:s,remainder:a}:a;if(t)return s;throw new Error("unreachable")}static __clz15(i){return JSBI.__clz30(i)-15}__inplaceAdd(_,t,e){let n=0;for(let g=0;g<e;g++){const i=this.__halfDigit(t+g)+_.__halfDigit(g)+n;n=i>>>15,this.__setHalfDigit(t+g,32767&i)}return n}__inplaceSub(_,t,e){let n=0;if(1&t){t>>=1;let g=this.__digit(t),o=32767&g,s=0;for(;s<e-1>>>1;s++){const i=_.__digit(s),e=(g>>>15)-(32767&i)-n;n=1&e>>>15,this.__setDigit(t+s,(32767&e)<<15|32767&o),g=this.__digit(t+s+1),o=(32767&g)-(i>>>15)-n,n=1&o>>>15}const i=_.__digit(s),l=(g>>>15)-(32767&i)-n;n=1&l>>>15,this.__setDigit(t+s,(32767&l)<<15|32767&o);if(t+s+1>=this.length)throw new RangeError("out of bounds");0==(1&e)&&(g=this.__digit(t+s+1),o=(32767&g)-(i>>>15)-n,n=1&o>>>15,this.__setDigit(t+_.length,1073709056&g|32767&o))}else{t>>=1;let g=0;for(;g<_.length-1;g++){const i=this.__digit(t+g),e=_.__digit(g),o=(32767&i)-(32767&e)-n;n=1&o>>>15;const s=(i>>>15)-(e>>>15)-n;n=1&s>>>15,this.__setDigit(t+g,(32767&s)<<15|32767&o)}const i=this.__digit(t+g),o=_.__digit(g),s=(32767&i)-(32767&o)-n;n=1&s>>>15;let l=0;0==(1&e)&&(l=(i>>>15)-(o>>>15)-n,n=1&l>>>15),this.__setDigit(t+g,(32767&l)<<15|32767&s)}return n}__inplaceRightShift(_){if(0===_)return;let t=this.__digit(0)>>>_;const e=this.length-1;for(let n=0;n<e;n++){const i=this.__digit(n+1);this.__setDigit(n,1073741823&i<<30-_|t),t=i>>>_}this.__setDigit(e,t)}static __specialLeftShift(_,t,e){const g=_.length,n=new JSBI(g+e,!1);if(0===t){for(let t=0;t<g;t++)n.__setDigit(t,_.__digit(t));return 0<e&&n.__setDigit(g,0),n}let o=0;for(let s=0;s<g;s++){const i=_.__digit(s);n.__setDigit(s,1073741823&i<<t|o),o=i>>>30-t}return 0<e&&n.__setDigit(g,o),n}static __leftShiftByAbsolute(_,i){const t=JSBI.__toShiftAmount(i);if(0>t)throw new RangeError("BigInt too big");const e=0|t/30,n=t%30,g=_.length,o=0!==n&&0!=_.__digit(g-1)>>>30-n,s=g+e+(o?1:0),l=new JSBI(s,_.sign);if(0===n){let t=0;for(;t<e;t++)l.__setDigit(t,0);for(;t<s;t++)l.__setDigit(t,_.__digit(t-e))}else{let t=0;for(let _=0;_<e;_++)l.__setDigit(_,0);for(let o=0;o<g;o++){const i=_.__digit(o);l.__setDigit(o+e,1073741823&i<<n|t),t=i>>>30-n}if(o)l.__setDigit(g+e,t);else if(0!==t)throw new Error("implementation bug")}return l.__trim()}static __rightShiftByAbsolute(_,i){const t=_.length,e=_.sign,n=JSBI.__toShiftAmount(i);if(0>n)return JSBI.__rightShiftByMaximum(e);const g=0|n/30,o=n%30;let s=t-g;if(0>=s)return JSBI.__rightShiftByMaximum(e);let l=!1;if(e){if(0!=(_.__digit(g)&(1<<o)-1))l=!0;else for(let t=0;t<g;t++)if(0!==_.__digit(t)){l=!0;break}}if(l&&0===o){const i=_.__digit(t-1);0==~i&&s++}let r=new JSBI(s,e);if(0===o){r.__setDigit(s-1,0);for(let e=g;e<t;e++)r.__setDigit(e-g,_.__digit(e))}else{let e=_.__digit(g)>>>o;const n=t-g-1;for(let t=0;t<n;t++){const i=_.__digit(t+g+1);r.__setDigit(t,1073741823&i<<30-o|e),e=i>>>o}r.__setDigit(n,e)}return l&&(r=JSBI.__absoluteAddOne(r,!0,r)),r.__trim()}static __rightShiftByMaximum(i){return i?JSBI.__oneDigit(1,!0):JSBI.__zero()}static __toShiftAmount(i){if(1<i.length)return-1;const _=i.__unsignedDigit(0);return _>JSBI.__kMaxLengthBits?-1:_}static __toPrimitive(i,_="default"){if("object"!=typeof i)return i;if(i.constructor===JSBI)return i;const t=i[Symbol.toPrimitive];if(t){const i=t(_);if("object"!=typeof i)return i;throw new TypeError("Cannot convert object to primitive value")}const e=i.valueOf;if(e){const _=e.call(i);if("object"!=typeof _)return _}const n=i.toString;if(n){const _=n.call(i);if("object"!=typeof _)return _}throw new TypeError("Cannot convert object to primitive value")}static __toNumeric(i){return JSBI.__isBigInt(i)?i:+i}static __isBigInt(i){return"object"==typeof i&&null!==i&&i.constructor===JSBI}static __truncateToNBits(i,_){const t=0|(i+29)/30,e=new JSBI(t,_.sign),n=t-1;for(let t=0;t<n;t++)e.__setDigit(t,_.__digit(t));let g=_.__digit(n);if(0!=i%30){const _=32-i%30;g=g<<_>>>_}return e.__setDigit(n,g),e.__trim()}static __truncateAndSubFromPowerOfTwo(_,t,e){var n=Math.min;const g=0|(_+29)/30,o=new JSBI(g,e);let s=0;const l=g-1;let a=0;for(const i=n(l,t.length);s<i;s++){const i=0-t.__digit(s)-a;a=1&i>>>30,o.__setDigit(s,1073741823&i)}for(;s<l;s++)o.__setDigit(s,0|1073741823&-a);let u=l<t.length?t.__digit(l):0;const d=_%30;let h;if(0==d)h=0-u-a,h&=1073741823;else{const i=32-d;u=u<<i>>>i;const _=1<<32-i;h=_-u-a,h&=_-1}return o.__setDigit(l,h),o.__trim()}__digit(_){return this[_]}__unsignedDigit(_){return this[_]>>>0}__setDigit(_,i){this[_]=0|i}__setDigitGrow(_,i){this[_]=0|i}__halfDigitLength(){const i=this.length;return 32767>=this.__unsignedDigit(i-1)?2*i-1:2*i}__halfDigit(_){return 32767&this[_>>>1]>>>15*(1&_)}__setHalfDigit(_,i){const t=_>>>1,e=this.__digit(t),n=1&_?32767&e|i<<15:1073709056&e|32767&i;this.__setDigit(t,n)}static __digitPow(i,_){let t=1;for(;0<_;)1&_&&(t*=i),_>>>=1,i*=i;return t}static __isOneDigitInt(i){return(1073741823&i)===i}}JSBI.__kMaxLength=33554432,JSBI.__kMaxLengthBits=JSBI.__kMaxLength<<5,JSBI.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],JSBI.__kBitsPerCharTableShift=5,JSBI.__kBitsPerCharTableMultiplier=1<<JSBI.__kBitsPerCharTableShift,JSBI.__kConversionChars=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],JSBI.__kBitConversionBuffer=new ArrayBuffer(8),JSBI.__kBitConversionDouble=new Float64Array(JSBI.__kBitConversionBuffer),JSBI.__kBitConversionInts=new Int32Array(JSBI.__kBitConversionBuffer),JSBI.__clz30=Math.clz32?function(i){return Math.clz32(i)-2}:function(i){return 0===i?30:0|29-(0|Math.log(i>>>0)/Math.LN2)},JSBI.__imul=Math.imul||function(i,_){return 0|i*_},module.exports=JSBI;
//# sourceMappingURL=jsbi-cjs.js.map


/***/ }),

/***/ 34676:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(83249)(__webpack_require__(89038)(__dirname))


/***/ }),

/***/ 37029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  module.exports = __webpack_require__(34676)
} catch (err) {
  module.exports = __webpack_require__(77270)
}


/***/ }),

/***/ 77270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(83249)(__webpack_require__(55270))


/***/ }),

/***/ 83249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const createKeccak = __webpack_require__(42532)
const createShake = __webpack_require__(14255)

module.exports = function (KeccakState) {
  const Keccak = createKeccak(KeccakState)
  const Shake = createShake(KeccakState)

  return function (algorithm, options) {
    const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}


/***/ }),

/***/ 42532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const { Transform } = __webpack_require__(95690)

module.exports = (KeccakState) => class Keccak extends Transform {
  constructor (rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  _transform (chunk, encoding, callback) {
    let error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  _flush (callback) {
    let error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

  update (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  digest (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
    let digest = this._state.squeeze(this._hashBitLength / 8)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
  _resetState () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
  _clone () {
    const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }
}


/***/ }),

/***/ 14255:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const { Transform } = __webpack_require__(95690)

module.exports = (KeccakState) => class Shake extends Transform {
  constructor (rate, capacity, delimitedSuffix, options) {
    super(options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  _transform (chunk, encoding, callback) {
    let error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  _flush () {}

  _read (size) {
    this.push(this.squeeze(size))
  }

  update (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Squeeze already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  squeeze (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true
      this._state.absorbLastFewBits(this._delimitedSuffix)
    }

    let data = this._state.squeeze(dataByteLength)
    if (encoding !== undefined) data = data.toString(encoding)

    return data
  }

  _resetState () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  _clone () {
    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }
}


/***/ }),

/***/ 53877:
/***/ ((__unused_webpack_module, exports) => {

const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]

exports.p1600 = function (s) {
  for (let round = 0; round < 24; ++round) {
    // theta
    const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
    const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
    const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
    const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
    const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
    const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
    const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
    const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
    const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
    const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)
    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)
    const t1slo0 = s[0] ^ lo
    const t1shi0 = s[1] ^ hi
    const t1slo5 = s[10] ^ lo
    const t1shi5 = s[11] ^ hi
    const t1slo10 = s[20] ^ lo
    const t1shi10 = s[21] ^ hi
    const t1slo15 = s[30] ^ lo
    const t1shi15 = s[31] ^ hi
    const t1slo20 = s[40] ^ lo
    const t1shi20 = s[41] ^ hi
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)
    const t1slo1 = s[2] ^ lo
    const t1shi1 = s[3] ^ hi
    const t1slo6 = s[12] ^ lo
    const t1shi6 = s[13] ^ hi
    const t1slo11 = s[22] ^ lo
    const t1shi11 = s[23] ^ hi
    const t1slo16 = s[32] ^ lo
    const t1shi16 = s[33] ^ hi
    const t1slo21 = s[42] ^ lo
    const t1shi21 = s[43] ^ hi
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)
    const t1slo2 = s[4] ^ lo
    const t1shi2 = s[5] ^ hi
    const t1slo7 = s[14] ^ lo
    const t1shi7 = s[15] ^ hi
    const t1slo12 = s[24] ^ lo
    const t1shi12 = s[25] ^ hi
    const t1slo17 = s[34] ^ lo
    const t1shi17 = s[35] ^ hi
    const t1slo22 = s[44] ^ lo
    const t1shi22 = s[45] ^ hi
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)
    const t1slo3 = s[6] ^ lo
    const t1shi3 = s[7] ^ hi
    const t1slo8 = s[16] ^ lo
    const t1shi8 = s[17] ^ hi
    const t1slo13 = s[26] ^ lo
    const t1shi13 = s[27] ^ hi
    const t1slo18 = s[36] ^ lo
    const t1shi18 = s[37] ^ hi
    const t1slo23 = s[46] ^ lo
    const t1shi23 = s[47] ^ hi
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)
    const t1slo4 = s[8] ^ lo
    const t1shi4 = s[9] ^ hi
    const t1slo9 = s[18] ^ lo
    const t1shi9 = s[19] ^ hi
    const t1slo14 = s[28] ^ lo
    const t1shi14 = s[29] ^ hi
    const t1slo19 = s[38] ^ lo
    const t1shi19 = s[39] ^ hi
    const t1slo24 = s[48] ^ lo
    const t1shi24 = s[49] ^ hi

    // rho & pi
    const t2slo0 = t1slo0
    const t2shi0 = t1shi0
    const t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)
    const t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)
    const t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)
    const t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)
    const t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)
    const t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)
    const t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)
    const t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)
    const t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)
    const t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)
    const t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)
    const t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)
    const t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)
    const t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)
    const t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)
    const t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)
    const t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)
    const t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)
    const t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)
    const t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)
    const t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)
    const t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)
    const t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)
    const t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)
    const t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)
    const t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)
    const t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)
    const t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)
    const t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)
    const t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)
    const t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)
    const t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)
    const t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)
    const t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)
    const t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)
    const t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)
    const t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)
    const t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)
    const t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)
    const t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)
    const t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)
    const t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)
    const t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)
    const t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)
    const t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)
    const t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)
    const t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)
    const t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)

    // chi
    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
  }
}


/***/ }),

/***/ 55270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const keccakState = __webpack_require__(53877)

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (let i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (let i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  const output = Buffer.alloc(length)
  for (let i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak


/***/ }),

/***/ 88809:
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.q = codes;


/***/ }),

/***/ 19589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(8888);

var Writable = __webpack_require__(11870);

__webpack_require__(98874)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 32514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(45842);

__webpack_require__(98874)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 8888:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = (__webpack_require__(82361).EventEmitter);

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(17510);
/*</replacement>*/


var Buffer = (__webpack_require__(14300).Buffer);

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(73837);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(61951);

var destroyImpl = __webpack_require__(13143);

var _require = __webpack_require__(34800),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(88809)/* .codes */ .q),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(98874)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(19589);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(30214)/* .StringDecoder */ .s);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(19589);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(30214)/* .StringDecoder */ .s);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(38883);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(88658);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ 45842:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = (__webpack_require__(88809)/* .codes */ .q),
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(19589);

__webpack_require__(98874)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 11870:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(63854)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(17510);
/*</replacement>*/


var Buffer = (__webpack_require__(14300).Buffer);

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(13143);

var _require = __webpack_require__(34800),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(88809)/* .codes */ .q),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(98874)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(19589);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(19589); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 38883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(97177);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 61951:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(14300),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(73837),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ 13143:
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 97177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(88809)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE);

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ 88658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERR_INVALID_ARG_TYPE = (__webpack_require__(88809)/* .codes.ERR_INVALID_ARG_TYPE */ .q.ERR_INVALID_ARG_TYPE);

function from(Readable, iterable, opts) {
  var iterator;

  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);

  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts)); // Reading boolean to protect against _read
  // being called before last iteration completion.

  var reading = false;

  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };

  function next() {
    return _next2.apply(this, arguments);
  }

  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _ref = yield iterator.next(),
            value = _ref.value,
            done = _ref.done;

        if (done) {
          readable.push(null);
        } else if (readable.push((yield value))) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }

  return readable;
}

module.exports = from;

/***/ }),

/***/ 11603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = (__webpack_require__(88809)/* .codes */ .q),
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(97177);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ 34800:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(88809)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE);

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 17510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 95690:
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(8888);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(11870);
  exports.Duplex = __webpack_require__(19589);
  exports.Transform = __webpack_require__(45842);
  exports.PassThrough = __webpack_require__(32514);
  exports.finished = __webpack_require__(97177);
  exports.pipeline = __webpack_require__(11603);
}


/***/ }),

/***/ 77105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(8006)

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ 11242:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var http = __webpack_require__(13685);

/**
 * Module exports.
 * @public
 */

module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

/**
 * Get the current Node.js methods.
 * @private
 */

function getCurrentNodeMethods() {
  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}

/**
 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
 * @private
 */

function getBasicNodeMethods() {
  return [
    'get',
    'post',
    'put',
    'head',
    'delete',
    'options',
    'trace',
    'copy',
    'lock',
    'mkcol',
    'move',
    'purge',
    'propfind',
    'proppatch',
    'unlock',
    'report',
    'mkactivity',
    'checkout',
    'merge',
    'm-search',
    'notify',
    'subscribe',
    'unsubscribe',
    'patch',
    'search',
    'connect'
  ];
}


/***/ }),

/***/ 9474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(57104)


/***/ }),

/***/ 6856:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(9474)
var extname = (__webpack_require__(71017).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 28939:
/***/ ((module) => {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ }),

/***/ 74050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Mime = __webpack_require__(28939);
module.exports = new Mime(__webpack_require__(43404), __webpack_require__(91420));


/***/ }),

/***/ 91420:
/***/ ((module) => {

module.exports = {"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};

/***/ }),

/***/ 43404:
/***/ ((module) => {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/mrb-consumer+xml":["*xdf"],"application/mrb-publish+xml":["*xdf"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["*xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-error+xml":["xer"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ }),

/***/ 79561:
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ 43022:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ 89038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(57147)
var path = __webpack_require__(71017)
var os = __webpack_require__(22037)

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? require : 0 // eslint-disable-line

var vars = (process.config && process.config.variables) || {}
var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : 'node'
var arch = os.arch()
var platform = os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''
var uv = (process.versions.uv || '').split('.')[0]

module.exports = load

function load (dir) {
  return runtimeRequire(load.path(dir))
}

load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var prebuild = resolve(dir)
  if (prebuild) return prebuild

  var nearby = resolve(path.dirname(process.execPath))
  if (nearby) return nearby

  var target = [
    'platform=' + platform,
    'arch=' + arch,
    'runtime=' + runtime,
    'abi=' + abi,
    'uv=' + uv,
    armv ? 'armv=' + armv : '',
    'libc=' + libc,
    'node=' + process.versions.node,
    (process.versions && process.versions.electron) ? 'electron=' + process.versions.electron : '',
     true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ')

  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

  function resolve (dir) {
    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', platform + '-' + arch)
    var parsed = readdirSync(prebuilds).map(parseTags)
    var candidates = parsed.filter(matchTags(runtime, abi))
    var winner = candidates.sort(compareTags(runtime))[0]
    if (winner) return path.join(prebuilds, winner.file)
  }
}

function readdirSync (dir) {
  try {
    return fs.readdirSync(dir)
  } catch (err) {
    return []
  }
}

function getFirst (dir, filter) {
  var files = readdirSync(dir).filter(filter)
  return files[0] && path.join(dir, files[0])
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function parseTags (file) {
  var arr = file.split('.')
  var extension = arr.pop()
  var tags = { file: file, specificity: 0 }

  if (extension !== 'node') return

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i]

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag
    } else if (tag === 'napi') {
      tags.napi = true
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3)
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2)
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4)
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag
    } else {
      continue
    }

    tags.specificity++
  }

  return tags
}

function matchTags (runtime, abi) {
  return function (tags) {
    if (tags == null) return false
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
    if (tags.abi !== abi && !tags.napi) return false
    if (tags.uv && tags.uv !== uv) return false
    if (tags.armv && tags.armv !== armv) return false
    if (tags.libc && tags.libc !== libc) return false

    return true
  }
}

function runtimeAgnostic (tags) {
  return tags.runtime === 'node' && tags.napi
}

function compareTags (runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1
    } else {
      return 0
    }
  }
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}

// Exposed for unit tests
// TODO: move to lib
load.parseTags = parseTags
load.matchTags = matchTags
load.compareTags = compareTags


/***/ }),

/***/ 99500:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

var inspectCustom = (__webpack_require__(6374).custom);
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var toStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag !== 'undefined' ? Symbol.toStringTag : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') {
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + keys.join(', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + [].concat(stringTag || [], protoTag || []).join(': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + ys.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 6374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(73837).inspect;


/***/ }),

/***/ 81239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var native = __webpack_require__(6113)

var checkParameters = __webpack_require__(87351)
var defaultEncoding = __webpack_require__(25214)
var toBuffer = __webpack_require__(97232)

function nativePBKDF2 (password, salt, iterations, keylen, digest, callback) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  if (typeof digest === 'function') {
    callback = digest
    digest = 'sha1'
  }
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  return native.pbkdf2(password, salt, iterations, keylen, digest, callback)
}

function nativePBKDF2Sync (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  digest = digest || 'sha1'
  return native.pbkdf2Sync(password, salt, iterations, keylen, digest)
}

/* istanbul ignore next */
if (!native.pbkdf2Sync || native.pbkdf2Sync.toString().indexOf('keylen, digest') === -1) {
  exports.pbkdf2Sync = __webpack_require__(62093)
  exports.pbkdf2 = __webpack_require__(14874)

// native
} else {
  exports.pbkdf2Sync = nativePBKDF2Sync
  exports.pbkdf2 = nativePBKDF2
}


/***/ }),

/***/ 14874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(77834).Buffer)

var checkParameters = __webpack_require__(87351)
var defaultEncoding = __webpack_require__(25214)
var sync = __webpack_require__(62093)
var toBuffer = __webpack_require__(97232)

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask
  } else if (global.setImmediate) {
    nextTick = global.setImmediate
  } else {
    nextTick = global.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}


/***/ }),

/***/ 25214:
/***/ ((module) => {

var defaultEncoding
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8'
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding


/***/ }),

/***/ 87351:
/***/ ((module) => {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),

/***/ 62093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

var createHmac = __webpack_require__(16245)
var Buffer = (__webpack_require__(77834).Buffer)

var checkParameters = __webpack_require__(87351)
var defaultEncoding = __webpack_require__(25214)
var toBuffer = __webpack_require__(97232)

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = createHmac(digest, password).update(block1).digest()
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ 97232:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(77834).Buffer)

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}


/***/ }),

/***/ 85527:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ 19126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(66845);
var parse = __webpack_require__(29166);
var formats = __webpack_require__(85527);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 29166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(12493);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 66845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(74294);
var utils = __webpack_require__(12493);
var formats = __webpack_require__(85527);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    if (sideChannel.has(object)) {
        throw new RangeError('Cyclic object value');
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = typeof key === 'object' && key.value !== undefined ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
            : prefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, true);
        var valueSideChannel = getSideChannel();
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 12493:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(85527);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ 91249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6113).randomBytes


/***/ }),

/***/ 77834:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(14300)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 14689:
/***/ (function(module) {

"use strict";


(function(root) {
    const MAX_VALUE = 0x7fffffff;

    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
       ]);

        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);

        function blocks(p) {
            let off = 0, len = p.length;
            while (len >= 64) {
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;

                for (i = 0; i < 16; i++) {
                    j = off + i*4;
                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |
                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);
                }

                for (i = 16; i < 64; i++) {
                    u = w[i-2];
                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);

                    u = w[i-15];
                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);

                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;
                }

                for (i = 0; i < 64; i++) {
                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^
                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +
                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;

                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^
                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;

                    h = g;
                    g = f;
                    f = e;
                    e = (d + t1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0;
                h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0;
                h7 = (h7 + h) | 0;

                off += 64;
                len -= 64;
            }
        }

        blocks(m);

        let i, bytesLeft = m.length % 64,
        bitLenHi = (m.length / 0x20000000) | 0,
        bitLenLo = m.length << 3,
        numZeros = (bytesLeft < 56) ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);

        p.push(0x80);
        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }
        p.push((bitLenHi >>> 24) & 0xff);
        p.push((bitLenHi >>> 16) & 0xff);
        p.push((bitLenHi >>> 8)  & 0xff);
        p.push((bitLenHi >>> 0)  & 0xff);
        p.push((bitLenLo >>> 24) & 0xff);
        p.push((bitLenLo >>> 16) & 0xff);
        p.push((bitLenLo >>> 8)  & 0xff);
        p.push((bitLenLo >>> 0)  & 0xff);

        blocks(p);

        return [
            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,
            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,
            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,
            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,
            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,
            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,
            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,
            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff
        ];
    }

    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = (password.length <= 64) ? password : SHA256(password);

        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);

        let i;
        let dk = [];

        // inner = (password ^ ipad) || salt || counter
        for (i = 0; i < 64; i++) { inner[i] = 0x36; }
        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }
        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }
        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }

        // outerKey = password ^ opad
        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

        // increments counter inside inner
        function incrementCounter() {
            for (let i = innerLen - 1; i >= innerLen - 4; i--) {
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }

        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }

        return dk;
    }

    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;

        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
    }

    function R(a, b) {
        return (a << b) | (a >>> (32 - b));
    }

    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);

        for (let i = 8; i > 0; i -= 2) {
            x[ 4] ^= R(x[ 0] + x[12], 7);
            x[ 8] ^= R(x[ 4] + x[ 0], 9);
            x[12] ^= R(x[ 8] + x[ 4], 13);
            x[ 0] ^= R(x[12] + x[ 8], 18);
            x[ 9] ^= R(x[ 5] + x[ 1], 7);
            x[13] ^= R(x[ 9] + x[ 5], 9);
            x[ 1] ^= R(x[13] + x[ 9], 13);
            x[ 5] ^= R(x[ 1] + x[13], 18);
            x[14] ^= R(x[10] + x[ 6], 7);
            x[ 2] ^= R(x[14] + x[10], 9);
            x[ 6] ^= R(x[ 2] + x[14], 13);
            x[10] ^= R(x[ 6] + x[ 2], 18);
            x[ 3] ^= R(x[15] + x[11], 7);
            x[ 7] ^= R(x[ 3] + x[15], 9);
            x[11] ^= R(x[ 7] + x[ 3], 13);
            x[15] ^= R(x[11] + x[ 7], 18);
            x[ 1] ^= R(x[ 0] + x[ 3], 7);
            x[ 2] ^= R(x[ 1] + x[ 0], 9);
            x[ 3] ^= R(x[ 2] + x[ 1], 13);
            x[ 0] ^= R(x[ 3] + x[ 2], 18);
            x[ 6] ^= R(x[ 5] + x[ 4], 7);
            x[ 7] ^= R(x[ 6] + x[ 5], 9);
            x[ 4] ^= R(x[ 7] + x[ 6], 13);
            x[ 5] ^= R(x[ 4] + x[ 7], 18);
            x[11] ^= R(x[10] + x[ 9], 7);
            x[ 8] ^= R(x[11] + x[10], 9);
            x[ 9] ^= R(x[ 8] + x[11], 13);
            x[10] ^= R(x[ 9] + x[ 8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }

        for (let i = 0; i < 16; ++i) {
            B[i] += x[i];
        }
    }

    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
            D[i] ^= S[Si + i]
        }
    }

    function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
            dest[destPos++] = src[srcPos++];
        }
    }

    function checkBufferish(o) {
        if (!o || typeof(o.length) !== 'number') { return false; }

        for (let i = 0; i < o.length; i++) {
            const v = o[i];
            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {
                return false;
            }
        }

        return true;
    }

    function ensureInteger(value, name) {
        if (typeof(value) !== "number" || (value % 1)) { throw new Error('invalid ' + name); }
        return value;
    }

    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {

        N = ensureInteger(N, 'N');
        r = ensureInteger(r, 'r');
        p = ensureInteger(p, 'p');

        dkLen = ensureInteger(dkLen, 'dkLen');

        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }

        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }
        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }

        if (!checkBufferish(password)) {
            throw new Error('password must be an array or buffer');
        }
        password = Array.prototype.slice.call(password);

        if (!checkBufferish(salt)) {
            throw new Error('salt must be an array or buffer');
        }
        salt = Array.prototype.slice.call(salt);

        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r)
        for (let i = 0; i < B.length; i++) {
            const j = i * 4;
            B[i] = ((b[j + 3] & 0xff) << 24) |
                   ((b[j + 2] & 0xff) << 16) |
                   ((b[j + 1] & 0xff) << 8) |
                   ((b[j + 0] & 0xff) << 0);
        }

        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);

        const Yi = 32 * r;

        // scratch space
        const x = new Uint32Array(16);       // salsa20_8
        const _X = new Uint32Array(16);      // blockmix_salsa8

        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;

        // Set this to true to abandon the scrypt on the next step
        let stop = false;

        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;

        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r): 0xffffffff;

        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;

        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) {
                return callback(new Error('cancelled'), currentOp / totalOps);
            }

            let steps;

            switch (state) {
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;

                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1

                    state = 1;                                         // Move to ROMix 2
                    i1 = 0;

                    // Fall through

                case 1:

                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                  // ROMix - 2
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3
                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4
                    }

                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;

                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    i1 = 0;                                          // Move to ROMix 6
                    state = 2;

                    // Fall through

                case 2:

                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                // ROMix - 6
                        const offset = (2 * r - 1) * 16;             // ROMix - 7
                        const j = XY[offset] & (N - 1);
                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)
                    }

                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;

                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10

                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }

                    b = [];
                    for (let i = 0; i < B.length; i++) {
                        b.push((B[i] >>  0) & 0xff);
                        b.push((B[i] >>  8) & 0xff);
                        b.push((B[i] >> 16) & 0xff);
                        b.push((B[i] >> 24) & 0xff);
                    }

                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

                    // Send the result to the callback
                    if (callback) { callback(null, 1.0, derivedKey); }

                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }

            // Schedule the next steps
            if (callback) { nextTick(incrementalSMix); }
        }

        // Run the smix state machine until completion
        if (!callback) {
            while (true) {
                const derivedKey = incrementalSMix();
                if (derivedKey != undefined) { return derivedKey; }
            }
        }

        // Bootstrap the async incremental smix
        incrementalSMix();
    }

    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) { progressCallback(0); }
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) {
                        reject(error);
                    } else if (key) {
                        if (progressCallback && lastProgress !== 1) {
                            progressCallback(1);
                        }
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };

    // node.js
    if (true) {
       module.exports = lib;

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}

})(this);


/***/ }),

/***/ 23992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(57353)('secp256k1')


/***/ }),

/***/ 97637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(15880)(__webpack_require__(36010))


/***/ }),

/***/ 62970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

try {
  module.exports = __webpack_require__(23992)
} catch (err) {
  if (process.env.DEBUG) {
    console.error('Secp256k1 bindings are not compiled. Pure JS implementation will be used.')
  }

  module.exports = __webpack_require__(97637)
}


/***/ }),

/***/ 2250:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];

var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}


/***/ }),

/***/ 65633:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(77834).Buffer)
var bip66 = __webpack_require__(39875)

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}


/***/ }),

/***/ 36010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(77834).Buffer)
var createHash = __webpack_require__(49373)
var BN = __webpack_require__(62197)
var EC = (__webpack_require__(87554).ec)

var messages = __webpack_require__(63747)

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}


/***/ }),

/***/ 15880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var assert = __webpack_require__(2250)
var der = __webpack_require__(65633)
var messages = __webpack_require__(63747)

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}


/***/ }),

/***/ 7847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(71388)
const {re, t} = __webpack_require__(94808)
const cmp = __webpack_require__(28117)
const debug = __webpack_require__(10952)
const SemVer = __webpack_require__(52435)
const Range = __webpack_require__(66843)


/***/ }),

/***/ 66843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(77105)
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(71388)
const Comparator = __webpack_require__(7847)
const debug = __webpack_require__(10952)
const SemVer = __webpack_require__(52435)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(94808)

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ 52435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(10952)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(55558)
const { re, t } = __webpack_require__(94808)

const parseOptions = __webpack_require__(71388)
const { compareIdentifiers } = __webpack_require__(14935)
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ 36694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(79943)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ 28117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(33276)
const neq = __webpack_require__(77893)
const gt = __webpack_require__(16379)
const gte = __webpack_require__(8463)
const lt = __webpack_require__(21897)
const lte = __webpack_require__(30506)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ 98686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const parse = __webpack_require__(79943)
const {re, t} = __webpack_require__(94808)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ 65914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ 55404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ 92271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ 66007:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(79943)
const eq = __webpack_require__(33276)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ 33276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ 16379:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ 8463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ 86360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ 21897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ 30506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ 14551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ 469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ 77893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ 79943:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(55558)
const { re, t } = __webpack_require__(94808)
const SemVer = __webpack_require__(52435)

const parseOptions = __webpack_require__(71388)
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ 54250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ 58204:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(79943)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ 70733:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(92271)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ 72961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(65914)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ 59844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(66843)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ 51116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(65914)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ 97230:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(79943)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ 97699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(94808)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: (__webpack_require__(55558).SEMVER_SPEC_VERSION),
  SemVer: __webpack_require__(52435),
  compareIdentifiers: (__webpack_require__(14935).compareIdentifiers),
  rcompareIdentifiers: (__webpack_require__(14935).rcompareIdentifiers),
  parse: __webpack_require__(79943),
  valid: __webpack_require__(97230),
  clean: __webpack_require__(36694),
  inc: __webpack_require__(86360),
  diff: __webpack_require__(66007),
  major: __webpack_require__(14551),
  minor: __webpack_require__(469),
  patch: __webpack_require__(54250),
  prerelease: __webpack_require__(58204),
  compare: __webpack_require__(92271),
  rcompare: __webpack_require__(70733),
  compareLoose: __webpack_require__(55404),
  compareBuild: __webpack_require__(65914),
  sort: __webpack_require__(51116),
  rsort: __webpack_require__(72961),
  gt: __webpack_require__(16379),
  lt: __webpack_require__(21897),
  eq: __webpack_require__(33276),
  neq: __webpack_require__(77893),
  gte: __webpack_require__(8463),
  lte: __webpack_require__(30506),
  cmp: __webpack_require__(28117),
  coerce: __webpack_require__(98686),
  Comparator: __webpack_require__(7847),
  Range: __webpack_require__(66843),
  satisfies: __webpack_require__(59844),
  toComparators: __webpack_require__(48865),
  maxSatisfying: __webpack_require__(53727),
  minSatisfying: __webpack_require__(14338),
  minVersion: __webpack_require__(21542),
  validRange: __webpack_require__(36240),
  outside: __webpack_require__(89106),
  gtr: __webpack_require__(90995),
  ltr: __webpack_require__(47805),
  intersects: __webpack_require__(22013),
  simplifyRange: __webpack_require__(81338),
  subset: __webpack_require__(53122),
}


/***/ }),

/***/ 55558:
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),

/***/ 10952:
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ 14935:
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),

/***/ 71388:
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),

/***/ 94808:
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(55558)
const debug = __webpack_require__(10952)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),

/***/ 90995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(89106)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ 22013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(66843)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ 47805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(89106)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ 53727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const Range = __webpack_require__(66843)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ 14338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const Range = __webpack_require__(66843)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ 21542:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const Range = __webpack_require__(66843)
const gt = __webpack_require__(16379)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ 89106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(52435)
const Comparator = __webpack_require__(7847)
const {ANY} = Comparator
const Range = __webpack_require__(66843)
const satisfies = __webpack_require__(59844)
const gt = __webpack_require__(16379)
const lt = __webpack_require__(21897)
const lte = __webpack_require__(30506)
const gte = __webpack_require__(8463)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ 81338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(59844)
const compare = __webpack_require__(92271)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ 53122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(66843)
const Comparator = __webpack_require__(7847)
const { ANY } = Comparator
const satisfies = __webpack_require__(59844)
const compare = __webpack_require__(92271)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ 48865:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(66843)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ 36240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(66843)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ 74294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(67286);
var callBound = __webpack_require__(62680);
var inspect = __webpack_require__(99500);

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ 30214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(77834).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 79826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isHexPrefixed = __webpack_require__(38320);

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}


/***/ }),

/***/ 66545:
/***/ ((module) => {

"use strict";


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function Agent() {
  this._defaults = [];
}

['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert', 'disableTLSCerts'].forEach(function (fn) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, _toConsumableArray(def.args));
  });
};

module.exports = Agent;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZ2VudC1iYXNlLmpzIl0sIm5hbWVzIjpbIkFnZW50IiwiX2RlZmF1bHRzIiwiZm9yRWFjaCIsImZuIiwicHJvdG90eXBlIiwiYXJncyIsInB1c2giLCJfc2V0RGVmYXVsdHMiLCJyZXEiLCJkZWYiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLEtBQVQsR0FBaUI7QUFDZixPQUFLQyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0Q7O0FBRUQsQ0FDRSxLQURGLEVBRUUsSUFGRixFQUdFLE1BSEYsRUFJRSxLQUpGLEVBS0UsT0FMRixFQU1FLE1BTkYsRUFPRSxRQVBGLEVBUUUsTUFSRixFQVNFLGlCQVRGLEVBVUUsV0FWRixFQVdFLE9BWEYsRUFZRSxJQVpGLEVBYUUsV0FiRixFQWNFLFNBZEYsRUFlRSxRQWZGLEVBZ0JFLFdBaEJGLEVBaUJFLE9BakJGLEVBa0JFLElBbEJGLEVBbUJFLEtBbkJGLEVBb0JFLEtBcEJGLEVBcUJFLE1BckJGLEVBc0JFLGlCQXRCRixFQXVCRUMsT0F2QkYsQ0F1QlUsVUFBQ0MsRUFBRCxFQUFRO0FBQ2hCO0FBQ0FILEVBQUFBLEtBQUssQ0FBQ0ksU0FBTixDQUFnQkQsRUFBaEIsSUFBc0IsWUFBbUI7QUFBQSxzQ0FBTkUsSUFBTTtBQUFOQSxNQUFBQSxJQUFNO0FBQUE7O0FBQ3ZDLFNBQUtKLFNBQUwsQ0FBZUssSUFBZixDQUFvQjtBQUFFSCxNQUFBQSxFQUFFLEVBQUZBLEVBQUY7QUFBTUUsTUFBQUEsSUFBSSxFQUFKQTtBQUFOLEtBQXBCOztBQUNBLFdBQU8sSUFBUDtBQUNELEdBSEQ7QUFJRCxDQTdCRDs7QUErQkFMLEtBQUssQ0FBQ0ksU0FBTixDQUFnQkcsWUFBaEIsR0FBK0IsVUFBVUMsR0FBVixFQUFlO0FBQzVDLE9BQUtQLFNBQUwsQ0FBZUMsT0FBZixDQUF1QixVQUFDTyxHQUFELEVBQVM7QUFDOUJELElBQUFBLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDTixFQUFMLENBQUgsT0FBQUssR0FBRyxxQkFBWUMsR0FBRyxDQUFDSixJQUFoQixFQUFIO0FBQ0QsR0FGRDtBQUdELENBSkQ7O0FBTUFLLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlgsS0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1xuICAndXNlJyxcbiAgJ29uJyxcbiAgJ29uY2UnLFxuICAnc2V0JyxcbiAgJ3F1ZXJ5JyxcbiAgJ3R5cGUnLFxuICAnYWNjZXB0JyxcbiAgJ2F1dGgnLFxuICAnd2l0aENyZWRlbnRpYWxzJyxcbiAgJ3NvcnRRdWVyeScsXG4gICdyZXRyeScsXG4gICdvaycsXG4gICdyZWRpcmVjdHMnLFxuICAndGltZW91dCcsXG4gICdidWZmZXInLFxuICAnc2VyaWFsaXplJyxcbiAgJ3BhcnNlJyxcbiAgJ2NhJyxcbiAgJ2tleScsXG4gICdwZngnLFxuICAnY2VydCcsXG4gICdkaXNhYmxlVExTQ2VydHMnXG5dLmZvckVhY2goKGZuKSA9PiB7XG4gIC8vIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudFxuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHsgZm4sIGFyZ3MgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgdGhpcy5fZGVmYXVsdHMuZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgcmVxW2RlZi5mbl0oLi4uZGVmLmFyZ3MpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnQ7XG4iXX0=

/***/ }),

/***/ 73354:
/***/ ((module) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
}

module.exports = isObject;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pcy1vYmplY3QuanMiXSwibmFtZXMiOlsiaXNPYmplY3QiLCJvYmoiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7QUFRQSxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNyQixTQUFPQSxHQUFHLEtBQUssSUFBUixJQUFnQixRQUFPQSxHQUFQLE1BQWUsUUFBdEM7QUFDRDs7QUFFREMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSCxRQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiJdfQ==

/***/ }),

/***/ 54921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */
// eslint-disable-next-line node/no-deprecated-api
var _require = __webpack_require__(57310),
    parse = _require.parse;

var _require2 = __webpack_require__(29392),
    CookieJar = _require2.CookieJar;

var _require3 = __webpack_require__(29392),
    CookieAccessInfo = _require3.CookieAccessInfo;

var methods = __webpack_require__(11242);

var request = __webpack_require__(32075);

var AgentBase = __webpack_require__(66545);
/**
 * Expose `Agent`.
 */


module.exports = Agent;
/**
 * Initialize a new `Agent`.
 *
 * @api public
 */

function Agent(options) {
  if (!(this instanceof Agent)) {
    return new Agent(options);
  }

  AgentBase.call(this);
  this.jar = new CookieJar();

  if (options) {
    if (options.ca) {
      this.ca(options.ca);
    }

    if (options.key) {
      this.key(options.key);
    }

    if (options.pfx) {
      this.pfx(options.pfx);
    }

    if (options.cert) {
      this.cert(options.cert);
    }

    if (options.rejectUnauthorized === false) {
      this.disableTLSCerts();
    }
  }
}

Agent.prototype = Object.create(AgentBase.prototype);
/**
 * Save the cookies in the given `res` to
 * the agent's cookie jar for persistence.
 *
 * @param {Response} res
 * @api private
 */

Agent.prototype._saveCookies = function (res) {
  var cookies = res.headers['set-cookie'];
  if (cookies) this.jar.setCookies(cookies);
};
/**
 * Attach cookies when available to the given `req`.
 *
 * @param {Request} req
 * @api private
 */


Agent.prototype._attachCookies = function (req) {
  var url = parse(req.url);
  var access = new CookieAccessInfo(url.hostname, url.pathname, url.protocol === 'https:');
  var cookies = this.jar.getCookies(access).toValueString();
  req.cookies = cookies;
};

methods.forEach(function (name) {
  var method = name.toUpperCase();

  Agent.prototype[name] = function (url, fn) {
    var req = new request.Request(method, url);
    req.on('response', this._saveCookies.bind(this));
    req.on('redirect', this._saveCookies.bind(this));
    req.on('redirect', this._attachCookies.bind(this, req));

    this._setDefaults(req);

    this._attachCookies(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype.delete;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL2FnZW50LmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJwYXJzZSIsIkNvb2tpZUphciIsIkNvb2tpZUFjY2Vzc0luZm8iLCJtZXRob2RzIiwicmVxdWVzdCIsIkFnZW50QmFzZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJBZ2VudCIsIm9wdGlvbnMiLCJjYWxsIiwiamFyIiwiY2EiLCJrZXkiLCJwZngiLCJjZXJ0IiwicmVqZWN0VW5hdXRob3JpemVkIiwiZGlzYWJsZVRMU0NlcnRzIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiX3NhdmVDb29raWVzIiwicmVzIiwiY29va2llcyIsImhlYWRlcnMiLCJzZXRDb29raWVzIiwiX2F0dGFjaENvb2tpZXMiLCJyZXEiLCJ1cmwiLCJhY2Nlc3MiLCJob3N0bmFtZSIsInBhdGhuYW1lIiwicHJvdG9jb2wiLCJnZXRDb29raWVzIiwidG9WYWx1ZVN0cmluZyIsImZvckVhY2giLCJuYW1lIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJmbiIsIlJlcXVlc3QiLCJvbiIsImJpbmQiLCJfc2V0RGVmYXVsdHMiLCJlbmQiLCJkZWwiLCJkZWxldGUiXSwibWFwcGluZ3MiOiI7O0FBQUE7OztBQUlBO2VBQ2tCQSxPQUFPLENBQUMsS0FBRCxDO0lBQWpCQyxLLFlBQUFBLEs7O2dCQUNjRCxPQUFPLENBQUMsV0FBRCxDO0lBQXJCRSxTLGFBQUFBLFM7O2dCQUNxQkYsT0FBTyxDQUFDLFdBQUQsQztJQUE1QkcsZ0IsYUFBQUEsZ0I7O0FBQ1IsSUFBTUMsT0FBTyxHQUFHSixPQUFPLENBQUMsU0FBRCxDQUF2Qjs7QUFDQSxJQUFNSyxPQUFPLEdBQUdMLE9BQU8sQ0FBQyxPQUFELENBQXZCOztBQUNBLElBQU1NLFNBQVMsR0FBR04sT0FBTyxDQUFDLGVBQUQsQ0FBekI7QUFFQTs7Ozs7QUFJQU8sTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxLQUFqQjtBQUVBOzs7Ozs7QUFNQSxTQUFTQSxLQUFULENBQWVDLE9BQWYsRUFBd0I7QUFDdEIsTUFBSSxFQUFFLGdCQUFnQkQsS0FBbEIsQ0FBSixFQUE4QjtBQUM1QixXQUFPLElBQUlBLEtBQUosQ0FBVUMsT0FBVixDQUFQO0FBQ0Q7O0FBRURKLEVBQUFBLFNBQVMsQ0FBQ0ssSUFBVixDQUFlLElBQWY7QUFDQSxPQUFLQyxHQUFMLEdBQVcsSUFBSVYsU0FBSixFQUFYOztBQUVBLE1BQUlRLE9BQUosRUFBYTtBQUNYLFFBQUlBLE9BQU8sQ0FBQ0csRUFBWixFQUFnQjtBQUNkLFdBQUtBLEVBQUwsQ0FBUUgsT0FBTyxDQUFDRyxFQUFoQjtBQUNEOztBQUVELFFBQUlILE9BQU8sQ0FBQ0ksR0FBWixFQUFpQjtBQUNmLFdBQUtBLEdBQUwsQ0FBU0osT0FBTyxDQUFDSSxHQUFqQjtBQUNEOztBQUVELFFBQUlKLE9BQU8sQ0FBQ0ssR0FBWixFQUFpQjtBQUNmLFdBQUtBLEdBQUwsQ0FBU0wsT0FBTyxDQUFDSyxHQUFqQjtBQUNEOztBQUVELFFBQUlMLE9BQU8sQ0FBQ00sSUFBWixFQUFrQjtBQUNoQixXQUFLQSxJQUFMLENBQVVOLE9BQU8sQ0FBQ00sSUFBbEI7QUFDRDs7QUFFRCxRQUFJTixPQUFPLENBQUNPLGtCQUFSLEtBQStCLEtBQW5DLEVBQTBDO0FBQ3hDLFdBQUtDLGVBQUw7QUFDRDtBQUNGO0FBQ0Y7O0FBRURULEtBQUssQ0FBQ1UsU0FBTixHQUFrQkMsTUFBTSxDQUFDQyxNQUFQLENBQWNmLFNBQVMsQ0FBQ2EsU0FBeEIsQ0FBbEI7QUFFQTs7Ozs7Ozs7QUFRQVYsS0FBSyxDQUFDVSxTQUFOLENBQWdCRyxZQUFoQixHQUErQixVQUFVQyxHQUFWLEVBQWU7QUFDNUMsTUFBTUMsT0FBTyxHQUFHRCxHQUFHLENBQUNFLE9BQUosQ0FBWSxZQUFaLENBQWhCO0FBQ0EsTUFBSUQsT0FBSixFQUFhLEtBQUtaLEdBQUwsQ0FBU2MsVUFBVCxDQUFvQkYsT0FBcEI7QUFDZCxDQUhEO0FBS0E7Ozs7Ozs7O0FBT0FmLEtBQUssQ0FBQ1UsU0FBTixDQUFnQlEsY0FBaEIsR0FBaUMsVUFBVUMsR0FBVixFQUFlO0FBQzlDLE1BQU1DLEdBQUcsR0FBRzVCLEtBQUssQ0FBQzJCLEdBQUcsQ0FBQ0MsR0FBTCxDQUFqQjtBQUNBLE1BQU1DLE1BQU0sR0FBRyxJQUFJM0IsZ0JBQUosQ0FDYjBCLEdBQUcsQ0FBQ0UsUUFEUyxFQUViRixHQUFHLENBQUNHLFFBRlMsRUFHYkgsR0FBRyxDQUFDSSxRQUFKLEtBQWlCLFFBSEosQ0FBZjtBQUtBLE1BQU1ULE9BQU8sR0FBRyxLQUFLWixHQUFMLENBQVNzQixVQUFULENBQW9CSixNQUFwQixFQUE0QkssYUFBNUIsRUFBaEI7QUFDQVAsRUFBQUEsR0FBRyxDQUFDSixPQUFKLEdBQWNBLE9BQWQ7QUFDRCxDQVREOztBQVdBcEIsT0FBTyxDQUFDZ0MsT0FBUixDQUFnQixVQUFDQyxJQUFELEVBQVU7QUFDeEIsTUFBTUMsTUFBTSxHQUFHRCxJQUFJLENBQUNFLFdBQUwsRUFBZjs7QUFDQTlCLEVBQUFBLEtBQUssQ0FBQ1UsU0FBTixDQUFnQmtCLElBQWhCLElBQXdCLFVBQVVSLEdBQVYsRUFBZVcsRUFBZixFQUFtQjtBQUN6QyxRQUFNWixHQUFHLEdBQUcsSUFBSXZCLE9BQU8sQ0FBQ29DLE9BQVosQ0FBb0JILE1BQXBCLEVBQTRCVCxHQUE1QixDQUFaO0FBRUFELElBQUFBLEdBQUcsQ0FBQ2MsRUFBSixDQUFPLFVBQVAsRUFBbUIsS0FBS3BCLFlBQUwsQ0FBa0JxQixJQUFsQixDQUF1QixJQUF2QixDQUFuQjtBQUNBZixJQUFBQSxHQUFHLENBQUNjLEVBQUosQ0FBTyxVQUFQLEVBQW1CLEtBQUtwQixZQUFMLENBQWtCcUIsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBbkI7QUFDQWYsSUFBQUEsR0FBRyxDQUFDYyxFQUFKLENBQU8sVUFBUCxFQUFtQixLQUFLZixjQUFMLENBQW9CZ0IsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0JmLEdBQS9CLENBQW5COztBQUNBLFNBQUtnQixZQUFMLENBQWtCaEIsR0FBbEI7O0FBQ0EsU0FBS0QsY0FBTCxDQUFvQkMsR0FBcEI7O0FBRUEsUUFBSVksRUFBSixFQUFRO0FBQ05aLE1BQUFBLEdBQUcsQ0FBQ2lCLEdBQUosQ0FBUUwsRUFBUjtBQUNEOztBQUVELFdBQU9aLEdBQVA7QUFDRCxHQWREO0FBZUQsQ0FqQkQ7QUFtQkFuQixLQUFLLENBQUNVLFNBQU4sQ0FBZ0IyQixHQUFoQixHQUFzQnJDLEtBQUssQ0FBQ1UsU0FBTixDQUFnQjRCLE1BQXRDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpXG5jb25zdCB7IHBhcnNlIH0gPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHsgQ29va2llSmFyIH0gPSByZXF1aXJlKCdjb29raWVqYXInKTtcbmNvbnN0IHsgQ29va2llQWNjZXNzSW5mbyB9ID0gcmVxdWlyZSgnY29va2llamFyJyk7XG5jb25zdCBtZXRob2RzID0gcmVxdWlyZSgnbWV0aG9kcycpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4uLy4uJyk7XG5jb25zdCBBZ2VudEJhc2UgPSByZXF1aXJlKCcuLi9hZ2VudC1iYXNlJyk7XG5cbi8qKlxuICogRXhwb3NlIGBBZ2VudGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBBZ2VudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBZ2VudChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBZ2VudCkpIHtcbiAgICByZXR1cm4gbmV3IEFnZW50KG9wdGlvbnMpO1xuICB9XG5cbiAgQWdlbnRCYXNlLmNhbGwodGhpcyk7XG4gIHRoaXMuamFyID0gbmV3IENvb2tpZUphcigpO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuY2EpIHtcbiAgICAgIHRoaXMuY2Eob3B0aW9ucy5jYSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMua2V5KSB7XG4gICAgICB0aGlzLmtleShvcHRpb25zLmtleSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGZ4KSB7XG4gICAgICB0aGlzLnBmeChvcHRpb25zLnBmeCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2VydCkge1xuICAgICAgdGhpcy5jZXJ0KG9wdGlvbnMuY2VydCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5kaXNhYmxlVExTQ2VydHMoKTtcbiAgICB9XG4gIH1cbn1cblxuQWdlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBZ2VudEJhc2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTYXZlIHRoZSBjb29raWVzIGluIHRoZSBnaXZlbiBgcmVzYCB0b1xuICogdGhlIGFnZW50J3MgY29va2llIGphciBmb3IgcGVyc2lzdGVuY2UuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2VudC5wcm90b3R5cGUuX3NhdmVDb29raWVzID0gZnVuY3Rpb24gKHJlcykge1xuICBjb25zdCBjb29raWVzID0gcmVzLmhlYWRlcnNbJ3NldC1jb29raWUnXTtcbiAgaWYgKGNvb2tpZXMpIHRoaXMuamFyLnNldENvb2tpZXMoY29va2llcyk7XG59O1xuXG4vKipcbiAqIEF0dGFjaCBjb29raWVzIHdoZW4gYXZhaWxhYmxlIHRvIHRoZSBnaXZlbiBgcmVxYC5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQWdlbnQucHJvdG90eXBlLl9hdHRhY2hDb29raWVzID0gZnVuY3Rpb24gKHJlcSkge1xuICBjb25zdCB1cmwgPSBwYXJzZShyZXEudXJsKTtcbiAgY29uc3QgYWNjZXNzID0gbmV3IENvb2tpZUFjY2Vzc0luZm8oXG4gICAgdXJsLmhvc3RuYW1lLFxuICAgIHVybC5wYXRobmFtZSxcbiAgICB1cmwucHJvdG9jb2wgPT09ICdodHRwczonXG4gICk7XG4gIGNvbnN0IGNvb2tpZXMgPSB0aGlzLmphci5nZXRDb29raWVzKGFjY2VzcykudG9WYWx1ZVN0cmluZygpO1xuICByZXEuY29va2llcyA9IGNvb2tpZXM7XG59O1xuXG5tZXRob2RzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgY29uc3QgbWV0aG9kID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBBZ2VudC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodXJsLCBmbikge1xuICAgIGNvbnN0IHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuXG4gICAgcmVxLm9uKCdyZXNwb25zZScsIHRoaXMuX3NhdmVDb29raWVzLmJpbmQodGhpcykpO1xuICAgIHJlcS5vbigncmVkaXJlY3QnLCB0aGlzLl9zYXZlQ29va2llcy5iaW5kKHRoaXMpKTtcbiAgICByZXEub24oJ3JlZGlyZWN0JywgdGhpcy5fYXR0YWNoQ29va2llcy5iaW5kKHRoaXMsIHJlcSkpO1xuICAgIHRoaXMuX3NldERlZmF1bHRzKHJlcSk7XG4gICAgdGhpcy5fYXR0YWNoQ29va2llcyhyZXEpO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXEuZW5kKGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGUuZGVsZXRlO1xuIl19

/***/ }),

/***/ 7473:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Stream = __webpack_require__(12781);

var util = __webpack_require__(73837);

var net = __webpack_require__(41808);

var tls = __webpack_require__(24404); // eslint-disable-next-line node/no-deprecated-api


var _require = __webpack_require__(57310),
    parse = _require.parse;

var semver = __webpack_require__(97699);

var http2; // eslint-disable-next-line node/no-unsupported-features/node-builtins

if (semver.gte(process.version, 'v10.10.0')) http2 = __webpack_require__(85158);else throw new Error('superagent: this version of Node.js does not support http2');
var _http2$constants = http2.constants,
    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,
    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,
    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,
    HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,
    HTTP2_HEADER_HOST = _http2$constants.HTTP2_HEADER_HOST,
    HTTP2_HEADER_SET_COOKIE = _http2$constants.HTTP2_HEADER_SET_COOKIE,
    NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;

function setProtocol(protocol) {
  return {
    request: function request(options) {
      return new Request(protocol, options);
    }
  };
}

function Request(protocol, options) {
  var _this = this;

  Stream.call(this);
  var defaultPort = protocol === 'https:' ? 443 : 80;
  var defaultHost = 'localhost';
  var port = options.port || defaultPort;
  var host = options.host || defaultHost;
  delete options.port;
  delete options.host;
  this.method = options.method;
  this.path = options.path;
  this.protocol = protocol;
  this.host = host;
  delete options.method;
  delete options.path;

  var sessionOptions = _objectSpread({}, options);

  if (options.socketPath) {
    sessionOptions.socketPath = options.socketPath;
    sessionOptions.createConnection = this.createUnixConnection.bind(this);
  }

  this._headers = {};
  var session = http2.connect("".concat(protocol, "//").concat(host, ":").concat(port), sessionOptions);
  this.setHeader('host', "".concat(host, ":").concat(port));
  session.on('error', function (err) {
    return _this.emit('error', err);
  });
  this.session = session;
}
/**
 * Inherit from `Stream` (which inherits from `EventEmitter`).
 */


util.inherits(Request, Stream);

Request.prototype.createUnixConnection = function (authority, options) {
  switch (this.protocol) {
    case 'http:':
      return net.connect(options.socketPath);

    case 'https:':
      options.ALPNProtocols = ['h2'];
      options.servername = this.host;
      options.allowHalfOpen = true;
      return tls.connect(options.socketPath, options);

    default:
      throw new Error('Unsupported protocol', this.protocol);
  }
}; // eslint-disable-next-line no-unused-vars


Request.prototype.setNoDelay = function (bool) {// We can not use setNoDelay with HTTP/2.
  // Node 10 limits http2session.socket methods to ones safe to use with HTTP/2.
  // See also https://nodejs.org/api/http2.html#http2_http2session_socket
};

Request.prototype.getFrame = function () {
  var _method,
      _this2 = this;

  if (this.frame) {
    return this.frame;
  }

  var method = (_method = {}, _defineProperty(_method, HTTP2_HEADER_PATH, this.path), _defineProperty(_method, HTTP2_HEADER_METHOD, this.method), _method);
  var headers = this.mapToHttp2Header(this._headers);
  headers = Object.assign(headers, method);
  var frame = this.session.request(headers); // eslint-disable-next-line no-unused-vars

  frame.once('response', function (headers, flags) {
    headers = _this2.mapToHttpHeader(headers);
    frame.headers = headers;
    frame.statusCode = headers[HTTP2_HEADER_STATUS];
    frame.status = frame.statusCode;

    _this2.emit('response', frame);
  });
  this._headerSent = true;
  frame.once('drain', function () {
    return _this2.emit('drain');
  });
  frame.on('error', function (err) {
    return _this2.emit('error', err);
  });
  frame.on('close', function () {
    return _this2.session.close();
  });
  this.frame = frame;
  return frame;
};

Request.prototype.mapToHttpHeader = function (headers) {
  var keys = Object.keys(headers);
  var http2Headers = {};

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    var value = headers[key];
    key = key.toLowerCase();

    switch (key) {
      case HTTP2_HEADER_SET_COOKIE:
        value = Array.isArray(value) ? value : [value];
        break;

      default:
        break;
    }

    http2Headers[key] = value;
  }

  return http2Headers;
};

Request.prototype.mapToHttp2Header = function (headers) {
  var keys = Object.keys(headers);
  var http2Headers = {};

  for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
    var key = _keys2[_i2];
    var value = headers[key];
    key = key.toLowerCase();

    switch (key) {
      case HTTP2_HEADER_HOST:
        key = HTTP2_HEADER_AUTHORITY;
        value = /^http:\/\/|^https:\/\//.test(value) ? parse(value).host : value;
        break;

      default:
        break;
    }

    http2Headers[key] = value;
  }

  return http2Headers;
};

Request.prototype.setHeader = function (name, value) {
  this._headers[name.toLowerCase()] = value;
};

Request.prototype.getHeader = function (name) {
  return this._headers[name.toLowerCase()];
};

Request.prototype.write = function (data, encoding) {
  var frame = this.getFrame();
  return frame.write(data, encoding);
};

Request.prototype.pipe = function (stream, options) {
  var frame = this.getFrame();
  return frame.pipe(stream, options);
};

Request.prototype.end = function (data) {
  var frame = this.getFrame();
  frame.end(data);
}; // eslint-disable-next-line no-unused-vars


Request.prototype.abort = function (data) {
  var frame = this.getFrame();
  frame.close(NGHTTP2_CANCEL);
  this.session.destroy();
};

exports.setProtocol = setProtocol;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL2h0dHAyd3JhcHBlci5qcyJdLCJuYW1lcyI6WyJTdHJlYW0iLCJyZXF1aXJlIiwidXRpbCIsIm5ldCIsInRscyIsInBhcnNlIiwic2VtdmVyIiwiaHR0cDIiLCJndGUiLCJwcm9jZXNzIiwidmVyc2lvbiIsIkVycm9yIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX1BBVEgiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwiSFRUUDJfSEVBREVSX01FVEhPRCIsIkhUVFAyX0hFQURFUl9BVVRIT1JJVFkiLCJIVFRQMl9IRUFERVJfSE9TVCIsIkhUVFAyX0hFQURFUl9TRVRfQ09PS0lFIiwiTkdIVFRQMl9DQU5DRUwiLCJzZXRQcm90b2NvbCIsInByb3RvY29sIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJSZXF1ZXN0IiwiY2FsbCIsImRlZmF1bHRQb3J0IiwiZGVmYXVsdEhvc3QiLCJwb3J0IiwiaG9zdCIsIm1ldGhvZCIsInBhdGgiLCJzZXNzaW9uT3B0aW9ucyIsInNvY2tldFBhdGgiLCJjcmVhdGVDb25uZWN0aW9uIiwiY3JlYXRlVW5peENvbm5lY3Rpb24iLCJiaW5kIiwiX2hlYWRlcnMiLCJzZXNzaW9uIiwiY29ubmVjdCIsInNldEhlYWRlciIsIm9uIiwiZXJyIiwiZW1pdCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiYXV0aG9yaXR5IiwiQUxQTlByb3RvY29scyIsInNlcnZlcm5hbWUiLCJhbGxvd0hhbGZPcGVuIiwic2V0Tm9EZWxheSIsImJvb2wiLCJnZXRGcmFtZSIsImZyYW1lIiwiaGVhZGVycyIsIm1hcFRvSHR0cDJIZWFkZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJvbmNlIiwiZmxhZ3MiLCJtYXBUb0h0dHBIZWFkZXIiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwiX2hlYWRlclNlbnQiLCJjbG9zZSIsImtleXMiLCJodHRwMkhlYWRlcnMiLCJrZXkiLCJ2YWx1ZSIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJpc0FycmF5IiwidGVzdCIsIm5hbWUiLCJnZXRIZWFkZXIiLCJ3cml0ZSIsImRhdGEiLCJlbmNvZGluZyIsInBpcGUiLCJzdHJlYW0iLCJlbmQiLCJhYm9ydCIsImRlc3Ryb3kiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLElBQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBdEI7O0FBQ0EsSUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxJQUFNRSxHQUFHLEdBQUdGLE9BQU8sQ0FBQyxLQUFELENBQW5COztBQUNBLElBQU1HLEdBQUcsR0FBR0gsT0FBTyxDQUFDLEtBQUQsQ0FBbkIsQyxDQUNBOzs7ZUFDa0JBLE9BQU8sQ0FBQyxLQUFELEM7SUFBakJJLEssWUFBQUEsSzs7QUFDUixJQUFNQyxNQUFNLEdBQUdMLE9BQU8sQ0FBQyxRQUFELENBQXRCOztBQUVBLElBQUlNLEtBQUosQyxDQUNBOztBQUNBLElBQUlELE1BQU0sQ0FBQ0UsR0FBUCxDQUFXQyxPQUFPLENBQUNDLE9BQW5CLEVBQTRCLFVBQTVCLENBQUosRUFBNkNILEtBQUssR0FBR04sT0FBTyxDQUFDLE9BQUQsQ0FBZixDQUE3QyxLQUVFLE1BQU0sSUFBSVUsS0FBSixDQUFVLDREQUFWLENBQU47dUJBVUVKLEtBQUssQ0FBQ0ssUztJQVBSQyxpQixvQkFBQUEsaUI7SUFDQUMsbUIsb0JBQUFBLG1CO0lBQ0FDLG1CLG9CQUFBQSxtQjtJQUNBQyxzQixvQkFBQUEsc0I7SUFDQUMsaUIsb0JBQUFBLGlCO0lBQ0FDLHVCLG9CQUFBQSx1QjtJQUNBQyxjLG9CQUFBQSxjOztBQUdGLFNBQVNDLFdBQVQsQ0FBcUJDLFFBQXJCLEVBQStCO0FBQzdCLFNBQU87QUFDTEMsSUFBQUEsT0FESyxtQkFDR0MsT0FESCxFQUNZO0FBQ2YsYUFBTyxJQUFJQyxPQUFKLENBQVlILFFBQVosRUFBc0JFLE9BQXRCLENBQVA7QUFDRDtBQUhJLEdBQVA7QUFLRDs7QUFFRCxTQUFTQyxPQUFULENBQWlCSCxRQUFqQixFQUEyQkUsT0FBM0IsRUFBb0M7QUFBQTs7QUFDbEN2QixFQUFBQSxNQUFNLENBQUN5QixJQUFQLENBQVksSUFBWjtBQUNBLE1BQU1DLFdBQVcsR0FBR0wsUUFBUSxLQUFLLFFBQWIsR0FBd0IsR0FBeEIsR0FBOEIsRUFBbEQ7QUFDQSxNQUFNTSxXQUFXLEdBQUcsV0FBcEI7QUFDQSxNQUFNQyxJQUFJLEdBQUdMLE9BQU8sQ0FBQ0ssSUFBUixJQUFnQkYsV0FBN0I7QUFDQSxNQUFNRyxJQUFJLEdBQUdOLE9BQU8sQ0FBQ00sSUFBUixJQUFnQkYsV0FBN0I7QUFFQSxTQUFPSixPQUFPLENBQUNLLElBQWY7QUFDQSxTQUFPTCxPQUFPLENBQUNNLElBQWY7QUFFQSxPQUFLQyxNQUFMLEdBQWNQLE9BQU8sQ0FBQ08sTUFBdEI7QUFDQSxPQUFLQyxJQUFMLEdBQVlSLE9BQU8sQ0FBQ1EsSUFBcEI7QUFDQSxPQUFLVixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUtRLElBQUwsR0FBWUEsSUFBWjtBQUVBLFNBQU9OLE9BQU8sQ0FBQ08sTUFBZjtBQUNBLFNBQU9QLE9BQU8sQ0FBQ1EsSUFBZjs7QUFFQSxNQUFNQyxjQUFjLHFCQUFRVCxPQUFSLENBQXBCOztBQUNBLE1BQUlBLE9BQU8sQ0FBQ1UsVUFBWixFQUF3QjtBQUN0QkQsSUFBQUEsY0FBYyxDQUFDQyxVQUFmLEdBQTRCVixPQUFPLENBQUNVLFVBQXBDO0FBQ0FELElBQUFBLGNBQWMsQ0FBQ0UsZ0JBQWYsR0FBa0MsS0FBS0Msb0JBQUwsQ0FBMEJDLElBQTFCLENBQStCLElBQS9CLENBQWxDO0FBQ0Q7O0FBRUQsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUVBLE1BQU1DLE9BQU8sR0FBRy9CLEtBQUssQ0FBQ2dDLE9BQU4sV0FBaUJsQixRQUFqQixlQUE4QlEsSUFBOUIsY0FBc0NELElBQXRDLEdBQThDSSxjQUE5QyxDQUFoQjtBQUNBLE9BQUtRLFNBQUwsQ0FBZSxNQUFmLFlBQTBCWCxJQUExQixjQUFrQ0QsSUFBbEM7QUFFQVUsRUFBQUEsT0FBTyxDQUFDRyxFQUFSLENBQVcsT0FBWCxFQUFvQixVQUFDQyxHQUFEO0FBQUEsV0FBUyxLQUFJLENBQUNDLElBQUwsQ0FBVSxPQUFWLEVBQW1CRCxHQUFuQixDQUFUO0FBQUEsR0FBcEI7QUFFQSxPQUFLSixPQUFMLEdBQWVBLE9BQWY7QUFDRDtBQUVEOzs7OztBQUdBcEMsSUFBSSxDQUFDMEMsUUFBTCxDQUFjcEIsT0FBZCxFQUF1QnhCLE1BQXZCOztBQUVBd0IsT0FBTyxDQUFDcUIsU0FBUixDQUFrQlYsb0JBQWxCLEdBQXlDLFVBQVVXLFNBQVYsRUFBcUJ2QixPQUFyQixFQUE4QjtBQUNyRSxVQUFRLEtBQUtGLFFBQWI7QUFDRSxTQUFLLE9BQUw7QUFDRSxhQUFPbEIsR0FBRyxDQUFDb0MsT0FBSixDQUFZaEIsT0FBTyxDQUFDVSxVQUFwQixDQUFQOztBQUNGLFNBQUssUUFBTDtBQUNFVixNQUFBQSxPQUFPLENBQUN3QixhQUFSLEdBQXdCLENBQUMsSUFBRCxDQUF4QjtBQUNBeEIsTUFBQUEsT0FBTyxDQUFDeUIsVUFBUixHQUFxQixLQUFLbkIsSUFBMUI7QUFDQU4sTUFBQUEsT0FBTyxDQUFDMEIsYUFBUixHQUF3QixJQUF4QjtBQUNBLGFBQU83QyxHQUFHLENBQUNtQyxPQUFKLENBQVloQixPQUFPLENBQUNVLFVBQXBCLEVBQWdDVixPQUFoQyxDQUFQOztBQUNGO0FBQ0UsWUFBTSxJQUFJWixLQUFKLENBQVUsc0JBQVYsRUFBa0MsS0FBS1UsUUFBdkMsQ0FBTjtBQVRKO0FBV0QsQ0FaRCxDLENBY0E7OztBQUNBRyxPQUFPLENBQUNxQixTQUFSLENBQWtCSyxVQUFsQixHQUErQixVQUFVQyxJQUFWLEVBQWdCLENBQzdDO0FBQ0E7QUFDQTtBQUNELENBSkQ7O0FBTUEzQixPQUFPLENBQUNxQixTQUFSLENBQWtCTyxRQUFsQixHQUE2QixZQUFZO0FBQUE7QUFBQTs7QUFDdkMsTUFBSSxLQUFLQyxLQUFULEVBQWdCO0FBQ2QsV0FBTyxLQUFLQSxLQUFaO0FBQ0Q7O0FBRUQsTUFBTXZCLE1BQU0sMkNBQ1RqQixpQkFEUyxFQUNXLEtBQUtrQixJQURoQiw0QkFFVGhCLG1CQUZTLEVBRWEsS0FBS2UsTUFGbEIsV0FBWjtBQUtBLE1BQUl3QixPQUFPLEdBQUcsS0FBS0MsZ0JBQUwsQ0FBc0IsS0FBS2xCLFFBQTNCLENBQWQ7QUFFQWlCLEVBQUFBLE9BQU8sR0FBR0UsTUFBTSxDQUFDQyxNQUFQLENBQWNILE9BQWQsRUFBdUJ4QixNQUF2QixDQUFWO0FBRUEsTUFBTXVCLEtBQUssR0FBRyxLQUFLZixPQUFMLENBQWFoQixPQUFiLENBQXFCZ0MsT0FBckIsQ0FBZCxDQWR1QyxDQWV2Qzs7QUFDQUQsRUFBQUEsS0FBSyxDQUFDSyxJQUFOLENBQVcsVUFBWCxFQUF1QixVQUFDSixPQUFELEVBQVVLLEtBQVYsRUFBb0I7QUFDekNMLElBQUFBLE9BQU8sR0FBRyxNQUFJLENBQUNNLGVBQUwsQ0FBcUJOLE9BQXJCLENBQVY7QUFDQUQsSUFBQUEsS0FBSyxDQUFDQyxPQUFOLEdBQWdCQSxPQUFoQjtBQUNBRCxJQUFBQSxLQUFLLENBQUNRLFVBQU4sR0FBbUJQLE9BQU8sQ0FBQ3hDLG1CQUFELENBQTFCO0FBQ0F1QyxJQUFBQSxLQUFLLENBQUNTLE1BQU4sR0FBZVQsS0FBSyxDQUFDUSxVQUFyQjs7QUFDQSxJQUFBLE1BQUksQ0FBQ2xCLElBQUwsQ0FBVSxVQUFWLEVBQXNCVSxLQUF0QjtBQUNELEdBTkQ7QUFRQSxPQUFLVSxXQUFMLEdBQW1CLElBQW5CO0FBRUFWLEVBQUFBLEtBQUssQ0FBQ0ssSUFBTixDQUFXLE9BQVgsRUFBb0I7QUFBQSxXQUFNLE1BQUksQ0FBQ2YsSUFBTCxDQUFVLE9BQVYsQ0FBTjtBQUFBLEdBQXBCO0FBQ0FVLEVBQUFBLEtBQUssQ0FBQ1osRUFBTixDQUFTLE9BQVQsRUFBa0IsVUFBQ0MsR0FBRDtBQUFBLFdBQVMsTUFBSSxDQUFDQyxJQUFMLENBQVUsT0FBVixFQUFtQkQsR0FBbkIsQ0FBVDtBQUFBLEdBQWxCO0FBQ0FXLEVBQUFBLEtBQUssQ0FBQ1osRUFBTixDQUFTLE9BQVQsRUFBa0I7QUFBQSxXQUFNLE1BQUksQ0FBQ0gsT0FBTCxDQUFhMEIsS0FBYixFQUFOO0FBQUEsR0FBbEI7QUFFQSxPQUFLWCxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFPQSxLQUFQO0FBQ0QsQ0FoQ0Q7O0FBa0NBN0IsT0FBTyxDQUFDcUIsU0FBUixDQUFrQmUsZUFBbEIsR0FBb0MsVUFBVU4sT0FBVixFQUFtQjtBQUNyRCxNQUFNVyxJQUFJLEdBQUdULE1BQU0sQ0FBQ1MsSUFBUCxDQUFZWCxPQUFaLENBQWI7QUFDQSxNQUFNWSxZQUFZLEdBQUcsRUFBckI7O0FBQ0EsMkJBQWdCRCxJQUFoQiwyQkFBc0I7QUFBakIsUUFBSUUsR0FBRyxZQUFQO0FBQ0gsUUFBSUMsS0FBSyxHQUFHZCxPQUFPLENBQUNhLEdBQUQsQ0FBbkI7QUFDQUEsSUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUNFLFdBQUosRUFBTjs7QUFDQSxZQUFRRixHQUFSO0FBQ0UsV0FBS2pELHVCQUFMO0FBQ0VrRCxRQUFBQSxLQUFLLEdBQUdFLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxLQUFkLElBQXVCQSxLQUF2QixHQUErQixDQUFDQSxLQUFELENBQXZDO0FBQ0E7O0FBQ0Y7QUFDRTtBQUxKOztBQVFBRixJQUFBQSxZQUFZLENBQUNDLEdBQUQsQ0FBWixHQUFvQkMsS0FBcEI7QUFDRDs7QUFFRCxTQUFPRixZQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBMUMsT0FBTyxDQUFDcUIsU0FBUixDQUFrQlUsZ0JBQWxCLEdBQXFDLFVBQVVELE9BQVYsRUFBbUI7QUFDdEQsTUFBTVcsSUFBSSxHQUFHVCxNQUFNLENBQUNTLElBQVAsQ0FBWVgsT0FBWixDQUFiO0FBQ0EsTUFBTVksWUFBWSxHQUFHLEVBQXJCOztBQUNBLDZCQUFnQkQsSUFBaEIsOEJBQXNCO0FBQWpCLFFBQUlFLEdBQUcsY0FBUDtBQUNILFFBQUlDLEtBQUssR0FBR2QsT0FBTyxDQUFDYSxHQUFELENBQW5CO0FBQ0FBLElBQUFBLEdBQUcsR0FBR0EsR0FBRyxDQUFDRSxXQUFKLEVBQU47O0FBQ0EsWUFBUUYsR0FBUjtBQUNFLFdBQUtsRCxpQkFBTDtBQUNFa0QsUUFBQUEsR0FBRyxHQUFHbkQsc0JBQU47QUFDQW9ELFFBQUFBLEtBQUssR0FBRyx5QkFBeUJJLElBQXpCLENBQThCSixLQUE5QixJQUNKL0QsS0FBSyxDQUFDK0QsS0FBRCxDQUFMLENBQWF2QyxJQURULEdBRUp1QyxLQUZKO0FBR0E7O0FBQ0Y7QUFDRTtBQVJKOztBQVdBRixJQUFBQSxZQUFZLENBQUNDLEdBQUQsQ0FBWixHQUFvQkMsS0FBcEI7QUFDRDs7QUFFRCxTQUFPRixZQUFQO0FBQ0QsQ0FyQkQ7O0FBdUJBMUMsT0FBTyxDQUFDcUIsU0FBUixDQUFrQkwsU0FBbEIsR0FBOEIsVUFBVWlDLElBQVYsRUFBZ0JMLEtBQWhCLEVBQXVCO0FBQ25ELE9BQUsvQixRQUFMLENBQWNvQyxJQUFJLENBQUNKLFdBQUwsRUFBZCxJQUFvQ0QsS0FBcEM7QUFDRCxDQUZEOztBQUlBNUMsT0FBTyxDQUFDcUIsU0FBUixDQUFrQjZCLFNBQWxCLEdBQThCLFVBQVVELElBQVYsRUFBZ0I7QUFDNUMsU0FBTyxLQUFLcEMsUUFBTCxDQUFjb0MsSUFBSSxDQUFDSixXQUFMLEVBQWQsQ0FBUDtBQUNELENBRkQ7O0FBSUE3QyxPQUFPLENBQUNxQixTQUFSLENBQWtCOEIsS0FBbEIsR0FBMEIsVUFBVUMsSUFBVixFQUFnQkMsUUFBaEIsRUFBMEI7QUFDbEQsTUFBTXhCLEtBQUssR0FBRyxLQUFLRCxRQUFMLEVBQWQ7QUFDQSxTQUFPQyxLQUFLLENBQUNzQixLQUFOLENBQVlDLElBQVosRUFBa0JDLFFBQWxCLENBQVA7QUFDRCxDQUhEOztBQUtBckQsT0FBTyxDQUFDcUIsU0FBUixDQUFrQmlDLElBQWxCLEdBQXlCLFVBQVVDLE1BQVYsRUFBa0J4RCxPQUFsQixFQUEyQjtBQUNsRCxNQUFNOEIsS0FBSyxHQUFHLEtBQUtELFFBQUwsRUFBZDtBQUNBLFNBQU9DLEtBQUssQ0FBQ3lCLElBQU4sQ0FBV0MsTUFBWCxFQUFtQnhELE9BQW5CLENBQVA7QUFDRCxDQUhEOztBQUtBQyxPQUFPLENBQUNxQixTQUFSLENBQWtCbUMsR0FBbEIsR0FBd0IsVUFBVUosSUFBVixFQUFnQjtBQUN0QyxNQUFNdkIsS0FBSyxHQUFHLEtBQUtELFFBQUwsRUFBZDtBQUNBQyxFQUFBQSxLQUFLLENBQUMyQixHQUFOLENBQVVKLElBQVY7QUFDRCxDQUhELEMsQ0FLQTs7O0FBQ0FwRCxPQUFPLENBQUNxQixTQUFSLENBQWtCb0MsS0FBbEIsR0FBMEIsVUFBVUwsSUFBVixFQUFnQjtBQUN4QyxNQUFNdkIsS0FBSyxHQUFHLEtBQUtELFFBQUwsRUFBZDtBQUNBQyxFQUFBQSxLQUFLLENBQUNXLEtBQU4sQ0FBWTdDLGNBQVo7QUFDQSxPQUFLbUIsT0FBTCxDQUFhNEMsT0FBYjtBQUNELENBSkQ7O0FBTUFDLE9BQU8sQ0FBQy9ELFdBQVIsR0FBc0JBLFdBQXRCIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpXG5jb25zdCB7IHBhcnNlIH0gPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuXG5sZXQgaHR0cDI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG5pZiAoc2VtdmVyLmd0ZShwcm9jZXNzLnZlcnNpb24sICd2MTAuMTAuMCcpKSBodHRwMiA9IHJlcXVpcmUoJ2h0dHAyJyk7XG5lbHNlXG4gIHRocm93IG5ldyBFcnJvcignc3VwZXJhZ2VudDogdGhpcyB2ZXJzaW9uIG9mIE5vZGUuanMgZG9lcyBub3Qgc3VwcG9ydCBodHRwMicpO1xuXG5jb25zdCB7XG4gIEhUVFAyX0hFQURFUl9QQVRILFxuICBIVFRQMl9IRUFERVJfU1RBVFVTLFxuICBIVFRQMl9IRUFERVJfTUVUSE9ELFxuICBIVFRQMl9IRUFERVJfQVVUSE9SSVRZLFxuICBIVFRQMl9IRUFERVJfSE9TVCxcbiAgSFRUUDJfSEVBREVSX1NFVF9DT09LSUUsXG4gIE5HSFRUUDJfQ0FOQ0VMXG59ID0gaHR0cDIuY29uc3RhbnRzO1xuXG5mdW5jdGlvbiBzZXRQcm90b2NvbChwcm90b2NvbCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHByb3RvY29sLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIFJlcXVlc3QocHJvdG9jb2wsIG9wdGlvbnMpIHtcbiAgU3RyZWFtLmNhbGwodGhpcyk7XG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gcHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODA7XG4gIGNvbnN0IGRlZmF1bHRIb3N0ID0gJ2xvY2FsaG9zdCc7XG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIGNvbnN0IGhvc3QgPSBvcHRpb25zLmhvc3QgfHwgZGVmYXVsdEhvc3Q7XG5cbiAgZGVsZXRlIG9wdGlvbnMucG9ydDtcbiAgZGVsZXRlIG9wdGlvbnMuaG9zdDtcblxuICB0aGlzLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICB0aGlzLnBhdGggPSBvcHRpb25zLnBhdGg7XG4gIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgdGhpcy5ob3N0ID0gaG9zdDtcblxuICBkZWxldGUgb3B0aW9ucy5tZXRob2Q7XG4gIGRlbGV0ZSBvcHRpb25zLnBhdGg7XG5cbiAgY29uc3Qgc2Vzc2lvbk9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgaWYgKG9wdGlvbnMuc29ja2V0UGF0aCkge1xuICAgIHNlc3Npb25PcHRpb25zLnNvY2tldFBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gICAgc2Vzc2lvbk9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IHRoaXMuY3JlYXRlVW5peENvbm5lY3Rpb24uYmluZCh0aGlzKTtcbiAgfVxuXG4gIHRoaXMuX2hlYWRlcnMgPSB7fTtcblxuICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChgJHtwcm90b2NvbH0vLyR7aG9zdH06JHtwb3J0fWAsIHNlc3Npb25PcHRpb25zKTtcbiAgdGhpcy5zZXRIZWFkZXIoJ2hvc3QnLCBgJHtob3N0fToke3BvcnR9YCk7XG5cbiAgc2Vzc2lvbi5vbignZXJyb3InLCAoZXJyKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG5cbiAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFN0cmVhbWAgKHdoaWNoIGluaGVyaXRzIGZyb20gYEV2ZW50RW1pdHRlcmApLlxuICovXG51dGlsLmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZVVuaXhDb25uZWN0aW9uID0gZnVuY3Rpb24gKGF1dGhvcml0eSwgb3B0aW9ucykge1xuICBzd2l0Y2ggKHRoaXMucHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwOic6XG4gICAgICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucy5zb2NrZXRQYXRoKTtcbiAgICBjYXNlICdodHRwczonOlxuICAgICAgb3B0aW9ucy5BTFBOUHJvdG9jb2xzID0gWydoMiddO1xuICAgICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gdGhpcy5ob3N0O1xuICAgICAgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zLnNvY2tldFBhdGgsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sJywgdGhpcy5wcm90b2NvbCk7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuUmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uIChib29sKSB7XG4gIC8vIFdlIGNhbiBub3QgdXNlIHNldE5vRGVsYXkgd2l0aCBIVFRQLzIuXG4gIC8vIE5vZGUgMTAgbGltaXRzIGh0dHAyc2Vzc2lvbi5zb2NrZXQgbWV0aG9kcyB0byBvbmVzIHNhZmUgdG8gdXNlIHdpdGggSFRUUC8yLlxuICAvLyBTZWUgYWxzbyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAyLmh0bWwjaHR0cDJfaHR0cDJzZXNzaW9uX3NvY2tldFxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWU7XG4gIH1cblxuICBjb25zdCBtZXRob2QgPSB7XG4gICAgW0hUVFAyX0hFQURFUl9QQVRIXTogdGhpcy5wYXRoLFxuICAgIFtIVFRQMl9IRUFERVJfTUVUSE9EXTogdGhpcy5tZXRob2RcbiAgfTtcblxuICBsZXQgaGVhZGVycyA9IHRoaXMubWFwVG9IdHRwMkhlYWRlcih0aGlzLl9oZWFkZXJzKTtcblxuICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBtZXRob2QpO1xuXG4gIGNvbnN0IGZyYW1lID0gdGhpcy5zZXNzaW9uLnJlcXVlc3QoaGVhZGVycyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBmcmFtZS5vbmNlKCdyZXNwb25zZScsIChoZWFkZXJzLCBmbGFncykgPT4ge1xuICAgIGhlYWRlcnMgPSB0aGlzLm1hcFRvSHR0cEhlYWRlcihoZWFkZXJzKTtcbiAgICBmcmFtZS5oZWFkZXJzID0gaGVhZGVycztcbiAgICBmcmFtZS5zdGF0dXNDb2RlID0gaGVhZGVyc1tIVFRQMl9IRUFERVJfU1RBVFVTXTtcbiAgICBmcmFtZS5zdGF0dXMgPSBmcmFtZS5zdGF0dXNDb2RlO1xuICAgIHRoaXMuZW1pdCgncmVzcG9uc2UnLCBmcmFtZSk7XG4gIH0pO1xuXG4gIHRoaXMuX2hlYWRlclNlbnQgPSB0cnVlO1xuXG4gIGZyYW1lLm9uY2UoJ2RyYWluJywgKCkgPT4gdGhpcy5lbWl0KCdkcmFpbicpKTtcbiAgZnJhbWUub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycikpO1xuICBmcmFtZS5vbignY2xvc2UnLCAoKSA9PiB0aGlzLnNlc3Npb24uY2xvc2UoKSk7XG5cbiAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICByZXR1cm4gZnJhbWU7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5tYXBUb0h0dHBIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gIGNvbnN0IGh0dHAySGVhZGVycyA9IHt9O1xuICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgIGxldCB2YWx1ZSA9IGhlYWRlcnNba2V5XTtcbiAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBIVFRQMl9IRUFERVJfU0VUX0NPT0tJRTpcbiAgICAgICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBodHRwMkhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGh0dHAySGVhZGVycztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLm1hcFRvSHR0cDJIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gIGNvbnN0IGh0dHAySGVhZGVycyA9IHt9O1xuICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgIGxldCB2YWx1ZSA9IGhlYWRlcnNba2V5XTtcbiAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBIVFRQMl9IRUFERVJfSE9TVDpcbiAgICAgICAga2V5ID0gSFRUUDJfSEVBREVSX0FVVEhPUklUWTtcbiAgICAgICAgdmFsdWUgPSAvXmh0dHA6XFwvXFwvfF5odHRwczpcXC9cXC8vLnRlc3QodmFsdWUpXG4gICAgICAgICAgPyBwYXJzZSh2YWx1ZSkuaG9zdFxuICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaHR0cDJIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBodHRwMkhlYWRlcnM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgZnJhbWUgPSB0aGlzLmdldEZyYW1lKCk7XG4gIHJldHVybiBmcmFtZS53cml0ZShkYXRhLCBlbmNvZGluZyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKHN0cmVhbSwgb3B0aW9ucykge1xuICBjb25zdCBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoKTtcbiAgcmV0dXJuIGZyYW1lLnBpcGUoc3RyZWFtLCBvcHRpb25zKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGZyYW1lID0gdGhpcy5nZXRGcmFtZSgpO1xuICBmcmFtZS5lbmQoZGF0YSk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZnJhbWUgPSB0aGlzLmdldEZyYW1lKCk7XG4gIGZyYW1lLmNsb3NlKE5HSFRUUDJfQ0FOQ0VMKTtcbiAgdGhpcy5zZXNzaW9uLmRlc3Ryb3koKTtcbn07XG5cbmV4cG9ydHMuc2V0UHJvdG9jb2wgPSBzZXRQcm90b2NvbDtcbiJdfQ==

/***/ }),

/***/ 32075:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Module dependencies.
 */
// eslint-disable-next-line node/no-deprecated-api
var _require = __webpack_require__(57310),
    parse = _require.parse,
    format = _require.format,
    resolve = _require.resolve;

var Stream = __webpack_require__(12781);

var https = __webpack_require__(95687);

var http = __webpack_require__(13685);

var fs = __webpack_require__(57147);

var zlib = __webpack_require__(59796);

var util = __webpack_require__(73837);

var qs = __webpack_require__(19126);

var mime = __webpack_require__(74050);

var methods = __webpack_require__(11242);

var FormData = __webpack_require__(21191);

var formidable = __webpack_require__(71341);

var debug = __webpack_require__(445)('superagent');

var CookieJar = __webpack_require__(29392);

var semver = __webpack_require__(97699);

var safeStringify = __webpack_require__(77847);

var utils = __webpack_require__(62433);

var RequestBase = __webpack_require__(2474);

var _require2 = __webpack_require__(34208),
    unzip = _require2.unzip;

var Response = __webpack_require__(90459);

var http2;
if (semver.gte(process.version, 'v10.10.0')) http2 = __webpack_require__(7473);

function request(method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

module.exports = request;
exports = module.exports;
/**
 * Expose `Request`.
 */

exports.Request = Request;
/**
 * Expose the agent function
 */

exports.agent = __webpack_require__(54921);
/**
 * Noop.
 */

function noop() {}
/**
 * Expose `Response`.
 */


exports.Response = Response;
/**
 * Define "form" mime type.
 */

mime.define({
  'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']
}, true);
/**
 * Protocol map.
 */

exports.protocols = {
  'http:': http,
  'https:': https,
  'http2:': http2
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

exports.serialize = {
  'application/x-www-form-urlencoded': qs.stringify,
  'application/json': safeStringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(res, fn){
 *       fn(null, res);
 *     };
 *
 */

exports.parse = __webpack_require__(33661);
/**
 * Default buffering map. Can be used to set certain
 * response types to buffer/not buffer.
 *
 *     superagent.buffer['application/xml'] = true;
 */

exports.buffer = {};
/**
 * Initialize internal header tracking properties on a request instance.
 *
 * @param {Object} req the instance
 * @api private
 */

function _initHeaders(req) {
  req._header = {// coerces header names to lowercase
  };
  req.header = {// preserves header name case
  };
}
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String|Object} url
 * @api public
 */


function Request(method, url) {
  Stream.call(this);
  if (typeof url !== 'string') url = format(url);
  this._enableHttp2 = Boolean(process.env.HTTP2_TEST); // internal only

  this._agent = false;
  this._formData = null;
  this.method = method;
  this.url = url;

  _initHeaders(this);

  this.writable = true;
  this._redirects = 0;
  this.redirects(method === 'HEAD' ? 0 : 5);
  this.cookies = '';
  this.qs = {};
  this._query = [];
  this.qsRaw = this._query; // Unused, for backwards compatibility only

  this._redirectList = [];
  this._streamRequest = false;
  this.once('end', this.clearTimeout.bind(this));
}
/**
 * Inherit from `Stream` (which inherits from `EventEmitter`).
 * Mixin `RequestBase`.
 */


util.inherits(Request, Stream); // eslint-disable-next-line new-cap

RequestBase(Request.prototype);
/**
 * Enable or Disable http2.
 *
 * Enable http2.
 *
 * ``` js
 * request.get('http://localhost/')
 *   .http2()
 *   .end(callback);
 *
 * request.get('http://localhost/')
 *   .http2(true)
 *   .end(callback);
 * ```
 *
 * Disable http2.
 *
 * ``` js
 * request = request.http2();
 * request.get('http://localhost/')
 *   .http2(false)
 *   .end(callback);
 * ```
 *
 * @param {Boolean} enable
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.http2 = function (bool) {
  if (exports.protocols['http2:'] === undefined) {
    throw new Error('superagent: this version of Node.js does not support http2');
  }

  this._enableHttp2 = bool === undefined ? true : bool;
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('http://localhost/upload')
 *   .attach('field', Buffer.from('<b>Hello world</b>'), 'hello.html')
 *   .end(callback);
 * ```
 *
 * A filename may also be used:
 *
 * ``` js
 * request.post('http://localhost/upload')
 *   .attach('files', 'image.jpg')
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {String|fs.ReadStream|Buffer} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    var o = options || {};

    if (typeof options === 'string') {
      o = {
        filename: options
      };
    }

    if (typeof file === 'string') {
      if (!o.filename) o.filename = file;
      debug('creating `fs.ReadStream` instance for file: %s', file);
      file = fs.createReadStream(file);
    } else if (!o.filename && file.path) {
      o.filename = file.path;
    }

    this._getFormData().append(field, file, o);
  }

  return this;
};

Request.prototype._getFormData = function () {
  var _this = this;

  if (!this._formData) {
    this._formData = new FormData();

    this._formData.on('error', function (err) {
      debug('FormData error', err);

      if (_this.called) {
        // The request has already finished and the callback was called.
        // Silently ignore the error.
        return;
      }

      _this.callback(err);

      _this.abort();
    });
  }

  return this._formData;
};
/**
 * Gets/sets the `Agent` to use for this HTTP request. The default (if this
 * function is not called) is to opt out of connection pooling (`agent: false`).
 *
 * @param {http.Agent} agent
 * @return {http.Agent}
 * @api public
 */


Request.prototype.agent = function (agent) {
  if (arguments.length === 0) return this._agent;
  this._agent = agent;
  return this;
};
/**
 * Set _Content-Type_ response header passed through `mime.getType()`.
 *
 * Examples:
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('json')
 *        .send(jsonstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/json')
 *        .send(jsonstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.type = function (type) {
  return this.set('Content-Type', type.includes('/') ? type : mime.getType(type));
};
/**
 * Set _Accept_ response header passed through `mime.getType()`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  return this.set('Accept', type.includes('/') ? type : mime.getType(type));
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if (typeof val === 'string') {
    this._query.push(val);
  } else {
    Object.assign(this.qs, val);
  }

  return this;
};
/**
 * Write raw `data` / `encoding` to the socket.
 *
 * @param {Buffer|String} data
 * @param {String} encoding
 * @return {Boolean}
 * @api public
 */


Request.prototype.write = function (data, encoding) {
  var req = this.request();

  if (!this._streamRequest) {
    this._streamRequest = true;
  }

  return req.write(data, encoding);
};
/**
 * Pipe the request body to `stream`.
 *
 * @param {Stream} stream
 * @param {Object} options
 * @return {Stream}
 * @api public
 */


Request.prototype.pipe = function (stream, options) {
  this.piped = true; // HACK...

  this.buffer(false);
  this.end();
  return this._pipeContinue(stream, options);
};

Request.prototype._pipeContinue = function (stream, options) {
  var _this2 = this;

  this.req.once('response', function (res) {
    // redirect
    if (isRedirect(res.statusCode) && _this2._redirects++ !== _this2._maxRedirects) {
      return _this2._redirect(res) === _this2 ? _this2._pipeContinue(stream, options) : undefined;
    }

    _this2.res = res;

    _this2._emitResponse();

    if (_this2._aborted) return;

    if (_this2._shouldUnzip(res)) {
      var unzipObj = zlib.createUnzip();
      unzipObj.on('error', function (err) {
        if (err && err.code === 'Z_BUF_ERROR') {
          // unexpected end of file is ignored by browsers and curl
          stream.emit('end');
          return;
        }

        stream.emit('error', err);
      });
      res.pipe(unzipObj).pipe(stream, options);
    } else {
      res.pipe(stream, options);
    }

    res.once('end', function () {
      _this2.emit('end');
    });
  });
  return stream;
};
/**
 * Enable / disable buffering.
 *
 * @return {Boolean} [val]
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.buffer = function (val) {
  this._buffer = val !== false;
  return this;
};
/**
 * Redirect to `url
 *
 * @param {IncomingMessage} res
 * @return {Request} for chaining
 * @api private
 */


Request.prototype._redirect = function (res) {
  var url = res.headers.location;

  if (!url) {
    return this.callback(new Error('No location header for redirect'), res);
  }

  debug('redirect %s -> %s', this.url, url); // location

  url = resolve(this.url, url); // ensure the response is being consumed
  // this is required for Node v0.10+

  res.resume();
  var headers = this.req.getHeaders ? this.req.getHeaders() : this.req._headers;
  var changesOrigin = parse(url).host !== parse(this.url).host; // implementation of 302 following defacto standard

  if (res.statusCode === 301 || res.statusCode === 302) {
    // strip Content-* related fields
    // in case of POST etc
    headers = utils.cleanHeader(headers, changesOrigin); // force GET

    this.method = this.method === 'HEAD' ? 'HEAD' : 'GET'; // clear data

    this._data = null;
  } // 303 is always GET


  if (res.statusCode === 303) {
    // strip Content-* related fields
    // in case of POST etc
    headers = utils.cleanHeader(headers, changesOrigin); // force method

    this.method = 'GET'; // clear data

    this._data = null;
  } // 307 preserves method
  // 308 preserves method


  delete headers.host;
  delete this.req;
  delete this._formData; // remove all add header except User-Agent

  _initHeaders(this); // redirect


  this._endCalled = false;
  this.url = url;
  this.qs = {};
  this._query.length = 0;
  this.set(headers);
  this.emit('redirect', res);

  this._redirectList.push(this.url);

  this.end(this._callback);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * Examples:
 *
 *   .auth('tobi', 'learnboost')
 *   .auth('tobi:learnboost')
 *   .auth('tobi')
 *   .auth(accessToken, { type: 'bearer' })
 *
 * @param {String} user
 * @param {String} [pass]
 * @param {Object} [options] options with authorization type 'basic' or 'bearer' ('basic' is default)
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: 'basic'
    };
  }

  var encoder = function encoder(string) {
    return Buffer.from(string).toString('base64');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Set the certificate authority option for https request.
 *
 * @param {Buffer | Array} cert
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.ca = function (cert) {
  this._ca = cert;
  return this;
};
/**
 * Set the client certificate key option for https request.
 *
 * @param {Buffer | String} cert
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.key = function (cert) {
  this._key = cert;
  return this;
};
/**
 * Set the key, certificate, and CA certs of the client in PFX or PKCS12 format.
 *
 * @param {Buffer | String} cert
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.pfx = function (cert) {
  if (_typeof(cert) === 'object' && !Buffer.isBuffer(cert)) {
    this._pfx = cert.pfx;
    this._passphrase = cert.passphrase;
  } else {
    this._pfx = cert;
  }

  return this;
};
/**
 * Set the client certificate option for https request.
 *
 * @param {Buffer | String} cert
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.cert = function (cert) {
  this._cert = cert;
  return this;
};
/**
 * Do not reject expired or invalid TLS certs.
 * sets `rejectUnauthorized=true`. Be warned that this allows MITM attacks.
 *
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.disableTLSCerts = function () {
  this._disableTLSCerts = true;
  return this;
};
/**
 * Return an http[s] request.
 *
 * @return {OutgoingMessage}
 * @api private
 */
// eslint-disable-next-line complexity


Request.prototype.request = function () {
  var _this3 = this;

  if (this.req) return this.req;
  var options = {};

  try {
    var query = qs.stringify(this.qs, {
      indices: false,
      strictNullHandling: true
    });

    if (query) {
      this.qs = {};

      this._query.push(query);
    }

    this._finalizeQueryString();
  } catch (err) {
    return this.emit('error', err);
  }

  var url = this.url;
  var retries = this._retries; // Capture backticks as-is from the final query string built above.
  // Note: this'll only find backticks entered in req.query(String)
  // calls, because qs.stringify unconditionally encodes backticks.

  var queryStringBackticks;

  if (url.includes('`')) {
    var queryStartIndex = url.indexOf('?');

    if (queryStartIndex !== -1) {
      var queryString = url.slice(queryStartIndex + 1);
      queryStringBackticks = queryString.match(/`|%60/g);
    }
  } // default to http://


  if (url.indexOf('http') !== 0) url = "http://".concat(url);
  url = parse(url); // See https://github.com/visionmedia/superagent/issues/1367

  if (queryStringBackticks) {
    var i = 0;
    url.query = url.query.replace(/%60/g, function () {
      return queryStringBackticks[i++];
    });
    url.search = "?".concat(url.query);
    url.path = url.pathname + url.search;
  } // support unix sockets


  if (/^https?\+unix:/.test(url.protocol) === true) {
    // get the protocol
    url.protocol = "".concat(url.protocol.split('+')[0], ":"); // get the socket, path

    var unixParts = url.path.match(/^([^/]+)(.+)$/);
    options.socketPath = unixParts[1].replace(/%2F/g, '/');
    url.path = unixParts[2];
  } // Override IP address of a hostname


  if (this._connectOverride) {
    var _url = url,
        hostname = _url.hostname;
    var match = hostname in this._connectOverride ? this._connectOverride[hostname] : this._connectOverride['*'];

    if (match) {
      // backup the real host
      if (!this._header.host) {
        this.set('host', url.host);
      }

      var newHost;
      var newPort;

      if (_typeof(match) === 'object') {
        newHost = match.host;
        newPort = match.port;
      } else {
        newHost = match;
        newPort = url.port;
      } // wrap [ipv6]


      url.host = /:/.test(newHost) ? "[".concat(newHost, "]") : newHost;

      if (newPort) {
        url.host += ":".concat(newPort);
        url.port = newPort;
      }

      url.hostname = newHost;
    }
  } // options


  options.method = this.method;
  options.port = url.port;
  options.path = url.path;
  options.host = url.hostname;
  options.ca = this._ca;
  options.key = this._key;
  options.pfx = this._pfx;
  options.cert = this._cert;
  options.passphrase = this._passphrase;
  options.agent = this._agent;
  options.rejectUnauthorized = typeof this._disableTLSCerts === 'boolean' ? !this._disableTLSCerts : process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0'; // Allows request.get('https://1.2.3.4/').set('Host', 'example.com')

  if (this._header.host) {
    options.servername = this._header.host.replace(/:\d+$/, '');
  }

  if (this._trustLocalhost && /^(?:localhost|127\.0\.0\.\d+|(0*:)+:0*1)$/.test(url.hostname)) {
    options.rejectUnauthorized = false;
  } // initiate request


  var mod = this._enableHttp2 ? exports.protocols['http2:'].setProtocol(url.protocol) : exports.protocols[url.protocol]; // request

  this.req = mod.request(options);
  var req = this.req; // set tcp no delay

  req.setNoDelay(true);

  if (options.method !== 'HEAD') {
    req.setHeader('Accept-Encoding', 'gzip, deflate');
  }

  this.protocol = url.protocol;
  this.host = url.host; // expose events

  req.once('drain', function () {
    _this3.emit('drain');
  });
  req.on('error', function (err) {
    // flag abortion here for out timeouts
    // because node will emit a faux-error "socket hang up"
    // when request is aborted before a connection is made
    if (_this3._aborted) return; // if not the same, we are in the **old** (cancelled) request,
    // so need to continue (same as for above)

    if (_this3._retries !== retries) return; // if we've received a response then we don't want to let
    // an error in the request blow up the response

    if (_this3.response) return;

    _this3.callback(err);
  }); // auth

  if (url.auth) {
    var auth = url.auth.split(':');
    this.auth(auth[0], auth[1]);
  }

  if (this.username && this.password) {
    this.auth(this.username, this.password);
  }

  for (var key in this.header) {
    if (Object.prototype.hasOwnProperty.call(this.header, key)) req.setHeader(key, this.header[key]);
  } // add cookies


  if (this.cookies) {
    if (Object.prototype.hasOwnProperty.call(this._header, 'cookie')) {
      // merge
      var tmpJar = new CookieJar.CookieJar();
      tmpJar.setCookies(this._header.cookie.split(';'));
      tmpJar.setCookies(this.cookies.split(';'));
      req.setHeader('Cookie', tmpJar.getCookies(CookieJar.CookieAccessInfo.All).toValueString());
    } else {
      req.setHeader('Cookie', this.cookies);
    }
  }

  return req;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  } // Avoid the error which is emitted from 'socket hang up' to cause the fn undefined error on JS runtime.


  var fn = this._callback || noop;
  this.clearTimeout();
  if (this.called) return console.warn('superagent: double callback bug');
  this.called = true;

  if (!err) {
    try {
      if (!this._isResponseOK(res)) {
        var msg = 'Unsuccessful HTTP response';

        if (res) {
          msg = http.STATUS_CODES[res.status] || msg;
        }

        err = new Error(msg);
        err.status = res ? res.status : undefined;
      }
    } catch (err_) {
      err = err_;
    }
  } // It's important that the callback is called outside try/catch
  // to avoid double callback


  if (!err) {
    return fn(null, res);
  }

  err.response = res;
  if (this._maxRetries) err.retries = this._retries - 1; // only emit error event if there is a listener
  // otherwise we assume the callback to `.end()` will get the error

  if (err && this.listeners('error').length > 0) {
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Check if `obj` is a host object,
 *
 * @param {Object} obj host object
 * @return {Boolean} is a host object
 * @api private
 */


Request.prototype._isHost = function (obj) {
  return Buffer.isBuffer(obj) || obj instanceof Stream || obj instanceof FormData;
};
/**
 * Initiate request, invoking callback `fn(err, res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype._emitResponse = function (body, files) {
  var response = new Response(this);
  this.response = response;
  response.redirects = this._redirectList;

  if (undefined !== body) {
    response.body = body;
  }

  response.files = files;

  if (this._endCalled) {
    response.pipe = function () {
      throw new Error("end() has already been called, so it's too late to start piping");
    };
  }

  this.emit('response', response);
  return response;
};

Request.prototype.end = function (fn) {
  this.request();
  debug('%s %s', this.method, this.url);

  if (this._endCalled) {
    throw new Error('.end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop;

  this._end();
};

Request.prototype._end = function () {
  var _this4 = this;

  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var data = this._data;
  var req = this.req;
  var method = this.method;

  this._setTimeouts(); // body


  if (method !== 'HEAD' && !req._headerSent) {
    // serialize stuff
    if (typeof data !== 'string') {
      var contentType = req.getHeader('Content-Type'); // Parse out just the content type from the header (ignore the charset)

      if (contentType) contentType = contentType.split(';')[0];
      var serialize = this._serializer || exports.serialize[contentType];

      if (!serialize && isJSON(contentType)) {
        serialize = exports.serialize['application/json'];
      }

      if (serialize) data = serialize(data);
    } // content-length


    if (data && !req.getHeader('Content-Length')) {
      req.setHeader('Content-Length', Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));
    }
  } // response
  // eslint-disable-next-line complexity


  req.once('response', function (res) {
    debug('%s %s -> %s', _this4.method, _this4.url, res.statusCode);

    if (_this4._responseTimeoutTimer) {
      clearTimeout(_this4._responseTimeoutTimer);
    }

    if (_this4.piped) {
      return;
    }

    var max = _this4._maxRedirects;
    var mime = utils.type(res.headers['content-type'] || '') || 'text/plain';
    var type = mime.split('/')[0];
    if (type) type = type.toLowerCase().trim();
    var multipart = type === 'multipart';
    var redirect = isRedirect(res.statusCode);
    var responseType = _this4._responseType;
    _this4.res = res; // redirect

    if (redirect && _this4._redirects++ !== max) {
      return _this4._redirect(res);
    }

    if (_this4.method === 'HEAD') {
      _this4.emit('end');

      _this4.callback(null, _this4._emitResponse());

      return;
    } // zlib support


    if (_this4._shouldUnzip(res)) {
      unzip(req, res);
    }

    var buffer = _this4._buffer;

    if (buffer === undefined && mime in exports.buffer) {
      buffer = Boolean(exports.buffer[mime]);
    }

    var parser = _this4._parser;

    if (undefined === buffer) {
      if (parser) {
        console.warn("A custom superagent parser has been set, but buffering strategy for the parser hasn't been configured. Call `req.buffer(true or false)` or set `superagent.buffer[mime] = true or false`");
        buffer = true;
      }
    }

    if (!parser) {
      if (responseType) {
        parser = exports.parse.image; // It's actually a generic Buffer

        buffer = true;
      } else if (multipart) {
        var form = new formidable.IncomingForm();
        parser = form.parse.bind(form);
        buffer = true;
      } else if (isImageOrVideo(mime)) {
        parser = exports.parse.image;
        buffer = true; // For backwards-compatibility buffering default is ad-hoc MIME-dependent
      } else if (exports.parse[mime]) {
        parser = exports.parse[mime];
      } else if (type === 'text') {
        parser = exports.parse.text;
        buffer = buffer !== false; // everyone wants their own white-labeled json
      } else if (isJSON(mime)) {
        parser = exports.parse['application/json'];
        buffer = buffer !== false;
      } else if (buffer) {
        parser = exports.parse.text;
      } else if (undefined === buffer) {
        parser = exports.parse.image; // It's actually a generic Buffer

        buffer = true;
      }
    } // by default only buffer text/*, json and messed up thing from hell


    if (undefined === buffer && isText(mime) || isJSON(mime)) {
      buffer = true;
    }

    _this4._resBuffered = buffer;
    var parserHandlesEnd = false;

    if (buffer) {
      // Protectiona against zip bombs and other nuisance
      var responseBytesLeft = _this4._maxResponseSize || 200000000;
      res.on('data', function (buf) {
        responseBytesLeft -= buf.byteLength || buf.length;

        if (responseBytesLeft < 0) {
          // This will propagate through error event
          var err = new Error('Maximum response size reached');
          err.code = 'ETOOLARGE'; // Parsers aren't required to observe error event,
          // so would incorrectly report success

          parserHandlesEnd = false; // Will emit error event

          res.destroy(err);
        }
      });
    }

    if (parser) {
      try {
        // Unbuffered parsers are supposed to emit response early,
        // which is weird BTW, because response.body won't be there.
        parserHandlesEnd = buffer;
        parser(res, function (err, obj, files) {
          if (_this4.timedout) {
            // Timeout has already handled all callbacks
            return;
          } // Intentional (non-timeout) abort is supposed to preserve partial response,
          // even if it doesn't parse.


          if (err && !_this4._aborted) {
            return _this4.callback(err);
          }

          if (parserHandlesEnd) {
            _this4.emit('end');

            _this4.callback(null, _this4._emitResponse(obj, files));
          }
        });
      } catch (err) {
        _this4.callback(err);

        return;
      }
    }

    _this4.res = res; // unbuffered

    if (!buffer) {
      debug('unbuffered %s %s', _this4.method, _this4.url);

      _this4.callback(null, _this4._emitResponse());

      if (multipart) return; // allow multipart to handle end event

      res.once('end', function () {
        debug('end %s %s', _this4.method, _this4.url);

        _this4.emit('end');
      });
      return;
    } // terminating events


    res.once('error', function (err) {
      parserHandlesEnd = false;

      _this4.callback(err, null);
    });
    if (!parserHandlesEnd) res.once('end', function () {
      debug('end %s %s', _this4.method, _this4.url); // TODO: unless buffering emit earlier to stream

      _this4.emit('end');

      _this4.callback(null, _this4._emitResponse());
    });
  });
  this.emit('request', this);

  var getProgressMonitor = function getProgressMonitor() {
    var lengthComputable = true;
    var total = req.getHeader('Content-Length');
    var loaded = 0;
    var progress = new Stream.Transform();

    progress._transform = function (chunk, encoding, cb) {
      loaded += chunk.length;

      _this4.emit('progress', {
        direction: 'upload',
        lengthComputable: lengthComputable,
        loaded: loaded,
        total: total
      });

      cb(null, chunk);
    };

    return progress;
  };

  var bufferToChunks = function bufferToChunks(buffer) {
    var chunkSize = 16 * 1024; // default highWaterMark value

    var chunking = new Stream.Readable();
    var totalLength = buffer.length;
    var remainder = totalLength % chunkSize;
    var cutoff = totalLength - remainder;

    for (var i = 0; i < cutoff; i += chunkSize) {
      var chunk = buffer.slice(i, i + chunkSize);
      chunking.push(chunk);
    }

    if (remainder > 0) {
      var remainderBuffer = buffer.slice(-remainder);
      chunking.push(remainderBuffer);
    }

    chunking.push(null); // no more data

    return chunking;
  }; // if a FormData instance got created, then we send that as the request body


  var formData = this._formData;

  if (formData) {
    // set headers
    var headers = formData.getHeaders();

    for (var i in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, i)) {
        debug('setting FormData header: "%s: %s"', i, headers[i]);
        req.setHeader(i, headers[i]);
      }
    } // attempt to get "Content-Length" header


    formData.getLength(function (err, length) {
      // TODO: Add chunked encoding when no length (if err)
      if (err) debug('formData.getLength had error', err, length);
      debug('got FormData Content-Length: %s', length);

      if (typeof length === 'number') {
        req.setHeader('Content-Length', length);
      }

      formData.pipe(getProgressMonitor()).pipe(req);
    });
  } else if (Buffer.isBuffer(data)) {
    bufferToChunks(data).pipe(getProgressMonitor()).pipe(req);
  } else {
    req.end(data);
  }
}; // Check whether response has a non-0-sized gzip-encoded body


Request.prototype._shouldUnzip = function (res) {
  if (res.statusCode === 204 || res.statusCode === 304) {
    // These aren't supposed to have any body
    return false;
  } // header content is a string, and distinction between 0 and no information is crucial


  if (res.headers['content-length'] === '0') {
    // We know that the body is empty (unfortunately, this check does not cover chunked encoding)
    return false;
  } // console.log(res);


  return /^\s*(?:deflate|gzip)\s*$/.test(res.headers['content-encoding']);
};
/**
 * Overrides DNS for selected hostnames. Takes object mapping hostnames to IP addresses.
 *
 * When making a request to a URL with a hostname exactly matching a key in the object,
 * use the given IP address to connect, instead of using DNS to resolve the hostname.
 *
 * A special host `*` matches every hostname (keep redirects in mind!)
 *
 *      request.connect({
 *        'test.example.com': '127.0.0.1',
 *        'ipv6.example.com': '::1',
 *      })
 */


Request.prototype.connect = function (connectOverride) {
  if (typeof connectOverride === 'string') {
    this._connectOverride = {
      '*': connectOverride
    };
  } else if (_typeof(connectOverride) === 'object') {
    this._connectOverride = connectOverride;
  } else {
    this._connectOverride = undefined;
  }

  return this;
};

Request.prototype.trustLocalhost = function (toggle) {
  this._trustLocalhost = toggle === undefined ? true : toggle;
  return this;
}; // generate HTTP verb methods


if (!methods.includes('del')) {
  // create a copy so we don't cause conflicts with
  // other packages using the methods package and
  // npm 3.x
  methods = methods.slice(0);
  methods.push('del');
}

methods.forEach(function (method) {
  var name = method;
  method = method === 'del' ? 'delete' : method;
  method = method.toUpperCase();

  request[name] = function (url, data, fn) {
    var req = request(method, url);

    if (typeof data === 'function') {
      fn = data;
      data = null;
    }

    if (data) {
      if (method === 'GET' || method === 'HEAD') {
        req.query(data);
      } else {
        req.send(data);
      }
    }

    if (fn) req.end(fn);
    return req;
  };
});
/**
 * Check if `mime` is text and should be buffered.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api public
 */

function isText(mime) {
  var parts = mime.split('/');
  var type = parts[0];
  if (type) type = type.toLowerCase().trim();
  var subtype = parts[1];
  if (subtype) subtype = subtype.toLowerCase().trim();
  return type === 'text' || subtype === 'x-www-form-urlencoded';
}

function isImageOrVideo(mime) {
  var type = mime.split('/')[0];
  if (type) type = type.toLowerCase().trim();
  return type === 'image' || type === 'video';
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[/+]json($|[^-\w])/i.test(mime);
}
/**
 * Check if we should follow the redirect `code`.
 *
 * @param {Number} code
 * @return {Boolean}
 * @api private
 */


function isRedirect(code) {
  return [301, 302, 303, 305, 307, 308].includes(code);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL2luZGV4LmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJwYXJzZSIsImZvcm1hdCIsInJlc29sdmUiLCJTdHJlYW0iLCJodHRwcyIsImh0dHAiLCJmcyIsInpsaWIiLCJ1dGlsIiwicXMiLCJtaW1lIiwibWV0aG9kcyIsIkZvcm1EYXRhIiwiZm9ybWlkYWJsZSIsImRlYnVnIiwiQ29va2llSmFyIiwic2VtdmVyIiwic2FmZVN0cmluZ2lmeSIsInV0aWxzIiwiUmVxdWVzdEJhc2UiLCJ1bnppcCIsIlJlc3BvbnNlIiwiaHR0cDIiLCJndGUiLCJwcm9jZXNzIiwidmVyc2lvbiIsInJlcXVlc3QiLCJtZXRob2QiLCJ1cmwiLCJleHBvcnRzIiwiUmVxdWVzdCIsImVuZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIm1vZHVsZSIsImFnZW50Iiwibm9vcCIsImRlZmluZSIsInByb3RvY29scyIsInNlcmlhbGl6ZSIsInN0cmluZ2lmeSIsImJ1ZmZlciIsIl9pbml0SGVhZGVycyIsInJlcSIsIl9oZWFkZXIiLCJoZWFkZXIiLCJjYWxsIiwiX2VuYWJsZUh0dHAyIiwiQm9vbGVhbiIsImVudiIsIkhUVFAyX1RFU1QiLCJfYWdlbnQiLCJfZm9ybURhdGEiLCJ3cml0YWJsZSIsIl9yZWRpcmVjdHMiLCJyZWRpcmVjdHMiLCJjb29raWVzIiwiX3F1ZXJ5IiwicXNSYXciLCJfcmVkaXJlY3RMaXN0IiwiX3N0cmVhbVJlcXVlc3QiLCJvbmNlIiwiY2xlYXJUaW1lb3V0IiwiYmluZCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiYm9vbCIsInVuZGVmaW5lZCIsIkVycm9yIiwiYXR0YWNoIiwiZmllbGQiLCJmaWxlIiwib3B0aW9ucyIsIl9kYXRhIiwibyIsImZpbGVuYW1lIiwiY3JlYXRlUmVhZFN0cmVhbSIsInBhdGgiLCJfZ2V0Rm9ybURhdGEiLCJhcHBlbmQiLCJvbiIsImVyciIsImNhbGxlZCIsImNhbGxiYWNrIiwiYWJvcnQiLCJ0eXBlIiwic2V0IiwiaW5jbHVkZXMiLCJnZXRUeXBlIiwiYWNjZXB0IiwicXVlcnkiLCJ2YWwiLCJwdXNoIiwiT2JqZWN0IiwiYXNzaWduIiwid3JpdGUiLCJkYXRhIiwiZW5jb2RpbmciLCJwaXBlIiwic3RyZWFtIiwicGlwZWQiLCJfcGlwZUNvbnRpbnVlIiwicmVzIiwiaXNSZWRpcmVjdCIsInN0YXR1c0NvZGUiLCJfbWF4UmVkaXJlY3RzIiwiX3JlZGlyZWN0IiwiX2VtaXRSZXNwb25zZSIsIl9hYm9ydGVkIiwiX3Nob3VsZFVuemlwIiwidW56aXBPYmoiLCJjcmVhdGVVbnppcCIsImNvZGUiLCJlbWl0IiwiX2J1ZmZlciIsImhlYWRlcnMiLCJsb2NhdGlvbiIsInJlc3VtZSIsImdldEhlYWRlcnMiLCJfaGVhZGVycyIsImNoYW5nZXNPcmlnaW4iLCJob3N0IiwiY2xlYW5IZWFkZXIiLCJfZW5kQ2FsbGVkIiwiX2NhbGxiYWNrIiwiYXV0aCIsInVzZXIiLCJwYXNzIiwiZW5jb2RlciIsInN0cmluZyIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIl9hdXRoIiwiY2EiLCJjZXJ0IiwiX2NhIiwia2V5IiwiX2tleSIsInBmeCIsImlzQnVmZmVyIiwiX3BmeCIsIl9wYXNzcGhyYXNlIiwicGFzc3BocmFzZSIsIl9jZXJ0IiwiZGlzYWJsZVRMU0NlcnRzIiwiX2Rpc2FibGVUTFNDZXJ0cyIsImluZGljZXMiLCJzdHJpY3ROdWxsSGFuZGxpbmciLCJfZmluYWxpemVRdWVyeVN0cmluZyIsInJldHJpZXMiLCJfcmV0cmllcyIsInF1ZXJ5U3RyaW5nQmFja3RpY2tzIiwicXVlcnlTdGFydEluZGV4IiwiaW5kZXhPZiIsInF1ZXJ5U3RyaW5nIiwic2xpY2UiLCJtYXRjaCIsImkiLCJyZXBsYWNlIiwic2VhcmNoIiwicGF0aG5hbWUiLCJ0ZXN0IiwicHJvdG9jb2wiLCJzcGxpdCIsInVuaXhQYXJ0cyIsInNvY2tldFBhdGgiLCJfY29ubmVjdE92ZXJyaWRlIiwiaG9zdG5hbWUiLCJuZXdIb3N0IiwibmV3UG9ydCIsInBvcnQiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJOT0RFX1RMU19SRUpFQ1RfVU5BVVRIT1JJWkVEIiwic2VydmVybmFtZSIsIl90cnVzdExvY2FsaG9zdCIsIm1vZCIsInNldFByb3RvY29sIiwic2V0Tm9EZWxheSIsInNldEhlYWRlciIsInJlc3BvbnNlIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImhhc093blByb3BlcnR5IiwidG1wSmFyIiwic2V0Q29va2llcyIsImNvb2tpZSIsImdldENvb2tpZXMiLCJDb29raWVBY2Nlc3NJbmZvIiwiQWxsIiwidG9WYWx1ZVN0cmluZyIsIl9zaG91bGRSZXRyeSIsIl9yZXRyeSIsImZuIiwiY29uc29sZSIsIndhcm4iLCJfaXNSZXNwb25zZU9LIiwibXNnIiwiU1RBVFVTX0NPREVTIiwic3RhdHVzIiwiZXJyXyIsIl9tYXhSZXRyaWVzIiwibGlzdGVuZXJzIiwiX2lzSG9zdCIsIm9iaiIsImJvZHkiLCJmaWxlcyIsIl9lbmQiLCJfc2V0VGltZW91dHMiLCJfaGVhZGVyU2VudCIsImNvbnRlbnRUeXBlIiwiZ2V0SGVhZGVyIiwiX3NlcmlhbGl6ZXIiLCJpc0pTT04iLCJieXRlTGVuZ3RoIiwiX3Jlc3BvbnNlVGltZW91dFRpbWVyIiwibWF4IiwidG9Mb3dlckNhc2UiLCJ0cmltIiwibXVsdGlwYXJ0IiwicmVkaXJlY3QiLCJyZXNwb25zZVR5cGUiLCJfcmVzcG9uc2VUeXBlIiwicGFyc2VyIiwiX3BhcnNlciIsImltYWdlIiwiZm9ybSIsIkluY29taW5nRm9ybSIsImlzSW1hZ2VPclZpZGVvIiwidGV4dCIsImlzVGV4dCIsIl9yZXNCdWZmZXJlZCIsInBhcnNlckhhbmRsZXNFbmQiLCJyZXNwb25zZUJ5dGVzTGVmdCIsIl9tYXhSZXNwb25zZVNpemUiLCJidWYiLCJkZXN0cm95IiwidGltZWRvdXQiLCJnZXRQcm9ncmVzc01vbml0b3IiLCJsZW5ndGhDb21wdXRhYmxlIiwidG90YWwiLCJsb2FkZWQiLCJwcm9ncmVzcyIsIlRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJjaHVuayIsImNiIiwiZGlyZWN0aW9uIiwiYnVmZmVyVG9DaHVua3MiLCJjaHVua1NpemUiLCJjaHVua2luZyIsIlJlYWRhYmxlIiwidG90YWxMZW5ndGgiLCJyZW1haW5kZXIiLCJjdXRvZmYiLCJyZW1haW5kZXJCdWZmZXIiLCJmb3JtRGF0YSIsImdldExlbmd0aCIsImNvbm5lY3QiLCJjb25uZWN0T3ZlcnJpZGUiLCJ0cnVzdExvY2FsaG9zdCIsInRvZ2dsZSIsImZvckVhY2giLCJuYW1lIiwidG9VcHBlckNhc2UiLCJzZW5kIiwicGFydHMiLCJzdWJ0eXBlIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztBQUlBO2VBQ21DQSxPQUFPLENBQUMsS0FBRCxDO0lBQWxDQyxLLFlBQUFBLEs7SUFBT0MsTSxZQUFBQSxNO0lBQVFDLE8sWUFBQUEsTzs7QUFDdkIsSUFBTUMsTUFBTSxHQUFHSixPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFDQSxJQUFNSyxLQUFLLEdBQUdMLE9BQU8sQ0FBQyxPQUFELENBQXJCOztBQUNBLElBQU1NLElBQUksR0FBR04sT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsSUFBTU8sRUFBRSxHQUFHUCxPQUFPLENBQUMsSUFBRCxDQUFsQjs7QUFDQSxJQUFNUSxJQUFJLEdBQUdSLE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLElBQU1TLElBQUksR0FBR1QsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsSUFBTVUsRUFBRSxHQUFHVixPQUFPLENBQUMsSUFBRCxDQUFsQjs7QUFDQSxJQUFNVyxJQUFJLEdBQUdYLE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLElBQUlZLE9BQU8sR0FBR1osT0FBTyxDQUFDLFNBQUQsQ0FBckI7O0FBQ0EsSUFBTWEsUUFBUSxHQUFHYixPQUFPLENBQUMsV0FBRCxDQUF4Qjs7QUFDQSxJQUFNYyxVQUFVLEdBQUdkLE9BQU8sQ0FBQyxZQUFELENBQTFCOztBQUNBLElBQU1lLEtBQUssR0FBR2YsT0FBTyxDQUFDLE9BQUQsQ0FBUCxDQUFpQixZQUFqQixDQUFkOztBQUNBLElBQU1nQixTQUFTLEdBQUdoQixPQUFPLENBQUMsV0FBRCxDQUF6Qjs7QUFDQSxJQUFNaUIsTUFBTSxHQUFHakIsT0FBTyxDQUFDLFFBQUQsQ0FBdEI7O0FBQ0EsSUFBTWtCLGFBQWEsR0FBR2xCLE9BQU8sQ0FBQyxxQkFBRCxDQUE3Qjs7QUFFQSxJQUFNbUIsS0FBSyxHQUFHbkIsT0FBTyxDQUFDLFVBQUQsQ0FBckI7O0FBQ0EsSUFBTW9CLFdBQVcsR0FBR3BCLE9BQU8sQ0FBQyxpQkFBRCxDQUEzQjs7Z0JBQ2tCQSxPQUFPLENBQUMsU0FBRCxDO0lBQWpCcUIsSyxhQUFBQSxLOztBQUNSLElBQU1DLFFBQVEsR0FBR3RCLE9BQU8sQ0FBQyxZQUFELENBQXhCOztBQUVBLElBQUl1QixLQUFKO0FBRUEsSUFBSU4sTUFBTSxDQUFDTyxHQUFQLENBQVdDLE9BQU8sQ0FBQ0MsT0FBbkIsRUFBNEIsVUFBNUIsQ0FBSixFQUE2Q0gsS0FBSyxHQUFHdkIsT0FBTyxDQUFDLGdCQUFELENBQWY7O0FBRTdDLFNBQVMyQixPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsR0FBekIsRUFBOEI7QUFDNUI7QUFDQSxNQUFJLE9BQU9BLEdBQVAsS0FBZSxVQUFuQixFQUErQjtBQUM3QixXQUFPLElBQUlDLE9BQU8sQ0FBQ0MsT0FBWixDQUFvQixLQUFwQixFQUEyQkgsTUFBM0IsRUFBbUNJLEdBQW5DLENBQXVDSCxHQUF2QyxDQUFQO0FBQ0QsR0FKMkIsQ0FNNUI7OztBQUNBLE1BQUlJLFNBQVMsQ0FBQ0MsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUMxQixXQUFPLElBQUlKLE9BQU8sQ0FBQ0MsT0FBWixDQUFvQixLQUFwQixFQUEyQkgsTUFBM0IsQ0FBUDtBQUNEOztBQUVELFNBQU8sSUFBSUUsT0FBTyxDQUFDQyxPQUFaLENBQW9CSCxNQUFwQixFQUE0QkMsR0FBNUIsQ0FBUDtBQUNEOztBQUVETSxNQUFNLENBQUNMLE9BQVAsR0FBaUJILE9BQWpCO0FBQ0FHLE9BQU8sR0FBR0ssTUFBTSxDQUFDTCxPQUFqQjtBQUVBOzs7O0FBSUFBLE9BQU8sQ0FBQ0MsT0FBUixHQUFrQkEsT0FBbEI7QUFFQTs7OztBQUlBRCxPQUFPLENBQUNNLEtBQVIsR0FBZ0JwQyxPQUFPLENBQUMsU0FBRCxDQUF2QjtBQUVBOzs7O0FBSUEsU0FBU3FDLElBQVQsR0FBZ0IsQ0FBRTtBQUVsQjs7Ozs7QUFJQVAsT0FBTyxDQUFDUixRQUFSLEdBQW1CQSxRQUFuQjtBQUVBOzs7O0FBSUFYLElBQUksQ0FBQzJCLE1BQUwsQ0FDRTtBQUNFLHVDQUFxQyxDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLFdBQXZCO0FBRHZDLENBREYsRUFJRSxJQUpGO0FBT0E7Ozs7QUFJQVIsT0FBTyxDQUFDUyxTQUFSLEdBQW9CO0FBQ2xCLFdBQVNqQyxJQURTO0FBRWxCLFlBQVVELEtBRlE7QUFHbEIsWUFBVWtCO0FBSFEsQ0FBcEI7QUFNQTs7Ozs7Ozs7O0FBU0FPLE9BQU8sQ0FBQ1UsU0FBUixHQUFvQjtBQUNsQix1Q0FBcUM5QixFQUFFLENBQUMrQixTQUR0QjtBQUVsQixzQkFBb0J2QjtBQUZGLENBQXBCO0FBS0E7Ozs7Ozs7OztBQVNBWSxPQUFPLENBQUM3QixLQUFSLEdBQWdCRCxPQUFPLENBQUMsV0FBRCxDQUF2QjtBQUVBOzs7Ozs7O0FBTUE4QixPQUFPLENBQUNZLE1BQVIsR0FBaUIsRUFBakI7QUFFQTs7Ozs7OztBQU1BLFNBQVNDLFlBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCO0FBQ3pCQSxFQUFBQSxHQUFHLENBQUNDLE9BQUosR0FBYyxDQUNaO0FBRFksR0FBZDtBQUdBRCxFQUFBQSxHQUFHLENBQUNFLE1BQUosR0FBYSxDQUNYO0FBRFcsR0FBYjtBQUdEO0FBRUQ7Ozs7Ozs7OztBQVFBLFNBQVNmLE9BQVQsQ0FBaUJILE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjtBQUM1QnpCLEVBQUFBLE1BQU0sQ0FBQzJDLElBQVAsQ0FBWSxJQUFaO0FBQ0EsTUFBSSxPQUFPbEIsR0FBUCxLQUFlLFFBQW5CLEVBQTZCQSxHQUFHLEdBQUczQixNQUFNLENBQUMyQixHQUFELENBQVo7QUFDN0IsT0FBS21CLFlBQUwsR0FBb0JDLE9BQU8sQ0FBQ3hCLE9BQU8sQ0FBQ3lCLEdBQVIsQ0FBWUMsVUFBYixDQUEzQixDQUg0QixDQUd5Qjs7QUFDckQsT0FBS0MsTUFBTCxHQUFjLEtBQWQ7QUFDQSxPQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsT0FBS3pCLE1BQUwsR0FBY0EsTUFBZDtBQUNBLE9BQUtDLEdBQUwsR0FBV0EsR0FBWDs7QUFDQWMsRUFBQUEsWUFBWSxDQUFDLElBQUQsQ0FBWjs7QUFDQSxPQUFLVyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsT0FBS0MsVUFBTCxHQUFrQixDQUFsQjtBQUNBLE9BQUtDLFNBQUwsQ0FBZTVCLE1BQU0sS0FBSyxNQUFYLEdBQW9CLENBQXBCLEdBQXdCLENBQXZDO0FBQ0EsT0FBSzZCLE9BQUwsR0FBZSxFQUFmO0FBQ0EsT0FBSy9DLEVBQUwsR0FBVSxFQUFWO0FBQ0EsT0FBS2dELE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBS0MsS0FBTCxHQUFhLEtBQUtELE1BQWxCLENBZjRCLENBZUY7O0FBQzFCLE9BQUtFLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxPQUFLQyxjQUFMLEdBQXNCLEtBQXRCO0FBQ0EsT0FBS0MsSUFBTCxDQUFVLEtBQVYsRUFBaUIsS0FBS0MsWUFBTCxDQUFrQkMsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBakI7QUFDRDtBQUVEOzs7Ozs7QUFJQXZELElBQUksQ0FBQ3dELFFBQUwsQ0FBY2xDLE9BQWQsRUFBdUIzQixNQUF2QixFLENBQ0E7O0FBQ0FnQixXQUFXLENBQUNXLE9BQU8sQ0FBQ21DLFNBQVQsQ0FBWDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQW5DLE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0IzQyxLQUFsQixHQUEwQixVQUFVNEMsSUFBVixFQUFnQjtBQUN4QyxNQUFJckMsT0FBTyxDQUFDUyxTQUFSLENBQWtCLFFBQWxCLE1BQWdDNkIsU0FBcEMsRUFBK0M7QUFDN0MsVUFBTSxJQUFJQyxLQUFKLENBQ0osNERBREksQ0FBTjtBQUdEOztBQUVELE9BQUtyQixZQUFMLEdBQW9CbUIsSUFBSSxLQUFLQyxTQUFULEdBQXFCLElBQXJCLEdBQTRCRCxJQUFoRDtBQUNBLFNBQU8sSUFBUDtBQUNELENBVEQ7QUFXQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkFwQyxPQUFPLENBQUNtQyxTQUFSLENBQWtCSSxNQUFsQixHQUEyQixVQUFVQyxLQUFWLEVBQWlCQyxJQUFqQixFQUF1QkMsT0FBdkIsRUFBZ0M7QUFDekQsTUFBSUQsSUFBSixFQUFVO0FBQ1IsUUFBSSxLQUFLRSxLQUFULEVBQWdCO0FBQ2QsWUFBTSxJQUFJTCxLQUFKLENBQVUsNENBQVYsQ0FBTjtBQUNEOztBQUVELFFBQUlNLENBQUMsR0FBR0YsT0FBTyxJQUFJLEVBQW5COztBQUNBLFFBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQkUsTUFBQUEsQ0FBQyxHQUFHO0FBQUVDLFFBQUFBLFFBQVEsRUFBRUg7QUFBWixPQUFKO0FBQ0Q7O0FBRUQsUUFBSSxPQUFPRCxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQUksQ0FBQ0csQ0FBQyxDQUFDQyxRQUFQLEVBQWlCRCxDQUFDLENBQUNDLFFBQUYsR0FBYUosSUFBYjtBQUNqQnpELE1BQUFBLEtBQUssQ0FBQyxnREFBRCxFQUFtRHlELElBQW5ELENBQUw7QUFDQUEsTUFBQUEsSUFBSSxHQUFHakUsRUFBRSxDQUFDc0UsZ0JBQUgsQ0FBb0JMLElBQXBCLENBQVA7QUFDRCxLQUpELE1BSU8sSUFBSSxDQUFDRyxDQUFDLENBQUNDLFFBQUgsSUFBZUosSUFBSSxDQUFDTSxJQUF4QixFQUE4QjtBQUNuQ0gsTUFBQUEsQ0FBQyxDQUFDQyxRQUFGLEdBQWFKLElBQUksQ0FBQ00sSUFBbEI7QUFDRDs7QUFFRCxTQUFLQyxZQUFMLEdBQW9CQyxNQUFwQixDQUEyQlQsS0FBM0IsRUFBa0NDLElBQWxDLEVBQXdDRyxDQUF4QztBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBdkJEOztBQXlCQTVDLE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0JhLFlBQWxCLEdBQWlDLFlBQVk7QUFBQTs7QUFDM0MsTUFBSSxDQUFDLEtBQUsxQixTQUFWLEVBQXFCO0FBQ25CLFNBQUtBLFNBQUwsR0FBaUIsSUFBSXhDLFFBQUosRUFBakI7O0FBQ0EsU0FBS3dDLFNBQUwsQ0FBZTRCLEVBQWYsQ0FBa0IsT0FBbEIsRUFBMkIsVUFBQ0MsR0FBRCxFQUFTO0FBQ2xDbkUsTUFBQUEsS0FBSyxDQUFDLGdCQUFELEVBQW1CbUUsR0FBbkIsQ0FBTDs7QUFDQSxVQUFJLEtBQUksQ0FBQ0MsTUFBVCxFQUFpQjtBQUNmO0FBQ0E7QUFDQTtBQUNEOztBQUVELE1BQUEsS0FBSSxDQUFDQyxRQUFMLENBQWNGLEdBQWQ7O0FBQ0EsTUFBQSxLQUFJLENBQUNHLEtBQUw7QUFDRCxLQVZEO0FBV0Q7O0FBRUQsU0FBTyxLQUFLaEMsU0FBWjtBQUNELENBakJEO0FBbUJBOzs7Ozs7Ozs7O0FBU0F0QixPQUFPLENBQUNtQyxTQUFSLENBQWtCOUIsS0FBbEIsR0FBMEIsVUFBVUEsS0FBVixFQUFpQjtBQUN6QyxNQUFJSCxTQUFTLENBQUNDLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEIsT0FBTyxLQUFLa0IsTUFBWjtBQUM1QixPQUFLQSxNQUFMLEdBQWNoQixLQUFkO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FKRDtBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQUwsT0FBTyxDQUFDbUMsU0FBUixDQUFrQm9CLElBQWxCLEdBQXlCLFVBQVVBLElBQVYsRUFBZ0I7QUFDdkMsU0FBTyxLQUFLQyxHQUFMLENBQ0wsY0FESyxFQUVMRCxJQUFJLENBQUNFLFFBQUwsQ0FBYyxHQUFkLElBQXFCRixJQUFyQixHQUE0QjNFLElBQUksQ0FBQzhFLE9BQUwsQ0FBYUgsSUFBYixDQUZ2QixDQUFQO0FBSUQsQ0FMRDtBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkF2RCxPQUFPLENBQUNtQyxTQUFSLENBQWtCd0IsTUFBbEIsR0FBMkIsVUFBVUosSUFBVixFQUFnQjtBQUN6QyxTQUFPLEtBQUtDLEdBQUwsQ0FBUyxRQUFULEVBQW1CRCxJQUFJLENBQUNFLFFBQUwsQ0FBYyxHQUFkLElBQXFCRixJQUFyQixHQUE0QjNFLElBQUksQ0FBQzhFLE9BQUwsQ0FBYUgsSUFBYixDQUEvQyxDQUFQO0FBQ0QsQ0FGRDtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7QUFjQXZELE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0J5QixLQUFsQixHQUEwQixVQUFVQyxHQUFWLEVBQWU7QUFDdkMsTUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsU0FBS2xDLE1BQUwsQ0FBWW1DLElBQVosQ0FBaUJELEdBQWpCO0FBQ0QsR0FGRCxNQUVPO0FBQ0xFLElBQUFBLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEtBQUtyRixFQUFuQixFQUF1QmtGLEdBQXZCO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0FSRDtBQVVBOzs7Ozs7Ozs7O0FBU0E3RCxPQUFPLENBQUNtQyxTQUFSLENBQWtCOEIsS0FBbEIsR0FBMEIsVUFBVUMsSUFBVixFQUFnQkMsUUFBaEIsRUFBMEI7QUFDbEQsTUFBTXRELEdBQUcsR0FBRyxLQUFLakIsT0FBTCxFQUFaOztBQUNBLE1BQUksQ0FBQyxLQUFLa0MsY0FBVixFQUEwQjtBQUN4QixTQUFLQSxjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7O0FBRUQsU0FBT2pCLEdBQUcsQ0FBQ29ELEtBQUosQ0FBVUMsSUFBVixFQUFnQkMsUUFBaEIsQ0FBUDtBQUNELENBUEQ7QUFTQTs7Ozs7Ozs7OztBQVNBbkUsT0FBTyxDQUFDbUMsU0FBUixDQUFrQmlDLElBQWxCLEdBQXlCLFVBQVVDLE1BQVYsRUFBa0IzQixPQUFsQixFQUEyQjtBQUNsRCxPQUFLNEIsS0FBTCxHQUFhLElBQWIsQ0FEa0QsQ0FDL0I7O0FBQ25CLE9BQUszRCxNQUFMLENBQVksS0FBWjtBQUNBLE9BQUtWLEdBQUw7QUFDQSxTQUFPLEtBQUtzRSxhQUFMLENBQW1CRixNQUFuQixFQUEyQjNCLE9BQTNCLENBQVA7QUFDRCxDQUxEOztBQU9BMUMsT0FBTyxDQUFDbUMsU0FBUixDQUFrQm9DLGFBQWxCLEdBQWtDLFVBQVVGLE1BQVYsRUFBa0IzQixPQUFsQixFQUEyQjtBQUFBOztBQUMzRCxPQUFLN0IsR0FBTCxDQUFTa0IsSUFBVCxDQUFjLFVBQWQsRUFBMEIsVUFBQ3lDLEdBQUQsRUFBUztBQUNqQztBQUNBLFFBQ0VDLFVBQVUsQ0FBQ0QsR0FBRyxDQUFDRSxVQUFMLENBQVYsSUFDQSxNQUFJLENBQUNsRCxVQUFMLE9BQXNCLE1BQUksQ0FBQ21ELGFBRjdCLEVBR0U7QUFDQSxhQUFPLE1BQUksQ0FBQ0MsU0FBTCxDQUFlSixHQUFmLE1BQXdCLE1BQXhCLEdBQ0gsTUFBSSxDQUFDRCxhQUFMLENBQW1CRixNQUFuQixFQUEyQjNCLE9BQTNCLENBREcsR0FFSEwsU0FGSjtBQUdEOztBQUVELElBQUEsTUFBSSxDQUFDbUMsR0FBTCxHQUFXQSxHQUFYOztBQUNBLElBQUEsTUFBSSxDQUFDSyxhQUFMOztBQUNBLFFBQUksTUFBSSxDQUFDQyxRQUFULEVBQW1COztBQUVuQixRQUFJLE1BQUksQ0FBQ0MsWUFBTCxDQUFrQlAsR0FBbEIsQ0FBSixFQUE0QjtBQUMxQixVQUFNUSxRQUFRLEdBQUd2RyxJQUFJLENBQUN3RyxXQUFMLEVBQWpCO0FBQ0FELE1BQUFBLFFBQVEsQ0FBQzlCLEVBQVQsQ0FBWSxPQUFaLEVBQXFCLFVBQUNDLEdBQUQsRUFBUztBQUM1QixZQUFJQSxHQUFHLElBQUlBLEdBQUcsQ0FBQytCLElBQUosS0FBYSxhQUF4QixFQUF1QztBQUNyQztBQUNBYixVQUFBQSxNQUFNLENBQUNjLElBQVAsQ0FBWSxLQUFaO0FBQ0E7QUFDRDs7QUFFRGQsUUFBQUEsTUFBTSxDQUFDYyxJQUFQLENBQVksT0FBWixFQUFxQmhDLEdBQXJCO0FBQ0QsT0FSRDtBQVNBcUIsTUFBQUEsR0FBRyxDQUFDSixJQUFKLENBQVNZLFFBQVQsRUFBbUJaLElBQW5CLENBQXdCQyxNQUF4QixFQUFnQzNCLE9BQWhDO0FBQ0QsS0FaRCxNQVlPO0FBQ0w4QixNQUFBQSxHQUFHLENBQUNKLElBQUosQ0FBU0MsTUFBVCxFQUFpQjNCLE9BQWpCO0FBQ0Q7O0FBRUQ4QixJQUFBQSxHQUFHLENBQUN6QyxJQUFKLENBQVMsS0FBVCxFQUFnQixZQUFNO0FBQ3BCLE1BQUEsTUFBSSxDQUFDb0QsSUFBTCxDQUFVLEtBQVY7QUFDRCxLQUZEO0FBR0QsR0FsQ0Q7QUFtQ0EsU0FBT2QsTUFBUDtBQUNELENBckNEO0FBdUNBOzs7Ozs7Ozs7QUFRQXJFLE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0J4QixNQUFsQixHQUEyQixVQUFVa0QsR0FBVixFQUFlO0FBQ3hDLE9BQUt1QixPQUFMLEdBQWV2QixHQUFHLEtBQUssS0FBdkI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUhEO0FBS0E7Ozs7Ozs7OztBQVFBN0QsT0FBTyxDQUFDbUMsU0FBUixDQUFrQnlDLFNBQWxCLEdBQThCLFVBQVVKLEdBQVYsRUFBZTtBQUMzQyxNQUFJMUUsR0FBRyxHQUFHMEUsR0FBRyxDQUFDYSxPQUFKLENBQVlDLFFBQXRCOztBQUNBLE1BQUksQ0FBQ3hGLEdBQUwsRUFBVTtBQUNSLFdBQU8sS0FBS3VELFFBQUwsQ0FBYyxJQUFJZixLQUFKLENBQVUsaUNBQVYsQ0FBZCxFQUE0RGtDLEdBQTVELENBQVA7QUFDRDs7QUFFRHhGLEVBQUFBLEtBQUssQ0FBQyxtQkFBRCxFQUFzQixLQUFLYyxHQUEzQixFQUFnQ0EsR0FBaEMsQ0FBTCxDQU4yQyxDQVEzQzs7QUFDQUEsRUFBQUEsR0FBRyxHQUFHMUIsT0FBTyxDQUFDLEtBQUswQixHQUFOLEVBQVdBLEdBQVgsQ0FBYixDQVQyQyxDQVczQztBQUNBOztBQUNBMEUsRUFBQUEsR0FBRyxDQUFDZSxNQUFKO0FBRUEsTUFBSUYsT0FBTyxHQUFHLEtBQUt4RSxHQUFMLENBQVMyRSxVQUFULEdBQXNCLEtBQUszRSxHQUFMLENBQVMyRSxVQUFULEVBQXRCLEdBQThDLEtBQUszRSxHQUFMLENBQVM0RSxRQUFyRTtBQUVBLE1BQU1DLGFBQWEsR0FBR3hILEtBQUssQ0FBQzRCLEdBQUQsQ0FBTCxDQUFXNkYsSUFBWCxLQUFvQnpILEtBQUssQ0FBQyxLQUFLNEIsR0FBTixDQUFMLENBQWdCNkYsSUFBMUQsQ0FqQjJDLENBbUIzQzs7QUFDQSxNQUFJbkIsR0FBRyxDQUFDRSxVQUFKLEtBQW1CLEdBQW5CLElBQTBCRixHQUFHLENBQUNFLFVBQUosS0FBbUIsR0FBakQsRUFBc0Q7QUFDcEQ7QUFDQTtBQUNBVyxJQUFBQSxPQUFPLEdBQUdqRyxLQUFLLENBQUN3RyxXQUFOLENBQWtCUCxPQUFsQixFQUEyQkssYUFBM0IsQ0FBVixDQUhvRCxDQUtwRDs7QUFDQSxTQUFLN0YsTUFBTCxHQUFjLEtBQUtBLE1BQUwsS0FBZ0IsTUFBaEIsR0FBeUIsTUFBekIsR0FBa0MsS0FBaEQsQ0FOb0QsQ0FRcEQ7O0FBQ0EsU0FBSzhDLEtBQUwsR0FBYSxJQUFiO0FBQ0QsR0E5QjBDLENBZ0MzQzs7O0FBQ0EsTUFBSTZCLEdBQUcsQ0FBQ0UsVUFBSixLQUFtQixHQUF2QixFQUE0QjtBQUMxQjtBQUNBO0FBQ0FXLElBQUFBLE9BQU8sR0FBR2pHLEtBQUssQ0FBQ3dHLFdBQU4sQ0FBa0JQLE9BQWxCLEVBQTJCSyxhQUEzQixDQUFWLENBSDBCLENBSzFCOztBQUNBLFNBQUs3RixNQUFMLEdBQWMsS0FBZCxDQU4wQixDQVExQjs7QUFDQSxTQUFLOEMsS0FBTCxHQUFhLElBQWI7QUFDRCxHQTNDMEMsQ0E2QzNDO0FBQ0E7OztBQUNBLFNBQU8wQyxPQUFPLENBQUNNLElBQWY7QUFFQSxTQUFPLEtBQUs5RSxHQUFaO0FBQ0EsU0FBTyxLQUFLUyxTQUFaLENBbEQyQyxDQW9EM0M7O0FBQ0FWLEVBQUFBLFlBQVksQ0FBQyxJQUFELENBQVosQ0FyRDJDLENBdUQzQzs7O0FBQ0EsT0FBS2lGLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxPQUFLL0YsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS25CLEVBQUwsR0FBVSxFQUFWO0FBQ0EsT0FBS2dELE1BQUwsQ0FBWXhCLE1BQVosR0FBcUIsQ0FBckI7QUFDQSxPQUFLcUQsR0FBTCxDQUFTNkIsT0FBVDtBQUNBLE9BQUtGLElBQUwsQ0FBVSxVQUFWLEVBQXNCWCxHQUF0Qjs7QUFDQSxPQUFLM0MsYUFBTCxDQUFtQmlDLElBQW5CLENBQXdCLEtBQUtoRSxHQUE3Qjs7QUFDQSxPQUFLRyxHQUFMLENBQVMsS0FBSzZGLFNBQWQ7QUFDQSxTQUFPLElBQVA7QUFDRCxDQWpFRDtBQW1FQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOUYsT0FBTyxDQUFDbUMsU0FBUixDQUFrQjRELElBQWxCLEdBQXlCLFVBQVVDLElBQVYsRUFBZ0JDLElBQWhCLEVBQXNCdkQsT0FBdEIsRUFBK0I7QUFDdEQsTUFBSXhDLFNBQVMsQ0FBQ0MsTUFBVixLQUFxQixDQUF6QixFQUE0QjhGLElBQUksR0FBRyxFQUFQOztBQUM1QixNQUFJLFFBQU9BLElBQVAsTUFBZ0IsUUFBaEIsSUFBNEJBLElBQUksS0FBSyxJQUF6QyxFQUErQztBQUM3QztBQUNBdkQsSUFBQUEsT0FBTyxHQUFHdUQsSUFBVjtBQUNBQSxJQUFBQSxJQUFJLEdBQUcsRUFBUDtBQUNEOztBQUVELE1BQUksQ0FBQ3ZELE9BQUwsRUFBYztBQUNaQSxJQUFBQSxPQUFPLEdBQUc7QUFBRWEsTUFBQUEsSUFBSSxFQUFFO0FBQVIsS0FBVjtBQUNEOztBQUVELE1BQU0yQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFDQyxNQUFEO0FBQUEsV0FBWUMsTUFBTSxDQUFDQyxJQUFQLENBQVlGLE1BQVosRUFBb0JHLFFBQXBCLENBQTZCLFFBQTdCLENBQVo7QUFBQSxHQUFoQjs7QUFFQSxTQUFPLEtBQUtDLEtBQUwsQ0FBV1AsSUFBWCxFQUFpQkMsSUFBakIsRUFBdUJ2RCxPQUF2QixFQUFnQ3dELE9BQWhDLENBQVA7QUFDRCxDQWZEO0FBaUJBOzs7Ozs7Ozs7QUFRQWxHLE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0JxRSxFQUFsQixHQUF1QixVQUFVQyxJQUFWLEVBQWdCO0FBQ3JDLE9BQUtDLEdBQUwsR0FBV0QsSUFBWDtBQUNBLFNBQU8sSUFBUDtBQUNELENBSEQ7QUFLQTs7Ozs7Ozs7O0FBUUF6RyxPQUFPLENBQUNtQyxTQUFSLENBQWtCd0UsR0FBbEIsR0FBd0IsVUFBVUYsSUFBVixFQUFnQjtBQUN0QyxPQUFLRyxJQUFMLEdBQVlILElBQVo7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUhEO0FBS0E7Ozs7Ozs7OztBQVFBekcsT0FBTyxDQUFDbUMsU0FBUixDQUFrQjBFLEdBQWxCLEdBQXdCLFVBQVVKLElBQVYsRUFBZ0I7QUFDdEMsTUFBSSxRQUFPQSxJQUFQLE1BQWdCLFFBQWhCLElBQTRCLENBQUNMLE1BQU0sQ0FBQ1UsUUFBUCxDQUFnQkwsSUFBaEIsQ0FBakMsRUFBd0Q7QUFDdEQsU0FBS00sSUFBTCxHQUFZTixJQUFJLENBQUNJLEdBQWpCO0FBQ0EsU0FBS0csV0FBTCxHQUFtQlAsSUFBSSxDQUFDUSxVQUF4QjtBQUNELEdBSEQsTUFHTztBQUNMLFNBQUtGLElBQUwsR0FBWU4sSUFBWjtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBVEQ7QUFXQTs7Ozs7Ozs7O0FBUUF6RyxPQUFPLENBQUNtQyxTQUFSLENBQWtCc0UsSUFBbEIsR0FBeUIsVUFBVUEsSUFBVixFQUFnQjtBQUN2QyxPQUFLUyxLQUFMLEdBQWFULElBQWI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUhEO0FBS0E7Ozs7Ozs7OztBQVFBekcsT0FBTyxDQUFDbUMsU0FBUixDQUFrQmdGLGVBQWxCLEdBQW9DLFlBQVk7QUFDOUMsT0FBS0MsZ0JBQUwsR0FBd0IsSUFBeEI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUhEO0FBS0E7Ozs7OztBQU9BOzs7QUFDQXBILE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0J2QyxPQUFsQixHQUE0QixZQUFZO0FBQUE7O0FBQ3RDLE1BQUksS0FBS2lCLEdBQVQsRUFBYyxPQUFPLEtBQUtBLEdBQVo7QUFFZCxNQUFNNkIsT0FBTyxHQUFHLEVBQWhCOztBQUVBLE1BQUk7QUFDRixRQUFNa0IsS0FBSyxHQUFHakYsRUFBRSxDQUFDK0IsU0FBSCxDQUFhLEtBQUsvQixFQUFsQixFQUFzQjtBQUNsQzBJLE1BQUFBLE9BQU8sRUFBRSxLQUR5QjtBQUVsQ0MsTUFBQUEsa0JBQWtCLEVBQUU7QUFGYyxLQUF0QixDQUFkOztBQUlBLFFBQUkxRCxLQUFKLEVBQVc7QUFDVCxXQUFLakYsRUFBTCxHQUFVLEVBQVY7O0FBQ0EsV0FBS2dELE1BQUwsQ0FBWW1DLElBQVosQ0FBaUJGLEtBQWpCO0FBQ0Q7O0FBRUQsU0FBSzJELG9CQUFMO0FBQ0QsR0FYRCxDQVdFLE9BQU9wRSxHQUFQLEVBQVk7QUFDWixXQUFPLEtBQUtnQyxJQUFMLENBQVUsT0FBVixFQUFtQmhDLEdBQW5CLENBQVA7QUFDRDs7QUFsQnFDLE1Bb0JoQ3JELEdBcEJnQyxHQW9CeEIsSUFwQndCLENBb0JoQ0EsR0FwQmdDO0FBcUJ0QyxNQUFNMEgsT0FBTyxHQUFHLEtBQUtDLFFBQXJCLENBckJzQyxDQXVCdEM7QUFDQTtBQUNBOztBQUNBLE1BQUlDLG9CQUFKOztBQUNBLE1BQUk1SCxHQUFHLENBQUMyRCxRQUFKLENBQWEsR0FBYixDQUFKLEVBQXVCO0FBQ3JCLFFBQU1rRSxlQUFlLEdBQUc3SCxHQUFHLENBQUM4SCxPQUFKLENBQVksR0FBWixDQUF4Qjs7QUFFQSxRQUFJRCxlQUFlLEtBQUssQ0FBQyxDQUF6QixFQUE0QjtBQUMxQixVQUFNRSxXQUFXLEdBQUcvSCxHQUFHLENBQUNnSSxLQUFKLENBQVVILGVBQWUsR0FBRyxDQUE1QixDQUFwQjtBQUNBRCxNQUFBQSxvQkFBb0IsR0FBR0csV0FBVyxDQUFDRSxLQUFaLENBQWtCLFFBQWxCLENBQXZCO0FBQ0Q7QUFDRixHQWxDcUMsQ0FvQ3RDOzs7QUFDQSxNQUFJakksR0FBRyxDQUFDOEgsT0FBSixDQUFZLE1BQVosTUFBd0IsQ0FBNUIsRUFBK0I5SCxHQUFHLG9CQUFhQSxHQUFiLENBQUg7QUFDL0JBLEVBQUFBLEdBQUcsR0FBRzVCLEtBQUssQ0FBQzRCLEdBQUQsQ0FBWCxDQXRDc0MsQ0F3Q3RDOztBQUNBLE1BQUk0SCxvQkFBSixFQUEwQjtBQUN4QixRQUFJTSxDQUFDLEdBQUcsQ0FBUjtBQUNBbEksSUFBQUEsR0FBRyxDQUFDOEQsS0FBSixHQUFZOUQsR0FBRyxDQUFDOEQsS0FBSixDQUFVcUUsT0FBVixDQUFrQixNQUFsQixFQUEwQjtBQUFBLGFBQU1QLG9CQUFvQixDQUFDTSxDQUFDLEVBQUYsQ0FBMUI7QUFBQSxLQUExQixDQUFaO0FBQ0FsSSxJQUFBQSxHQUFHLENBQUNvSSxNQUFKLGNBQWlCcEksR0FBRyxDQUFDOEQsS0FBckI7QUFDQTlELElBQUFBLEdBQUcsQ0FBQ2lELElBQUosR0FBV2pELEdBQUcsQ0FBQ3FJLFFBQUosR0FBZXJJLEdBQUcsQ0FBQ29JLE1BQTlCO0FBQ0QsR0E5Q3FDLENBZ0R0Qzs7O0FBQ0EsTUFBSSxpQkFBaUJFLElBQWpCLENBQXNCdEksR0FBRyxDQUFDdUksUUFBMUIsTUFBd0MsSUFBNUMsRUFBa0Q7QUFDaEQ7QUFDQXZJLElBQUFBLEdBQUcsQ0FBQ3VJLFFBQUosYUFBa0J2SSxHQUFHLENBQUN1SSxRQUFKLENBQWFDLEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBbEIsT0FGZ0QsQ0FJaEQ7O0FBQ0EsUUFBTUMsU0FBUyxHQUFHekksR0FBRyxDQUFDaUQsSUFBSixDQUFTZ0YsS0FBVCxDQUFlLGVBQWYsQ0FBbEI7QUFDQXJGLElBQUFBLE9BQU8sQ0FBQzhGLFVBQVIsR0FBcUJELFNBQVMsQ0FBQyxDQUFELENBQVQsQ0FBYU4sT0FBYixDQUFxQixNQUFyQixFQUE2QixHQUE3QixDQUFyQjtBQUNBbkksSUFBQUEsR0FBRyxDQUFDaUQsSUFBSixHQUFXd0YsU0FBUyxDQUFDLENBQUQsQ0FBcEI7QUFDRCxHQXpEcUMsQ0EyRHRDOzs7QUFDQSxNQUFJLEtBQUtFLGdCQUFULEVBQTJCO0FBQUEsZUFDSjNJLEdBREk7QUFBQSxRQUNqQjRJLFFBRGlCLFFBQ2pCQSxRQURpQjtBQUV6QixRQUFNWCxLQUFLLEdBQ1RXLFFBQVEsSUFBSSxLQUFLRCxnQkFBakIsR0FDSSxLQUFLQSxnQkFBTCxDQUFzQkMsUUFBdEIsQ0FESixHQUVJLEtBQUtELGdCQUFMLENBQXNCLEdBQXRCLENBSE47O0FBSUEsUUFBSVYsS0FBSixFQUFXO0FBQ1Q7QUFDQSxVQUFJLENBQUMsS0FBS2pILE9BQUwsQ0FBYTZFLElBQWxCLEVBQXdCO0FBQ3RCLGFBQUtuQyxHQUFMLENBQVMsTUFBVCxFQUFpQjFELEdBQUcsQ0FBQzZGLElBQXJCO0FBQ0Q7O0FBRUQsVUFBSWdELE9BQUo7QUFDQSxVQUFJQyxPQUFKOztBQUVBLFVBQUksUUFBT2IsS0FBUCxNQUFpQixRQUFyQixFQUErQjtBQUM3QlksUUFBQUEsT0FBTyxHQUFHWixLQUFLLENBQUNwQyxJQUFoQjtBQUNBaUQsUUFBQUEsT0FBTyxHQUFHYixLQUFLLENBQUNjLElBQWhCO0FBQ0QsT0FIRCxNQUdPO0FBQ0xGLFFBQUFBLE9BQU8sR0FBR1osS0FBVjtBQUNBYSxRQUFBQSxPQUFPLEdBQUc5SSxHQUFHLENBQUMrSSxJQUFkO0FBQ0QsT0FmUSxDQWlCVDs7O0FBQ0EvSSxNQUFBQSxHQUFHLENBQUM2RixJQUFKLEdBQVcsSUFBSXlDLElBQUosQ0FBU08sT0FBVCxlQUF3QkEsT0FBeEIsU0FBcUNBLE9BQWhEOztBQUNBLFVBQUlDLE9BQUosRUFBYTtBQUNYOUksUUFBQUEsR0FBRyxDQUFDNkYsSUFBSixlQUFnQmlELE9BQWhCO0FBQ0E5SSxRQUFBQSxHQUFHLENBQUMrSSxJQUFKLEdBQVdELE9BQVg7QUFDRDs7QUFFRDlJLE1BQUFBLEdBQUcsQ0FBQzRJLFFBQUosR0FBZUMsT0FBZjtBQUNEO0FBQ0YsR0E1RnFDLENBOEZ0Qzs7O0FBQ0FqRyxFQUFBQSxPQUFPLENBQUM3QyxNQUFSLEdBQWlCLEtBQUtBLE1BQXRCO0FBQ0E2QyxFQUFBQSxPQUFPLENBQUNtRyxJQUFSLEdBQWUvSSxHQUFHLENBQUMrSSxJQUFuQjtBQUNBbkcsRUFBQUEsT0FBTyxDQUFDSyxJQUFSLEdBQWVqRCxHQUFHLENBQUNpRCxJQUFuQjtBQUNBTCxFQUFBQSxPQUFPLENBQUNpRCxJQUFSLEdBQWU3RixHQUFHLENBQUM0SSxRQUFuQjtBQUNBaEcsRUFBQUEsT0FBTyxDQUFDOEQsRUFBUixHQUFhLEtBQUtFLEdBQWxCO0FBQ0FoRSxFQUFBQSxPQUFPLENBQUNpRSxHQUFSLEdBQWMsS0FBS0MsSUFBbkI7QUFDQWxFLEVBQUFBLE9BQU8sQ0FBQ21FLEdBQVIsR0FBYyxLQUFLRSxJQUFuQjtBQUNBckUsRUFBQUEsT0FBTyxDQUFDK0QsSUFBUixHQUFlLEtBQUtTLEtBQXBCO0FBQ0F4RSxFQUFBQSxPQUFPLENBQUN1RSxVQUFSLEdBQXFCLEtBQUtELFdBQTFCO0FBQ0F0RSxFQUFBQSxPQUFPLENBQUNyQyxLQUFSLEdBQWdCLEtBQUtnQixNQUFyQjtBQUNBcUIsRUFBQUEsT0FBTyxDQUFDb0csa0JBQVIsR0FDRSxPQUFPLEtBQUsxQixnQkFBWixLQUFpQyxTQUFqQyxHQUNJLENBQUMsS0FBS0EsZ0JBRFYsR0FFSTFILE9BQU8sQ0FBQ3lCLEdBQVIsQ0FBWTRILDRCQUFaLEtBQTZDLEdBSG5ELENBekdzQyxDQThHdEM7O0FBQ0EsTUFBSSxLQUFLakksT0FBTCxDQUFhNkUsSUFBakIsRUFBdUI7QUFDckJqRCxJQUFBQSxPQUFPLENBQUNzRyxVQUFSLEdBQXFCLEtBQUtsSSxPQUFMLENBQWE2RSxJQUFiLENBQWtCc0MsT0FBbEIsQ0FBMEIsT0FBMUIsRUFBbUMsRUFBbkMsQ0FBckI7QUFDRDs7QUFFRCxNQUNFLEtBQUtnQixlQUFMLElBQ0EsNENBQTRDYixJQUE1QyxDQUFpRHRJLEdBQUcsQ0FBQzRJLFFBQXJELENBRkYsRUFHRTtBQUNBaEcsSUFBQUEsT0FBTyxDQUFDb0csa0JBQVIsR0FBNkIsS0FBN0I7QUFDRCxHQXhIcUMsQ0EwSHRDOzs7QUFDQSxNQUFNSSxHQUFHLEdBQUcsS0FBS2pJLFlBQUwsR0FDUmxCLE9BQU8sQ0FBQ1MsU0FBUixDQUFrQixRQUFsQixFQUE0QjJJLFdBQTVCLENBQXdDckosR0FBRyxDQUFDdUksUUFBNUMsQ0FEUSxHQUVSdEksT0FBTyxDQUFDUyxTQUFSLENBQWtCVixHQUFHLENBQUN1SSxRQUF0QixDQUZKLENBM0hzQyxDQStIdEM7O0FBQ0EsT0FBS3hILEdBQUwsR0FBV3FJLEdBQUcsQ0FBQ3RKLE9BQUosQ0FBWThDLE9BQVosQ0FBWDtBQWhJc0MsTUFpSTlCN0IsR0FqSThCLEdBaUl0QixJQWpJc0IsQ0FpSTlCQSxHQWpJOEIsRUFtSXRDOztBQUNBQSxFQUFBQSxHQUFHLENBQUN1SSxVQUFKLENBQWUsSUFBZjs7QUFFQSxNQUFJMUcsT0FBTyxDQUFDN0MsTUFBUixLQUFtQixNQUF2QixFQUErQjtBQUM3QmdCLElBQUFBLEdBQUcsQ0FBQ3dJLFNBQUosQ0FBYyxpQkFBZCxFQUFpQyxlQUFqQztBQUNEOztBQUVELE9BQUtoQixRQUFMLEdBQWdCdkksR0FBRyxDQUFDdUksUUFBcEI7QUFDQSxPQUFLMUMsSUFBTCxHQUFZN0YsR0FBRyxDQUFDNkYsSUFBaEIsQ0EzSXNDLENBNkl0Qzs7QUFDQTlFLEVBQUFBLEdBQUcsQ0FBQ2tCLElBQUosQ0FBUyxPQUFULEVBQWtCLFlBQU07QUFDdEIsSUFBQSxNQUFJLENBQUNvRCxJQUFMLENBQVUsT0FBVjtBQUNELEdBRkQ7QUFJQXRFLEVBQUFBLEdBQUcsQ0FBQ3FDLEVBQUosQ0FBTyxPQUFQLEVBQWdCLFVBQUNDLEdBQUQsRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFJLE1BQUksQ0FBQzJCLFFBQVQsRUFBbUIsT0FKSSxDQUt2QjtBQUNBOztBQUNBLFFBQUksTUFBSSxDQUFDMkMsUUFBTCxLQUFrQkQsT0FBdEIsRUFBK0IsT0FQUixDQVF2QjtBQUNBOztBQUNBLFFBQUksTUFBSSxDQUFDOEIsUUFBVCxFQUFtQjs7QUFDbkIsSUFBQSxNQUFJLENBQUNqRyxRQUFMLENBQWNGLEdBQWQ7QUFDRCxHQVpELEVBbEpzQyxDQWdLdEM7O0FBQ0EsTUFBSXJELEdBQUcsQ0FBQ2lHLElBQVIsRUFBYztBQUNaLFFBQU1BLElBQUksR0FBR2pHLEdBQUcsQ0FBQ2lHLElBQUosQ0FBU3VDLEtBQVQsQ0FBZSxHQUFmLENBQWI7QUFDQSxTQUFLdkMsSUFBTCxDQUFVQSxJQUFJLENBQUMsQ0FBRCxDQUFkLEVBQW1CQSxJQUFJLENBQUMsQ0FBRCxDQUF2QjtBQUNEOztBQUVELE1BQUksS0FBS3dELFFBQUwsSUFBaUIsS0FBS0MsUUFBMUIsRUFBb0M7QUFDbEMsU0FBS3pELElBQUwsQ0FBVSxLQUFLd0QsUUFBZixFQUF5QixLQUFLQyxRQUE5QjtBQUNEOztBQUVELE9BQUssSUFBTTdDLEdBQVgsSUFBa0IsS0FBSzVGLE1BQXZCLEVBQStCO0FBQzdCLFFBQUlnRCxNQUFNLENBQUM1QixTQUFQLENBQWlCc0gsY0FBakIsQ0FBZ0N6SSxJQUFoQyxDQUFxQyxLQUFLRCxNQUExQyxFQUFrRDRGLEdBQWxELENBQUosRUFDRTlGLEdBQUcsQ0FBQ3dJLFNBQUosQ0FBYzFDLEdBQWQsRUFBbUIsS0FBSzVGLE1BQUwsQ0FBWTRGLEdBQVosQ0FBbkI7QUFDSCxHQTdLcUMsQ0ErS3RDOzs7QUFDQSxNQUFJLEtBQUtqRixPQUFULEVBQWtCO0FBQ2hCLFFBQUlxQyxNQUFNLENBQUM1QixTQUFQLENBQWlCc0gsY0FBakIsQ0FBZ0N6SSxJQUFoQyxDQUFxQyxLQUFLRixPQUExQyxFQUFtRCxRQUFuRCxDQUFKLEVBQWtFO0FBQ2hFO0FBQ0EsVUFBTTRJLE1BQU0sR0FBRyxJQUFJekssU0FBUyxDQUFDQSxTQUFkLEVBQWY7QUFDQXlLLE1BQUFBLE1BQU0sQ0FBQ0MsVUFBUCxDQUFrQixLQUFLN0ksT0FBTCxDQUFhOEksTUFBYixDQUFvQnRCLEtBQXBCLENBQTBCLEdBQTFCLENBQWxCO0FBQ0FvQixNQUFBQSxNQUFNLENBQUNDLFVBQVAsQ0FBa0IsS0FBS2pJLE9BQUwsQ0FBYTRHLEtBQWIsQ0FBbUIsR0FBbkIsQ0FBbEI7QUFDQXpILE1BQUFBLEdBQUcsQ0FBQ3dJLFNBQUosQ0FDRSxRQURGLEVBRUVLLE1BQU0sQ0FBQ0csVUFBUCxDQUFrQjVLLFNBQVMsQ0FBQzZLLGdCQUFWLENBQTJCQyxHQUE3QyxFQUFrREMsYUFBbEQsRUFGRjtBQUlELEtBVEQsTUFTTztBQUNMbkosTUFBQUEsR0FBRyxDQUFDd0ksU0FBSixDQUFjLFFBQWQsRUFBd0IsS0FBSzNILE9BQTdCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPYixHQUFQO0FBQ0QsQ0FoTUQ7QUFrTUE7Ozs7Ozs7Ozs7QUFTQWIsT0FBTyxDQUFDbUMsU0FBUixDQUFrQmtCLFFBQWxCLEdBQTZCLFVBQVVGLEdBQVYsRUFBZXFCLEdBQWYsRUFBb0I7QUFDL0MsTUFBSSxLQUFLeUYsWUFBTCxDQUFrQjlHLEdBQWxCLEVBQXVCcUIsR0FBdkIsQ0FBSixFQUFpQztBQUMvQixXQUFPLEtBQUswRixNQUFMLEVBQVA7QUFDRCxHQUg4QyxDQUsvQzs7O0FBQ0EsTUFBTUMsRUFBRSxHQUFHLEtBQUtyRSxTQUFMLElBQWtCeEYsSUFBN0I7QUFDQSxPQUFLMEIsWUFBTDtBQUNBLE1BQUksS0FBS29CLE1BQVQsRUFBaUIsT0FBT2dILE9BQU8sQ0FBQ0MsSUFBUixDQUFhLGlDQUFiLENBQVA7QUFDakIsT0FBS2pILE1BQUwsR0FBYyxJQUFkOztBQUVBLE1BQUksQ0FBQ0QsR0FBTCxFQUFVO0FBQ1IsUUFBSTtBQUNGLFVBQUksQ0FBQyxLQUFLbUgsYUFBTCxDQUFtQjlGLEdBQW5CLENBQUwsRUFBOEI7QUFDNUIsWUFBSStGLEdBQUcsR0FBRyw0QkFBVjs7QUFDQSxZQUFJL0YsR0FBSixFQUFTO0FBQ1ArRixVQUFBQSxHQUFHLEdBQUdoTSxJQUFJLENBQUNpTSxZQUFMLENBQWtCaEcsR0FBRyxDQUFDaUcsTUFBdEIsS0FBaUNGLEdBQXZDO0FBQ0Q7O0FBRURwSCxRQUFBQSxHQUFHLEdBQUcsSUFBSWIsS0FBSixDQUFVaUksR0FBVixDQUFOO0FBQ0FwSCxRQUFBQSxHQUFHLENBQUNzSCxNQUFKLEdBQWFqRyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ2lHLE1BQVAsR0FBZ0JwSSxTQUFoQztBQUNEO0FBQ0YsS0FWRCxDQVVFLE9BQU9xSSxJQUFQLEVBQWE7QUFDYnZILE1BQUFBLEdBQUcsR0FBR3VILElBQU47QUFDRDtBQUNGLEdBekI4QyxDQTJCL0M7QUFDQTs7O0FBQ0EsTUFBSSxDQUFDdkgsR0FBTCxFQUFVO0FBQ1IsV0FBT2dILEVBQUUsQ0FBQyxJQUFELEVBQU8zRixHQUFQLENBQVQ7QUFDRDs7QUFFRHJCLEVBQUFBLEdBQUcsQ0FBQ21HLFFBQUosR0FBZTlFLEdBQWY7QUFDQSxNQUFJLEtBQUttRyxXQUFULEVBQXNCeEgsR0FBRyxDQUFDcUUsT0FBSixHQUFjLEtBQUtDLFFBQUwsR0FBZ0IsQ0FBOUIsQ0FsQ3lCLENBb0MvQztBQUNBOztBQUNBLE1BQUl0RSxHQUFHLElBQUksS0FBS3lILFNBQUwsQ0FBZSxPQUFmLEVBQXdCekssTUFBeEIsR0FBaUMsQ0FBNUMsRUFBK0M7QUFDN0MsU0FBS2dGLElBQUwsQ0FBVSxPQUFWLEVBQW1CaEMsR0FBbkI7QUFDRDs7QUFFRGdILEVBQUFBLEVBQUUsQ0FBQ2hILEdBQUQsRUFBTXFCLEdBQU4sQ0FBRjtBQUNELENBM0NEO0FBNkNBOzs7Ozs7Ozs7QUFPQXhFLE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0IwSSxPQUFsQixHQUE0QixVQUFVQyxHQUFWLEVBQWU7QUFDekMsU0FDRTFFLE1BQU0sQ0FBQ1UsUUFBUCxDQUFnQmdFLEdBQWhCLEtBQXdCQSxHQUFHLFlBQVl6TSxNQUF2QyxJQUFpRHlNLEdBQUcsWUFBWWhNLFFBRGxFO0FBR0QsQ0FKRDtBQU1BOzs7Ozs7Ozs7O0FBU0FrQixPQUFPLENBQUNtQyxTQUFSLENBQWtCMEMsYUFBbEIsR0FBa0MsVUFBVWtHLElBQVYsRUFBZ0JDLEtBQWhCLEVBQXVCO0FBQ3ZELE1BQU0xQixRQUFRLEdBQUcsSUFBSS9KLFFBQUosQ0FBYSxJQUFiLENBQWpCO0FBQ0EsT0FBSytKLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0FBLEVBQUFBLFFBQVEsQ0FBQzdILFNBQVQsR0FBcUIsS0FBS0ksYUFBMUI7O0FBQ0EsTUFBSVEsU0FBUyxLQUFLMEksSUFBbEIsRUFBd0I7QUFDdEJ6QixJQUFBQSxRQUFRLENBQUN5QixJQUFULEdBQWdCQSxJQUFoQjtBQUNEOztBQUVEekIsRUFBQUEsUUFBUSxDQUFDMEIsS0FBVCxHQUFpQkEsS0FBakI7O0FBQ0EsTUFBSSxLQUFLbkYsVUFBVCxFQUFxQjtBQUNuQnlELElBQUFBLFFBQVEsQ0FBQ2xGLElBQVQsR0FBZ0IsWUFBWTtBQUMxQixZQUFNLElBQUk5QixLQUFKLENBQ0osaUVBREksQ0FBTjtBQUdELEtBSkQ7QUFLRDs7QUFFRCxPQUFLNkMsSUFBTCxDQUFVLFVBQVYsRUFBc0JtRSxRQUF0QjtBQUNBLFNBQU9BLFFBQVA7QUFDRCxDQW5CRDs7QUFxQkF0SixPQUFPLENBQUNtQyxTQUFSLENBQWtCbEMsR0FBbEIsR0FBd0IsVUFBVWtLLEVBQVYsRUFBYztBQUNwQyxPQUFLdkssT0FBTDtBQUNBWixFQUFBQSxLQUFLLENBQUMsT0FBRCxFQUFVLEtBQUthLE1BQWYsRUFBdUIsS0FBS0MsR0FBNUIsQ0FBTDs7QUFFQSxNQUFJLEtBQUsrRixVQUFULEVBQXFCO0FBQ25CLFVBQU0sSUFBSXZELEtBQUosQ0FDSiw4REFESSxDQUFOO0FBR0Q7O0FBRUQsT0FBS3VELFVBQUwsR0FBa0IsSUFBbEIsQ0FWb0MsQ0FZcEM7O0FBQ0EsT0FBS0MsU0FBTCxHQUFpQnFFLEVBQUUsSUFBSTdKLElBQXZCOztBQUVBLE9BQUsySyxJQUFMO0FBQ0QsQ0FoQkQ7O0FBa0JBakwsT0FBTyxDQUFDbUMsU0FBUixDQUFrQjhJLElBQWxCLEdBQXlCLFlBQVk7QUFBQTs7QUFDbkMsTUFBSSxLQUFLbkcsUUFBVCxFQUNFLE9BQU8sS0FBS3pCLFFBQUwsQ0FDTCxJQUFJZixLQUFKLENBQVUsNERBQVYsQ0FESyxDQUFQO0FBSUYsTUFBSTRCLElBQUksR0FBRyxLQUFLdkIsS0FBaEI7QUFObUMsTUFPM0I5QixHQVAyQixHQU9uQixJQVBtQixDQU8zQkEsR0FQMkI7QUFBQSxNQVEzQmhCLE1BUjJCLEdBUWhCLElBUmdCLENBUTNCQSxNQVIyQjs7QUFVbkMsT0FBS3FMLFlBQUwsR0FWbUMsQ0FZbkM7OztBQUNBLE1BQUlyTCxNQUFNLEtBQUssTUFBWCxJQUFxQixDQUFDZ0IsR0FBRyxDQUFDc0ssV0FBOUIsRUFBMkM7QUFDekM7QUFDQSxRQUFJLE9BQU9qSCxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQUlrSCxXQUFXLEdBQUd2SyxHQUFHLENBQUN3SyxTQUFKLENBQWMsY0FBZCxDQUFsQixDQUQ0QixDQUU1Qjs7QUFDQSxVQUFJRCxXQUFKLEVBQWlCQSxXQUFXLEdBQUdBLFdBQVcsQ0FBQzlDLEtBQVosQ0FBa0IsR0FBbEIsRUFBdUIsQ0FBdkIsQ0FBZDtBQUNqQixVQUFJN0gsU0FBUyxHQUFHLEtBQUs2SyxXQUFMLElBQW9CdkwsT0FBTyxDQUFDVSxTQUFSLENBQWtCMkssV0FBbEIsQ0FBcEM7O0FBQ0EsVUFBSSxDQUFDM0ssU0FBRCxJQUFjOEssTUFBTSxDQUFDSCxXQUFELENBQXhCLEVBQXVDO0FBQ3JDM0ssUUFBQUEsU0FBUyxHQUFHVixPQUFPLENBQUNVLFNBQVIsQ0FBa0Isa0JBQWxCLENBQVo7QUFDRDs7QUFFRCxVQUFJQSxTQUFKLEVBQWV5RCxJQUFJLEdBQUd6RCxTQUFTLENBQUN5RCxJQUFELENBQWhCO0FBQ2hCLEtBWndDLENBY3pDOzs7QUFDQSxRQUFJQSxJQUFJLElBQUksQ0FBQ3JELEdBQUcsQ0FBQ3dLLFNBQUosQ0FBYyxnQkFBZCxDQUFiLEVBQThDO0FBQzVDeEssTUFBQUEsR0FBRyxDQUFDd0ksU0FBSixDQUNFLGdCQURGLEVBRUVqRCxNQUFNLENBQUNVLFFBQVAsQ0FBZ0I1QyxJQUFoQixJQUF3QkEsSUFBSSxDQUFDL0QsTUFBN0IsR0FBc0NpRyxNQUFNLENBQUNvRixVQUFQLENBQWtCdEgsSUFBbEIsQ0FGeEM7QUFJRDtBQUNGLEdBbENrQyxDQW9DbkM7QUFDQTs7O0FBQ0FyRCxFQUFBQSxHQUFHLENBQUNrQixJQUFKLENBQVMsVUFBVCxFQUFxQixVQUFDeUMsR0FBRCxFQUFTO0FBQzVCeEYsSUFBQUEsS0FBSyxDQUFDLGFBQUQsRUFBZ0IsTUFBSSxDQUFDYSxNQUFyQixFQUE2QixNQUFJLENBQUNDLEdBQWxDLEVBQXVDMEUsR0FBRyxDQUFDRSxVQUEzQyxDQUFMOztBQUVBLFFBQUksTUFBSSxDQUFDK0cscUJBQVQsRUFBZ0M7QUFDOUJ6SixNQUFBQSxZQUFZLENBQUMsTUFBSSxDQUFDeUoscUJBQU4sQ0FBWjtBQUNEOztBQUVELFFBQUksTUFBSSxDQUFDbkgsS0FBVCxFQUFnQjtBQUNkO0FBQ0Q7O0FBRUQsUUFBTW9ILEdBQUcsR0FBRyxNQUFJLENBQUMvRyxhQUFqQjtBQUNBLFFBQU0vRixJQUFJLEdBQUdRLEtBQUssQ0FBQ21FLElBQU4sQ0FBV2lCLEdBQUcsQ0FBQ2EsT0FBSixDQUFZLGNBQVosS0FBK0IsRUFBMUMsS0FBaUQsWUFBOUQ7QUFDQSxRQUFJOUIsSUFBSSxHQUFHM0UsSUFBSSxDQUFDMEosS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBWDtBQUNBLFFBQUkvRSxJQUFKLEVBQVVBLElBQUksR0FBR0EsSUFBSSxDQUFDb0ksV0FBTCxHQUFtQkMsSUFBbkIsRUFBUDtBQUNWLFFBQU1DLFNBQVMsR0FBR3RJLElBQUksS0FBSyxXQUEzQjtBQUNBLFFBQU11SSxRQUFRLEdBQUdySCxVQUFVLENBQUNELEdBQUcsQ0FBQ0UsVUFBTCxDQUEzQjtBQUNBLFFBQU1xSCxZQUFZLEdBQUcsTUFBSSxDQUFDQyxhQUExQjtBQUVBLElBQUEsTUFBSSxDQUFDeEgsR0FBTCxHQUFXQSxHQUFYLENBbkI0QixDQXFCNUI7O0FBQ0EsUUFBSXNILFFBQVEsSUFBSSxNQUFJLENBQUN0SyxVQUFMLE9BQXNCa0ssR0FBdEMsRUFBMkM7QUFDekMsYUFBTyxNQUFJLENBQUM5RyxTQUFMLENBQWVKLEdBQWYsQ0FBUDtBQUNEOztBQUVELFFBQUksTUFBSSxDQUFDM0UsTUFBTCxLQUFnQixNQUFwQixFQUE0QjtBQUMxQixNQUFBLE1BQUksQ0FBQ3NGLElBQUwsQ0FBVSxLQUFWOztBQUNBLE1BQUEsTUFBSSxDQUFDOUIsUUFBTCxDQUFjLElBQWQsRUFBb0IsTUFBSSxDQUFDd0IsYUFBTCxFQUFwQjs7QUFDQTtBQUNELEtBOUIyQixDQWdDNUI7OztBQUNBLFFBQUksTUFBSSxDQUFDRSxZQUFMLENBQWtCUCxHQUFsQixDQUFKLEVBQTRCO0FBQzFCbEYsTUFBQUEsS0FBSyxDQUFDdUIsR0FBRCxFQUFNMkQsR0FBTixDQUFMO0FBQ0Q7O0FBRUQsUUFBSTdELE1BQU0sR0FBRyxNQUFJLENBQUN5RSxPQUFsQjs7QUFDQSxRQUFJekUsTUFBTSxLQUFLMEIsU0FBWCxJQUF3QnpELElBQUksSUFBSW1CLE9BQU8sQ0FBQ1ksTUFBNUMsRUFBb0Q7QUFDbERBLE1BQUFBLE1BQU0sR0FBR08sT0FBTyxDQUFDbkIsT0FBTyxDQUFDWSxNQUFSLENBQWUvQixJQUFmLENBQUQsQ0FBaEI7QUFDRDs7QUFFRCxRQUFJcU4sTUFBTSxHQUFHLE1BQUksQ0FBQ0MsT0FBbEI7O0FBQ0EsUUFBSTdKLFNBQVMsS0FBSzFCLE1BQWxCLEVBQTBCO0FBQ3hCLFVBQUlzTCxNQUFKLEVBQVk7QUFDVjdCLFFBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUNFLDBMQURGO0FBR0ExSixRQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSSxDQUFDc0wsTUFBTCxFQUFhO0FBQ1gsVUFBSUYsWUFBSixFQUFrQjtBQUNoQkUsUUFBQUEsTUFBTSxHQUFHbE0sT0FBTyxDQUFDN0IsS0FBUixDQUFjaU8sS0FBdkIsQ0FEZ0IsQ0FDYzs7QUFDOUJ4TCxRQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNELE9BSEQsTUFHTyxJQUFJa0wsU0FBSixFQUFlO0FBQ3BCLFlBQU1PLElBQUksR0FBRyxJQUFJck4sVUFBVSxDQUFDc04sWUFBZixFQUFiO0FBQ0FKLFFBQUFBLE1BQU0sR0FBR0csSUFBSSxDQUFDbE8sS0FBTCxDQUFXK0QsSUFBWCxDQUFnQm1LLElBQWhCLENBQVQ7QUFDQXpMLFFBQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0QsT0FKTSxNQUlBLElBQUkyTCxjQUFjLENBQUMxTixJQUFELENBQWxCLEVBQTBCO0FBQy9CcU4sUUFBQUEsTUFBTSxHQUFHbE0sT0FBTyxDQUFDN0IsS0FBUixDQUFjaU8sS0FBdkI7QUFDQXhMLFFBQUFBLE1BQU0sR0FBRyxJQUFULENBRitCLENBRWhCO0FBQ2hCLE9BSE0sTUFHQSxJQUFJWixPQUFPLENBQUM3QixLQUFSLENBQWNVLElBQWQsQ0FBSixFQUF5QjtBQUM5QnFOLFFBQUFBLE1BQU0sR0FBR2xNLE9BQU8sQ0FBQzdCLEtBQVIsQ0FBY1UsSUFBZCxDQUFUO0FBQ0QsT0FGTSxNQUVBLElBQUkyRSxJQUFJLEtBQUssTUFBYixFQUFxQjtBQUMxQjBJLFFBQUFBLE1BQU0sR0FBR2xNLE9BQU8sQ0FBQzdCLEtBQVIsQ0FBY3FPLElBQXZCO0FBQ0E1TCxRQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxLQUFwQixDQUYwQixDQUkxQjtBQUNELE9BTE0sTUFLQSxJQUFJNEssTUFBTSxDQUFDM00sSUFBRCxDQUFWLEVBQWtCO0FBQ3ZCcU4sUUFBQUEsTUFBTSxHQUFHbE0sT0FBTyxDQUFDN0IsS0FBUixDQUFjLGtCQUFkLENBQVQ7QUFDQXlDLFFBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLEtBQXBCO0FBQ0QsT0FITSxNQUdBLElBQUlBLE1BQUosRUFBWTtBQUNqQnNMLFFBQUFBLE1BQU0sR0FBR2xNLE9BQU8sQ0FBQzdCLEtBQVIsQ0FBY3FPLElBQXZCO0FBQ0QsT0FGTSxNQUVBLElBQUlsSyxTQUFTLEtBQUsxQixNQUFsQixFQUEwQjtBQUMvQnNMLFFBQUFBLE1BQU0sR0FBR2xNLE9BQU8sQ0FBQzdCLEtBQVIsQ0FBY2lPLEtBQXZCLENBRCtCLENBQ0Q7O0FBQzlCeEwsUUFBQUEsTUFBTSxHQUFHLElBQVQ7QUFDRDtBQUNGLEtBL0UyQixDQWlGNUI7OztBQUNBLFFBQUswQixTQUFTLEtBQUsxQixNQUFkLElBQXdCNkwsTUFBTSxDQUFDNU4sSUFBRCxDQUEvQixJQUEwQzJNLE1BQU0sQ0FBQzNNLElBQUQsQ0FBcEQsRUFBNEQ7QUFDMUQrQixNQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNEOztBQUVELElBQUEsTUFBSSxDQUFDOEwsWUFBTCxHQUFvQjlMLE1BQXBCO0FBQ0EsUUFBSStMLGdCQUFnQixHQUFHLEtBQXZCOztBQUNBLFFBQUkvTCxNQUFKLEVBQVk7QUFDVjtBQUNBLFVBQUlnTSxpQkFBaUIsR0FBRyxNQUFJLENBQUNDLGdCQUFMLElBQXlCLFNBQWpEO0FBQ0FwSSxNQUFBQSxHQUFHLENBQUN0QixFQUFKLENBQU8sTUFBUCxFQUFlLFVBQUMySixHQUFELEVBQVM7QUFDdEJGLFFBQUFBLGlCQUFpQixJQUFJRSxHQUFHLENBQUNyQixVQUFKLElBQWtCcUIsR0FBRyxDQUFDMU0sTUFBM0M7O0FBQ0EsWUFBSXdNLGlCQUFpQixHQUFHLENBQXhCLEVBQTJCO0FBQ3pCO0FBQ0EsY0FBTXhKLEdBQUcsR0FBRyxJQUFJYixLQUFKLENBQVUsK0JBQVYsQ0FBWjtBQUNBYSxVQUFBQSxHQUFHLENBQUMrQixJQUFKLEdBQVcsV0FBWCxDQUh5QixDQUl6QjtBQUNBOztBQUNBd0gsVUFBQUEsZ0JBQWdCLEdBQUcsS0FBbkIsQ0FOeUIsQ0FPekI7O0FBQ0FsSSxVQUFBQSxHQUFHLENBQUNzSSxPQUFKLENBQVkzSixHQUFaO0FBQ0Q7QUFDRixPQVpEO0FBYUQ7O0FBRUQsUUFBSThJLE1BQUosRUFBWTtBQUNWLFVBQUk7QUFDRjtBQUNBO0FBQ0FTLFFBQUFBLGdCQUFnQixHQUFHL0wsTUFBbkI7QUFFQXNMLFFBQUFBLE1BQU0sQ0FBQ3pILEdBQUQsRUFBTSxVQUFDckIsR0FBRCxFQUFNMkgsR0FBTixFQUFXRSxLQUFYLEVBQXFCO0FBQy9CLGNBQUksTUFBSSxDQUFDK0IsUUFBVCxFQUFtQjtBQUNqQjtBQUNBO0FBQ0QsV0FKOEIsQ0FNL0I7QUFDQTs7O0FBQ0EsY0FBSTVKLEdBQUcsSUFBSSxDQUFDLE1BQUksQ0FBQzJCLFFBQWpCLEVBQTJCO0FBQ3pCLG1CQUFPLE1BQUksQ0FBQ3pCLFFBQUwsQ0FBY0YsR0FBZCxDQUFQO0FBQ0Q7O0FBRUQsY0FBSXVKLGdCQUFKLEVBQXNCO0FBQ3BCLFlBQUEsTUFBSSxDQUFDdkgsSUFBTCxDQUFVLEtBQVY7O0FBQ0EsWUFBQSxNQUFJLENBQUM5QixRQUFMLENBQWMsSUFBZCxFQUFvQixNQUFJLENBQUN3QixhQUFMLENBQW1CaUcsR0FBbkIsRUFBd0JFLEtBQXhCLENBQXBCO0FBQ0Q7QUFDRixTQWhCSyxDQUFOO0FBaUJELE9BdEJELENBc0JFLE9BQU83SCxHQUFQLEVBQVk7QUFDWixRQUFBLE1BQUksQ0FBQ0UsUUFBTCxDQUFjRixHQUFkOztBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxJQUFBLE1BQUksQ0FBQ3FCLEdBQUwsR0FBV0EsR0FBWCxDQXZJNEIsQ0F5STVCOztBQUNBLFFBQUksQ0FBQzdELE1BQUwsRUFBYTtBQUNYM0IsTUFBQUEsS0FBSyxDQUFDLGtCQUFELEVBQXFCLE1BQUksQ0FBQ2EsTUFBMUIsRUFBa0MsTUFBSSxDQUFDQyxHQUF2QyxDQUFMOztBQUNBLE1BQUEsTUFBSSxDQUFDdUQsUUFBTCxDQUFjLElBQWQsRUFBb0IsTUFBSSxDQUFDd0IsYUFBTCxFQUFwQjs7QUFDQSxVQUFJZ0gsU0FBSixFQUFlLE9BSEosQ0FHWTs7QUFDdkJySCxNQUFBQSxHQUFHLENBQUN6QyxJQUFKLENBQVMsS0FBVCxFQUFnQixZQUFNO0FBQ3BCL0MsUUFBQUEsS0FBSyxDQUFDLFdBQUQsRUFBYyxNQUFJLENBQUNhLE1BQW5CLEVBQTJCLE1BQUksQ0FBQ0MsR0FBaEMsQ0FBTDs7QUFDQSxRQUFBLE1BQUksQ0FBQ3FGLElBQUwsQ0FBVSxLQUFWO0FBQ0QsT0FIRDtBQUlBO0FBQ0QsS0FuSjJCLENBcUo1Qjs7O0FBQ0FYLElBQUFBLEdBQUcsQ0FBQ3pDLElBQUosQ0FBUyxPQUFULEVBQWtCLFVBQUNvQixHQUFELEVBQVM7QUFDekJ1SixNQUFBQSxnQkFBZ0IsR0FBRyxLQUFuQjs7QUFDQSxNQUFBLE1BQUksQ0FBQ3JKLFFBQUwsQ0FBY0YsR0FBZCxFQUFtQixJQUFuQjtBQUNELEtBSEQ7QUFJQSxRQUFJLENBQUN1SixnQkFBTCxFQUNFbEksR0FBRyxDQUFDekMsSUFBSixDQUFTLEtBQVQsRUFBZ0IsWUFBTTtBQUNwQi9DLE1BQUFBLEtBQUssQ0FBQyxXQUFELEVBQWMsTUFBSSxDQUFDYSxNQUFuQixFQUEyQixNQUFJLENBQUNDLEdBQWhDLENBQUwsQ0FEb0IsQ0FFcEI7O0FBQ0EsTUFBQSxNQUFJLENBQUNxRixJQUFMLENBQVUsS0FBVjs7QUFDQSxNQUFBLE1BQUksQ0FBQzlCLFFBQUwsQ0FBYyxJQUFkLEVBQW9CLE1BQUksQ0FBQ3dCLGFBQUwsRUFBcEI7QUFDRCxLQUxEO0FBTUgsR0FqS0Q7QUFtS0EsT0FBS00sSUFBTCxDQUFVLFNBQVYsRUFBcUIsSUFBckI7O0FBRUEsTUFBTTZILGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsR0FBTTtBQUMvQixRQUFNQyxnQkFBZ0IsR0FBRyxJQUF6QjtBQUNBLFFBQU1DLEtBQUssR0FBR3JNLEdBQUcsQ0FBQ3dLLFNBQUosQ0FBYyxnQkFBZCxDQUFkO0FBQ0EsUUFBSThCLE1BQU0sR0FBRyxDQUFiO0FBRUEsUUFBTUMsUUFBUSxHQUFHLElBQUkvTyxNQUFNLENBQUNnUCxTQUFYLEVBQWpCOztBQUNBRCxJQUFBQSxRQUFRLENBQUNFLFVBQVQsR0FBc0IsVUFBQ0MsS0FBRCxFQUFRcEosUUFBUixFQUFrQnFKLEVBQWxCLEVBQXlCO0FBQzdDTCxNQUFBQSxNQUFNLElBQUlJLEtBQUssQ0FBQ3BOLE1BQWhCOztBQUNBLE1BQUEsTUFBSSxDQUFDZ0YsSUFBTCxDQUFVLFVBQVYsRUFBc0I7QUFDcEJzSSxRQUFBQSxTQUFTLEVBQUUsUUFEUztBQUVwQlIsUUFBQUEsZ0JBQWdCLEVBQWhCQSxnQkFGb0I7QUFHcEJFLFFBQUFBLE1BQU0sRUFBTkEsTUFIb0I7QUFJcEJELFFBQUFBLEtBQUssRUFBTEE7QUFKb0IsT0FBdEI7O0FBTUFNLE1BQUFBLEVBQUUsQ0FBQyxJQUFELEVBQU9ELEtBQVAsQ0FBRjtBQUNELEtBVEQ7O0FBV0EsV0FBT0gsUUFBUDtBQUNELEdBbEJEOztBQW9CQSxNQUFNTSxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQUMvTSxNQUFELEVBQVk7QUFDakMsUUFBTWdOLFNBQVMsR0FBRyxLQUFLLElBQXZCLENBRGlDLENBQ0o7O0FBQzdCLFFBQU1DLFFBQVEsR0FBRyxJQUFJdlAsTUFBTSxDQUFDd1AsUUFBWCxFQUFqQjtBQUNBLFFBQU1DLFdBQVcsR0FBR25OLE1BQU0sQ0FBQ1IsTUFBM0I7QUFDQSxRQUFNNE4sU0FBUyxHQUFHRCxXQUFXLEdBQUdILFNBQWhDO0FBQ0EsUUFBTUssTUFBTSxHQUFHRixXQUFXLEdBQUdDLFNBQTdCOztBQUVBLFNBQUssSUFBSS9GLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnRyxNQUFwQixFQUE0QmhHLENBQUMsSUFBSTJGLFNBQWpDLEVBQTRDO0FBQzFDLFVBQU1KLEtBQUssR0FBRzVNLE1BQU0sQ0FBQ21ILEtBQVAsQ0FBYUUsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMkYsU0FBcEIsQ0FBZDtBQUNBQyxNQUFBQSxRQUFRLENBQUM5SixJQUFULENBQWN5SixLQUFkO0FBQ0Q7O0FBRUQsUUFBSVEsU0FBUyxHQUFHLENBQWhCLEVBQW1CO0FBQ2pCLFVBQU1FLGVBQWUsR0FBR3ROLE1BQU0sQ0FBQ21ILEtBQVAsQ0FBYSxDQUFDaUcsU0FBZCxDQUF4QjtBQUNBSCxNQUFBQSxRQUFRLENBQUM5SixJQUFULENBQWNtSyxlQUFkO0FBQ0Q7O0FBRURMLElBQUFBLFFBQVEsQ0FBQzlKLElBQVQsQ0FBYyxJQUFkLEVBakJpQyxDQWlCWjs7QUFFckIsV0FBTzhKLFFBQVA7QUFDRCxHQXBCRCxDQS9ObUMsQ0FxUG5DOzs7QUFDQSxNQUFNTSxRQUFRLEdBQUcsS0FBSzVNLFNBQXRCOztBQUNBLE1BQUk0TSxRQUFKLEVBQWM7QUFDWjtBQUNBLFFBQU03SSxPQUFPLEdBQUc2SSxRQUFRLENBQUMxSSxVQUFULEVBQWhCOztBQUNBLFNBQUssSUFBTXdDLENBQVgsSUFBZ0IzQyxPQUFoQixFQUF5QjtBQUN2QixVQUFJdEIsTUFBTSxDQUFDNUIsU0FBUCxDQUFpQnNILGNBQWpCLENBQWdDekksSUFBaEMsQ0FBcUNxRSxPQUFyQyxFQUE4QzJDLENBQTlDLENBQUosRUFBc0Q7QUFDcERoSixRQUFBQSxLQUFLLENBQUMsbUNBQUQsRUFBc0NnSixDQUF0QyxFQUF5QzNDLE9BQU8sQ0FBQzJDLENBQUQsQ0FBaEQsQ0FBTDtBQUNBbkgsUUFBQUEsR0FBRyxDQUFDd0ksU0FBSixDQUFjckIsQ0FBZCxFQUFpQjNDLE9BQU8sQ0FBQzJDLENBQUQsQ0FBeEI7QUFDRDtBQUNGLEtBUlcsQ0FVWjs7O0FBQ0FrRyxJQUFBQSxRQUFRLENBQUNDLFNBQVQsQ0FBbUIsVUFBQ2hMLEdBQUQsRUFBTWhELE1BQU4sRUFBaUI7QUFDbEM7QUFDQSxVQUFJZ0QsR0FBSixFQUFTbkUsS0FBSyxDQUFDLDhCQUFELEVBQWlDbUUsR0FBakMsRUFBc0NoRCxNQUF0QyxDQUFMO0FBRVRuQixNQUFBQSxLQUFLLENBQUMsaUNBQUQsRUFBb0NtQixNQUFwQyxDQUFMOztBQUNBLFVBQUksT0FBT0EsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QlUsUUFBQUEsR0FBRyxDQUFDd0ksU0FBSixDQUFjLGdCQUFkLEVBQWdDbEosTUFBaEM7QUFDRDs7QUFFRCtOLE1BQUFBLFFBQVEsQ0FBQzlKLElBQVQsQ0FBYzRJLGtCQUFrQixFQUFoQyxFQUFvQzVJLElBQXBDLENBQXlDdkQsR0FBekM7QUFDRCxLQVZEO0FBV0QsR0F0QkQsTUFzQk8sSUFBSXVGLE1BQU0sQ0FBQ1UsUUFBUCxDQUFnQjVDLElBQWhCLENBQUosRUFBMkI7QUFDaEN3SixJQUFBQSxjQUFjLENBQUN4SixJQUFELENBQWQsQ0FBcUJFLElBQXJCLENBQTBCNEksa0JBQWtCLEVBQTVDLEVBQWdENUksSUFBaEQsQ0FBcUR2RCxHQUFyRDtBQUNELEdBRk0sTUFFQTtBQUNMQSxJQUFBQSxHQUFHLENBQUNaLEdBQUosQ0FBUWlFLElBQVI7QUFDRDtBQUNGLENBbFJELEMsQ0FvUkE7OztBQUNBbEUsT0FBTyxDQUFDbUMsU0FBUixDQUFrQjRDLFlBQWxCLEdBQWlDLFVBQUNQLEdBQUQsRUFBUztBQUN4QyxNQUFJQSxHQUFHLENBQUNFLFVBQUosS0FBbUIsR0FBbkIsSUFBMEJGLEdBQUcsQ0FBQ0UsVUFBSixLQUFtQixHQUFqRCxFQUFzRDtBQUNwRDtBQUNBLFdBQU8sS0FBUDtBQUNELEdBSnVDLENBTXhDOzs7QUFDQSxNQUFJRixHQUFHLENBQUNhLE9BQUosQ0FBWSxnQkFBWixNQUFrQyxHQUF0QyxFQUEyQztBQUN6QztBQUNBLFdBQU8sS0FBUDtBQUNELEdBVnVDLENBWXhDOzs7QUFDQSxTQUFPLDJCQUEyQitDLElBQTNCLENBQWdDNUQsR0FBRyxDQUFDYSxPQUFKLENBQVksa0JBQVosQ0FBaEMsQ0FBUDtBQUNELENBZEQ7QUFnQkE7Ozs7Ozs7Ozs7Ozs7OztBQWFBckYsT0FBTyxDQUFDbUMsU0FBUixDQUFrQmlNLE9BQWxCLEdBQTRCLFVBQVVDLGVBQVYsRUFBMkI7QUFDckQsTUFBSSxPQUFPQSxlQUFQLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDLFNBQUs1RixnQkFBTCxHQUF3QjtBQUFFLFdBQUs0RjtBQUFQLEtBQXhCO0FBQ0QsR0FGRCxNQUVPLElBQUksUUFBT0EsZUFBUCxNQUEyQixRQUEvQixFQUF5QztBQUM5QyxTQUFLNUYsZ0JBQUwsR0FBd0I0RixlQUF4QjtBQUNELEdBRk0sTUFFQTtBQUNMLFNBQUs1RixnQkFBTCxHQUF3QnBHLFNBQXhCO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0FWRDs7QUFZQXJDLE9BQU8sQ0FBQ21DLFNBQVIsQ0FBa0JtTSxjQUFsQixHQUFtQyxVQUFVQyxNQUFWLEVBQWtCO0FBQ25ELE9BQUt0RixlQUFMLEdBQXVCc0YsTUFBTSxLQUFLbE0sU0FBWCxHQUF1QixJQUF2QixHQUE4QmtNLE1BQXJEO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FIRCxDLENBS0E7OztBQUNBLElBQUksQ0FBQzFQLE9BQU8sQ0FBQzRFLFFBQVIsQ0FBaUIsS0FBakIsQ0FBTCxFQUE4QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTVFLEVBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDaUosS0FBUixDQUFjLENBQWQsQ0FBVjtBQUNBakosRUFBQUEsT0FBTyxDQUFDaUYsSUFBUixDQUFhLEtBQWI7QUFDRDs7QUFFRGpGLE9BQU8sQ0FBQzJQLE9BQVIsQ0FBZ0IsVUFBQzNPLE1BQUQsRUFBWTtBQUMxQixNQUFNNE8sSUFBSSxHQUFHNU8sTUFBYjtBQUNBQSxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxLQUFYLEdBQW1CLFFBQW5CLEdBQThCQSxNQUF2QztBQUVBQSxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQzZPLFdBQVAsRUFBVDs7QUFDQTlPLEVBQUFBLE9BQU8sQ0FBQzZPLElBQUQsQ0FBUCxHQUFnQixVQUFDM08sR0FBRCxFQUFNb0UsSUFBTixFQUFZaUcsRUFBWixFQUFtQjtBQUNqQyxRQUFNdEosR0FBRyxHQUFHakIsT0FBTyxDQUFDQyxNQUFELEVBQVNDLEdBQVQsQ0FBbkI7O0FBQ0EsUUFBSSxPQUFPb0UsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmlHLE1BQUFBLEVBQUUsR0FBR2pHLElBQUw7QUFDQUEsTUFBQUEsSUFBSSxHQUFHLElBQVA7QUFDRDs7QUFFRCxRQUFJQSxJQUFKLEVBQVU7QUFDUixVQUFJckUsTUFBTSxLQUFLLEtBQVgsSUFBb0JBLE1BQU0sS0FBSyxNQUFuQyxFQUEyQztBQUN6Q2dCLFFBQUFBLEdBQUcsQ0FBQytDLEtBQUosQ0FBVU0sSUFBVjtBQUNELE9BRkQsTUFFTztBQUNMckQsUUFBQUEsR0FBRyxDQUFDOE4sSUFBSixDQUFTekssSUFBVDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSWlHLEVBQUosRUFBUXRKLEdBQUcsQ0FBQ1osR0FBSixDQUFRa0ssRUFBUjtBQUNSLFdBQU90SixHQUFQO0FBQ0QsR0FqQkQ7QUFrQkQsQ0F2QkQ7QUF5QkE7Ozs7Ozs7O0FBUUEsU0FBUzJMLE1BQVQsQ0FBZ0I1TixJQUFoQixFQUFzQjtBQUNwQixNQUFNZ1EsS0FBSyxHQUFHaFEsSUFBSSxDQUFDMEosS0FBTCxDQUFXLEdBQVgsQ0FBZDtBQUNBLE1BQUkvRSxJQUFJLEdBQUdxTCxLQUFLLENBQUMsQ0FBRCxDQUFoQjtBQUNBLE1BQUlyTCxJQUFKLEVBQVVBLElBQUksR0FBR0EsSUFBSSxDQUFDb0ksV0FBTCxHQUFtQkMsSUFBbkIsRUFBUDtBQUNWLE1BQUlpRCxPQUFPLEdBQUdELEtBQUssQ0FBQyxDQUFELENBQW5CO0FBQ0EsTUFBSUMsT0FBSixFQUFhQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2xELFdBQVIsR0FBc0JDLElBQXRCLEVBQVY7QUFFYixTQUFPckksSUFBSSxLQUFLLE1BQVQsSUFBbUJzTCxPQUFPLEtBQUssdUJBQXRDO0FBQ0Q7O0FBRUQsU0FBU3ZDLGNBQVQsQ0FBd0IxTixJQUF4QixFQUE4QjtBQUM1QixNQUFJMkUsSUFBSSxHQUFHM0UsSUFBSSxDQUFDMEosS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBWDtBQUNBLE1BQUkvRSxJQUFKLEVBQVVBLElBQUksR0FBR0EsSUFBSSxDQUFDb0ksV0FBTCxHQUFtQkMsSUFBbkIsRUFBUDtBQUVWLFNBQU9ySSxJQUFJLEtBQUssT0FBVCxJQUFvQkEsSUFBSSxLQUFLLE9BQXBDO0FBQ0Q7QUFFRDs7Ozs7Ozs7O0FBUUEsU0FBU2dJLE1BQVQsQ0FBZ0IzTSxJQUFoQixFQUFzQjtBQUNwQjtBQUNBO0FBQ0EsU0FBTyxzQkFBc0J3SixJQUF0QixDQUEyQnhKLElBQTNCLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7QUFRQSxTQUFTNkYsVUFBVCxDQUFvQlMsSUFBcEIsRUFBMEI7QUFDeEIsU0FBTyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixHQUFyQixFQUEwQixHQUExQixFQUErQnpCLFFBQS9CLENBQXdDeUIsSUFBeEMsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpXG5jb25zdCB7IHBhcnNlLCBmb3JtYXQsIHJlc29sdmUgfSA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBxcyA9IHJlcXVpcmUoJ3FzJyk7XG5jb25zdCBtaW1lID0gcmVxdWlyZSgnbWltZScpO1xubGV0IG1ldGhvZHMgPSByZXF1aXJlKCdtZXRob2RzJyk7XG5jb25zdCBGb3JtRGF0YSA9IHJlcXVpcmUoJ2Zvcm0tZGF0YScpO1xuY29uc3QgZm9ybWlkYWJsZSA9IHJlcXVpcmUoJ2Zvcm1pZGFibGUnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc3VwZXJhZ2VudCcpO1xuY29uc3QgQ29va2llSmFyID0gcmVxdWlyZSgnY29va2llamFyJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IHNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdmYXN0LXNhZmUtc3RyaW5naWZ5Jyk7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi4vcmVxdWVzdC1iYXNlJyk7XG5jb25zdCB7IHVuemlwIH0gPSByZXF1aXJlKCcuL3VuemlwJyk7XG5jb25zdCBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcblxubGV0IGh0dHAyO1xuXG5pZiAoc2VtdmVyLmd0ZShwcm9jZXNzLnZlcnNpb24sICd2MTAuMTAuMCcpKSBodHRwMiA9IHJlcXVpcmUoJy4vaHR0cDJ3cmFwcGVyJyk7XG5cbmZ1bmN0aW9uIHJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3Q7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0YC5cbiAqL1xuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEV4cG9zZSB0aGUgYWdlbnQgZnVuY3Rpb25cbiAqL1xuXG5leHBvcnRzLmFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIERlZmluZSBcImZvcm1cIiBtaW1lIHR5cGUuXG4gKi9cblxubWltZS5kZWZpbmUoXG4gIHtcbiAgICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogWydmb3JtJywgJ3VybGVuY29kZWQnLCAnZm9ybS1kYXRhJ11cbiAgfSxcbiAgdHJ1ZVxuKTtcblxuLyoqXG4gKiBQcm90b2NvbCBtYXAuXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbHMgPSB7XG4gICdodHRwOic6IGh0dHAsXG4gICdodHRwczonOiBodHRwcyxcbiAgJ2h0dHAyOic6IGh0dHAyXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxuZXhwb3J0cy5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBxcy5zdHJpbmdpZnksXG4gICdhcHBsaWNhdGlvbi9qc29uJzogc2FmZVN0cmluZ2lmeVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHBhcnNlcnMuXG4gKlxuICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ocmVzLCBmbil7XG4gKiAgICAgICBmbihudWxsLCByZXMpO1xuICogICAgIH07XG4gKlxuICovXG5cbmV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcblxuLyoqXG4gKiBEZWZhdWx0IGJ1ZmZlcmluZyBtYXAuIENhbiBiZSB1c2VkIHRvIHNldCBjZXJ0YWluXG4gKiByZXNwb25zZSB0eXBlcyB0byBidWZmZXIvbm90IGJ1ZmZlci5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5idWZmZXJbJ2FwcGxpY2F0aW9uL3htbCddID0gdHJ1ZTtcbiAqL1xuZXhwb3J0cy5idWZmZXIgPSB7fTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGludGVybmFsIGhlYWRlciB0cmFja2luZyBwcm9wZXJ0aWVzIG9uIGEgcmVxdWVzdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxIHRoZSBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pbml0SGVhZGVycyhyZXEpIHtcbiAgcmVxLl9oZWFkZXIgPSB7XG4gICAgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIH07XG4gIHJlcS5oZWFkZXIgPSB7XG4gICAgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB1cmwgPSBmb3JtYXQodXJsKTtcbiAgdGhpcy5fZW5hYmxlSHR0cDIgPSBCb29sZWFuKHByb2Nlc3MuZW52LkhUVFAyX1RFU1QpOyAvLyBpbnRlcm5hbCBvbmx5XG4gIHRoaXMuX2FnZW50ID0gZmFsc2U7XG4gIHRoaXMuX2Zvcm1EYXRhID0gbnVsbDtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICBfaW5pdEhlYWRlcnModGhpcyk7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuICB0aGlzLnJlZGlyZWN0cyhtZXRob2QgPT09ICdIRUFEJyA/IDAgOiA1KTtcbiAgdGhpcy5jb29raWVzID0gJyc7XG4gIHRoaXMucXMgPSB7fTtcbiAgdGhpcy5fcXVlcnkgPSBbXTtcbiAgdGhpcy5xc1JhdyA9IHRoaXMuX3F1ZXJ5OyAvLyBVbnVzZWQsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBvbmx5XG4gIHRoaXMuX3JlZGlyZWN0TGlzdCA9IFtdO1xuICB0aGlzLl9zdHJlYW1SZXF1ZXN0ID0gZmFsc2U7XG4gIHRoaXMub25jZSgnZW5kJywgdGhpcy5jbGVhclRpbWVvdXQuYmluZCh0aGlzKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBTdHJlYW1gICh3aGljaCBpbmhlcml0cyBmcm9tIGBFdmVudEVtaXR0ZXJgKS5cbiAqIE1peGluIGBSZXF1ZXN0QmFzZWAuXG4gKi9cbnV0aWwuaW5oZXJpdHMoUmVxdWVzdCwgU3RyZWFtKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5SZXF1ZXN0QmFzZShSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW5hYmxlIG9yIERpc2FibGUgaHR0cDIuXG4gKlxuICogRW5hYmxlIGh0dHAyLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5nZXQoJ2h0dHA6Ly9sb2NhbGhvc3QvJylcbiAqICAgLmh0dHAyKClcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5nZXQoJ2h0dHA6Ly9sb2NhbGhvc3QvJylcbiAqICAgLmh0dHAyKHRydWUpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogRGlzYWJsZSBodHRwMi5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QgPSByZXF1ZXN0Lmh0dHAyKCk7XG4gKiByZXF1ZXN0LmdldCgnaHR0cDovL2xvY2FsaG9zdC8nKVxuICogICAuaHR0cDIoZmFsc2UpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5odHRwMiA9IGZ1bmN0aW9uIChib29sKSB7XG4gIGlmIChleHBvcnRzLnByb3RvY29sc1snaHR0cDI6J10gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdzdXBlcmFnZW50OiB0aGlzIHZlcnNpb24gb2YgTm9kZS5qcyBkb2VzIG5vdCBzdXBwb3J0IGh0dHAyJ1xuICAgICk7XG4gIH1cblxuICB0aGlzLl9lbmFibGVIdHRwMiA9IGJvb2wgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnZmllbGQnLCBCdWZmZXIuZnJvbSgnPGI+SGVsbG8gd29ybGQ8L2I+JyksICdoZWxsby5odG1sJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBBIGZpbGVuYW1lIG1heSBhbHNvIGJlIHVzZWQ6XG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnZmlsZXMnLCAnaW1hZ2UuanBnJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfGZzLlJlYWRTdHJlYW18QnVmZmVyfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZmllbGQsIGZpbGUsIG9wdGlvbnMpIHtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VwZXJhZ2VudCBjYW4ndCBtaXggLnNlbmQoKSBhbmQgLmF0dGFjaCgpXCIpO1xuICAgIH1cblxuICAgIGxldCBvID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvID0geyBmaWxlbmFtZTogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghby5maWxlbmFtZSkgby5maWxlbmFtZSA9IGZpbGU7XG4gICAgICBkZWJ1ZygnY3JlYXRpbmcgYGZzLlJlYWRTdHJlYW1gIGluc3RhbmNlIGZvciBmaWxlOiAlcycsIGZpbGUpO1xuICAgICAgZmlsZSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgfSBlbHNlIGlmICghby5maWxlbmFtZSAmJiBmaWxlLnBhdGgpIHtcbiAgICAgIG8uZmlsZW5hbWUgPSBmaWxlLnBhdGg7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG8pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIHRoaXMuX2Zvcm1EYXRhLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGRlYnVnKCdGb3JtRGF0YSBlcnJvcicsIGVycik7XG4gICAgICBpZiAodGhpcy5jYWxsZWQpIHtcbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgYW5kIHRoZSBjYWxsYmFjayB3YXMgY2FsbGVkLlxuICAgICAgICAvLyBTaWxlbnRseSBpZ25vcmUgdGhlIGVycm9yLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogR2V0cy9zZXRzIHRoZSBgQWdlbnRgIHRvIHVzZSBmb3IgdGhpcyBIVFRQIHJlcXVlc3QuIFRoZSBkZWZhdWx0IChpZiB0aGlzXG4gKiBmdW5jdGlvbiBpcyBub3QgY2FsbGVkKSBpcyB0byBvcHQgb3V0IG9mIGNvbm5lY3Rpb24gcG9vbGluZyAoYGFnZW50OiBmYWxzZWApLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5BZ2VudH0gYWdlbnRcbiAqIEByZXR1cm4ge2h0dHAuQWdlbnR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24gKGFnZW50KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYWdlbnQ7XG4gIHRoaXMuX2FnZW50ID0gYWdlbnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgX0NvbnRlbnQtVHlwZV8gcmVzcG9uc2UgaGVhZGVyIHBhc3NlZCB0aHJvdWdoIGBtaW1lLmdldFR5cGUoKWAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgIC5zZW5kKGpzb25zdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2VuZChqc29uc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiB0aGlzLnNldChcbiAgICAnQ29udGVudC1UeXBlJyxcbiAgICB0eXBlLmluY2x1ZGVzKCcvJykgPyB0eXBlIDogbWltZS5nZXRUeXBlKHR5cGUpXG4gICk7XG59O1xuXG4vKipcbiAqIFNldCBfQWNjZXB0XyByZXNwb25zZSBoZWFkZXIgcGFzc2VkIHRocm91Z2ggYG1pbWUuZ2V0VHlwZSgpYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiB0aGlzLnNldCgnQWNjZXB0JywgdHlwZS5pbmNsdWRlcygnLycpID8gdHlwZSA6IG1pbWUuZ2V0VHlwZSh0eXBlKSk7XG59O1xuXG4vKipcbiAqIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiAqICAgICAucXVlcnkoJ3NpemU9MTAnKVxuICogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9xdWVyeS5wdXNoKHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnFzLCB2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHJhdyBgZGF0YWAgLyBgZW5jb2RpbmdgIHRvIHRoZSBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nKSB7XG4gIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICBpZiAoIXRoaXMuX3N0cmVhbVJlcXVlc3QpIHtcbiAgICB0aGlzLl9zdHJlYW1SZXF1ZXN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZXEud3JpdGUoZGF0YSwgZW5jb2RpbmcpO1xufTtcblxuLyoqXG4gKiBQaXBlIHRoZSByZXF1ZXN0IGJvZHkgdG8gYHN0cmVhbWAuXG4gKlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChzdHJlYW0sIG9wdGlvbnMpIHtcbiAgdGhpcy5waXBlZCA9IHRydWU7IC8vIEhBQ0suLi5cbiAgdGhpcy5idWZmZXIoZmFsc2UpO1xuICB0aGlzLmVuZCgpO1xuICByZXR1cm4gdGhpcy5fcGlwZUNvbnRpbnVlKHN0cmVhbSwgb3B0aW9ucyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fcGlwZUNvbnRpbnVlID0gZnVuY3Rpb24gKHN0cmVhbSwgb3B0aW9ucykge1xuICB0aGlzLnJlcS5vbmNlKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICAvLyByZWRpcmVjdFxuICAgIGlmIChcbiAgICAgIGlzUmVkaXJlY3QocmVzLnN0YXR1c0NvZGUpICYmXG4gICAgICB0aGlzLl9yZWRpcmVjdHMrKyAhPT0gdGhpcy5fbWF4UmVkaXJlY3RzXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVkaXJlY3QocmVzKSA9PT0gdGhpc1xuICAgICAgICA/IHRoaXMuX3BpcGVDb250aW51ZShzdHJlYW0sIG9wdGlvbnMpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMucmVzID0gcmVzO1xuICAgIHRoaXMuX2VtaXRSZXNwb25zZSgpO1xuICAgIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fc2hvdWxkVW56aXAocmVzKSkge1xuICAgICAgY29uc3QgdW56aXBPYmogPSB6bGliLmNyZWF0ZVVuemlwKCk7XG4gICAgICB1bnppcE9iai5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdaX0JVRl9FUlJPUicpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIGVuZCBvZiBmaWxlIGlzIGlnbm9yZWQgYnkgYnJvd3NlcnMgYW5kIGN1cmxcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0pO1xuICAgICAgcmVzLnBpcGUodW56aXBPYmopLnBpcGUoc3RyZWFtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnBpcGUoc3RyZWFtLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXMub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW07XG59O1xuXG4vKipcbiAqIEVuYWJsZSAvIGRpc2FibGUgYnVmZmVyaW5nLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFt2YWxdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gKHZhbCkge1xuICB0aGlzLl9idWZmZXIgPSB2YWwgIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVkaXJlY3QgdG8gYHVybFxuICpcbiAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSByZXNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuX3JlZGlyZWN0ID0gZnVuY3Rpb24gKHJlcykge1xuICBsZXQgdXJsID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2sobmV3IEVycm9yKCdObyBsb2NhdGlvbiBoZWFkZXIgZm9yIHJlZGlyZWN0JyksIHJlcyk7XG4gIH1cblxuICBkZWJ1ZygncmVkaXJlY3QgJXMgLT4gJXMnLCB0aGlzLnVybCwgdXJsKTtcblxuICAvLyBsb2NhdGlvblxuICB1cmwgPSByZXNvbHZlKHRoaXMudXJsLCB1cmwpO1xuXG4gIC8vIGVuc3VyZSB0aGUgcmVzcG9uc2UgaXMgYmVpbmcgY29uc3VtZWRcbiAgLy8gdGhpcyBpcyByZXF1aXJlZCBmb3IgTm9kZSB2MC4xMCtcbiAgcmVzLnJlc3VtZSgpO1xuXG4gIGxldCBoZWFkZXJzID0gdGhpcy5yZXEuZ2V0SGVhZGVycyA/IHRoaXMucmVxLmdldEhlYWRlcnMoKSA6IHRoaXMucmVxLl9oZWFkZXJzO1xuXG4gIGNvbnN0IGNoYW5nZXNPcmlnaW4gPSBwYXJzZSh1cmwpLmhvc3QgIT09IHBhcnNlKHRoaXMudXJsKS5ob3N0O1xuXG4gIC8vIGltcGxlbWVudGF0aW9uIG9mIDMwMiBmb2xsb3dpbmcgZGVmYWN0byBzdGFuZGFyZFxuICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgLy8gc3RyaXAgQ29udGVudC0qIHJlbGF0ZWQgZmllbGRzXG4gICAgLy8gaW4gY2FzZSBvZiBQT1NUIGV0Y1xuICAgIGhlYWRlcnMgPSB1dGlscy5jbGVhbkhlYWRlcihoZWFkZXJzLCBjaGFuZ2VzT3JpZ2luKTtcblxuICAgIC8vIGZvcmNlIEdFVFxuICAgIHRoaXMubWV0aG9kID0gdGhpcy5tZXRob2QgPT09ICdIRUFEJyA/ICdIRUFEJyA6ICdHRVQnO1xuXG4gICAgLy8gY2xlYXIgZGF0YVxuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICB9XG5cbiAgLy8gMzAzIGlzIGFsd2F5cyBHRVRcbiAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDMpIHtcbiAgICAvLyBzdHJpcCBDb250ZW50LSogcmVsYXRlZCBmaWVsZHNcbiAgICAvLyBpbiBjYXNlIG9mIFBPU1QgZXRjXG4gICAgaGVhZGVycyA9IHV0aWxzLmNsZWFuSGVhZGVyKGhlYWRlcnMsIGNoYW5nZXNPcmlnaW4pO1xuXG4gICAgLy8gZm9yY2UgbWV0aG9kXG4gICAgdGhpcy5tZXRob2QgPSAnR0VUJztcblxuICAgIC8vIGNsZWFyIGRhdGFcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfVxuXG4gIC8vIDMwNyBwcmVzZXJ2ZXMgbWV0aG9kXG4gIC8vIDMwOCBwcmVzZXJ2ZXMgbWV0aG9kXG4gIGRlbGV0ZSBoZWFkZXJzLmhvc3Q7XG5cbiAgZGVsZXRlIHRoaXMucmVxO1xuICBkZWxldGUgdGhpcy5fZm9ybURhdGE7XG5cbiAgLy8gcmVtb3ZlIGFsbCBhZGQgaGVhZGVyIGV4Y2VwdCBVc2VyLUFnZW50XG4gIF9pbml0SGVhZGVycyh0aGlzKTtcblxuICAvLyByZWRpcmVjdFxuICB0aGlzLl9lbmRDYWxsZWQgPSBmYWxzZTtcbiAgdGhpcy51cmwgPSB1cmw7XG4gIHRoaXMucXMgPSB7fTtcbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDtcbiAgdGhpcy5zZXQoaGVhZGVycyk7XG4gIHRoaXMuZW1pdCgncmVkaXJlY3QnLCByZXMpO1xuICB0aGlzLl9yZWRpcmVjdExpc3QucHVzaCh0aGlzLnVybCk7XG4gIHRoaXMuZW5kKHRoaXMuX2NhbGxiYWNrKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAuYXV0aCgndG9iaScsICdsZWFybmJvb3N0JylcbiAqICAgLmF1dGgoJ3RvYmk6bGVhcm5ib29zdCcpXG4gKiAgIC5hdXRoKCd0b2JpJylcbiAqICAgLmF1dGgoYWNjZXNzVG9rZW4sIHsgdHlwZTogJ2JlYXJlcicgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXNzXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHdpdGggYXV0aG9yaXphdGlvbiB0eXBlICdiYXNpYycgb3IgJ2JlYXJlcicgKCdiYXNpYycgaXMgZGVmYXVsdClcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHBhc3MgPSAnJztcbiAgaWYgKHR5cGVvZiBwYXNzID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7XG4gICAgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IHR5cGU6ICdiYXNpYycgfTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZXIgPSAoc3RyaW5nKSA9PiBCdWZmZXIuZnJvbShzdHJpbmcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgb3B0aW9uIGZvciBodHRwcyByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXl9IGNlcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYSA9IGZ1bmN0aW9uIChjZXJ0KSB7XG4gIHRoaXMuX2NhID0gY2VydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY2xpZW50IGNlcnRpZmljYXRlIGtleSBvcHRpb24gZm9yIGh0dHBzIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBTdHJpbmd9IGNlcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoY2VydCkge1xuICB0aGlzLl9rZXkgPSBjZXJ0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBrZXksIGNlcnRpZmljYXRlLCBhbmQgQ0EgY2VydHMgb2YgdGhlIGNsaWVudCBpbiBQRlggb3IgUEtDUzEyIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IFN0cmluZ30gY2VydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnBmeCA9IGZ1bmN0aW9uIChjZXJ0KSB7XG4gIGlmICh0eXBlb2YgY2VydCA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIHRoaXMuX3BmeCA9IGNlcnQucGZ4O1xuICAgIHRoaXMuX3Bhc3NwaHJhc2UgPSBjZXJ0LnBhc3NwaHJhc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcGZ4ID0gY2VydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBvcHRpb24gZm9yIGh0dHBzIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBTdHJpbmd9IGNlcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jZXJ0ID0gZnVuY3Rpb24gKGNlcnQpIHtcbiAgdGhpcy5fY2VydCA9IGNlcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEbyBub3QgcmVqZWN0IGV4cGlyZWQgb3IgaW52YWxpZCBUTFMgY2VydHMuXG4gKiBzZXRzIGByZWplY3RVbmF1dGhvcml6ZWQ9dHJ1ZWAuIEJlIHdhcm5lZCB0aGF0IHRoaXMgYWxsb3dzIE1JVE0gYXR0YWNrcy5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZGlzYWJsZVRMU0NlcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kaXNhYmxlVExTQ2VydHMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGh0dHBbc10gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHtPdXRnb2luZ01lc3NhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuUmVxdWVzdC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmVxKSByZXR1cm4gdGhpcy5yZXE7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBxcy5zdHJpbmdpZnkodGhpcy5xcywge1xuICAgICAgaW5kaWNlczogZmFsc2UsXG4gICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHRoaXMucXMgPSB7fTtcbiAgICAgIHRoaXMuX3F1ZXJ5LnB1c2gocXVlcnkpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgbGV0IHsgdXJsIH0gPSB0aGlzO1xuICBjb25zdCByZXRyaWVzID0gdGhpcy5fcmV0cmllcztcblxuICAvLyBDYXB0dXJlIGJhY2t0aWNrcyBhcy1pcyBmcm9tIHRoZSBmaW5hbCBxdWVyeSBzdHJpbmcgYnVpbHQgYWJvdmUuXG4gIC8vIE5vdGU6IHRoaXMnbGwgb25seSBmaW5kIGJhY2t0aWNrcyBlbnRlcmVkIGluIHJlcS5xdWVyeShTdHJpbmcpXG4gIC8vIGNhbGxzLCBiZWNhdXNlIHFzLnN0cmluZ2lmeSB1bmNvbmRpdGlvbmFsbHkgZW5jb2RlcyBiYWNrdGlja3MuXG4gIGxldCBxdWVyeVN0cmluZ0JhY2t0aWNrcztcbiAgaWYgKHVybC5pbmNsdWRlcygnYCcpKSB7XG4gICAgY29uc3QgcXVlcnlTdGFydEluZGV4ID0gdXJsLmluZGV4T2YoJz8nKTtcblxuICAgIGlmIChxdWVyeVN0YXJ0SW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBxdWVyeVN0cmluZyA9IHVybC5zbGljZShxdWVyeVN0YXJ0SW5kZXggKyAxKTtcbiAgICAgIHF1ZXJ5U3RyaW5nQmFja3RpY2tzID0gcXVlcnlTdHJpbmcubWF0Y2goL2B8JTYwL2cpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8gaHR0cDovL1xuICBpZiAodXJsLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCkgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICB1cmwgPSBwYXJzZSh1cmwpO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvc3VwZXJhZ2VudC9pc3N1ZXMvMTM2N1xuICBpZiAocXVlcnlTdHJpbmdCYWNrdGlja3MpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgdXJsLnF1ZXJ5ID0gdXJsLnF1ZXJ5LnJlcGxhY2UoLyU2MC9nLCAoKSA9PiBxdWVyeVN0cmluZ0JhY2t0aWNrc1tpKytdKTtcbiAgICB1cmwuc2VhcmNoID0gYD8ke3VybC5xdWVyeX1gO1xuICAgIHVybC5wYXRoID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgfVxuXG4gIC8vIHN1cHBvcnQgdW5peCBzb2NrZXRzXG4gIGlmICgvXmh0dHBzP1xcK3VuaXg6Ly50ZXN0KHVybC5wcm90b2NvbCkgPT09IHRydWUpIHtcbiAgICAvLyBnZXQgdGhlIHByb3RvY29sXG4gICAgdXJsLnByb3RvY29sID0gYCR7dXJsLnByb3RvY29sLnNwbGl0KCcrJylbMF19OmA7XG5cbiAgICAvLyBnZXQgdGhlIHNvY2tldCwgcGF0aFxuICAgIGNvbnN0IHVuaXhQYXJ0cyA9IHVybC5wYXRoLm1hdGNoKC9eKFteL10rKSguKykkLyk7XG4gICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gdW5peFBhcnRzWzFdLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xuICAgIHVybC5wYXRoID0gdW5peFBhcnRzWzJdO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgSVAgYWRkcmVzcyBvZiBhIGhvc3RuYW1lXG4gIGlmICh0aGlzLl9jb25uZWN0T3ZlcnJpZGUpIHtcbiAgICBjb25zdCB7IGhvc3RuYW1lIH0gPSB1cmw7XG4gICAgY29uc3QgbWF0Y2ggPVxuICAgICAgaG9zdG5hbWUgaW4gdGhpcy5fY29ubmVjdE92ZXJyaWRlXG4gICAgICAgID8gdGhpcy5fY29ubmVjdE92ZXJyaWRlW2hvc3RuYW1lXVxuICAgICAgICA6IHRoaXMuX2Nvbm5lY3RPdmVycmlkZVsnKiddO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgLy8gYmFja3VwIHRoZSByZWFsIGhvc3RcbiAgICAgIGlmICghdGhpcy5faGVhZGVyLmhvc3QpIHtcbiAgICAgICAgdGhpcy5zZXQoJ2hvc3QnLCB1cmwuaG9zdCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdIb3N0O1xuICAgICAgbGV0IG5ld1BvcnQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG5ld0hvc3QgPSBtYXRjaC5ob3N0O1xuICAgICAgICBuZXdQb3J0ID0gbWF0Y2gucG9ydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0hvc3QgPSBtYXRjaDtcbiAgICAgICAgbmV3UG9ydCA9IHVybC5wb3J0O1xuICAgICAgfVxuXG4gICAgICAvLyB3cmFwIFtpcHY2XVxuICAgICAgdXJsLmhvc3QgPSAvOi8udGVzdChuZXdIb3N0KSA/IGBbJHtuZXdIb3N0fV1gIDogbmV3SG9zdDtcbiAgICAgIGlmIChuZXdQb3J0KSB7XG4gICAgICAgIHVybC5ob3N0ICs9IGA6JHtuZXdQb3J0fWA7XG4gICAgICAgIHVybC5wb3J0ID0gbmV3UG9ydDtcbiAgICAgIH1cblxuICAgICAgdXJsLmhvc3RuYW1lID0gbmV3SG9zdDtcbiAgICB9XG4gIH1cblxuICAvLyBvcHRpb25zXG4gIG9wdGlvbnMubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIG9wdGlvbnMucG9ydCA9IHVybC5wb3J0O1xuICBvcHRpb25zLnBhdGggPSB1cmwucGF0aDtcbiAgb3B0aW9ucy5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICBvcHRpb25zLmNhID0gdGhpcy5fY2E7XG4gIG9wdGlvbnMua2V5ID0gdGhpcy5fa2V5O1xuICBvcHRpb25zLnBmeCA9IHRoaXMuX3BmeDtcbiAgb3B0aW9ucy5jZXJ0ID0gdGhpcy5fY2VydDtcbiAgb3B0aW9ucy5wYXNzcGhyYXNlID0gdGhpcy5fcGFzc3BocmFzZTtcbiAgb3B0aW9ucy5hZ2VudCA9IHRoaXMuX2FnZW50O1xuICBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9XG4gICAgdHlwZW9mIHRoaXMuX2Rpc2FibGVUTFNDZXJ0cyA9PT0gJ2Jvb2xlYW4nXG4gICAgICA/ICF0aGlzLl9kaXNhYmxlVExTQ2VydHNcbiAgICAgIDogcHJvY2Vzcy5lbnYuTk9ERV9UTFNfUkVKRUNUX1VOQVVUSE9SSVpFRCAhPT0gJzAnO1xuXG4gIC8vIEFsbG93cyByZXF1ZXN0LmdldCgnaHR0cHM6Ly8xLjIuMy40LycpLnNldCgnSG9zdCcsICdleGFtcGxlLmNvbScpXG4gIGlmICh0aGlzLl9oZWFkZXIuaG9zdCkge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IHRoaXMuX2hlYWRlci5ob3N0LnJlcGxhY2UoLzpcXGQrJC8sICcnKTtcbiAgfVxuXG4gIGlmIChcbiAgICB0aGlzLl90cnVzdExvY2FsaG9zdCAmJlxuICAgIC9eKD86bG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuXFxkK3woMCo6KSs6MCoxKSQvLnRlc3QodXJsLmhvc3RuYW1lKVxuICApIHtcbiAgICBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICBjb25zdCBtb2QgPSB0aGlzLl9lbmFibGVIdHRwMlxuICAgID8gZXhwb3J0cy5wcm90b2NvbHNbJ2h0dHAyOiddLnNldFByb3RvY29sKHVybC5wcm90b2NvbClcbiAgICA6IGV4cG9ydHMucHJvdG9jb2xzW3VybC5wcm90b2NvbF07XG5cbiAgLy8gcmVxdWVzdFxuICB0aGlzLnJlcSA9IG1vZC5yZXF1ZXN0KG9wdGlvbnMpO1xuICBjb25zdCB7IHJlcSB9ID0gdGhpcztcblxuICAvLyBzZXQgdGNwIG5vIGRlbGF5XG4gIHJlcS5zZXROb0RlbGF5KHRydWUpO1xuXG4gIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgcmVxLnNldEhlYWRlcignQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUnKTtcbiAgfVxuXG4gIHRoaXMucHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG4gIHRoaXMuaG9zdCA9IHVybC5ob3N0O1xuXG4gIC8vIGV4cG9zZSBldmVudHNcbiAgcmVxLm9uY2UoJ2RyYWluJywgKCkgPT4ge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSk7XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAvLyBmbGFnIGFib3J0aW9uIGhlcmUgZm9yIG91dCB0aW1lb3V0c1xuICAgIC8vIGJlY2F1c2Ugbm9kZSB3aWxsIGVtaXQgYSBmYXV4LWVycm9yIFwic29ja2V0IGhhbmcgdXBcIlxuICAgIC8vIHdoZW4gcmVxdWVzdCBpcyBhYm9ydGVkIGJlZm9yZSBhIGNvbm5lY3Rpb24gaXMgbWFkZVxuICAgIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm47XG4gICAgLy8gaWYgbm90IHRoZSBzYW1lLCB3ZSBhcmUgaW4gdGhlICoqb2xkKiogKGNhbmNlbGxlZCkgcmVxdWVzdCxcbiAgICAvLyBzbyBuZWVkIHRvIGNvbnRpbnVlIChzYW1lIGFzIGZvciBhYm92ZSlcbiAgICBpZiAodGhpcy5fcmV0cmllcyAhPT0gcmV0cmllcykgcmV0dXJuO1xuICAgIC8vIGlmIHdlJ3ZlIHJlY2VpdmVkIGEgcmVzcG9uc2UgdGhlbiB3ZSBkb24ndCB3YW50IHRvIGxldFxuICAgIC8vIGFuIGVycm9yIGluIHRoZSByZXF1ZXN0IGJsb3cgdXAgdGhlIHJlc3BvbnNlXG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHJldHVybjtcbiAgICB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH0pO1xuXG4gIC8vIGF1dGhcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgY29uc3QgYXV0aCA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdGhpcy5hdXRoKGF1dGhbMF0sIGF1dGhbMV0pO1xuICB9XG5cbiAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgIHRoaXMuYXV0aCh0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhlYWRlciwga2V5KSlcbiAgICAgIHJlcS5zZXRIZWFkZXIoa2V5LCB0aGlzLmhlYWRlcltrZXldKTtcbiAgfVxuXG4gIC8vIGFkZCBjb29raWVzXG4gIGlmICh0aGlzLmNvb2tpZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2hlYWRlciwgJ2Nvb2tpZScpKSB7XG4gICAgICAvLyBtZXJnZVxuICAgICAgY29uc3QgdG1wSmFyID0gbmV3IENvb2tpZUphci5Db29raWVKYXIoKTtcbiAgICAgIHRtcEphci5zZXRDb29raWVzKHRoaXMuX2hlYWRlci5jb29raWUuc3BsaXQoJzsnKSk7XG4gICAgICB0bXBKYXIuc2V0Q29va2llcyh0aGlzLmNvb2tpZXMuc3BsaXQoJzsnKSk7XG4gICAgICByZXEuc2V0SGVhZGVyKFxuICAgICAgICAnQ29va2llJyxcbiAgICAgICAgdG1wSmFyLmdldENvb2tpZXMoQ29va2llSmFyLkNvb2tpZUFjY2Vzc0luZm8uQWxsKS50b1ZhbHVlU3RyaW5nKClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcS5zZXRIZWFkZXIoJ0Nvb2tpZScsIHRoaXMuY29va2llcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgLy8gQXZvaWQgdGhlIGVycm9yIHdoaWNoIGlzIGVtaXR0ZWQgZnJvbSAnc29ja2V0IGhhbmcgdXAnIHRvIGNhdXNlIHRoZSBmbiB1bmRlZmluZWQgZXJyb3Igb24gSlMgcnVudGltZS5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjayB8fCBub29wO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICBpZiAodGhpcy5jYWxsZWQpIHJldHVybiBjb25zb2xlLndhcm4oJ3N1cGVyYWdlbnQ6IGRvdWJsZSBjYWxsYmFjayBidWcnKTtcbiAgdGhpcy5jYWxsZWQgPSB0cnVlO1xuXG4gIGlmICghZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZSc7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBtc2cgPSBodHRwLlNUQVRVU19DT0RFU1tyZXMuc3RhdHVzXSB8fCBtc2c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgZXJyLnN0YXR1cyA9IHJlcyA/IHJlcy5zdGF0dXMgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyXykge1xuICAgICAgZXJyID0gZXJyXztcbiAgICB9XG4gIH1cblxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgb3V0c2lkZSB0cnkvY2F0Y2hcbiAgLy8gdG8gYXZvaWQgZG91YmxlIGNhbGxiYWNrXG4gIGlmICghZXJyKSB7XG4gICAgcmV0dXJuIGZuKG51bGwsIHJlcyk7XG4gIH1cblxuICBlcnIucmVzcG9uc2UgPSByZXM7XG4gIGlmICh0aGlzLl9tYXhSZXRyaWVzKSBlcnIucmV0cmllcyA9IHRoaXMuX3JldHJpZXMgLSAxO1xuXG4gIC8vIG9ubHkgZW1pdCBlcnJvciBldmVudCBpZiB0aGVyZSBpcyBhIGxpc3RlbmVyXG4gIC8vIG90aGVyd2lzZSB3ZSBhc3N1bWUgdGhlIGNhbGxiYWNrIHRvIGAuZW5kKClgIHdpbGwgZ2V0IHRoZSBlcnJvclxuICBpZiAoZXJyICYmIHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIGhvc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpcyBhIGhvc3Qgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBTdHJlYW0gfHwgb2JqIGluc3RhbmNlb2YgRm9ybURhdGFcbiAgKTtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKGVyciwgcmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuX2VtaXRSZXNwb25zZSA9IGZ1bmN0aW9uIChib2R5LCBmaWxlcykge1xuICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh0aGlzKTtcbiAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXNwb25zZS5yZWRpcmVjdHMgPSB0aGlzLl9yZWRpcmVjdExpc3Q7XG4gIGlmICh1bmRlZmluZWQgIT09IGJvZHkpIHtcbiAgICByZXNwb25zZS5ib2R5ID0gYm9keTtcbiAgfVxuXG4gIHJlc3BvbnNlLmZpbGVzID0gZmlsZXM7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICByZXNwb25zZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImVuZCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLCBzbyBpdCdzIHRvbyBsYXRlIHRvIHN0YXJ0IHBpcGluZ1wiXG4gICAgICApO1xuICAgIH07XG4gIH1cblxuICB0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgcmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5yZXF1ZXN0KCk7XG4gIGRlYnVnKCclcyAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVybCk7XG5cbiAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICcuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnQnXG4gICAgKTtcbiAgfVxuXG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIHRoaXMuX2VuZCgpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpXG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soXG4gICAgICBuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgZXZlbiBiZWZvcmUgLmVuZCgpIHdhcyBjYWxsZWQnKVxuICAgICk7XG5cbiAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICBjb25zdCB7IHJlcSB9ID0gdGhpcztcbiAgY29uc3QgeyBtZXRob2QgfSA9IHRoaXM7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBib2R5XG4gIGlmIChtZXRob2QgIT09ICdIRUFEJyAmJiAhcmVxLl9oZWFkZXJTZW50KSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGNvbnRlbnRUeXBlID0gcmVxLmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAvLyBQYXJzZSBvdXQganVzdCB0aGUgY29udGVudCB0eXBlIGZyb20gdGhlIGhlYWRlciAoaWdub3JlIHRoZSBjaGFyc2V0KVxuICAgICAgaWYgKGNvbnRlbnRUeXBlKSBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF07XG4gICAgICBsZXQgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCBleHBvcnRzLnNlcmlhbGl6ZVtjb250ZW50VHlwZV07XG4gICAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICAgIHNlcmlhbGl6ZSA9IGV4cG9ydHMuc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gY29udGVudC1sZW5ndGhcbiAgICBpZiAoZGF0YSAmJiAhcmVxLmdldEhlYWRlcignQ29udGVudC1MZW5ndGgnKSkge1xuICAgICAgcmVxLnNldEhlYWRlcihcbiAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJyxcbiAgICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEpID8gZGF0YS5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNwb25zZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICByZXEub25jZSgncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgZGVidWcoJyVzICVzIC0+ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJsLCByZXMuc3RhdHVzQ29kZSk7XG5cbiAgICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGlwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXggPSB0aGlzLl9tYXhSZWRpcmVjdHM7XG4gICAgY29uc3QgbWltZSA9IHV0aWxzLnR5cGUocmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKSB8fCAndGV4dC9wbGFpbic7XG4gICAgbGV0IHR5cGUgPSBtaW1lLnNwbGl0KCcvJylbMF07XG4gICAgaWYgKHR5cGUpIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGNvbnN0IG11bHRpcGFydCA9IHR5cGUgPT09ICdtdWx0aXBhcnQnO1xuICAgIGNvbnN0IHJlZGlyZWN0ID0gaXNSZWRpcmVjdChyZXMuc3RhdHVzQ29kZSk7XG4gICAgY29uc3QgcmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuXG4gICAgdGhpcy5yZXMgPSByZXM7XG5cbiAgICAvLyByZWRpcmVjdFxuICAgIGlmIChyZWRpcmVjdCAmJiB0aGlzLl9yZWRpcmVjdHMrKyAhPT0gbWF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVkaXJlY3QocmVzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgdGhpcy5fZW1pdFJlc3BvbnNlKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHpsaWIgc3VwcG9ydFxuICAgIGlmICh0aGlzLl9zaG91bGRVbnppcChyZXMpKSB7XG4gICAgICB1bnppcChyZXEsIHJlcyk7XG4gICAgfVxuXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQgJiYgbWltZSBpbiBleHBvcnRzLmJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gQm9vbGVhbihleHBvcnRzLmJ1ZmZlclttaW1lXSk7XG4gICAgfVxuXG4gICAgbGV0IHBhcnNlciA9IHRoaXMuX3BhcnNlcjtcbiAgICBpZiAodW5kZWZpbmVkID09PSBidWZmZXIpIHtcbiAgICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjdXN0b20gc3VwZXJhZ2VudCBwYXJzZXIgaGFzIGJlZW4gc2V0LCBidXQgYnVmZmVyaW5nIHN0cmF0ZWd5IGZvciB0aGUgcGFyc2VyIGhhc24ndCBiZWVuIGNvbmZpZ3VyZWQuIENhbGwgYHJlcS5idWZmZXIodHJ1ZSBvciBmYWxzZSlgIG9yIHNldCBgc3VwZXJhZ2VudC5idWZmZXJbbWltZV0gPSB0cnVlIG9yIGZhbHNlYFwiXG4gICAgICAgICk7XG4gICAgICAgIGJ1ZmZlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgIGlmIChyZXNwb25zZVR5cGUpIHtcbiAgICAgICAgcGFyc2VyID0gZXhwb3J0cy5wYXJzZS5pbWFnZTsgLy8gSXQncyBhY3R1YWxseSBhIGdlbmVyaWMgQnVmZmVyXG4gICAgICAgIGJ1ZmZlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG11bHRpcGFydCkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IGZvcm1pZGFibGUuSW5jb21pbmdGb3JtKCk7XG4gICAgICAgIHBhcnNlciA9IGZvcm0ucGFyc2UuYmluZChmb3JtKTtcbiAgICAgICAgYnVmZmVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbWFnZU9yVmlkZW8obWltZSkpIHtcbiAgICAgICAgcGFyc2VyID0gZXhwb3J0cy5wYXJzZS5pbWFnZTtcbiAgICAgICAgYnVmZmVyID0gdHJ1ZTsgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGJ1ZmZlcmluZyBkZWZhdWx0IGlzIGFkLWhvYyBNSU1FLWRlcGVuZGVudFxuICAgICAgfSBlbHNlIGlmIChleHBvcnRzLnBhcnNlW21pbWVdKSB7XG4gICAgICAgIHBhcnNlciA9IGV4cG9ydHMucGFyc2VbbWltZV07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBwYXJzZXIgPSBleHBvcnRzLnBhcnNlLnRleHQ7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gZXZlcnlvbmUgd2FudHMgdGhlaXIgb3duIHdoaXRlLWxhYmVsZWQganNvblxuICAgICAgfSBlbHNlIGlmIChpc0pTT04obWltZSkpIHtcbiAgICAgICAgcGFyc2VyID0gZXhwb3J0cy5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgICAgICBidWZmZXIgPSBidWZmZXIgIT09IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIpIHtcbiAgICAgICAgcGFyc2VyID0gZXhwb3J0cy5wYXJzZS50ZXh0O1xuICAgICAgfSBlbHNlIGlmICh1bmRlZmluZWQgPT09IGJ1ZmZlcikge1xuICAgICAgICBwYXJzZXIgPSBleHBvcnRzLnBhcnNlLmltYWdlOyAvLyBJdCdzIGFjdHVhbGx5IGEgZ2VuZXJpYyBCdWZmZXJcbiAgICAgICAgYnVmZmVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBieSBkZWZhdWx0IG9ubHkgYnVmZmVyIHRleHQvKiwganNvbiBhbmQgbWVzc2VkIHVwIHRoaW5nIGZyb20gaGVsbFxuICAgIGlmICgodW5kZWZpbmVkID09PSBidWZmZXIgJiYgaXNUZXh0KG1pbWUpKSB8fCBpc0pTT04obWltZSkpIHtcbiAgICAgIGJ1ZmZlciA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVzQnVmZmVyZWQgPSBidWZmZXI7XG4gICAgbGV0IHBhcnNlckhhbmRsZXNFbmQgPSBmYWxzZTtcbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAvLyBQcm90ZWN0aW9uYSBhZ2FpbnN0IHppcCBib21icyBhbmQgb3RoZXIgbnVpc2FuY2VcbiAgICAgIGxldCByZXNwb25zZUJ5dGVzTGVmdCA9IHRoaXMuX21heFJlc3BvbnNlU2l6ZSB8fCAyMDAwMDAwMDA7XG4gICAgICByZXMub24oJ2RhdGEnLCAoYnVmKSA9PiB7XG4gICAgICAgIHJlc3BvbnNlQnl0ZXNMZWZ0IC09IGJ1Zi5ieXRlTGVuZ3RoIHx8IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGlmIChyZXNwb25zZUJ5dGVzTGVmdCA8IDApIHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJvcGFnYXRlIHRocm91Z2ggZXJyb3IgZXZlbnRcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ01heGltdW0gcmVzcG9uc2Ugc2l6ZSByZWFjaGVkJyk7XG4gICAgICAgICAgZXJyLmNvZGUgPSAnRVRPT0xBUkdFJztcbiAgICAgICAgICAvLyBQYXJzZXJzIGFyZW4ndCByZXF1aXJlZCB0byBvYnNlcnZlIGVycm9yIGV2ZW50LFxuICAgICAgICAgIC8vIHNvIHdvdWxkIGluY29ycmVjdGx5IHJlcG9ydCBzdWNjZXNzXG4gICAgICAgICAgcGFyc2VySGFuZGxlc0VuZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIFdpbGwgZW1pdCBlcnJvciBldmVudFxuICAgICAgICAgIHJlcy5kZXN0cm95KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFVuYnVmZmVyZWQgcGFyc2VycyBhcmUgc3VwcG9zZWQgdG8gZW1pdCByZXNwb25zZSBlYXJseSxcbiAgICAgICAgLy8gd2hpY2ggaXMgd2VpcmQgQlRXLCBiZWNhdXNlIHJlc3BvbnNlLmJvZHkgd29uJ3QgYmUgdGhlcmUuXG4gICAgICAgIHBhcnNlckhhbmRsZXNFbmQgPSBidWZmZXI7XG5cbiAgICAgICAgcGFyc2VyKHJlcywgKGVyciwgb2JqLCBmaWxlcykgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVkb3V0KSB7XG4gICAgICAgICAgICAvLyBUaW1lb3V0IGhhcyBhbHJlYWR5IGhhbmRsZWQgYWxsIGNhbGxiYWNrc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEludGVudGlvbmFsIChub24tdGltZW91dCkgYWJvcnQgaXMgc3VwcG9zZWQgdG8gcHJlc2VydmUgcGFydGlhbCByZXNwb25zZSxcbiAgICAgICAgICAvLyBldmVuIGlmIGl0IGRvZXNuJ3QgcGFyc2UuXG4gICAgICAgICAgaWYgKGVyciAmJiAhdGhpcy5fYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyc2VySGFuZGxlc0VuZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgdGhpcy5fZW1pdFJlc3BvbnNlKG9iaiwgZmlsZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVzID0gcmVzO1xuXG4gICAgLy8gdW5idWZmZXJlZFxuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICBkZWJ1ZygndW5idWZmZXJlZCAlcyAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVybCk7XG4gICAgICB0aGlzLmNhbGxiYWNrKG51bGwsIHRoaXMuX2VtaXRSZXNwb25zZSgpKTtcbiAgICAgIGlmIChtdWx0aXBhcnQpIHJldHVybjsgLy8gYWxsb3cgbXVsdGlwYXJ0IHRvIGhhbmRsZSBlbmQgZXZlbnRcbiAgICAgIHJlcy5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGRlYnVnKCdlbmQgJXMgJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmwpO1xuICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRpbmcgZXZlbnRzXG4gICAgcmVzLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgcGFyc2VySGFuZGxlc0VuZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH0pO1xuICAgIGlmICghcGFyc2VySGFuZGxlc0VuZClcbiAgICAgIHJlcy5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGRlYnVnKCdlbmQgJXMgJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmwpO1xuICAgICAgICAvLyBUT0RPOiB1bmxlc3MgYnVmZmVyaW5nIGVtaXQgZWFybGllciB0byBzdHJlYW1cbiAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCB0aGlzLl9lbWl0UmVzcG9uc2UoKSk7XG4gICAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgY29uc3QgZ2V0UHJvZ3Jlc3NNb25pdG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHRvdGFsID0gcmVxLmdldEhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcbiAgICBsZXQgbG9hZGVkID0gMDtcblxuICAgIGNvbnN0IHByb2dyZXNzID0gbmV3IFN0cmVhbS5UcmFuc2Zvcm0oKTtcbiAgICBwcm9ncmVzcy5fdHJhbnNmb3JtID0gKGNodW5rLCBlbmNvZGluZywgY2IpID0+IHtcbiAgICAgIGxvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywge1xuICAgICAgICBkaXJlY3Rpb246ICd1cGxvYWQnLFxuICAgICAgICBsZW5ndGhDb21wdXRhYmxlLFxuICAgICAgICBsb2FkZWQsXG4gICAgICAgIHRvdGFsXG4gICAgICB9KTtcbiAgICAgIGNiKG51bGwsIGNodW5rKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9O1xuXG4gIGNvbnN0IGJ1ZmZlclRvQ2h1bmtzID0gKGJ1ZmZlcikgPT4ge1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDE2ICogMTAyNDsgLy8gZGVmYXVsdCBoaWdoV2F0ZXJNYXJrIHZhbHVlXG4gICAgY29uc3QgY2h1bmtpbmcgPSBuZXcgU3RyZWFtLlJlYWRhYmxlKCk7XG4gICAgY29uc3QgdG90YWxMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHRvdGFsTGVuZ3RoICUgY2h1bmtTaXplO1xuICAgIGNvbnN0IGN1dG9mZiA9IHRvdGFsTGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXRvZmY7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICBjb25zdCBjaHVuayA9IGJ1ZmZlci5zbGljZShpLCBpICsgY2h1bmtTaXplKTtcbiAgICAgIGNodW5raW5nLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIGlmIChyZW1haW5kZXIgPiAwKSB7XG4gICAgICBjb25zdCByZW1haW5kZXJCdWZmZXIgPSBidWZmZXIuc2xpY2UoLXJlbWFpbmRlcik7XG4gICAgICBjaHVua2luZy5wdXNoKHJlbWFpbmRlckJ1ZmZlcik7XG4gICAgfVxuXG4gICAgY2h1bmtpbmcucHVzaChudWxsKTsgLy8gbm8gbW9yZSBkYXRhXG5cbiAgICByZXR1cm4gY2h1bmtpbmc7XG4gIH07XG5cbiAgLy8gaWYgYSBGb3JtRGF0YSBpbnN0YW5jZSBnb3QgY3JlYXRlZCwgdGhlbiB3ZSBzZW5kIHRoYXQgYXMgdGhlIHJlcXVlc3QgYm9keVxuICBjb25zdCBmb3JtRGF0YSA9IHRoaXMuX2Zvcm1EYXRhO1xuICBpZiAoZm9ybURhdGEpIHtcbiAgICAvLyBzZXQgaGVhZGVyc1xuICAgIGNvbnN0IGhlYWRlcnMgPSBmb3JtRGF0YS5nZXRIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBpIGluIGhlYWRlcnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgaSkpIHtcbiAgICAgICAgZGVidWcoJ3NldHRpbmcgRm9ybURhdGEgaGVhZGVyOiBcIiVzOiAlc1wiJywgaSwgaGVhZGVyc1tpXSk7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoaSwgaGVhZGVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXR0ZW1wdCB0byBnZXQgXCJDb250ZW50LUxlbmd0aFwiIGhlYWRlclxuICAgIGZvcm1EYXRhLmdldExlbmd0aCgoZXJyLCBsZW5ndGgpID0+IHtcbiAgICAgIC8vIFRPRE86IEFkZCBjaHVua2VkIGVuY29kaW5nIHdoZW4gbm8gbGVuZ3RoIChpZiBlcnIpXG4gICAgICBpZiAoZXJyKSBkZWJ1ZygnZm9ybURhdGEuZ2V0TGVuZ3RoIGhhZCBlcnJvcicsIGVyciwgbGVuZ3RoKTtcblxuICAgICAgZGVidWcoJ2dvdCBGb3JtRGF0YSBDb250ZW50LUxlbmd0aDogJXMnLCBsZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgZm9ybURhdGEucGlwZShnZXRQcm9ncmVzc01vbml0b3IoKSkucGlwZShyZXEpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIGJ1ZmZlclRvQ2h1bmtzKGRhdGEpLnBpcGUoZ2V0UHJvZ3Jlc3NNb25pdG9yKCkpLnBpcGUocmVxKTtcbiAgfSBlbHNlIHtcbiAgICByZXEuZW5kKGRhdGEpO1xuICB9XG59O1xuXG4vLyBDaGVjayB3aGV0aGVyIHJlc3BvbnNlIGhhcyBhIG5vbi0wLXNpemVkIGd6aXAtZW5jb2RlZCBib2R5XG5SZXF1ZXN0LnByb3RvdHlwZS5fc2hvdWxkVW56aXAgPSAocmVzKSA9PiB7XG4gIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHJlcy5zdGF0dXNDb2RlID09PSAzMDQpIHtcbiAgICAvLyBUaGVzZSBhcmVuJ3Qgc3VwcG9zZWQgdG8gaGF2ZSBhbnkgYm9keVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGhlYWRlciBjb250ZW50IGlzIGEgc3RyaW5nLCBhbmQgZGlzdGluY3Rpb24gYmV0d2VlbiAwIGFuZCBubyBpbmZvcm1hdGlvbiBpcyBjcnVjaWFsXG4gIGlmIChyZXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9PT0gJzAnKSB7XG4gICAgLy8gV2Uga25vdyB0aGF0IHRoZSBib2R5IGlzIGVtcHR5ICh1bmZvcnR1bmF0ZWx5LCB0aGlzIGNoZWNrIGRvZXMgbm90IGNvdmVyIGNodW5rZWQgZW5jb2RpbmcpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY29uc29sZS5sb2cocmVzKTtcbiAgcmV0dXJuIC9eXFxzKig/OmRlZmxhdGV8Z3ppcClcXHMqJC8udGVzdChyZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddKTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGVzIEROUyBmb3Igc2VsZWN0ZWQgaG9zdG5hbWVzLiBUYWtlcyBvYmplY3QgbWFwcGluZyBob3N0bmFtZXMgdG8gSVAgYWRkcmVzc2VzLlxuICpcbiAqIFdoZW4gbWFraW5nIGEgcmVxdWVzdCB0byBhIFVSTCB3aXRoIGEgaG9zdG5hbWUgZXhhY3RseSBtYXRjaGluZyBhIGtleSBpbiB0aGUgb2JqZWN0LFxuICogdXNlIHRoZSBnaXZlbiBJUCBhZGRyZXNzIHRvIGNvbm5lY3QsIGluc3RlYWQgb2YgdXNpbmcgRE5TIHRvIHJlc29sdmUgdGhlIGhvc3RuYW1lLlxuICpcbiAqIEEgc3BlY2lhbCBob3N0IGAqYCBtYXRjaGVzIGV2ZXJ5IGhvc3RuYW1lIChrZWVwIHJlZGlyZWN0cyBpbiBtaW5kISlcbiAqXG4gKiAgICAgIHJlcXVlc3QuY29ubmVjdCh7XG4gKiAgICAgICAgJ3Rlc3QuZXhhbXBsZS5jb20nOiAnMTI3LjAuMC4xJyxcbiAqICAgICAgICAnaXB2Ni5leGFtcGxlLmNvbSc6ICc6OjEnLFxuICogICAgICB9KVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGNvbm5lY3RPdmVycmlkZSkge1xuICBpZiAodHlwZW9mIGNvbm5lY3RPdmVycmlkZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9jb25uZWN0T3ZlcnJpZGUgPSB7ICcqJzogY29ubmVjdE92ZXJyaWRlIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbm5lY3RPdmVycmlkZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0aGlzLl9jb25uZWN0T3ZlcnJpZGUgPSBjb25uZWN0T3ZlcnJpZGU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY29ubmVjdE92ZXJyaWRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50cnVzdExvY2FsaG9zdCA9IGZ1bmN0aW9uICh0b2dnbGUpIHtcbiAgdGhpcy5fdHJ1c3RMb2NhbGhvc3QgPSB0b2dnbGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB0b2dnbGU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZ2VuZXJhdGUgSFRUUCB2ZXJiIG1ldGhvZHNcbmlmICghbWV0aG9kcy5pbmNsdWRlcygnZGVsJykpIHtcbiAgLy8gY3JlYXRlIGEgY29weSBzbyB3ZSBkb24ndCBjYXVzZSBjb25mbGljdHMgd2l0aFxuICAvLyBvdGhlciBwYWNrYWdlcyB1c2luZyB0aGUgbWV0aG9kcyBwYWNrYWdlIGFuZFxuICAvLyBucG0gMy54XG4gIG1ldGhvZHMgPSBtZXRob2RzLnNsaWNlKDApO1xuICBtZXRob2RzLnB1c2goJ2RlbCcpO1xufVxuXG5tZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBjb25zdCBuYW1lID0gbWV0aG9kO1xuICBtZXRob2QgPSBtZXRob2QgPT09ICdkZWwnID8gJ2RlbGV0ZScgOiBtZXRob2Q7XG5cbiAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIHJlcXVlc3RbbmFtZV0gPSAodXJsLCBkYXRhLCBmbikgPT4ge1xuICAgIGNvbnN0IHJlcSA9IHJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4gPSBkYXRhO1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIHJlcS5xdWVyeShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcS5zZW5kKGRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmbikgcmVxLmVuZChmbik7XG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyB0ZXh0IGFuZCBzaG91bGQgYmUgYnVmZmVyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGlzVGV4dChtaW1lKSB7XG4gIGNvbnN0IHBhcnRzID0gbWltZS5zcGxpdCgnLycpO1xuICBsZXQgdHlwZSA9IHBhcnRzWzBdO1xuICBpZiAodHlwZSkgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIGxldCBzdWJ0eXBlID0gcGFydHNbMV07XG4gIGlmIChzdWJ0eXBlKSBzdWJ0eXBlID0gc3VidHlwZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICByZXR1cm4gdHlwZSA9PT0gJ3RleHQnIHx8IHN1YnR5cGUgPT09ICd4LXd3dy1mb3JtLXVybGVuY29kZWQnO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlT3JWaWRlbyhtaW1lKSB7XG4gIGxldCB0eXBlID0gbWltZS5zcGxpdCgnLycpWzBdO1xuICBpZiAodHlwZSkgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgcmV0dXJuIHR5cGUgPT09ICdpbWFnZScgfHwgdHlwZSA9PT0gJ3ZpZGVvJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvWy8rXWpzb24oJHxbXi1cXHddKS9pLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2Ugc2hvdWxkIGZvbGxvdyB0aGUgcmVkaXJlY3QgYGNvZGVgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNSZWRpcmVjdChjb2RlKSB7XG4gIHJldHVybiBbMzAxLCAzMDIsIDMwMywgMzA1LCAzMDcsIDMwOF0uaW5jbHVkZXMoY29kZSk7XG59XG4iXX0=

/***/ }),

/***/ 81109:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];


module.exports = function (res, fn) {
  var data = []; // Binary data needs binary storage

  res.on('data', function (chunk) {
    data.push(chunk);
  });
  res.on('end', function () {
    fn(null, Buffer.concat(data));
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ub2RlL3BhcnNlcnMvaW1hZ2UuanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcyIsImZuIiwiZGF0YSIsIm9uIiwiY2h1bmsiLCJwdXNoIiwiQnVmZmVyIiwiY29uY2F0Il0sIm1hcHBpbmdzIjoiOztBQUFBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsVUFBQ0MsR0FBRCxFQUFNQyxFQUFOLEVBQWE7QUFDNUIsTUFBTUMsSUFBSSxHQUFHLEVBQWIsQ0FENEIsQ0FDWDs7QUFFakJGLEVBQUFBLEdBQUcsQ0FBQ0csRUFBSixDQUFPLE1BQVAsRUFBZSxVQUFDQyxLQUFELEVBQVc7QUFDeEJGLElBQUFBLElBQUksQ0FBQ0csSUFBTCxDQUFVRCxLQUFWO0FBQ0QsR0FGRDtBQUdBSixFQUFBQSxHQUFHLENBQUNHLEVBQUosQ0FBTyxLQUFQLEVBQWMsWUFBTTtBQUNsQkYsSUFBQUEsRUFBRSxDQUFDLElBQUQsRUFBT0ssTUFBTSxDQUFDQyxNQUFQLENBQWNMLElBQWQsQ0FBUCxDQUFGO0FBQ0QsR0FGRDtBQUdELENBVEQiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChyZXMsIGZuKSA9PiB7XG4gIGNvbnN0IGRhdGEgPSBbXTsgLy8gQmluYXJ5IGRhdGEgbmVlZHMgYmluYXJ5IHN0b3JhZ2VcblxuICByZXMub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICBkYXRhLnB1c2goY2h1bmspO1xuICB9KTtcbiAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgZm4obnVsbCwgQnVmZmVyLmNvbmNhdChkYXRhKSk7XG4gIH0pO1xufTtcbiJdfQ==

/***/ }),

/***/ 33661:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports["application/x-www-form-urlencoded"] = __webpack_require__(63090);
exports["application/json"] = __webpack_require__(62859);
exports.text = __webpack_require__(6228);

var binary = __webpack_require__(81109);

exports["application/octet-stream"] = binary;
exports["application/pdf"] = binary;
exports.image = binary;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ub2RlL3BhcnNlcnMvaW5kZXguanMiXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlcXVpcmUiLCJ0ZXh0IiwiYmluYXJ5IiwiaW1hZ2UiXSwibWFwcGluZ3MiOiI7O0FBQUFBLE9BQU8sQ0FBQyxtQ0FBRCxDQUFQLEdBQStDQyxPQUFPLENBQUMsY0FBRCxDQUF0RDtBQUNBRCxPQUFPLENBQUMsa0JBQUQsQ0FBUCxHQUE4QkMsT0FBTyxDQUFDLFFBQUQsQ0FBckM7QUFDQUQsT0FBTyxDQUFDRSxJQUFSLEdBQWVELE9BQU8sQ0FBQyxRQUFELENBQXRCOztBQUVBLElBQU1FLE1BQU0sR0FBR0YsT0FBTyxDQUFDLFNBQUQsQ0FBdEI7O0FBRUFELE9BQU8sQ0FBQywwQkFBRCxDQUFQLEdBQXNDRyxNQUF0QztBQUNBSCxPQUFPLENBQUMsaUJBQUQsQ0FBUCxHQUE2QkcsTUFBN0I7QUFDQUgsT0FBTyxDQUFDSSxLQUFSLEdBQWdCRCxNQUFoQiIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHNbJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCddID0gcmVxdWlyZSgnLi91cmxlbmNvZGVkJyk7XG5leHBvcnRzWydhcHBsaWNhdGlvbi9qc29uJ10gPSByZXF1aXJlKCcuL2pzb24nKTtcbmV4cG9ydHMudGV4dCA9IHJlcXVpcmUoJy4vdGV4dCcpO1xuXG5jb25zdCBiaW5hcnkgPSByZXF1aXJlKCcuL2ltYWdlJyk7XG5cbmV4cG9ydHNbJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddID0gYmluYXJ5O1xuZXhwb3J0c1snYXBwbGljYXRpb24vcGRmJ10gPSBiaW5hcnk7XG5leHBvcnRzLmltYWdlID0gYmluYXJ5O1xuIl19

/***/ }),

/***/ 62859:
/***/ ((module) => {

"use strict";


module.exports = function (res, fn) {
  res.text = '';
  res.setEncoding('utf8');
  res.on('data', function (chunk) {
    res.text += chunk;
  });
  res.on('end', function () {
    var body;
    var err;

    try {
      body = res.text && JSON.parse(res.text);
    } catch (err_) {
      err = err_; // issue #675: return the raw response if the response parsing fails

      err.rawResponse = res.text || null; // issue #876: return the http status code if the response parsing fails

      err.statusCode = res.statusCode;
    } finally {
      fn(err, body);
    }
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ub2RlL3BhcnNlcnMvanNvbi5qcyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVzIiwiZm4iLCJ0ZXh0Iiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiYm9keSIsImVyciIsIkpTT04iLCJwYXJzZSIsImVycl8iLCJyYXdSZXNwb25zZSIsInN0YXR1c0NvZGUiXSwibWFwcGluZ3MiOiI7O0FBQUFBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWVDLEVBQWYsRUFBbUI7QUFDbENELEVBQUFBLEdBQUcsQ0FBQ0UsSUFBSixHQUFXLEVBQVg7QUFDQUYsRUFBQUEsR0FBRyxDQUFDRyxXQUFKLENBQWdCLE1BQWhCO0FBQ0FILEVBQUFBLEdBQUcsQ0FBQ0ksRUFBSixDQUFPLE1BQVAsRUFBZSxVQUFDQyxLQUFELEVBQVc7QUFDeEJMLElBQUFBLEdBQUcsQ0FBQ0UsSUFBSixJQUFZRyxLQUFaO0FBQ0QsR0FGRDtBQUdBTCxFQUFBQSxHQUFHLENBQUNJLEVBQUosQ0FBTyxLQUFQLEVBQWMsWUFBTTtBQUNsQixRQUFJRSxJQUFKO0FBQ0EsUUFBSUMsR0FBSjs7QUFDQSxRQUFJO0FBQ0ZELE1BQUFBLElBQUksR0FBR04sR0FBRyxDQUFDRSxJQUFKLElBQVlNLElBQUksQ0FBQ0MsS0FBTCxDQUFXVCxHQUFHLENBQUNFLElBQWYsQ0FBbkI7QUFDRCxLQUZELENBRUUsT0FBT1EsSUFBUCxFQUFhO0FBQ2JILE1BQUFBLEdBQUcsR0FBR0csSUFBTixDQURhLENBRWI7O0FBQ0FILE1BQUFBLEdBQUcsQ0FBQ0ksV0FBSixHQUFrQlgsR0FBRyxDQUFDRSxJQUFKLElBQVksSUFBOUIsQ0FIYSxDQUliOztBQUNBSyxNQUFBQSxHQUFHLENBQUNLLFVBQUosR0FBaUJaLEdBQUcsQ0FBQ1ksVUFBckI7QUFDRCxLQVJELFNBUVU7QUFDUlgsTUFBQUEsRUFBRSxDQUFDTSxHQUFELEVBQU1ELElBQU4sQ0FBRjtBQUNEO0FBQ0YsR0FkRDtBQWVELENBckJEIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVzLCBmbikge1xuICByZXMudGV4dCA9ICcnO1xuICByZXMuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgcmVzLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgcmVzLnRleHQgKz0gY2h1bms7XG4gIH0pO1xuICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICBsZXQgYm9keTtcbiAgICBsZXQgZXJyO1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gcmVzLnRleHQgJiYgSlNPTi5wYXJzZShyZXMudGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyXykge1xuICAgICAgZXJyID0gZXJyXztcbiAgICAgIC8vIGlzc3VlICM2NzU6IHJldHVybiB0aGUgcmF3IHJlc3BvbnNlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICBlcnIucmF3UmVzcG9uc2UgPSByZXMudGV4dCB8fCBudWxsO1xuICAgICAgLy8gaXNzdWUgIzg3NjogcmV0dXJuIHRoZSBodHRwIHN0YXR1cyBjb2RlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICBlcnIuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmbihlcnIsIGJvZHkpO1xuICAgIH1cbiAgfSk7XG59O1xuIl19

/***/ }),

/***/ 6228:
/***/ ((module) => {

"use strict";


module.exports = function (res, fn) {
  res.text = '';
  res.setEncoding('utf8');
  res.on('data', function (chunk) {
    res.text += chunk;
  });
  res.on('end', fn);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ub2RlL3BhcnNlcnMvdGV4dC5qcyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVzIiwiZm4iLCJ0ZXh0Iiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIl0sIm1hcHBpbmdzIjoiOztBQUFBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsVUFBQ0MsR0FBRCxFQUFNQyxFQUFOLEVBQWE7QUFDNUJELEVBQUFBLEdBQUcsQ0FBQ0UsSUFBSixHQUFXLEVBQVg7QUFDQUYsRUFBQUEsR0FBRyxDQUFDRyxXQUFKLENBQWdCLE1BQWhCO0FBQ0FILEVBQUFBLEdBQUcsQ0FBQ0ksRUFBSixDQUFPLE1BQVAsRUFBZSxVQUFDQyxLQUFELEVBQVc7QUFDeEJMLElBQUFBLEdBQUcsQ0FBQ0UsSUFBSixJQUFZRyxLQUFaO0FBQ0QsR0FGRDtBQUdBTCxFQUFBQSxHQUFHLENBQUNJLEVBQUosQ0FBTyxLQUFQLEVBQWNILEVBQWQ7QUFDRCxDQVBEIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAocmVzLCBmbikgPT4ge1xuICByZXMudGV4dCA9ICcnO1xuICByZXMuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgcmVzLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgcmVzLnRleHQgKz0gY2h1bms7XG4gIH0pO1xuICByZXMub24oJ2VuZCcsIGZuKTtcbn07XG4iXX0=

/***/ }),

/***/ 63090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */
var qs = __webpack_require__(19126);

module.exports = function (res, fn) {
  res.text = '';
  res.setEncoding('ascii');
  res.on('data', function (chunk) {
    res.text += chunk;
  });
  res.on('end', function () {
    try {
      fn(null, qs.parse(res.text));
    } catch (err) {
      fn(err);
    }
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ub2RlL3BhcnNlcnMvdXJsZW5jb2RlZC5qcyJdLCJuYW1lcyI6WyJxcyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVzIiwiZm4iLCJ0ZXh0Iiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwicGFyc2UiLCJlcnIiXSwibWFwcGluZ3MiOiI7O0FBQUE7OztBQUlBLElBQU1BLEVBQUUsR0FBR0MsT0FBTyxDQUFDLElBQUQsQ0FBbEI7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFDQyxHQUFELEVBQU1DLEVBQU4sRUFBYTtBQUM1QkQsRUFBQUEsR0FBRyxDQUFDRSxJQUFKLEdBQVcsRUFBWDtBQUNBRixFQUFBQSxHQUFHLENBQUNHLFdBQUosQ0FBZ0IsT0FBaEI7QUFDQUgsRUFBQUEsR0FBRyxDQUFDSSxFQUFKLENBQU8sTUFBUCxFQUFlLFVBQUNDLEtBQUQsRUFBVztBQUN4QkwsSUFBQUEsR0FBRyxDQUFDRSxJQUFKLElBQVlHLEtBQVo7QUFDRCxHQUZEO0FBR0FMLEVBQUFBLEdBQUcsQ0FBQ0ksRUFBSixDQUFPLEtBQVAsRUFBYyxZQUFNO0FBQ2xCLFFBQUk7QUFDRkgsTUFBQUEsRUFBRSxDQUFDLElBQUQsRUFBT0wsRUFBRSxDQUFDVSxLQUFILENBQVNOLEdBQUcsQ0FBQ0UsSUFBYixDQUFQLENBQUY7QUFDRCxLQUZELENBRUUsT0FBT0ssR0FBUCxFQUFZO0FBQ1pOLE1BQUFBLEVBQUUsQ0FBQ00sR0FBRCxDQUFGO0FBQ0Q7QUFDRixHQU5EO0FBT0QsQ0FiRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBxcyA9IHJlcXVpcmUoJ3FzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHJlcywgZm4pID0+IHtcbiAgcmVzLnRleHQgPSAnJztcbiAgcmVzLnNldEVuY29kaW5nKCdhc2NpaScpO1xuICByZXMub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICByZXMudGV4dCArPSBjaHVuaztcbiAgfSk7XG4gIHJlcy5vbignZW5kJywgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmbihudWxsLCBxcy5wYXJzZShyZXMudGV4dCkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZm4oZXJyKTtcbiAgICB9XG4gIH0pO1xufTtcbiJdfQ==

/***/ }),

/***/ 90459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */
var util = __webpack_require__(73837);

var Stream = __webpack_require__(12781);

var ResponseBase = __webpack_require__(99228);
/**
 * Expose `Response`.
 */


module.exports = Response;
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * @param {Request} req
 * @param {Object} options
 * @constructor
 * @extends {Stream}
 * @implements {ReadableStream}
 * @api private
 */

function Response(req) {
  Stream.call(this);
  this.res = req.res;
  var res = this.res;
  this.request = req;
  this.req = req.req;
  this.text = res.text;
  this.body = res.body === undefined ? {} : res.body;
  this.files = res.files || {};
  this.buffered = req._resBuffered;
  this.headers = res.headers;
  this.header = this.headers;

  this._setStatusProperties(res.statusCode);

  this._setHeaderProperties(this.header);

  this.setEncoding = res.setEncoding.bind(res);
  res.on('data', this.emit.bind(this, 'data'));
  res.on('end', this.emit.bind(this, 'end'));
  res.on('close', this.emit.bind(this, 'close'));
  res.on('error', this.emit.bind(this, 'error'));
}
/**
 * Inherit from `Stream`.
 */


util.inherits(Response, Stream); // eslint-disable-next-line new-cap

ResponseBase(Response.prototype);
/**
 * Implements methods of a `ReadableStream`
 */

Response.prototype.destroy = function (err) {
  this.res.destroy(err);
};
/**
 * Pause.
 */


Response.prototype.pause = function () {
  this.res.pause();
};
/**
 * Resume.
 */


Response.prototype.resume = function () {
  this.res.resume();
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var path = req.path;
  var msg = "cannot ".concat(method, " ").concat(path, " (").concat(this.status, ")");
  var err = new Error(msg);
  err.status = this.status;
  err.text = this.text;
  err.method = method;
  err.path = path;
  return err;
};

Response.prototype.setStatusProperties = function (status) {
  console.warn('In superagent 2.x setStatusProperties is a private method');
  return this._setStatusProperties(status);
};
/**
 * To json.
 *
 * @return {Object}
 * @api public
 */


Response.prototype.toJSON = function () {
  return {
    req: this.request.toJSON(),
    header: this.header,
    status: this.status,
    text: this.text
  };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL3Jlc3BvbnNlLmpzIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiU3RyZWFtIiwiUmVzcG9uc2VCYXNlIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlc3BvbnNlIiwicmVxIiwiY2FsbCIsInJlcyIsInJlcXVlc3QiLCJ0ZXh0IiwiYm9keSIsInVuZGVmaW5lZCIsImZpbGVzIiwiYnVmZmVyZWQiLCJfcmVzQnVmZmVyZWQiLCJoZWFkZXJzIiwiaGVhZGVyIiwiX3NldFN0YXR1c1Byb3BlcnRpZXMiLCJzdGF0dXNDb2RlIiwiX3NldEhlYWRlclByb3BlcnRpZXMiLCJzZXRFbmNvZGluZyIsImJpbmQiLCJvbiIsImVtaXQiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImRlc3Ryb3kiLCJlcnIiLCJwYXVzZSIsInJlc3VtZSIsInRvRXJyb3IiLCJtZXRob2QiLCJwYXRoIiwibXNnIiwic3RhdHVzIiwiRXJyb3IiLCJzZXRTdGF0dXNQcm9wZXJ0aWVzIiwiY29uc29sZSIsIndhcm4iLCJ0b0pTT04iXSwibWFwcGluZ3MiOiI7O0FBQUE7OztBQUlBLElBQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsSUFBTUMsTUFBTSxHQUFHRCxPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFDQSxJQUFNRSxZQUFZLEdBQUdGLE9BQU8sQ0FBQyxrQkFBRCxDQUE1QjtBQUVBOzs7OztBQUlBRyxNQUFNLENBQUNDLE9BQVAsR0FBaUJDLFFBQWpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBU0EsUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDckJMLEVBQUFBLE1BQU0sQ0FBQ00sSUFBUCxDQUFZLElBQVo7QUFDQSxPQUFLQyxHQUFMLEdBQVdGLEdBQUcsQ0FBQ0UsR0FBZjtBQUZxQixNQUdiQSxHQUhhLEdBR0wsSUFISyxDQUdiQSxHQUhhO0FBSXJCLE9BQUtDLE9BQUwsR0FBZUgsR0FBZjtBQUNBLE9BQUtBLEdBQUwsR0FBV0EsR0FBRyxDQUFDQSxHQUFmO0FBQ0EsT0FBS0ksSUFBTCxHQUFZRixHQUFHLENBQUNFLElBQWhCO0FBQ0EsT0FBS0MsSUFBTCxHQUFZSCxHQUFHLENBQUNHLElBQUosS0FBYUMsU0FBYixHQUF5QixFQUF6QixHQUE4QkosR0FBRyxDQUFDRyxJQUE5QztBQUNBLE9BQUtFLEtBQUwsR0FBYUwsR0FBRyxDQUFDSyxLQUFKLElBQWEsRUFBMUI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCUixHQUFHLENBQUNTLFlBQXBCO0FBQ0EsT0FBS0MsT0FBTCxHQUFlUixHQUFHLENBQUNRLE9BQW5CO0FBQ0EsT0FBS0MsTUFBTCxHQUFjLEtBQUtELE9BQW5COztBQUNBLE9BQUtFLG9CQUFMLENBQTBCVixHQUFHLENBQUNXLFVBQTlCOztBQUNBLE9BQUtDLG9CQUFMLENBQTBCLEtBQUtILE1BQS9COztBQUNBLE9BQUtJLFdBQUwsR0FBbUJiLEdBQUcsQ0FBQ2EsV0FBSixDQUFnQkMsSUFBaEIsQ0FBcUJkLEdBQXJCLENBQW5CO0FBQ0FBLEVBQUFBLEdBQUcsQ0FBQ2UsRUFBSixDQUFPLE1BQVAsRUFBZSxLQUFLQyxJQUFMLENBQVVGLElBQVYsQ0FBZSxJQUFmLEVBQXFCLE1BQXJCLENBQWY7QUFDQWQsRUFBQUEsR0FBRyxDQUFDZSxFQUFKLENBQU8sS0FBUCxFQUFjLEtBQUtDLElBQUwsQ0FBVUYsSUFBVixDQUFlLElBQWYsRUFBcUIsS0FBckIsQ0FBZDtBQUNBZCxFQUFBQSxHQUFHLENBQUNlLEVBQUosQ0FBTyxPQUFQLEVBQWdCLEtBQUtDLElBQUwsQ0FBVUYsSUFBVixDQUFlLElBQWYsRUFBcUIsT0FBckIsQ0FBaEI7QUFDQWQsRUFBQUEsR0FBRyxDQUFDZSxFQUFKLENBQU8sT0FBUCxFQUFnQixLQUFLQyxJQUFMLENBQVVGLElBQVYsQ0FBZSxJQUFmLEVBQXFCLE9BQXJCLENBQWhCO0FBQ0Q7QUFFRDs7Ozs7QUFJQXZCLElBQUksQ0FBQzBCLFFBQUwsQ0FBY3BCLFFBQWQsRUFBd0JKLE1BQXhCLEUsQ0FDQTs7QUFDQUMsWUFBWSxDQUFDRyxRQUFRLENBQUNxQixTQUFWLENBQVo7QUFFQTs7OztBQUlBckIsUUFBUSxDQUFDcUIsU0FBVCxDQUFtQkMsT0FBbkIsR0FBNkIsVUFBVUMsR0FBVixFQUFlO0FBQzFDLE9BQUtwQixHQUFMLENBQVNtQixPQUFULENBQWlCQyxHQUFqQjtBQUNELENBRkQ7QUFJQTs7Ozs7QUFJQXZCLFFBQVEsQ0FBQ3FCLFNBQVQsQ0FBbUJHLEtBQW5CLEdBQTJCLFlBQVk7QUFDckMsT0FBS3JCLEdBQUwsQ0FBU3FCLEtBQVQ7QUFDRCxDQUZEO0FBSUE7Ozs7O0FBSUF4QixRQUFRLENBQUNxQixTQUFULENBQW1CSSxNQUFuQixHQUE0QixZQUFZO0FBQ3RDLE9BQUt0QixHQUFMLENBQVNzQixNQUFUO0FBQ0QsQ0FGRDtBQUlBOzs7Ozs7OztBQU9BekIsUUFBUSxDQUFDcUIsU0FBVCxDQUFtQkssT0FBbkIsR0FBNkIsWUFBWTtBQUFBLE1BQy9CekIsR0FEK0IsR0FDdkIsSUFEdUIsQ0FDL0JBLEdBRCtCO0FBQUEsTUFFL0IwQixNQUYrQixHQUVwQjFCLEdBRm9CLENBRS9CMEIsTUFGK0I7QUFBQSxNQUcvQkMsSUFIK0IsR0FHdEIzQixHQUhzQixDQUcvQjJCLElBSCtCO0FBS3ZDLE1BQU1DLEdBQUcsb0JBQWFGLE1BQWIsY0FBdUJDLElBQXZCLGVBQWdDLEtBQUtFLE1BQXJDLE1BQVQ7QUFDQSxNQUFNUCxHQUFHLEdBQUcsSUFBSVEsS0FBSixDQUFVRixHQUFWLENBQVo7QUFDQU4sRUFBQUEsR0FBRyxDQUFDTyxNQUFKLEdBQWEsS0FBS0EsTUFBbEI7QUFDQVAsRUFBQUEsR0FBRyxDQUFDbEIsSUFBSixHQUFXLEtBQUtBLElBQWhCO0FBQ0FrQixFQUFBQSxHQUFHLENBQUNJLE1BQUosR0FBYUEsTUFBYjtBQUNBSixFQUFBQSxHQUFHLENBQUNLLElBQUosR0FBV0EsSUFBWDtBQUVBLFNBQU9MLEdBQVA7QUFDRCxDQWJEOztBQWVBdkIsUUFBUSxDQUFDcUIsU0FBVCxDQUFtQlcsbUJBQW5CLEdBQXlDLFVBQVVGLE1BQVYsRUFBa0I7QUFDekRHLEVBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLDJEQUFiO0FBQ0EsU0FBTyxLQUFLckIsb0JBQUwsQ0FBMEJpQixNQUExQixDQUFQO0FBQ0QsQ0FIRDtBQUtBOzs7Ozs7OztBQU9BOUIsUUFBUSxDQUFDcUIsU0FBVCxDQUFtQmMsTUFBbkIsR0FBNEIsWUFBWTtBQUN0QyxTQUFPO0FBQ0xsQyxJQUFBQSxHQUFHLEVBQUUsS0FBS0csT0FBTCxDQUFhK0IsTUFBYixFQURBO0FBRUx2QixJQUFBQSxNQUFNLEVBQUUsS0FBS0EsTUFGUjtBQUdMa0IsSUFBQUEsTUFBTSxFQUFFLEtBQUtBLE1BSFI7QUFJTHpCLElBQUFBLElBQUksRUFBRSxLQUFLQTtBQUpOLEdBQVA7QUFNRCxDQVBEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IFJlc3BvbnNlQmFzZSA9IHJlcXVpcmUoJy4uL3Jlc3BvbnNlLWJhc2UnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1N0cmVhbX1cbiAqIEBpbXBsZW1lbnRzIHtSZWFkYWJsZVN0cmVhbX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgdGhpcy5yZXMgPSByZXEucmVzO1xuICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxO1xuICB0aGlzLnJlcSA9IHJlcS5yZXE7XG4gIHRoaXMudGV4dCA9IHJlcy50ZXh0O1xuICB0aGlzLmJvZHkgPSByZXMuYm9keSA9PT0gdW5kZWZpbmVkID8ge30gOiByZXMuYm9keTtcbiAgdGhpcy5maWxlcyA9IHJlcy5maWxlcyB8fCB7fTtcbiAgdGhpcy5idWZmZXJlZCA9IHJlcS5fcmVzQnVmZmVyZWQ7XG4gIHRoaXMuaGVhZGVycyA9IHJlcy5oZWFkZXJzO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycztcbiAgdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyhyZXMuc3RhdHVzQ29kZSk7XG4gIHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuICB0aGlzLnNldEVuY29kaW5nID0gcmVzLnNldEVuY29kaW5nLmJpbmQocmVzKTtcbiAgcmVzLm9uKCdkYXRhJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2RhdGEnKSk7XG4gIHJlcy5vbignZW5kJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2VuZCcpKTtcbiAgcmVzLm9uKCdjbG9zZScsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdjbG9zZScpKTtcbiAgcmVzLm9uKCdlcnJvcicsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFN0cmVhbWAuXG4gKi9cblxudXRpbC5pbmhlcml0cyhSZXNwb25zZSwgU3RyZWFtKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5SZXNwb25zZUJhc2UoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIG1ldGhvZHMgb2YgYSBgUmVhZGFibGVTdHJlYW1gXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMucmVzLmRlc3Ryb3koZXJyKTtcbn07XG5cbi8qKlxuICogUGF1c2UuXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlcy5wYXVzZSgpO1xufTtcblxuLyoqXG4gKiBSZXN1bWUuXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXMucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBgRXJyb3JgIHJlcHJlc2VudGF0aXZlIG9mIHRoaXMgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybiB7RXJyb3J9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS50b0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB7IHJlcSB9ID0gdGhpcztcbiAgY29uc3QgeyBtZXRob2QgfSA9IHJlcTtcbiAgY29uc3QgeyBwYXRoIH0gPSByZXE7XG5cbiAgY29uc3QgbXNnID0gYGNhbm5vdCAke21ldGhvZH0gJHtwYXRofSAoJHt0aGlzLnN0YXR1c30pYDtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLnRleHQgPSB0aGlzLnRleHQ7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci5wYXRoID0gcGF0aDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLnNldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIGNvbnNvbGUud2FybignSW4gc3VwZXJhZ2VudCAyLnggc2V0U3RhdHVzUHJvcGVydGllcyBpcyBhIHByaXZhdGUgbWV0aG9kJyk7XG4gIHJldHVybiB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG59O1xuXG4vKipcbiAqIFRvIGpzb24uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHJlcTogdGhpcy5yZXF1ZXN0LnRvSlNPTigpLFxuICAgIGhlYWRlcjogdGhpcy5oZWFkZXIsXG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICB0ZXh0OiB0aGlzLnRleHRcbiAgfTtcbn07XG4iXX0=

/***/ }),

/***/ 34208:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */
var _require = __webpack_require__(71576),
    StringDecoder = _require.StringDecoder;

var Stream = __webpack_require__(12781);

var zlib = __webpack_require__(59796);
/**
 * Buffers response data events and re-emits when they're unzipped.
 *
 * @param {Request} req
 * @param {Response} res
 * @api private
 */


exports.unzip = function (req, res) {
  var unzip = zlib.createUnzip();
  var stream = new Stream();
  var decoder; // make node responseOnEnd() happy

  stream.req = req;
  unzip.on('error', function (err) {
    if (err && err.code === 'Z_BUF_ERROR') {
      // unexpected end of file is ignored by browsers and curl
      stream.emit('end');
      return;
    }

    stream.emit('error', err);
  }); // pipe to unzip

  res.pipe(unzip); // override `setEncoding` to capture encoding

  res.setEncoding = function (type) {
    decoder = new StringDecoder(type);
  }; // decode upon decompressing with captured encoding


  unzip.on('data', function (buf) {
    if (decoder) {
      var str = decoder.write(buf);
      if (str.length > 0) stream.emit('data', str);
    } else {
      stream.emit('data', buf);
    }
  });
  unzip.on('end', function () {
    stream.emit('end');
  }); // override `on` to capture data listeners

  var _on = res.on;

  res.on = function (type, fn) {
    if (type === 'data' || type === 'end') {
      stream.on(type, fn.bind(res));
    } else if (type === 'error') {
      stream.on(type, fn.bind(res));

      _on.call(res, type, fn);
    } else {
      _on.call(res, type, fn);
    }

    return this;
  };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL3VuemlwLmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJTdHJpbmdEZWNvZGVyIiwiU3RyZWFtIiwiemxpYiIsImV4cG9ydHMiLCJ1bnppcCIsInJlcSIsInJlcyIsImNyZWF0ZVVuemlwIiwic3RyZWFtIiwiZGVjb2RlciIsIm9uIiwiZXJyIiwiY29kZSIsImVtaXQiLCJwaXBlIiwic2V0RW5jb2RpbmciLCJ0eXBlIiwiYnVmIiwic3RyIiwid3JpdGUiLCJsZW5ndGgiLCJfb24iLCJmbiIsImJpbmQiLCJjYWxsIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7ZUFJMEJBLE9BQU8sQ0FBQyxnQkFBRCxDO0lBQXpCQyxhLFlBQUFBLGE7O0FBQ1IsSUFBTUMsTUFBTSxHQUFHRixPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFDQSxJQUFNRyxJQUFJLEdBQUdILE9BQU8sQ0FBQyxNQUFELENBQXBCO0FBRUE7Ozs7Ozs7OztBQVFBSSxPQUFPLENBQUNDLEtBQVIsR0FBZ0IsVUFBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQWM7QUFDNUIsTUFBTUYsS0FBSyxHQUFHRixJQUFJLENBQUNLLFdBQUwsRUFBZDtBQUNBLE1BQU1DLE1BQU0sR0FBRyxJQUFJUCxNQUFKLEVBQWY7QUFDQSxNQUFJUSxPQUFKLENBSDRCLENBSzVCOztBQUNBRCxFQUFBQSxNQUFNLENBQUNILEdBQVAsR0FBYUEsR0FBYjtBQUVBRCxFQUFBQSxLQUFLLENBQUNNLEVBQU4sQ0FBUyxPQUFULEVBQWtCLFVBQUNDLEdBQUQsRUFBUztBQUN6QixRQUFJQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsSUFBSixLQUFhLGFBQXhCLEVBQXVDO0FBQ3JDO0FBQ0FKLE1BQUFBLE1BQU0sQ0FBQ0ssSUFBUCxDQUFZLEtBQVo7QUFDQTtBQUNEOztBQUVETCxJQUFBQSxNQUFNLENBQUNLLElBQVAsQ0FBWSxPQUFaLEVBQXFCRixHQUFyQjtBQUNELEdBUkQsRUFSNEIsQ0FrQjVCOztBQUNBTCxFQUFBQSxHQUFHLENBQUNRLElBQUosQ0FBU1YsS0FBVCxFQW5CNEIsQ0FxQjVCOztBQUNBRSxFQUFBQSxHQUFHLENBQUNTLFdBQUosR0FBa0IsVUFBQ0MsSUFBRCxFQUFVO0FBQzFCUCxJQUFBQSxPQUFPLEdBQUcsSUFBSVQsYUFBSixDQUFrQmdCLElBQWxCLENBQVY7QUFDRCxHQUZELENBdEI0QixDQTBCNUI7OztBQUNBWixFQUFBQSxLQUFLLENBQUNNLEVBQU4sQ0FBUyxNQUFULEVBQWlCLFVBQUNPLEdBQUQsRUFBUztBQUN4QixRQUFJUixPQUFKLEVBQWE7QUFDWCxVQUFNUyxHQUFHLEdBQUdULE9BQU8sQ0FBQ1UsS0FBUixDQUFjRixHQUFkLENBQVo7QUFDQSxVQUFJQyxHQUFHLENBQUNFLE1BQUosR0FBYSxDQUFqQixFQUFvQlosTUFBTSxDQUFDSyxJQUFQLENBQVksTUFBWixFQUFvQkssR0FBcEI7QUFDckIsS0FIRCxNQUdPO0FBQ0xWLE1BQUFBLE1BQU0sQ0FBQ0ssSUFBUCxDQUFZLE1BQVosRUFBb0JJLEdBQXBCO0FBQ0Q7QUFDRixHQVBEO0FBU0FiLEVBQUFBLEtBQUssQ0FBQ00sRUFBTixDQUFTLEtBQVQsRUFBZ0IsWUFBTTtBQUNwQkYsSUFBQUEsTUFBTSxDQUFDSyxJQUFQLENBQVksS0FBWjtBQUNELEdBRkQsRUFwQzRCLENBd0M1Qjs7QUFDQSxNQUFNUSxHQUFHLEdBQUdmLEdBQUcsQ0FBQ0ksRUFBaEI7O0FBQ0FKLEVBQUFBLEdBQUcsQ0FBQ0ksRUFBSixHQUFTLFVBQVVNLElBQVYsRUFBZ0JNLEVBQWhCLEVBQW9CO0FBQzNCLFFBQUlOLElBQUksS0FBSyxNQUFULElBQW1CQSxJQUFJLEtBQUssS0FBaEMsRUFBdUM7QUFDckNSLE1BQUFBLE1BQU0sQ0FBQ0UsRUFBUCxDQUFVTSxJQUFWLEVBQWdCTSxFQUFFLENBQUNDLElBQUgsQ0FBUWpCLEdBQVIsQ0FBaEI7QUFDRCxLQUZELE1BRU8sSUFBSVUsSUFBSSxLQUFLLE9BQWIsRUFBc0I7QUFDM0JSLE1BQUFBLE1BQU0sQ0FBQ0UsRUFBUCxDQUFVTSxJQUFWLEVBQWdCTSxFQUFFLENBQUNDLElBQUgsQ0FBUWpCLEdBQVIsQ0FBaEI7O0FBQ0FlLE1BQUFBLEdBQUcsQ0FBQ0csSUFBSixDQUFTbEIsR0FBVCxFQUFjVSxJQUFkLEVBQW9CTSxFQUFwQjtBQUNELEtBSE0sTUFHQTtBQUNMRCxNQUFBQSxHQUFHLENBQUNHLElBQUosQ0FBU2xCLEdBQVQsRUFBY1UsSUFBZCxFQUFvQk0sRUFBcEI7QUFDRDs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQVhEO0FBWUQsQ0F0REQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgeyBTdHJpbmdEZWNvZGVyIH0gPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG4vKipcbiAqIEJ1ZmZlcnMgcmVzcG9uc2UgZGF0YSBldmVudHMgYW5kIHJlLWVtaXRzIHdoZW4gdGhleSdyZSB1bnppcHBlZC5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcVxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnVuemlwID0gKHJlcSwgcmVzKSA9PiB7XG4gIGNvbnN0IHVuemlwID0gemxpYi5jcmVhdGVVbnppcCgpO1xuICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKCk7XG4gIGxldCBkZWNvZGVyO1xuXG4gIC8vIG1ha2Ugbm9kZSByZXNwb25zZU9uRW5kKCkgaGFwcHlcbiAgc3RyZWFtLnJlcSA9IHJlcTtcblxuICB1bnppcC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ1pfQlVGX0VSUk9SJykge1xuICAgICAgLy8gdW5leHBlY3RlZCBlbmQgb2YgZmlsZSBpcyBpZ25vcmVkIGJ5IGJyb3dzZXJzIGFuZCBjdXJsXG4gICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSk7XG5cbiAgLy8gcGlwZSB0byB1bnppcFxuICByZXMucGlwZSh1bnppcCk7XG5cbiAgLy8gb3ZlcnJpZGUgYHNldEVuY29kaW5nYCB0byBjYXB0dXJlIGVuY29kaW5nXG4gIHJlcy5zZXRFbmNvZGluZyA9ICh0eXBlKSA9PiB7XG4gICAgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKHR5cGUpO1xuICB9O1xuXG4gIC8vIGRlY29kZSB1cG9uIGRlY29tcHJlc3Npbmcgd2l0aCBjYXB0dXJlZCBlbmNvZGluZ1xuICB1bnppcC5vbignZGF0YScsIChidWYpID0+IHtcbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgY29uc3Qgc3RyID0gZGVjb2Rlci53cml0ZShidWYpO1xuICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSBzdHJlYW0uZW1pdCgnZGF0YScsIHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYnVmKTtcbiAgICB9XG4gIH0pO1xuXG4gIHVuemlwLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9KTtcblxuICAvLyBvdmVycmlkZSBgb25gIHRvIGNhcHR1cmUgZGF0YSBsaXN0ZW5lcnNcbiAgY29uc3QgX29uID0gcmVzLm9uO1xuICByZXMub24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICBpZiAodHlwZSA9PT0gJ2RhdGEnIHx8IHR5cGUgPT09ICdlbmQnKSB7XG4gICAgICBzdHJlYW0ub24odHlwZSwgZm4uYmluZChyZXMpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHN0cmVhbS5vbih0eXBlLCBmbi5iaW5kKHJlcykpO1xuICAgICAgX29uLmNhbGwocmVzLCB0eXBlLCBmbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9vbi5jYWxsKHJlcywgdHlwZSwgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdfQ==

/***/ }),

/***/ 2474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = __webpack_require__(73354);
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(object) {
  if (object) return mixin(object);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(object) {
  for (var key in RequestBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key)) object[key] = RequestBase.prototype[key];
  }

  return object;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function () {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function (fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (value) {
  this._responseType = value;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function (fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 * - upload is the time  since last bit of data was sent or received. This timeout works only if deadline timeout is off
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function (options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }

  for (var option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      switch (option) {
        case 'deadline':
          this._timeout = options.deadline;
          break;

        case 'response':
          this._responseTimeout = options.response;
          break;

        case 'upload':
          this._uploadTimeout = options.upload;
          break;

        default:
          console.warn('Unknown timeout option', option);
      }
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function (count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
}; //
// NOTE: we do not include ESOCKETTIMEDOUT because that is from `request` package
//       <https://github.com/sindresorhus/got/pull/537>
//
// NOTE: we do not include EADDRINFO because it was removed from libuv in 2014
//       <https://github.com/libuv/libuv/commit/02e1ebd40b807be5af46343ea873331b2ee4e9c1>
//       <https://github.com/request/request/search?q=ESOCKETTIMEDOUT&unscoped_q=ESOCKETTIMEDOUT>
//
//
// TODO: expose these as configurable defaults
//


var ERROR_CODES = new Set(['ETIMEDOUT', 'ECONNRESET', 'EADDRINUSE', 'ECONNREFUSED', 'EPIPE', 'ENOTFOUND', 'ENETUNREACH', 'EAI_AGAIN']);
var STATUS_CODES = new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]); // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)
// const METHODS = new Set(['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE']);

/**
 * Determine if a request should be retried.
 * (Inspired by https://github.com/sindresorhus/got#retry)
 *
 * @param {Error} err an error
 * @param {Response} [res] response
 * @returns {Boolean} if segment should be retried
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (err_) {
      console.error(err_);
    }
  } // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)

  /*
  if (
    this.req &&
    this.req.method &&
    !METHODS.has(this.req.method.toUpperCase())
  )
    return false;
  */


  if (res && res.status && STATUS_CODES.has(res.status)) return true;

  if (err) {
    if (err.code && ERROR_CODES.has(err.code)) return true; // Superagent timeout

    if (err.timeout && err.code === 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  this.timedoutError = null;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function (resolve, reject) {
  var _this = this;

  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (resolve, reject) {
      self.on('abort', function () {
        if (_this._maxRetries && _this._maxRetries > _this._retries) {
          return;
        }

        if (_this.timedout && _this.timedoutError) {
          reject(_this.timedoutError);
          return;
        }

        var err = new Error('Aborted');
        err.code = 'ABORTED';
        err.status = _this.status;
        err.method = _this.method;
        err.url = _this.url;
        reject(err);
      });
      self.end(function (err, res) {
        if (err) reject(err);else resolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function (fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if (typeof cb !== 'function') throw new Error('Callback required');
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, value) {
  if (isObject(field)) {
    for (var key in field) {
      if (Object.prototype.hasOwnProperty.call(field, key)) this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = value;
  this.header[field] = value;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field field name
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name name of field
 * @param {String|Blob|File|Buffer|fs.ReadStream} val value of field
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, value) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      if (Object.prototype.hasOwnProperty.call(name, key)) this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(value)) {
    for (var i in value) {
      if (Object.prototype.hasOwnProperty.call(value, i)) this.field(name, value[i]);
    }

    return this;
  } // val should be defined now


  if (value === null || undefined === value) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof value === 'boolean') {
    value = String(value);
  }

  this._getFormData().append(name, value);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request} request
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  if (this.xhr) this.xhr.abort(); // browser

  if (this.req) this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;

    default:
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on === undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does nothing in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n number of bytes
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */
// eslint-disable-next-line complexity


RequestBase.prototype.send = function (data) {
  var isObject_ = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject_ && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObject_ && isObject(this._data)) {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) this._data[key] = data[key];
    }
  } else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if (type) type = type.toLowerCase().trim();

    if (type === 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObject_ || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.includes('?') ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArray = this.url.slice(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArray.sort(this._sort);
      } else {
        queryArray.sort();
      }

      this.url = this.url.slice(0, index) + '?' + queryArray.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.warn('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error("".concat(reason + timeout, "ms exceeded"));
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.timedoutError = err;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXF1ZXN0LWJhc2UuanMiXSwibmFtZXMiOlsiaXNPYmplY3QiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlcXVlc3RCYXNlIiwib2JqZWN0IiwibWl4aW4iLCJrZXkiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjbGVhclRpbWVvdXQiLCJfdGltZXIiLCJfcmVzcG9uc2VUaW1lb3V0VGltZXIiLCJfdXBsb2FkVGltZW91dFRpbWVyIiwicGFyc2UiLCJmbiIsIl9wYXJzZXIiLCJyZXNwb25zZVR5cGUiLCJ2YWx1ZSIsIl9yZXNwb25zZVR5cGUiLCJzZXJpYWxpemUiLCJfc2VyaWFsaXplciIsInRpbWVvdXQiLCJvcHRpb25zIiwiX3RpbWVvdXQiLCJfcmVzcG9uc2VUaW1lb3V0IiwiX3VwbG9hZFRpbWVvdXQiLCJvcHRpb24iLCJkZWFkbGluZSIsInJlc3BvbnNlIiwidXBsb2FkIiwiY29uc29sZSIsIndhcm4iLCJyZXRyeSIsImNvdW50IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX21heFJldHJpZXMiLCJfcmV0cmllcyIsIl9yZXRyeUNhbGxiYWNrIiwiRVJST1JfQ09ERVMiLCJTZXQiLCJTVEFUVVNfQ09ERVMiLCJfc2hvdWxkUmV0cnkiLCJlcnIiLCJyZXMiLCJvdmVycmlkZSIsImVycl8iLCJlcnJvciIsInN0YXR1cyIsImhhcyIsImNvZGUiLCJjcm9zc0RvbWFpbiIsIl9yZXRyeSIsInJlcSIsInJlcXVlc3QiLCJfYWJvcnRlZCIsInRpbWVkb3V0IiwidGltZWRvdXRFcnJvciIsIl9lbmQiLCJ0aGVuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9mdWxsZmlsbGVkUHJvbWlzZSIsInNlbGYiLCJfZW5kQ2FsbGVkIiwiUHJvbWlzZSIsIm9uIiwiRXJyb3IiLCJtZXRob2QiLCJ1cmwiLCJlbmQiLCJjYXRjaCIsImNiIiwidW5kZWZpbmVkIiwidXNlIiwib2siLCJfb2tDYWxsYmFjayIsIl9pc1Jlc3BvbnNlT0siLCJnZXQiLCJmaWVsZCIsIl9oZWFkZXIiLCJ0b0xvd2VyQ2FzZSIsImdldEhlYWRlciIsInNldCIsImhlYWRlciIsInVuc2V0IiwibmFtZSIsIl9kYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiaSIsIlN0cmluZyIsIl9nZXRGb3JtRGF0YSIsImFwcGVuZCIsImFib3J0IiwieGhyIiwiZW1pdCIsIl9hdXRoIiwidXNlciIsInBhc3MiLCJiYXNlNjRFbmNvZGVyIiwidHlwZSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ3aXRoQ3JlZGVudGlhbHMiLCJfd2l0aENyZWRlbnRpYWxzIiwicmVkaXJlY3RzIiwibiIsIl9tYXhSZWRpcmVjdHMiLCJtYXhSZXNwb25zZVNpemUiLCJUeXBlRXJyb3IiLCJfbWF4UmVzcG9uc2VTaXplIiwidG9KU09OIiwiZGF0YSIsImhlYWRlcnMiLCJzZW5kIiwiaXNPYmplY3RfIiwiX2Zvcm1EYXRhIiwiX2lzSG9zdCIsInRyaW0iLCJzb3J0UXVlcnkiLCJzb3J0IiwiX3NvcnQiLCJfZmluYWxpemVRdWVyeVN0cmluZyIsInF1ZXJ5IiwiX3F1ZXJ5Iiwiam9pbiIsImluY2x1ZGVzIiwiaW5kZXgiLCJpbmRleE9mIiwicXVlcnlBcnJheSIsInNsaWNlIiwic3BsaXQiLCJfYXBwZW5kUXVlcnlTdHJpbmciLCJfdGltZW91dEVycm9yIiwicmVhc29uIiwiZXJybm8iLCJjYWxsYmFjayIsIl9zZXRUaW1lb3V0cyIsInNldFRpbWVvdXQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FBR0EsSUFBTUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsYUFBRCxDQUF4QjtBQUVBOzs7OztBQUlBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJDLFdBQWpCO0FBRUE7Ozs7OztBQU1BLFNBQVNBLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCO0FBQzNCLE1BQUlBLE1BQUosRUFBWSxPQUFPQyxLQUFLLENBQUNELE1BQUQsQ0FBWjtBQUNiO0FBRUQ7Ozs7Ozs7OztBQVFBLFNBQVNDLEtBQVQsQ0FBZUQsTUFBZixFQUF1QjtBQUNyQixPQUFLLElBQU1FLEdBQVgsSUFBa0JILFdBQVcsQ0FBQ0ksU0FBOUIsRUFBeUM7QUFDdkMsUUFBSUMsTUFBTSxDQUFDRCxTQUFQLENBQWlCRSxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNQLFdBQVcsQ0FBQ0ksU0FBakQsRUFBNERELEdBQTVELENBQUosRUFDRUYsTUFBTSxDQUFDRSxHQUFELENBQU4sR0FBY0gsV0FBVyxDQUFDSSxTQUFaLENBQXNCRCxHQUF0QixDQUFkO0FBQ0g7O0FBRUQsU0FBT0YsTUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7O0FBT0FELFdBQVcsQ0FBQ0ksU0FBWixDQUFzQkksWUFBdEIsR0FBcUMsWUFBWTtBQUMvQ0EsRUFBQUEsWUFBWSxDQUFDLEtBQUtDLE1BQU4sQ0FBWjtBQUNBRCxFQUFBQSxZQUFZLENBQUMsS0FBS0UscUJBQU4sQ0FBWjtBQUNBRixFQUFBQSxZQUFZLENBQUMsS0FBS0csbUJBQU4sQ0FBWjtBQUNBLFNBQU8sS0FBS0YsTUFBWjtBQUNBLFNBQU8sS0FBS0MscUJBQVo7QUFDQSxTQUFPLEtBQUtDLG1CQUFaO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FSRDtBQVVBOzs7Ozs7Ozs7O0FBU0FYLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQlEsS0FBdEIsR0FBOEIsVUFBVUMsRUFBVixFQUFjO0FBQzFDLE9BQUtDLE9BQUwsR0FBZUQsRUFBZjtBQUNBLFNBQU8sSUFBUDtBQUNELENBSEQ7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQWIsV0FBVyxDQUFDSSxTQUFaLENBQXNCVyxZQUF0QixHQUFxQyxVQUFVQyxLQUFWLEVBQWlCO0FBQ3BELE9BQUtDLGFBQUwsR0FBcUJELEtBQXJCO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FIRDtBQUtBOzs7Ozs7Ozs7O0FBU0FoQixXQUFXLENBQUNJLFNBQVosQ0FBc0JjLFNBQXRCLEdBQWtDLFVBQVVMLEVBQVYsRUFBYztBQUM5QyxPQUFLTSxXQUFMLEdBQW1CTixFQUFuQjtBQUNBLFNBQU8sSUFBUDtBQUNELENBSEQ7QUFLQTs7Ozs7Ozs7Ozs7Ozs7O0FBY0FiLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQmdCLE9BQXRCLEdBQWdDLFVBQVVDLE9BQVYsRUFBbUI7QUFDakQsTUFBSSxDQUFDQSxPQUFELElBQVksUUFBT0EsT0FBUCxNQUFtQixRQUFuQyxFQUE2QztBQUMzQyxTQUFLQyxRQUFMLEdBQWdCRCxPQUFoQjtBQUNBLFNBQUtFLGdCQUFMLEdBQXdCLENBQXhCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixDQUF0QjtBQUNBLFdBQU8sSUFBUDtBQUNEOztBQUVELE9BQUssSUFBTUMsTUFBWCxJQUFxQkosT0FBckIsRUFBOEI7QUFDNUIsUUFBSWhCLE1BQU0sQ0FBQ0QsU0FBUCxDQUFpQkUsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDYyxPQUFyQyxFQUE4Q0ksTUFBOUMsQ0FBSixFQUEyRDtBQUN6RCxjQUFRQSxNQUFSO0FBQ0UsYUFBSyxVQUFMO0FBQ0UsZUFBS0gsUUFBTCxHQUFnQkQsT0FBTyxDQUFDSyxRQUF4QjtBQUNBOztBQUNGLGFBQUssVUFBTDtBQUNFLGVBQUtILGdCQUFMLEdBQXdCRixPQUFPLENBQUNNLFFBQWhDO0FBQ0E7O0FBQ0YsYUFBSyxRQUFMO0FBQ0UsZUFBS0gsY0FBTCxHQUFzQkgsT0FBTyxDQUFDTyxNQUE5QjtBQUNBOztBQUNGO0FBQ0VDLFVBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHdCQUFiLEVBQXVDTCxNQUF2QztBQVhKO0FBYUQ7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQTNCRDtBQTZCQTs7Ozs7Ozs7Ozs7O0FBV0F6QixXQUFXLENBQUNJLFNBQVosQ0FBc0IyQixLQUF0QixHQUE4QixVQUFVQyxLQUFWLEVBQWlCbkIsRUFBakIsRUFBcUI7QUFDakQ7QUFDQSxNQUFJb0IsU0FBUyxDQUFDQyxNQUFWLEtBQXFCLENBQXJCLElBQTBCRixLQUFLLEtBQUssSUFBeEMsRUFBOENBLEtBQUssR0FBRyxDQUFSO0FBQzlDLE1BQUlBLEtBQUssSUFBSSxDQUFiLEVBQWdCQSxLQUFLLEdBQUcsQ0FBUjtBQUNoQixPQUFLRyxXQUFMLEdBQW1CSCxLQUFuQjtBQUNBLE9BQUtJLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxPQUFLQyxjQUFMLEdBQXNCeEIsRUFBdEI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQVJELEMsQ0FVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFNeUIsV0FBVyxHQUFHLElBQUlDLEdBQUosQ0FBUSxDQUMxQixXQUQwQixFQUUxQixZQUYwQixFQUcxQixZQUgwQixFQUkxQixjQUowQixFQUsxQixPQUwwQixFQU0xQixXQU4wQixFQU8xQixhQVAwQixFQVExQixXQVIwQixDQUFSLENBQXBCO0FBV0EsSUFBTUMsWUFBWSxHQUFHLElBQUlELEdBQUosQ0FBUSxDQUMzQixHQUQyQixFQUUzQixHQUYyQixFQUczQixHQUgyQixFQUkzQixHQUoyQixFQUszQixHQUwyQixFQU0zQixHQU4yQixFQU8zQixHQVAyQixFQVEzQixHQVIyQixFQVMzQixHQVQyQixFQVUzQixHQVYyQixDQUFSLENBQXJCLEMsQ0FhQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUFRQXZDLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQnFDLFlBQXRCLEdBQXFDLFVBQVVDLEdBQVYsRUFBZUMsR0FBZixFQUFvQjtBQUN2RCxNQUFJLENBQUMsS0FBS1IsV0FBTixJQUFxQixLQUFLQyxRQUFMLE1BQW1CLEtBQUtELFdBQWpELEVBQThEO0FBQzVELFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksS0FBS0UsY0FBVCxFQUF5QjtBQUN2QixRQUFJO0FBQ0YsVUFBTU8sUUFBUSxHQUFHLEtBQUtQLGNBQUwsQ0FBb0JLLEdBQXBCLEVBQXlCQyxHQUF6QixDQUFqQjs7QUFDQSxVQUFJQyxRQUFRLEtBQUssSUFBakIsRUFBdUIsT0FBTyxJQUFQO0FBQ3ZCLFVBQUlBLFFBQVEsS0FBSyxLQUFqQixFQUF3QixPQUFPLEtBQVAsQ0FIdEIsQ0FJRjtBQUNELEtBTEQsQ0FLRSxPQUFPQyxJQUFQLEVBQWE7QUFDYmhCLE1BQUFBLE9BQU8sQ0FBQ2lCLEtBQVIsQ0FBY0QsSUFBZDtBQUNEO0FBQ0YsR0Fkc0QsQ0FnQnZEOztBQUNBOzs7Ozs7Ozs7O0FBUUEsTUFBSUYsR0FBRyxJQUFJQSxHQUFHLENBQUNJLE1BQVgsSUFBcUJQLFlBQVksQ0FBQ1EsR0FBYixDQUFpQkwsR0FBRyxDQUFDSSxNQUFyQixDQUF6QixFQUF1RCxPQUFPLElBQVA7O0FBQ3ZELE1BQUlMLEdBQUosRUFBUztBQUNQLFFBQUlBLEdBQUcsQ0FBQ08sSUFBSixJQUFZWCxXQUFXLENBQUNVLEdBQVosQ0FBZ0JOLEdBQUcsQ0FBQ08sSUFBcEIsQ0FBaEIsRUFBMkMsT0FBTyxJQUFQLENBRHBDLENBRVA7O0FBQ0EsUUFBSVAsR0FBRyxDQUFDdEIsT0FBSixJQUFlc0IsR0FBRyxDQUFDTyxJQUFKLEtBQWEsY0FBaEMsRUFBZ0QsT0FBTyxJQUFQO0FBQ2hELFFBQUlQLEdBQUcsQ0FBQ1EsV0FBUixFQUFxQixPQUFPLElBQVA7QUFDdEI7O0FBRUQsU0FBTyxLQUFQO0FBQ0QsQ0FsQ0Q7QUFvQ0E7Ozs7Ozs7O0FBT0FsRCxXQUFXLENBQUNJLFNBQVosQ0FBc0IrQyxNQUF0QixHQUErQixZQUFZO0FBQ3pDLE9BQUszQyxZQUFMLEdBRHlDLENBR3pDOztBQUNBLE1BQUksS0FBSzRDLEdBQVQsRUFBYztBQUNaLFNBQUtBLEdBQUwsR0FBVyxJQUFYO0FBQ0EsU0FBS0EsR0FBTCxHQUFXLEtBQUtDLE9BQUwsRUFBWDtBQUNEOztBQUVELE9BQUtDLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsT0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUVBLFNBQU8sS0FBS0MsSUFBTCxFQUFQO0FBQ0QsQ0FkRDtBQWdCQTs7Ozs7Ozs7O0FBUUF6RCxXQUFXLENBQUNJLFNBQVosQ0FBc0JzRCxJQUF0QixHQUE2QixVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUFBOztBQUN0RCxNQUFJLENBQUMsS0FBS0Msa0JBQVYsRUFBOEI7QUFDNUIsUUFBTUMsSUFBSSxHQUFHLElBQWI7O0FBQ0EsUUFBSSxLQUFLQyxVQUFULEVBQXFCO0FBQ25CbEMsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQ0UsZ0lBREY7QUFHRDs7QUFFRCxTQUFLK0Isa0JBQUwsR0FBMEIsSUFBSUcsT0FBSixDQUFZLFVBQUNMLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUN6REUsTUFBQUEsSUFBSSxDQUFDRyxFQUFMLENBQVEsT0FBUixFQUFpQixZQUFNO0FBQ3JCLFlBQUksS0FBSSxDQUFDOUIsV0FBTCxJQUFvQixLQUFJLENBQUNBLFdBQUwsR0FBbUIsS0FBSSxDQUFDQyxRQUFoRCxFQUEwRDtBQUN4RDtBQUNEOztBQUVELFlBQUksS0FBSSxDQUFDbUIsUUFBTCxJQUFpQixLQUFJLENBQUNDLGFBQTFCLEVBQXlDO0FBQ3ZDSSxVQUFBQSxNQUFNLENBQUMsS0FBSSxDQUFDSixhQUFOLENBQU47QUFDQTtBQUNEOztBQUVELFlBQU1kLEdBQUcsR0FBRyxJQUFJd0IsS0FBSixDQUFVLFNBQVYsQ0FBWjtBQUNBeEIsUUFBQUEsR0FBRyxDQUFDTyxJQUFKLEdBQVcsU0FBWDtBQUNBUCxRQUFBQSxHQUFHLENBQUNLLE1BQUosR0FBYSxLQUFJLENBQUNBLE1BQWxCO0FBQ0FMLFFBQUFBLEdBQUcsQ0FBQ3lCLE1BQUosR0FBYSxLQUFJLENBQUNBLE1BQWxCO0FBQ0F6QixRQUFBQSxHQUFHLENBQUMwQixHQUFKLEdBQVUsS0FBSSxDQUFDQSxHQUFmO0FBQ0FSLFFBQUFBLE1BQU0sQ0FBQ2xCLEdBQUQsQ0FBTjtBQUNELE9BaEJEO0FBaUJBb0IsTUFBQUEsSUFBSSxDQUFDTyxHQUFMLENBQVMsVUFBQzNCLEdBQUQsRUFBTUMsR0FBTixFQUFjO0FBQ3JCLFlBQUlELEdBQUosRUFBU2tCLE1BQU0sQ0FBQ2xCLEdBQUQsQ0FBTixDQUFULEtBQ0tpQixPQUFPLENBQUNoQixHQUFELENBQVA7QUFDTixPQUhEO0FBSUQsS0F0QnlCLENBQTFCO0FBdUJEOztBQUVELFNBQU8sS0FBS2tCLGtCQUFMLENBQXdCSCxJQUF4QixDQUE2QkMsT0FBN0IsRUFBc0NDLE1BQXRDLENBQVA7QUFDRCxDQW5DRDs7QUFxQ0E1RCxXQUFXLENBQUNJLFNBQVosQ0FBc0JrRSxLQUF0QixHQUE4QixVQUFVQyxFQUFWLEVBQWM7QUFDMUMsU0FBTyxLQUFLYixJQUFMLENBQVVjLFNBQVYsRUFBcUJELEVBQXJCLENBQVA7QUFDRCxDQUZEO0FBSUE7Ozs7O0FBSUF2RSxXQUFXLENBQUNJLFNBQVosQ0FBc0JxRSxHQUF0QixHQUE0QixVQUFVNUQsRUFBVixFQUFjO0FBQ3hDQSxFQUFBQSxFQUFFLENBQUMsSUFBRCxDQUFGO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FIRDs7QUFLQWIsV0FBVyxDQUFDSSxTQUFaLENBQXNCc0UsRUFBdEIsR0FBMkIsVUFBVUgsRUFBVixFQUFjO0FBQ3ZDLE1BQUksT0FBT0EsRUFBUCxLQUFjLFVBQWxCLEVBQThCLE1BQU0sSUFBSUwsS0FBSixDQUFVLG1CQUFWLENBQU47QUFDOUIsT0FBS1MsV0FBTCxHQUFtQkosRUFBbkI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUpEOztBQU1BdkUsV0FBVyxDQUFDSSxTQUFaLENBQXNCd0UsYUFBdEIsR0FBc0MsVUFBVWpDLEdBQVYsRUFBZTtBQUNuRCxNQUFJLENBQUNBLEdBQUwsRUFBVTtBQUNSLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksS0FBS2dDLFdBQVQsRUFBc0I7QUFDcEIsV0FBTyxLQUFLQSxXQUFMLENBQWlCaEMsR0FBakIsQ0FBUDtBQUNEOztBQUVELFNBQU9BLEdBQUcsQ0FBQ0ksTUFBSixJQUFjLEdBQWQsSUFBcUJKLEdBQUcsQ0FBQ0ksTUFBSixHQUFhLEdBQXpDO0FBQ0QsQ0FWRDtBQVlBOzs7Ozs7Ozs7O0FBU0EvQyxXQUFXLENBQUNJLFNBQVosQ0FBc0J5RSxHQUF0QixHQUE0QixVQUFVQyxLQUFWLEVBQWlCO0FBQzNDLFNBQU8sS0FBS0MsT0FBTCxDQUFhRCxLQUFLLENBQUNFLFdBQU4sRUFBYixDQUFQO0FBQ0QsQ0FGRDtBQUlBOzs7Ozs7Ozs7Ozs7O0FBWUFoRixXQUFXLENBQUNJLFNBQVosQ0FBc0I2RSxTQUF0QixHQUFrQ2pGLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQnlFLEdBQXhEO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTdFLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQjhFLEdBQXRCLEdBQTRCLFVBQVVKLEtBQVYsRUFBaUI5RCxLQUFqQixFQUF3QjtBQUNsRCxNQUFJcEIsUUFBUSxDQUFDa0YsS0FBRCxDQUFaLEVBQXFCO0FBQ25CLFNBQUssSUFBTTNFLEdBQVgsSUFBa0IyRSxLQUFsQixFQUF5QjtBQUN2QixVQUFJekUsTUFBTSxDQUFDRCxTQUFQLENBQWlCRSxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUN1RSxLQUFyQyxFQUE0QzNFLEdBQTVDLENBQUosRUFDRSxLQUFLK0UsR0FBTCxDQUFTL0UsR0FBVCxFQUFjMkUsS0FBSyxDQUFDM0UsR0FBRCxDQUFuQjtBQUNIOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQUVELE9BQUs0RSxPQUFMLENBQWFELEtBQUssQ0FBQ0UsV0FBTixFQUFiLElBQW9DaEUsS0FBcEM7QUFDQSxPQUFLbUUsTUFBTCxDQUFZTCxLQUFaLElBQXFCOUQsS0FBckI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQWJEO0FBZUE7Ozs7Ozs7Ozs7Ozs7O0FBWUFoQixXQUFXLENBQUNJLFNBQVosQ0FBc0JnRixLQUF0QixHQUE4QixVQUFVTixLQUFWLEVBQWlCO0FBQzdDLFNBQU8sS0FBS0MsT0FBTCxDQUFhRCxLQUFLLENBQUNFLFdBQU4sRUFBYixDQUFQO0FBQ0EsU0FBTyxLQUFLRyxNQUFMLENBQVlMLEtBQVosQ0FBUDtBQUNBLFNBQU8sSUFBUDtBQUNELENBSkQ7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOUUsV0FBVyxDQUFDSSxTQUFaLENBQXNCMEUsS0FBdEIsR0FBOEIsVUFBVU8sSUFBVixFQUFnQnJFLEtBQWhCLEVBQXVCO0FBQ25EO0FBQ0EsTUFBSXFFLElBQUksS0FBSyxJQUFULElBQWlCYixTQUFTLEtBQUthLElBQW5DLEVBQXlDO0FBQ3ZDLFVBQU0sSUFBSW5CLEtBQUosQ0FBVSx5Q0FBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBSSxLQUFLb0IsS0FBVCxFQUFnQjtBQUNkLFVBQU0sSUFBSXBCLEtBQUosQ0FDSixpR0FESSxDQUFOO0FBR0Q7O0FBRUQsTUFBSXRFLFFBQVEsQ0FBQ3lGLElBQUQsQ0FBWixFQUFvQjtBQUNsQixTQUFLLElBQU1sRixHQUFYLElBQWtCa0YsSUFBbEIsRUFBd0I7QUFDdEIsVUFBSWhGLE1BQU0sQ0FBQ0QsU0FBUCxDQUFpQkUsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDOEUsSUFBckMsRUFBMkNsRixHQUEzQyxDQUFKLEVBQ0UsS0FBSzJFLEtBQUwsQ0FBVzNFLEdBQVgsRUFBZ0JrRixJQUFJLENBQUNsRixHQUFELENBQXBCO0FBQ0g7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSW9GLEtBQUssQ0FBQ0MsT0FBTixDQUFjeEUsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCLFNBQUssSUFBTXlFLENBQVgsSUFBZ0J6RSxLQUFoQixFQUF1QjtBQUNyQixVQUFJWCxNQUFNLENBQUNELFNBQVAsQ0FBaUJFLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ1MsS0FBckMsRUFBNEN5RSxDQUE1QyxDQUFKLEVBQ0UsS0FBS1gsS0FBTCxDQUFXTyxJQUFYLEVBQWlCckUsS0FBSyxDQUFDeUUsQ0FBRCxDQUF0QjtBQUNIOztBQUVELFdBQU8sSUFBUDtBQUNELEdBNUJrRCxDQThCbkQ7OztBQUNBLE1BQUl6RSxLQUFLLEtBQUssSUFBVixJQUFrQndELFNBQVMsS0FBS3hELEtBQXBDLEVBQTJDO0FBQ3pDLFVBQU0sSUFBSWtELEtBQUosQ0FBVSx3Q0FBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPbEQsS0FBUCxLQUFpQixTQUFyQixFQUFnQztBQUM5QkEsSUFBQUEsS0FBSyxHQUFHMEUsTUFBTSxDQUFDMUUsS0FBRCxDQUFkO0FBQ0Q7O0FBRUQsT0FBSzJFLFlBQUwsR0FBb0JDLE1BQXBCLENBQTJCUCxJQUEzQixFQUFpQ3JFLEtBQWpDOztBQUNBLFNBQU8sSUFBUDtBQUNELENBekNEO0FBMkNBOzs7Ozs7OztBQU1BaEIsV0FBVyxDQUFDSSxTQUFaLENBQXNCeUYsS0FBdEIsR0FBOEIsWUFBWTtBQUN4QyxNQUFJLEtBQUt2QyxRQUFULEVBQW1CO0FBQ2pCLFdBQU8sSUFBUDtBQUNEOztBQUVELE9BQUtBLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxNQUFJLEtBQUt3QyxHQUFULEVBQWMsS0FBS0EsR0FBTCxDQUFTRCxLQUFULEdBTjBCLENBTVI7O0FBQ2hDLE1BQUksS0FBS3pDLEdBQVQsRUFBYyxLQUFLQSxHQUFMLENBQVN5QyxLQUFULEdBUDBCLENBT1I7O0FBQ2hDLE9BQUtyRixZQUFMO0FBQ0EsT0FBS3VGLElBQUwsQ0FBVSxPQUFWO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FYRDs7QUFhQS9GLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQjRGLEtBQXRCLEdBQThCLFVBQVVDLElBQVYsRUFBZ0JDLElBQWhCLEVBQXNCN0UsT0FBdEIsRUFBK0I4RSxhQUEvQixFQUE4QztBQUMxRSxVQUFROUUsT0FBTyxDQUFDK0UsSUFBaEI7QUFDRSxTQUFLLE9BQUw7QUFDRSxXQUFLbEIsR0FBTCxDQUFTLGVBQVQsa0JBQW1DaUIsYUFBYSxXQUFJRixJQUFKLGNBQVlDLElBQVosRUFBaEQ7QUFDQTs7QUFFRixTQUFLLE1BQUw7QUFDRSxXQUFLRyxRQUFMLEdBQWdCSixJQUFoQjtBQUNBLFdBQUtLLFFBQUwsR0FBZ0JKLElBQWhCO0FBQ0E7O0FBRUYsU0FBSyxRQUFMO0FBQWU7QUFDYixXQUFLaEIsR0FBTCxDQUFTLGVBQVQsbUJBQW9DZSxJQUFwQztBQUNBOztBQUNGO0FBQ0U7QUFkSjs7QUFpQkEsU0FBTyxJQUFQO0FBQ0QsQ0FuQkQ7QUFxQkE7Ozs7Ozs7Ozs7OztBQVdBakcsV0FBVyxDQUFDSSxTQUFaLENBQXNCbUcsZUFBdEIsR0FBd0MsVUFBVXRDLEVBQVYsRUFBYztBQUNwRDtBQUNBLE1BQUlBLEVBQUUsS0FBS08sU0FBWCxFQUFzQlAsRUFBRSxHQUFHLElBQUw7QUFDdEIsT0FBS3VDLGdCQUFMLEdBQXdCdkMsRUFBeEI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUxEO0FBT0E7Ozs7Ozs7OztBQVFBakUsV0FBVyxDQUFDSSxTQUFaLENBQXNCcUcsU0FBdEIsR0FBa0MsVUFBVUMsQ0FBVixFQUFhO0FBQzdDLE9BQUtDLGFBQUwsR0FBcUJELENBQXJCO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FIRDtBQUtBOzs7Ozs7Ozs7QUFPQTFHLFdBQVcsQ0FBQ0ksU0FBWixDQUFzQndHLGVBQXRCLEdBQXdDLFVBQVVGLENBQVYsRUFBYTtBQUNuRCxNQUFJLE9BQU9BLENBQVAsS0FBYSxRQUFqQixFQUEyQjtBQUN6QixVQUFNLElBQUlHLFNBQUosQ0FBYyxrQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsT0FBS0MsZ0JBQUwsR0FBd0JKLENBQXhCO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FQRDtBQVNBOzs7Ozs7Ozs7O0FBU0ExRyxXQUFXLENBQUNJLFNBQVosQ0FBc0IyRyxNQUF0QixHQUErQixZQUFZO0FBQ3pDLFNBQU87QUFDTDVDLElBQUFBLE1BQU0sRUFBRSxLQUFLQSxNQURSO0FBRUxDLElBQUFBLEdBQUcsRUFBRSxLQUFLQSxHQUZMO0FBR0w0QyxJQUFBQSxJQUFJLEVBQUUsS0FBSzFCLEtBSE47QUFJTDJCLElBQUFBLE9BQU8sRUFBRSxLQUFLbEM7QUFKVCxHQUFQO0FBTUQsQ0FQRDtBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q0E7OztBQUNBL0UsV0FBVyxDQUFDSSxTQUFaLENBQXNCOEcsSUFBdEIsR0FBNkIsVUFBVUYsSUFBVixFQUFnQjtBQUMzQyxNQUFNRyxTQUFTLEdBQUd2SCxRQUFRLENBQUNvSCxJQUFELENBQTFCO0FBQ0EsTUFBSVosSUFBSSxHQUFHLEtBQUtyQixPQUFMLENBQWEsY0FBYixDQUFYOztBQUVBLE1BQUksS0FBS3FDLFNBQVQsRUFBb0I7QUFDbEIsVUFBTSxJQUFJbEQsS0FBSixDQUNKLDhHQURJLENBQU47QUFHRDs7QUFFRCxNQUFJaUQsU0FBUyxJQUFJLENBQUMsS0FBSzdCLEtBQXZCLEVBQThCO0FBQzVCLFFBQUlDLEtBQUssQ0FBQ0MsT0FBTixDQUFjd0IsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFdBQUsxQixLQUFMLEdBQWEsRUFBYjtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsS0FBSytCLE9BQUwsQ0FBYUwsSUFBYixDQUFMLEVBQXlCO0FBQzlCLFdBQUsxQixLQUFMLEdBQWEsRUFBYjtBQUNEO0FBQ0YsR0FORCxNQU1PLElBQUkwQixJQUFJLElBQUksS0FBSzFCLEtBQWIsSUFBc0IsS0FBSytCLE9BQUwsQ0FBYSxLQUFLL0IsS0FBbEIsQ0FBMUIsRUFBb0Q7QUFDekQsVUFBTSxJQUFJcEIsS0FBSixDQUFVLDhCQUFWLENBQU47QUFDRCxHQWxCMEMsQ0FvQjNDOzs7QUFDQSxNQUFJaUQsU0FBUyxJQUFJdkgsUUFBUSxDQUFDLEtBQUswRixLQUFOLENBQXpCLEVBQXVDO0FBQ3JDLFNBQUssSUFBTW5GLEdBQVgsSUFBa0I2RyxJQUFsQixFQUF3QjtBQUN0QixVQUFJM0csTUFBTSxDQUFDRCxTQUFQLENBQWlCRSxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUN5RyxJQUFyQyxFQUEyQzdHLEdBQTNDLENBQUosRUFDRSxLQUFLbUYsS0FBTCxDQUFXbkYsR0FBWCxJQUFrQjZHLElBQUksQ0FBQzdHLEdBQUQsQ0FBdEI7QUFDSDtBQUNGLEdBTEQsTUFLTyxJQUFJLE9BQU82RyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQ25DO0FBQ0EsUUFBSSxDQUFDWixJQUFMLEVBQVcsS0FBS0EsSUFBTCxDQUFVLE1BQVY7QUFDWEEsSUFBQUEsSUFBSSxHQUFHLEtBQUtyQixPQUFMLENBQWEsY0FBYixDQUFQO0FBQ0EsUUFBSXFCLElBQUosRUFBVUEsSUFBSSxHQUFHQSxJQUFJLENBQUNwQixXQUFMLEdBQW1Cc0MsSUFBbkIsRUFBUDs7QUFDVixRQUFJbEIsSUFBSSxLQUFLLG1DQUFiLEVBQWtEO0FBQ2hELFdBQUtkLEtBQUwsR0FBYSxLQUFLQSxLQUFMLGFBQWdCLEtBQUtBLEtBQXJCLGNBQThCMEIsSUFBOUIsSUFBdUNBLElBQXBEO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBSzFCLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQUwsSUFBYyxFQUFmLElBQXFCMEIsSUFBbEM7QUFDRDtBQUNGLEdBVk0sTUFVQTtBQUNMLFNBQUsxQixLQUFMLEdBQWEwQixJQUFiO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDRyxTQUFELElBQWMsS0FBS0UsT0FBTCxDQUFhTCxJQUFiLENBQWxCLEVBQXNDO0FBQ3BDLFdBQU8sSUFBUDtBQUNELEdBMUMwQyxDQTRDM0M7OztBQUNBLE1BQUksQ0FBQ1osSUFBTCxFQUFXLEtBQUtBLElBQUwsQ0FBVSxNQUFWO0FBQ1gsU0FBTyxJQUFQO0FBQ0QsQ0EvQ0Q7QUFpREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBcEcsV0FBVyxDQUFDSSxTQUFaLENBQXNCbUgsU0FBdEIsR0FBa0MsVUFBVUMsSUFBVixFQUFnQjtBQUNoRDtBQUNBLE9BQUtDLEtBQUwsR0FBYSxPQUFPRCxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLElBQTlCLEdBQXFDQSxJQUFsRDtBQUNBLFNBQU8sSUFBUDtBQUNELENBSkQ7QUFNQTs7Ozs7OztBQUtBeEgsV0FBVyxDQUFDSSxTQUFaLENBQXNCc0gsb0JBQXRCLEdBQTZDLFlBQVk7QUFDdkQsTUFBTUMsS0FBSyxHQUFHLEtBQUtDLE1BQUwsQ0FBWUMsSUFBWixDQUFpQixHQUFqQixDQUFkOztBQUNBLE1BQUlGLEtBQUosRUFBVztBQUNULFNBQUt2RCxHQUFMLElBQVksQ0FBQyxLQUFLQSxHQUFMLENBQVMwRCxRQUFULENBQWtCLEdBQWxCLElBQXlCLEdBQXpCLEdBQStCLEdBQWhDLElBQXVDSCxLQUFuRDtBQUNEOztBQUVELE9BQUtDLE1BQUwsQ0FBWTFGLE1BQVosR0FBcUIsQ0FBckIsQ0FOdUQsQ0FNL0I7O0FBRXhCLE1BQUksS0FBS3VGLEtBQVQsRUFBZ0I7QUFDZCxRQUFNTSxLQUFLLEdBQUcsS0FBSzNELEdBQUwsQ0FBUzRELE9BQVQsQ0FBaUIsR0FBakIsQ0FBZDs7QUFDQSxRQUFJRCxLQUFLLElBQUksQ0FBYixFQUFnQjtBQUNkLFVBQU1FLFVBQVUsR0FBRyxLQUFLN0QsR0FBTCxDQUFTOEQsS0FBVCxDQUFlSCxLQUFLLEdBQUcsQ0FBdkIsRUFBMEJJLEtBQTFCLENBQWdDLEdBQWhDLENBQW5COztBQUNBLFVBQUksT0FBTyxLQUFLVixLQUFaLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDUSxRQUFBQSxVQUFVLENBQUNULElBQVgsQ0FBZ0IsS0FBS0MsS0FBckI7QUFDRCxPQUZELE1BRU87QUFDTFEsUUFBQUEsVUFBVSxDQUFDVCxJQUFYO0FBQ0Q7O0FBRUQsV0FBS3BELEdBQUwsR0FBVyxLQUFLQSxHQUFMLENBQVM4RCxLQUFULENBQWUsQ0FBZixFQUFrQkgsS0FBbEIsSUFBMkIsR0FBM0IsR0FBaUNFLFVBQVUsQ0FBQ0osSUFBWCxDQUFnQixHQUFoQixDQUE1QztBQUNEO0FBQ0Y7QUFDRixDQXJCRCxDLENBdUJBOzs7QUFDQTdILFdBQVcsQ0FBQ0ksU0FBWixDQUFzQmdJLGtCQUF0QixHQUEyQyxZQUFNO0FBQy9DdkcsRUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsYUFBYjtBQUNELENBRkQ7QUFJQTs7Ozs7OztBQU1BOUIsV0FBVyxDQUFDSSxTQUFaLENBQXNCaUksYUFBdEIsR0FBc0MsVUFBVUMsTUFBVixFQUFrQmxILE9BQWxCLEVBQTJCbUgsS0FBM0IsRUFBa0M7QUFDdEUsTUFBSSxLQUFLakYsUUFBVCxFQUFtQjtBQUNqQjtBQUNEOztBQUVELE1BQU1aLEdBQUcsR0FBRyxJQUFJd0IsS0FBSixXQUFhb0UsTUFBTSxHQUFHbEgsT0FBdEIsaUJBQVo7QUFDQXNCLEVBQUFBLEdBQUcsQ0FBQ3RCLE9BQUosR0FBY0EsT0FBZDtBQUNBc0IsRUFBQUEsR0FBRyxDQUFDTyxJQUFKLEdBQVcsY0FBWDtBQUNBUCxFQUFBQSxHQUFHLENBQUM2RixLQUFKLEdBQVlBLEtBQVo7QUFDQSxPQUFLaEYsUUFBTCxHQUFnQixJQUFoQjtBQUNBLE9BQUtDLGFBQUwsR0FBcUJkLEdBQXJCO0FBQ0EsT0FBS21ELEtBQUw7QUFDQSxPQUFLMkMsUUFBTCxDQUFjOUYsR0FBZDtBQUNELENBYkQ7O0FBZUExQyxXQUFXLENBQUNJLFNBQVosQ0FBc0JxSSxZQUF0QixHQUFxQyxZQUFZO0FBQy9DLE1BQU0zRSxJQUFJLEdBQUcsSUFBYixDQUQrQyxDQUcvQzs7QUFDQSxNQUFJLEtBQUt4QyxRQUFMLElBQWlCLENBQUMsS0FBS2IsTUFBM0IsRUFBbUM7QUFDakMsU0FBS0EsTUFBTCxHQUFjaUksVUFBVSxDQUFDLFlBQU07QUFDN0I1RSxNQUFBQSxJQUFJLENBQUN1RSxhQUFMLENBQW1CLGFBQW5CLEVBQWtDdkUsSUFBSSxDQUFDeEMsUUFBdkMsRUFBaUQsT0FBakQ7QUFDRCxLQUZ1QixFQUVyQixLQUFLQSxRQUZnQixDQUF4QjtBQUdELEdBUjhDLENBVS9DOzs7QUFDQSxNQUFJLEtBQUtDLGdCQUFMLElBQXlCLENBQUMsS0FBS2IscUJBQW5DLEVBQTBEO0FBQ3hELFNBQUtBLHFCQUFMLEdBQTZCZ0ksVUFBVSxDQUFDLFlBQU07QUFDNUM1RSxNQUFBQSxJQUFJLENBQUN1RSxhQUFMLENBQ0Usc0JBREYsRUFFRXZFLElBQUksQ0FBQ3ZDLGdCQUZQLEVBR0UsV0FIRjtBQUtELEtBTnNDLEVBTXBDLEtBQUtBLGdCQU4rQixDQUF2QztBQU9EO0FBQ0YsQ0FwQkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqZWN0KSB7XG4gIGlmIChvYmplY3QpIHJldHVybiBtaXhpbihvYmplY3QpO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmplY3QpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSZXF1ZXN0QmFzZS5wcm90b3R5cGUsIGtleSkpXG4gICAgICBvYmplY3Rba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdXBsb2FkVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIGRlbGV0ZSB0aGlzLl91cGxvYWRUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZm9ybWF0IG9mIGJpbmFyeSByZXNwb25zZSBib2R5LlxuICogSW4gYnJvd3NlciB2YWxpZCBmb3JtYXRzIGFyZSAnYmxvYicgYW5kICdhcnJheWJ1ZmZlcicsXG4gKiB3aGljaCByZXR1cm4gQmxvYiBhbmQgQXJyYXlCdWZmZXIsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJbiBOb2RlIGFsbCB2YWx1ZXMgcmVzdWx0IGluIEJ1ZmZlci5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqIC0gdXBsb2FkIGlzIHRoZSB0aW1lICBzaW5jZSBsYXN0IGJpdCBvZiBkYXRhIHdhcyBzZW50IG9yIHJlY2VpdmVkLiBUaGlzIHRpbWVvdXQgd29ya3Mgb25seSBpZiBkZWFkbGluZSB0aW1lb3V0IGlzIG9mZlxuICpcbiAqIFZhbHVlIG9mIDAgb3IgZmFsc2UgbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG1zIG9yIHtyZXNwb25zZSwgZGVhZGxpbmV9XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gMDtcbiAgICB0aGlzLl91cGxvYWRUaW1lb3V0ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2RlYWRsaW5lJzpcbiAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VwbG9hZCc6XG4gICAgICAgICAgdGhpcy5fdXBsb2FkVGltZW91dCA9IG9wdGlvbnMudXBsb2FkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biB0aW1lb3V0IG9wdGlvbicsIG9wdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIChjb3VudCwgZm4pIHtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gTk9URTogd2UgZG8gbm90IGluY2x1ZGUgRVNPQ0tFVFRJTUVET1VUIGJlY2F1c2UgdGhhdCBpcyBmcm9tIGByZXF1ZXN0YCBwYWNrYWdlXG4vLyAgICAgICA8aHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nb3QvcHVsbC81Mzc+XG4vL1xuLy8gTk9URTogd2UgZG8gbm90IGluY2x1ZGUgRUFERFJJTkZPIGJlY2F1c2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBsaWJ1diBpbiAyMDE0XG4vLyAgICAgICA8aHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xpYnV2L2NvbW1pdC8wMmUxZWJkNDBiODA3YmU1YWY0NjM0M2VhODczMzMxYjJlZTRlOWMxPlxuLy8gICAgICAgPGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3Qvc2VhcmNoP3E9RVNPQ0tFVFRJTUVET1VUJnVuc2NvcGVkX3E9RVNPQ0tFVFRJTUVET1VUPlxuLy9cbi8vXG4vLyBUT0RPOiBleHBvc2UgdGhlc2UgYXMgY29uZmlndXJhYmxlIGRlZmF1bHRzXG4vL1xuY29uc3QgRVJST1JfQ09ERVMgPSBuZXcgU2V0KFtcbiAgJ0VUSU1FRE9VVCcsXG4gICdFQ09OTlJFU0VUJyxcbiAgJ0VBRERSSU5VU0UnLFxuICAnRUNPTk5SRUZVU0VEJyxcbiAgJ0VQSVBFJyxcbiAgJ0VOT1RGT1VORCcsXG4gICdFTkVUVU5SRUFDSCcsXG4gICdFQUlfQUdBSU4nXG5dKTtcblxuY29uc3QgU1RBVFVTX0NPREVTID0gbmV3IFNldChbXG4gIDQwOCxcbiAgNDEzLFxuICA0MjksXG4gIDUwMCxcbiAgNTAyLFxuICA1MDMsXG4gIDUwNCxcbiAgNTIxLFxuICA1MjIsXG4gIDUyNFxuXSk7XG5cbi8vIFRPRE86IHdlIHdvdWxkIG5lZWQgdG8gbWFrZSB0aGlzIGVhc2lseSBjb25maWd1cmFibGUgYmVmb3JlIGFkZGluZyBpdCBpbiAoZS5nLiBzb21lIG1pZ2h0IHdhbnQgdG8gYWRkIFBPU1QpXG4vLyBjb25zdCBNRVRIT0RTID0gbmV3IFNldChbJ0dFVCcsICdQVVQnLCAnSEVBRCcsICdERUxFVEUnLCAnT1BUSU9OUycsICdUUkFDRSddKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkLlxuICogKEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290I3JldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBhbiBlcnJvclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc10gcmVzcG9uc2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpZiBzZWdtZW50IHNob3VsZCBiZSByZXRyaWVkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2hvdWxkUmV0cnkgPSBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3JldHJ5Q2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGUgPSB0aGlzLl9yZXRyeUNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2ggKGVycl8pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyXyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogd2Ugd291bGQgbmVlZCB0byBtYWtlIHRoaXMgZWFzaWx5IGNvbmZpZ3VyYWJsZSBiZWZvcmUgYWRkaW5nIGl0IGluIChlLmcuIHNvbWUgbWlnaHQgd2FudCB0byBhZGQgUE9TVClcbiAgLypcbiAgaWYgKFxuICAgIHRoaXMucmVxICYmXG4gICAgdGhpcy5yZXEubWV0aG9kICYmXG4gICAgIU1FVEhPRFMuaGFzKHRoaXMucmVxLm1ldGhvZC50b1VwcGVyQ2FzZSgpKVxuICApXG4gICAgcmV0dXJuIGZhbHNlO1xuICAqL1xuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgU1RBVFVTX0NPREVTLmhhcyhyZXMuc3RhdHVzKSkgcmV0dXJuIHRydWU7XG4gIGlmIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgJiYgRVJST1JfQ09ERVMuaGFzKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGVyci5jcm9zc0RvbWFpbikgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgLy8gbm9kZVxuICBpZiAodGhpcy5yZXEpIHtcbiAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgdGhpcy5yZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aW1lZG91dCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0RXJyb3IgPSBudWxsO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXMnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc2VsZi5vbignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9tYXhSZXRyaWVzICYmIHRoaXMuX21heFJldHJpZXMgPiB0aGlzLl9yZXRyaWVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGltZWRvdXQgJiYgdGhpcy50aW1lZG91dEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHRoaXMudGltZWRvdXRFcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICAgIGVyci5jb2RlID0gJ0FCT1JURUQnO1xuICAgICAgICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgICAgIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgICAgICAgZXJyLnVybCA9IHRoaXMudXJsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5lbmQoKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIHJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayByZXF1aXJlZCcpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbiAocmVzKSB7XG4gIGlmICghcmVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX29rQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fb2tDYWxsYmFjayhyZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDA7XG59O1xuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZmllbGQsIGtleSkpXG4gICAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZCBmaWVsZCBuYW1lXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3RcbiAqIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCh7IGZvbzogJ2JhcicsIGJhejogJ3F1eCcgfSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWUgbmFtZSBvZiBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWwgdmFsdWUgb2YgZmllbGRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChuYW1lID09PSBudWxsIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIlxuICAgICk7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5hbWUsIGtleSkpXG4gICAgICAgIHRoaXMuZmllbGQoa2V5LCBuYW1lW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHZhbHVlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBpKSlcbiAgICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWx1ZVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB1bmRlZmluZWQgPT09IHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMueGhyKSB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIGlmICh0aGlzLnJlcSkgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hdXRoID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGJhc2U2NEVuY29kZXIpIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2Jhc2U2NEVuY29kZXIoYCR7dXNlcn06JHtwYXNzfWApfWApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt1c2VyfWApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIG51bWJlciBvZiBieXRlc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbiAobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXJcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgaXNPYmplY3RfID0gaXNPYmplY3QoZGF0YSk7XG4gIGxldCB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiXG4gICAgKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdF8gJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfVxuXG4gIC8vIG1lcmdlXG4gIGlmIChpc09iamVjdF8gJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpXG4gICAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICh0eXBlKSB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBpZiAodHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhID8gYCR7dGhpcy5fZGF0YX0mJHtkYXRhfWAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0XyB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uIChzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBxdWVyeUFycmF5ID0gdGhpcy51cmwuc2xpY2UoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXJ5QXJyYXkuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyYXkuc29ydCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnNsaWNlKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyYXkuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9ICgpID0+IHtcbiAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCcpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24gKHJlYXNvbiwgdGltZW91dCwgZXJybm8pIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7cmVhc29uICsgdGltZW91dH1tcyBleGNlZWRlZGApO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy50aW1lZG91dEVycm9yID0gZXJyO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1RpbWVvdXQgb2YgJywgc2VsZi5fdGltZW91dCwgJ0VUSU1FJyk7XG4gICAgfSwgdGhpcy5fdGltZW91dCk7XG4gIH1cblxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJyxcbiAgICAgICAgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LFxuICAgICAgICAnRVRJTUVET1VUJ1xuICAgICAgKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuIl19

/***/ }),

/***/ 99228:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */
var utils = __webpack_require__(62433);
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key)) obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    if (Object.prototype.hasOwnProperty.call(params, key)) this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (_unused) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type; // basics

  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false; // sugar

  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNwb25zZS1iYXNlLmpzIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZXNwb25zZUJhc2UiLCJvYmoiLCJtaXhpbiIsImtleSIsInByb3RvdHlwZSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldCIsImZpZWxkIiwiaGVhZGVyIiwidG9Mb3dlckNhc2UiLCJfc2V0SGVhZGVyUHJvcGVydGllcyIsImN0IiwidHlwZSIsInBhcmFtcyIsImxpbmtzIiwibGluayIsInBhcnNlTGlua3MiLCJfc2V0U3RhdHVzUHJvcGVydGllcyIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJzdGF0dXNUeXBlIiwiaW5mbyIsIm9rIiwicmVkaXJlY3QiLCJjbGllbnRFcnJvciIsInNlcnZlckVycm9yIiwiZXJyb3IiLCJ0b0Vycm9yIiwiY3JlYXRlZCIsImFjY2VwdGVkIiwibm9Db250ZW50IiwiYmFkUmVxdWVzdCIsInVuYXV0aG9yaXplZCIsIm5vdEFjY2VwdGFibGUiLCJmb3JiaWRkZW4iLCJub3RGb3VuZCIsInVucHJvY2Vzc2FibGVFbnRpdHkiXSwibWFwcGluZ3MiOiI7O0FBQUE7OztBQUlBLElBQU1BLEtBQUssR0FBR0MsT0FBTyxDQUFDLFNBQUQsQ0FBckI7QUFFQTs7Ozs7QUFJQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxZQUFqQjtBQUVBOzs7Ozs7QUFNQSxTQUFTQSxZQUFULENBQXNCQyxHQUF0QixFQUEyQjtBQUN6QixNQUFJQSxHQUFKLEVBQVMsT0FBT0MsS0FBSyxDQUFDRCxHQUFELENBQVo7QUFDVjtBQUVEOzs7Ozs7Ozs7QUFRQSxTQUFTQyxLQUFULENBQWVELEdBQWYsRUFBb0I7QUFDbEIsT0FBSyxJQUFNRSxHQUFYLElBQWtCSCxZQUFZLENBQUNJLFNBQS9CLEVBQTBDO0FBQ3hDLFFBQUlDLE1BQU0sQ0FBQ0QsU0FBUCxDQUFpQkUsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDUCxZQUFZLENBQUNJLFNBQWxELEVBQTZERCxHQUE3RCxDQUFKLEVBQ0VGLEdBQUcsQ0FBQ0UsR0FBRCxDQUFILEdBQVdILFlBQVksQ0FBQ0ksU0FBYixDQUF1QkQsR0FBdkIsQ0FBWDtBQUNIOztBQUVELFNBQU9GLEdBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7QUFRQUQsWUFBWSxDQUFDSSxTQUFiLENBQXVCSSxHQUF2QixHQUE2QixVQUFVQyxLQUFWLEVBQWlCO0FBQzVDLFNBQU8sS0FBS0MsTUFBTCxDQUFZRCxLQUFLLENBQUNFLFdBQU4sRUFBWixDQUFQO0FBQ0QsQ0FGRDtBQUlBOzs7Ozs7Ozs7Ozs7O0FBWUFYLFlBQVksQ0FBQ0ksU0FBYixDQUF1QlEsb0JBQXZCLEdBQThDLFVBQVVGLE1BQVYsRUFBa0I7QUFDOUQ7QUFDQTtBQUVBO0FBQ0EsTUFBTUcsRUFBRSxHQUFHSCxNQUFNLENBQUMsY0FBRCxDQUFOLElBQTBCLEVBQXJDO0FBQ0EsT0FBS0ksSUFBTCxHQUFZbEIsS0FBSyxDQUFDa0IsSUFBTixDQUFXRCxFQUFYLENBQVosQ0FOOEQsQ0FROUQ7O0FBQ0EsTUFBTUUsTUFBTSxHQUFHbkIsS0FBSyxDQUFDbUIsTUFBTixDQUFhRixFQUFiLENBQWY7O0FBQ0EsT0FBSyxJQUFNVixHQUFYLElBQWtCWSxNQUFsQixFQUEwQjtBQUN4QixRQUFJVixNQUFNLENBQUNELFNBQVAsQ0FBaUJFLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ1EsTUFBckMsRUFBNkNaLEdBQTdDLENBQUosRUFDRSxLQUFLQSxHQUFMLElBQVlZLE1BQU0sQ0FBQ1osR0FBRCxDQUFsQjtBQUNIOztBQUVELE9BQUthLEtBQUwsR0FBYSxFQUFiLENBZjhELENBaUI5RDs7QUFDQSxNQUFJO0FBQ0YsUUFBSU4sTUFBTSxDQUFDTyxJQUFYLEVBQWlCO0FBQ2YsV0FBS0QsS0FBTCxHQUFhcEIsS0FBSyxDQUFDc0IsVUFBTixDQUFpQlIsTUFBTSxDQUFDTyxJQUF4QixDQUFiO0FBQ0Q7QUFDRixHQUpELENBSUUsZ0JBQU0sQ0FDTjtBQUNEO0FBQ0YsQ0F6QkQ7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkFqQixZQUFZLENBQUNJLFNBQWIsQ0FBdUJlLG9CQUF2QixHQUE4QyxVQUFVQyxNQUFWLEVBQWtCO0FBQzlELE1BQU1OLElBQUksR0FBSU0sTUFBTSxHQUFHLEdBQVYsR0FBaUIsQ0FBOUIsQ0FEOEQsQ0FHOUQ7O0FBQ0EsT0FBS0MsVUFBTCxHQUFrQkQsTUFBbEI7QUFDQSxPQUFLQSxNQUFMLEdBQWMsS0FBS0MsVUFBbkI7QUFDQSxPQUFLQyxVQUFMLEdBQWtCUixJQUFsQixDQU44RCxDQVE5RDs7QUFDQSxPQUFLUyxJQUFMLEdBQVlULElBQUksS0FBSyxDQUFyQjtBQUNBLE9BQUtVLEVBQUwsR0FBVVYsSUFBSSxLQUFLLENBQW5CO0FBQ0EsT0FBS1csUUFBTCxHQUFnQlgsSUFBSSxLQUFLLENBQXpCO0FBQ0EsT0FBS1ksV0FBTCxHQUFtQlosSUFBSSxLQUFLLENBQTVCO0FBQ0EsT0FBS2EsV0FBTCxHQUFtQmIsSUFBSSxLQUFLLENBQTVCO0FBQ0EsT0FBS2MsS0FBTCxHQUFhZCxJQUFJLEtBQUssQ0FBVCxJQUFjQSxJQUFJLEtBQUssQ0FBdkIsR0FBMkIsS0FBS2UsT0FBTCxFQUEzQixHQUE0QyxLQUF6RCxDQWQ4RCxDQWdCOUQ7O0FBQ0EsT0FBS0MsT0FBTCxHQUFlVixNQUFNLEtBQUssR0FBMUI7QUFDQSxPQUFLVyxRQUFMLEdBQWdCWCxNQUFNLEtBQUssR0FBM0I7QUFDQSxPQUFLWSxTQUFMLEdBQWlCWixNQUFNLEtBQUssR0FBNUI7QUFDQSxPQUFLYSxVQUFMLEdBQWtCYixNQUFNLEtBQUssR0FBN0I7QUFDQSxPQUFLYyxZQUFMLEdBQW9CZCxNQUFNLEtBQUssR0FBL0I7QUFDQSxPQUFLZSxhQUFMLEdBQXFCZixNQUFNLEtBQUssR0FBaEM7QUFDQSxPQUFLZ0IsU0FBTCxHQUFpQmhCLE1BQU0sS0FBSyxHQUE1QjtBQUNBLE9BQUtpQixRQUFMLEdBQWdCakIsTUFBTSxLQUFLLEdBQTNCO0FBQ0EsT0FBS2tCLG1CQUFMLEdBQTJCbEIsTUFBTSxLQUFLLEdBQXRDO0FBQ0QsQ0ExQkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZUJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzcG9uc2VCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlQmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZUJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVzcG9uc2VCYXNlLnByb3RvdHlwZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUmVzcG9uc2VCYXNlLnByb3RvdHlwZSwga2V5KSlcbiAgICAgIG9ialtrZXldID0gUmVzcG9uc2VCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgLy8gVE9ETzogbW9hciFcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuXG4gIC8vIGNvbnRlbnQtdHlwZVxuICBjb25zdCBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICBjb25zdCBwYXJhbXMgPSB1dGlscy5wYXJhbXMoY3QpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywga2V5KSlcbiAgICAgIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuICB9XG5cbiAgdGhpcy5saW5rcyA9IHt9O1xuXG4gIC8vIGxpbmtzXG4gIHRyeSB7XG4gICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBpZ25vcmVcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICBjb25zdCB0eXBlID0gKHN0YXR1cyAvIDEwMCkgfCAwO1xuXG4gIC8vIHN0YXR1cyAvIGNsYXNzXG4gIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGU7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IHR5cGUgPT09IDE7XG4gIHRoaXMub2sgPSB0eXBlID09PSAyO1xuICB0aGlzLnJlZGlyZWN0ID0gdHlwZSA9PT0gMztcbiAgdGhpcy5jbGllbnRFcnJvciA9IHR5cGUgPT09IDQ7XG4gIHRoaXMuc2VydmVyRXJyb3IgPSB0eXBlID09PSA1O1xuICB0aGlzLmVycm9yID0gdHlwZSA9PT0gNCB8fCB0eXBlID09PSA1ID8gdGhpcy50b0Vycm9yKCkgOiBmYWxzZTtcblxuICAvLyBzdWdhclxuICB0aGlzLmNyZWF0ZWQgPSBzdGF0dXMgPT09IDIwMTtcbiAgdGhpcy5hY2NlcHRlZCA9IHN0YXR1cyA9PT0gMjAyO1xuICB0aGlzLm5vQ29udGVudCA9IHN0YXR1cyA9PT0gMjA0O1xuICB0aGlzLmJhZFJlcXVlc3QgPSBzdGF0dXMgPT09IDQwMDtcbiAgdGhpcy51bmF1dGhvcml6ZWQgPSBzdGF0dXMgPT09IDQwMTtcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gc3RhdHVzID09PSA0MDY7XG4gIHRoaXMuZm9yYmlkZGVuID0gc3RhdHVzID09PSA0MDM7XG4gIHRoaXMubm90Rm91bmQgPSBzdGF0dXMgPT09IDQwNDtcbiAgdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5ID0gc3RhdHVzID09PSA0MjI7XG59O1xuIl19

/***/ }),

/***/ 62433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */
exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (val) {
  var obj = {};

  var _iterator = _createForOfIteratorHelper(val.split(/ *; */)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var str = _step.value;
      var parts = str.split(/ *= */);
      var key = parts.shift();

      var _val = parts.shift();

      if (key && _val) obj[key] = _val;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return obj;
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (val) {
  var obj = {};

  var _iterator2 = _createForOfIteratorHelper(val.split(/ *, */)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var str = _step2.value;
      var parts = str.split(/ *; */);
      var url = parts[0].slice(1, -1);
      var rel = parts[1].split(/ *= */)[1].slice(1, -1);
      obj[rel] = url;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return obj;
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJleHBvcnRzIiwidHlwZSIsInN0ciIsInNwbGl0Iiwic2hpZnQiLCJwYXJhbXMiLCJ2YWwiLCJvYmoiLCJwYXJ0cyIsImtleSIsInBhcnNlTGlua3MiLCJ1cmwiLCJzbGljZSIsInJlbCIsImNsZWFuSGVhZGVyIiwiaGVhZGVyIiwiY2hhbmdlc09yaWdpbiIsImhvc3QiLCJhdXRob3JpemF0aW9uIiwiY29va2llIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7O0FBUUFBLE9BQU8sQ0FBQ0MsSUFBUixHQUFlLFVBQUNDLEdBQUQ7QUFBQSxTQUFTQSxHQUFHLENBQUNDLEtBQUosQ0FBVSxPQUFWLEVBQW1CQyxLQUFuQixFQUFUO0FBQUEsQ0FBZjtBQUVBOzs7Ozs7Ozs7QUFRQUosT0FBTyxDQUFDSyxNQUFSLEdBQWlCLFVBQUNDLEdBQUQsRUFBUztBQUN4QixNQUFNQyxHQUFHLEdBQUcsRUFBWjs7QUFEd0IsNkNBRU5ELEdBQUcsQ0FBQ0gsS0FBSixDQUFVLE9BQVYsQ0FGTTtBQUFBOztBQUFBO0FBRXhCLHdEQUFzQztBQUFBLFVBQTNCRCxHQUEyQjtBQUNwQyxVQUFNTSxLQUFLLEdBQUdOLEdBQUcsQ0FBQ0MsS0FBSixDQUFVLE9BQVYsQ0FBZDtBQUNBLFVBQU1NLEdBQUcsR0FBR0QsS0FBSyxDQUFDSixLQUFOLEVBQVo7O0FBQ0EsVUFBTUUsSUFBRyxHQUFHRSxLQUFLLENBQUNKLEtBQU4sRUFBWjs7QUFFQSxVQUFJSyxHQUFHLElBQUlILElBQVgsRUFBZ0JDLEdBQUcsQ0FBQ0UsR0FBRCxDQUFILEdBQVdILElBQVg7QUFDakI7QUFSdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVeEIsU0FBT0MsR0FBUDtBQUNELENBWEQ7QUFhQTs7Ozs7Ozs7O0FBUUFQLE9BQU8sQ0FBQ1UsVUFBUixHQUFxQixVQUFDSixHQUFELEVBQVM7QUFDNUIsTUFBTUMsR0FBRyxHQUFHLEVBQVo7O0FBRDRCLDhDQUVWRCxHQUFHLENBQUNILEtBQUosQ0FBVSxPQUFWLENBRlU7QUFBQTs7QUFBQTtBQUU1QiwyREFBc0M7QUFBQSxVQUEzQkQsR0FBMkI7QUFDcEMsVUFBTU0sS0FBSyxHQUFHTixHQUFHLENBQUNDLEtBQUosQ0FBVSxPQUFWLENBQWQ7QUFDQSxVQUFNUSxHQUFHLEdBQUdILEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU0ksS0FBVCxDQUFlLENBQWYsRUFBa0IsQ0FBQyxDQUFuQixDQUFaO0FBQ0EsVUFBTUMsR0FBRyxHQUFHTCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNMLEtBQVQsQ0FBZSxPQUFmLEVBQXdCLENBQXhCLEVBQTJCUyxLQUEzQixDQUFpQyxDQUFqQyxFQUFvQyxDQUFDLENBQXJDLENBQVo7QUFDQUwsTUFBQUEsR0FBRyxDQUFDTSxHQUFELENBQUgsR0FBV0YsR0FBWDtBQUNEO0FBUDJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBUzVCLFNBQU9KLEdBQVA7QUFDRCxDQVZEO0FBWUE7Ozs7Ozs7OztBQVFBUCxPQUFPLENBQUNjLFdBQVIsR0FBc0IsVUFBQ0MsTUFBRCxFQUFTQyxhQUFULEVBQTJCO0FBQy9DLFNBQU9ELE1BQU0sQ0FBQyxjQUFELENBQWI7QUFDQSxTQUFPQSxNQUFNLENBQUMsZ0JBQUQsQ0FBYjtBQUNBLFNBQU9BLE1BQU0sQ0FBQyxtQkFBRCxDQUFiO0FBQ0EsU0FBT0EsTUFBTSxDQUFDRSxJQUFkLENBSitDLENBSy9DOztBQUNBLE1BQUlELGFBQUosRUFBbUI7QUFDakIsV0FBT0QsTUFBTSxDQUFDRyxhQUFkO0FBQ0EsV0FBT0gsTUFBTSxDQUFDSSxNQUFkO0FBQ0Q7O0FBRUQsU0FBT0osTUFBUDtBQUNELENBWkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50eXBlID0gKHN0cikgPT4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyYW1zID0gKHZhbCkgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcbiAgZm9yIChjb25zdCBzdHIgb2YgdmFsLnNwbGl0KC8gKjsgKi8pKSB7XG4gICAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCB2YWwgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VMaW5rcyA9ICh2YWwpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAoY29uc3Qgc3RyIG9mIHZhbC5zcGxpdCgvICosICovKSkge1xuICAgIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KC8gKjsgKi8pO1xuICAgIGNvbnN0IHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBjb25zdCByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqW3JlbF0gPSB1cmw7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSAoaGVhZGVyLCBjaGFuZ2VzT3JpZ2luKSA9PiB7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyLmhvc3Q7XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlci5hdXRob3JpemF0aW9uO1xuICAgIGRlbGV0ZSBoZWFkZXIuY29va2llO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcjtcbn07XG4iXX0=

/***/ }),

/***/ 78743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = (__webpack_require__(30775).strict)

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}


/***/ }),

/***/ 63854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(73837).deprecate;


/***/ }),

/***/ 98117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(86005);

/***/ }),

/***/ 30906:
/***/ ((module) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var Deprecation = {
    disableWarnings: false,

    deprecationWarningMap: {

    },

    warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
            console.warn('DEPRECATION WARNING: ' + this.deprecationWarningMap[deprecationName]);
            this.deprecationWarningMap[deprecationName] = false;
        }
    }
};

module.exports = Deprecation;


/***/ }),

/***/ 81883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var WebSocketClient = __webpack_require__(18951);
var toBuffer = __webpack_require__(78743);
var yaeti = __webpack_require__(66284);


const CONNECTING = 0;
const OPEN = 1;
const CLOSING = 2;
const CLOSED = 3;


module.exports = W3CWebSocket;


function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
    // Make this an EventTarget.
    yaeti.EventTarget.call(this);

    // Sanitize clientConfig.
    clientConfig = clientConfig || {};
    clientConfig.assembleFragments = true;  // Required in the W3C API.

    var self = this;

    this._url = url;
    this._readyState = CONNECTING;
    this._protocol = undefined;
    this._extensions = '';
    this._bufferedAmount = 0;  // Hack, always 0.
    this._binaryType = 'arraybuffer';  // TODO: Should be 'blob' by default, but Node has no Blob.

    // The WebSocketConnection instance.
    this._connection = undefined;

    // WebSocketClient instance.
    this._client = new WebSocketClient(clientConfig);

    this._client.on('connect', function(connection) {
        onConnect.call(self, connection);
    });

    this._client.on('connectFailed', function() {
        onConnectFailed.call(self);
    });

    this._client.connect(url, protocols, origin, headers, requestOptions);
}


// Expose W3C read only attributes.
Object.defineProperties(W3CWebSocket.prototype, {
    url:            { get: function() { return this._url;            } },
    readyState:     { get: function() { return this._readyState;     } },
    protocol:       { get: function() { return this._protocol;       } },
    extensions:     { get: function() { return this._extensions;     } },
    bufferedAmount: { get: function() { return this._bufferedAmount; } }
});


// Expose W3C write/read attributes.
Object.defineProperties(W3CWebSocket.prototype, {
    binaryType: {
        get: function() {
            return this._binaryType;
        },
        set: function(type) {
            // TODO: Just 'arraybuffer' supported.
            if (type !== 'arraybuffer') {
                throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
            }
            this._binaryType = type;
        }
    }
});


// Expose W3C readyState constants into the WebSocket instance as W3C states.
[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {
    Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() { return property[1]; }
    });
});

// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,
// but there are so many libs relying on them).
[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {
    Object.defineProperty(W3CWebSocket, property[0], {
        get: function() { return property[1]; }
    });
});


W3CWebSocket.prototype.send = function(data) {
    if (this._readyState !== OPEN) {
        throw new Error('cannot call send() while not connected');
    }

    // Text.
    if (typeof data === 'string' || data instanceof String) {
        this._connection.sendUTF(data);
    }
    // Binary.
    else {
        // Node Buffer.
        if (data instanceof Buffer) {
            this._connection.sendBytes(data);
        }
        // If ArrayBuffer or ArrayBufferView convert it to Node Buffer.
        else if (data.byteLength || data.byteLength === 0) {
            data = toBuffer(data);
            this._connection.sendBytes(data);
        }
        else {
            throw new Error('unknown binary data:', data);
        }
    }
};


W3CWebSocket.prototype.close = function(code, reason) {
    switch(this._readyState) {
        case CONNECTING:
            // NOTE: We don't have the WebSocketConnection instance yet so no
            // way to close the TCP connection.
            // Artificially invoke the onConnectFailed event.
            onConnectFailed.call(this);
            // And close if it connects after a while.
            this._client.on('connect', function(connection) {
                if (code) {
                    connection.close(code, reason);
                } else {
                    connection.close();
                }
            });
            break;
        case OPEN:
            this._readyState = CLOSING;
            if (code) {
                this._connection.close(code, reason);
            } else {
                this._connection.close();
            }
            break;
        case CLOSING:
        case CLOSED:
            break;
    }
};


/**
 * Private API.
 */


function createCloseEvent(code, reason) {
    var event = new yaeti.Event('close');

    event.code = code;
    event.reason = reason;
    event.wasClean = (typeof code === 'undefined' || code === 1000);

    return event;
}


function createMessageEvent(data) {
    var event = new yaeti.Event('message');

    event.data = data;

    return event;
}


function onConnect(connection) {
    var self = this;

    this._readyState = OPEN;
    this._connection = connection;
    this._protocol = connection.protocol;
    this._extensions = connection.extensions;

    this._connection.on('close', function(code, reason) {
        onClose.call(self, code, reason);
    });

    this._connection.on('message', function(msg) {
        onMessage.call(self, msg);
    });

    this.dispatchEvent(new yaeti.Event('open'));
}


function onConnectFailed() {
    destroy.call(this);
    this._readyState = CLOSED;

    try {
        this.dispatchEvent(new yaeti.Event('error'));
    } finally {
        this.dispatchEvent(createCloseEvent(1006, 'connection failed'));
    }
}


function onClose(code, reason) {
    destroy.call(this);
    this._readyState = CLOSED;

    this.dispatchEvent(createCloseEvent(code, reason || ''));
}


function onMessage(message) {
    if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
    }
    else if (message.binaryData) {
        // Must convert from Node Buffer to ArrayBuffer.
        // TODO: or to a Blob (which does not exist in Node!).
        if (this.binaryType === 'arraybuffer') {
            var buffer = message.binaryData;
            var arraybuffer = new ArrayBuffer(buffer.length);
            var view = new Uint8Array(arraybuffer);
            for (var i=0, len=buffer.length; i<len; ++i) {
                view[i] = buffer[i];
            }
            this.dispatchEvent(createMessageEvent(arraybuffer));
        }
    }
}


function destroy() {
    this._client.removeAllListeners();
    if (this._connection) {
        this._connection.removeAllListeners();
    }
}


/***/ }),

/***/ 18951:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var utils = __webpack_require__(76093);
var extend = utils.extend;
var util = __webpack_require__(73837);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var url = __webpack_require__(57310);
var crypto = __webpack_require__(6113);
var WebSocketConnection = __webpack_require__(16283);
var bufferAllocUnsafe = utils.bufferAllocUnsafe;

var protocolSeparators = [
    '(', ')', '<', '>', '@',
    ',', ';', ':', '\\', '\"',
    '/', '[', ']', '?', '=',
    '{', '}', ' ', String.fromCharCode(9)
];

var excludedTlsOptions = ['hostname','port','method','path','headers'];

function WebSocketClient(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    // TODO: Implement extensions

    this.config = {
        // 1MiB max frame size.
        maxReceivedFrameSize: 0x100000,

        // 8MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 0x800000,

        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,

        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 0x4000,

        // Which version of the protocol to use for this session.  This
        // option will be removed once the protocol is finalized by the IETF
        // It is only available to ease the transition through the
        // intermediate draft protocol versions.
        // At present, it only affects the name of the Origin header.
        webSocketVersion: 13,

        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,

        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,

        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5000,

        // Options to pass to https.connect if connecting via TLS
        tlsOptions: {}
    };

    if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        }
        else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
    }

    this._req = null;
    
    switch (this.config.webSocketVersion) {
        case 8:
        case 13:
            break;
        default:
            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');
    }
}

util.inherits(WebSocketClient, EventEmitter);

WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
    var self = this;
    
    if (typeof(protocols) === 'string') {
        if (protocols.length > 0) {
            protocols = [protocols];
        }
        else {
            protocols = [];
        }
    }
    if (!(protocols instanceof Array)) {
        protocols = [];
    }
    this.protocols = protocols;
    this.origin = origin;

    if (typeof(requestUrl) === 'string') {
        this.url = url.parse(requestUrl);
    }
    else {
        this.url = requestUrl; // in case an already parsed url is passed in.
    }
    if (!this.url.protocol) {
        throw new Error('You must specify a full WebSocket URL, including protocol.');
    }
    if (!this.url.host) {
        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');
    }

    this.secure = (this.url.protocol === 'wss:');

    // validate protocol characters:
    this.protocols.forEach(function(protocol) {
        for (var i=0; i < protocol.length; i ++) {
            var charCode = protocol.charCodeAt(i);
            var character = protocol.charAt(i);
            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {
                throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
            }
        }
    });

    var defaultPorts = {
        'ws:': '80',
        'wss:': '443'
    };

    if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
    }

    var nonce = bufferAllocUnsafe(16);
    for (var i=0; i < 16; i++) {
        nonce[i] = Math.round(Math.random()*0xFF);
    }
    this.base64nonce = nonce.toString('base64');

    var hostHeaderValue = this.url.hostname;
    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||
        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {
        hostHeaderValue += (':' + this.url.port);
    }

    var reqHeaders = {};
    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {
      // Allow for additional headers to be provided when connecting via HTTPS
      extend(reqHeaders, this.config.tlsOptions.headers);
    }
    if (headers) {
      // Explicitly provided headers take priority over any from tlsOptions
      extend(reqHeaders, headers);
    }
    extend(reqHeaders, {
        'Upgrade': 'websocket',
        'Connection': 'Upgrade',
        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),
        'Sec-WebSocket-Key': this.base64nonce,
        'Host': reqHeaders.Host || hostHeaderValue
    });

    if (this.protocols.length > 0) {
        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');
    }
    if (this.origin) {
        if (this.config.webSocketVersion === 13) {
            reqHeaders['Origin'] = this.origin;
        }
        else if (this.config.webSocketVersion === 8) {
            reqHeaders['Sec-WebSocket-Origin'] = this.origin;
        }
    }

    // TODO: Implement extensions

    var pathAndQuery;
    // Ensure it begins with '/'.
    if (this.url.pathname) {
        pathAndQuery = this.url.path;
    }
    else if (this.url.path) {
        pathAndQuery = '/' + this.url.path;
    }
    else {
        pathAndQuery = '/';
    }

    function handleRequestError(error) {
        self._req = null;
        self.emit('connectFailed', error);
    }

    var requestOptions = {
        agent: false
    };
    if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
    }
    // These options are always overridden by the library.  The user is not
    // allowed to specify these directly.
    extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: 'GET',
        path: pathAndQuery,
        headers: reqHeaders
    });
    if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key in tlsOptions) {
            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {
                requestOptions[key] = tlsOptions[key];
            }
        }
    }

    var req = this._req = (this.secure ? https : http).request(requestOptions);
    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {
        self._req = null;
        req.removeListener('error', handleRequestError);
        self.socket = socket;
        self.response = response;
        self.firstDataChunk = head;
        self.validateHandshake();
    });
    req.on('error', handleRequestError);

    req.on('response', function(response) {
        self._req = null;
        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {
            self.emit('httpResponse', response, self);
            if (response.socket) {
                response.socket.end();
            }
        }
        else {
            var headerDumpParts = [];
            for (var headerName in response.headers) {
                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);
            }
            self.failHandshake(
                'Server responded with a non-101 status: ' +
                response.statusCode + ' ' + response.statusMessage +
                '\nResponse Headers Follow:\n' +
                headerDumpParts.join('\n') + '\n'
            );
        }
    });
    req.end();
};

WebSocketClient.prototype.validateHandshake = function() {
    var headers = this.response.headers;

    if (this.protocols.length > 0) {
        this.protocol = headers['sec-websocket-protocol'];
        if (this.protocol) {
            if (this.protocols.indexOf(this.protocol) === -1) {
                this.failHandshake('Server did not respond with a requested protocol.');
                return;
            }
        }
        else {
            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');
            return;
        }
    }

    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {
        this.failHandshake('Expected a Connection: Upgrade header from the server');
        return;
    }

    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {
        this.failHandshake('Expected an Upgrade: websocket header from the server');
        return;
    }

    var sha1 = crypto.createHash('sha1');
    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    var expectedKey = sha1.digest('base64');

    if (!headers['sec-websocket-accept']) {
        this.failHandshake('Expected Sec-WebSocket-Accept header from server');
        return;
    }

    if (headers['sec-websocket-accept'] !== expectedKey) {
        this.failHandshake('Sec-WebSocket-Accept header from server didn\'t match expected value of ' + expectedKey);
        return;
    }

    // TODO: Support extensions

    this.succeedHandshake();
};

WebSocketClient.prototype.failHandshake = function(errorDescription) {
    if (this.socket && this.socket.writable) {
        this.socket.end();
    }
    this.emit('connectFailed', new Error(errorDescription));
};

WebSocketClient.prototype.succeedHandshake = function() {
    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);

    connection.webSocketVersion = this.config.webSocketVersion;
    connection._addSocketEventListeners();

    this.emit('connect', connection);
    if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
    }
    this.firstDataChunk = null;
};

WebSocketClient.prototype.abort = function() {
    if (this._req) {
        this._req.abort();
    }
};

module.exports = WebSocketClient;


/***/ }),

/***/ 16283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var util = __webpack_require__(73837);
var utils = __webpack_require__(76093);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var WebSocketFrame = __webpack_require__(57834);
var BufferList = __webpack_require__(90266);
var isValidUTF8 = __webpack_require__(23284);
var bufferAllocUnsafe = utils.bufferAllocUnsafe;
var bufferFromString = utils.bufferFromString;

// Connected, fully-open, ready to send and receive frames
const STATE_OPEN = 'open';
// Received a close frame from the remote peer
const STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';
// Sent close frame to remote peer.  No further data can be sent.
const STATE_ENDING = 'ending';
// Connection is fully closed.  No further data can be sent or received.
const STATE_CLOSED = 'closed';

var setImmediateImpl = ('setImmediate' in global) ?
                            global.setImmediate.bind(global) :
                            process.nextTick.bind(process);

var idCounter = 0;

function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);
    this._debug('constructor');
    
    if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
    }
    
    // Superclass Constructor
    EventEmitter.call(this);

    this._pingListenerCount = 0;
    this.on('newListener', function(ev) {
        if (ev === 'ping'){
            this._pingListenerCount++;
        }
      }).on('removeListener', function(ev) {
        if (ev === 'ping') {
            this._pingListenerCount--;
        }
    });

    this.config = config;
    this.socket = socket;
    this.protocol = protocol;
    this.extensions = extensions;
    this.remoteAddress = socket.remoteAddress;
    this.closeReasonCode = -1;
    this.closeDescription = null;
    this.closeEventEmitted = false;

    // We have to mask outgoing packets if we're acting as a WebSocket client.
    this.maskOutgoingPackets = maskOutgoingPackets;

    // We re-use the same buffers for the mask and frame header for all frames
    // received on each connection to avoid a small memory allocation for each
    // frame.
    this.maskBytes = bufferAllocUnsafe(4);
    this.frameHeader = bufferAllocUnsafe(10);

    // the BufferList will handle the data streaming in
    this.bufferList = new BufferList();

    // Prepare for receiving first frame
    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    this.fragmentationSize = 0; // data received so far...
    this.frameQueue = [];
    
    // Various bits of connection state
    this.connected = true;
    this.state = STATE_OPEN;
    this.waitingForCloseResponse = false;
    // Received TCP FIN, socket's readable stream is finished.
    this.receivedEnd = false;

    this.closeTimeout = this.config.closeTimeout;
    this.assembleFragments = this.config.assembleFragments;
    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;

    this.outputBufferFull = false;
    this.inputPaused = false;
    this.receivedDataHandler = this.processReceivedData.bind(this);
    this._closeTimerHandler = this.handleCloseTimer.bind(this);

    // Disable nagle algorithm?
    this.socket.setNoDelay(this.config.disableNagleAlgorithm);

    // Make sure there is no socket inactivity timeout
    this.socket.setTimeout(0);

    if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof(this.config.keepaliveInterval) !== 'number') {
            throw new Error('keepaliveInterval must be specified and numeric ' +
                            'if keepalive is true.');
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();

        if (this.config.dropConnectionOnKeepaliveTimeout) {
            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {
                throw new Error('keepaliveGracePeriod  must be specified and ' +
                                'numeric if dropConnectionOnKeepaliveTimeout ' +
                                'is true.');
            }
            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
    }
    else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!('setKeepAlive' in this.socket)) {
            throw new Error('Unable to use native keepalive: unsupported by ' +
                            'this version of Node.');
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
    }
    
    // The HTTP Client seems to subscribe to socket error events
    // and re-dispatch them in such a way that doesn't make sense
    // for users of our client, so we want to make sure nobody
    // else is listening for error events on the socket besides us.
    this.socket.removeAllListeners('error');
}

WebSocketConnection.CLOSE_REASON_NORMAL = 1000;
WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
WebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.
WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire
WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire
WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire

WebSocketConnection.CLOSE_DESCRIPTIONS = {
    1000: 'Normal connection closure',
    1001: 'Remote peer is going away',
    1002: 'Protocol error',
    1003: 'Unprocessable input',
    1004: 'Reserved',
    1005: 'Reason not provided',
    1006: 'Abnormal closure, no further detail available',
    1007: 'Invalid data received',
    1008: 'Policy violation',
    1009: 'Message too big',
    1010: 'Extension requested by client is required',
    1011: 'Internal Server Error',
    1015: 'TLS Handshake Failed'
};

function validateCloseReason(code) {
    if (code < 1000) {
        // Status codes in the range 0-999 are not used
        return false;
    }
    if (code >= 1000 && code <= 2999) {
        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only
        // a few codes are defined, all others are currently illegal.
        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
    }
    if (code >= 3000 && code <= 3999) {
        // Reserved for use by libraries, frameworks, and applications.
        // Should be registered with IANA.  Interpretation of these codes is
        // undefined by the WebSocket protocol.
        return true;
    }
    if (code >= 4000 && code <= 4999) {
        // Reserved for private use.  Interpretation of these codes is
        // undefined by the WebSocket protocol.
        return true;
    }
    if (code >= 5000) {
        return false;
    }
}

util.inherits(WebSocketConnection, EventEmitter);

WebSocketConnection.prototype._addSocketEventListeners = function() {
    this.socket.on('error', this.handleSocketError.bind(this));
    this.socket.on('end', this.handleSocketEnd.bind(this));
    this.socket.on('close', this.handleSocketClose.bind(this));
    this.socket.on('drain', this.handleSocketDrain.bind(this));
    this.socket.on('pause', this.handleSocketPause.bind(this));
    this.socket.on('resume', this.handleSocketResume.bind(this));
    this.socket.on('data', this.handleSocketData.bind(this));
};

// set or reset the keepalive timer when data is received.
WebSocketConnection.prototype.setKeepaliveTimer = function() {
    this._debug('setKeepaliveTimer');
    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();
    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
};

WebSocketConnection.prototype.clearKeepaliveTimer = function() {
    if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
    }
};

// No data has been received within config.keepaliveTimeout ms.
WebSocketConnection.prototype.handleKeepaliveTimer = function() {
    this._debug('handleKeepaliveTimer');
    this._keepaliveTimeoutID = null;
    this.ping();

    // If we are configured to drop connections if the client doesn't respond
    // then set the grace period timer.
    if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
    }
    else {
        // Otherwise reset the keepalive timer to send the next ping.
        this.setKeepaliveTimer();
    }
};

WebSocketConnection.prototype.setGracePeriodTimer = function() {
    this._debug('setGracePeriodTimer');
    this.clearGracePeriodTimer();
    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
};

WebSocketConnection.prototype.clearGracePeriodTimer = function() {
    if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
    }
};

WebSocketConnection.prototype.handleGracePeriodTimer = function() {
    this._debug('handleGracePeriodTimer');
    // If this is called, the client has not responded and is assumed dead.
    this._gracePeriodTimeoutID = null;
    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);
};

WebSocketConnection.prototype.handleSocketData = function(data) {
    this._debug('handleSocketData');
    // Reset the keepalive timer when receiving data of any kind.
    this.setKeepaliveTimer();

    // Add received data to our bufferList, which efficiently holds received
    // data chunks in a linked list of Buffer objects.
    this.bufferList.write(data);

    this.processReceivedData();
};

WebSocketConnection.prototype.processReceivedData = function() {
    this._debug('processReceivedData');
    // If we're not connected, we should ignore any data remaining on the buffer.
    if (!this.connected) { return; }

    // Receiving/parsing is expected to be halted when paused.
    if (this.inputPaused) { return; }

    var frame = this.currentFrame;

    // WebSocketFrame.prototype.addData returns true if all data necessary to
    // parse the frame was available.  It returns false if we are waiting for
    // more data to come in on the wire.
    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }

    var self = this;

    // Handle possible parsing errors
    if (frame.protocolError) {
        // Something bad happened.. get rid of this client.
        this._debug('-- protocol error');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
    }
    else if (frame.frameTooLarge) {
        this._debug('-- frame too large');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
    }

    // For now since we don't support extensions, all RSV bits are illegal
    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug('-- illegal rsv flag');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
              'Unsupported usage of rsv bits without negotiated extension.');
        });
        return;
    }

    if (!this.assembleFragments) {
        this._debug('-- emitting frame');
        process.nextTick(function() { self.emit('frame', frame); });
    }

    process.nextTick(function() { self.processFrame(frame); });
    
    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);

    // If there's data remaining, schedule additional processing, but yield
    // for now so that other connections have a chance to have their data
    // processed.  We use setImmediate here instead of process.nextTick to
    // explicitly indicate that we wish for other I/O to be handled first.
    if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
    }
};

WebSocketConnection.prototype.handleSocketError = function(error) {
    this._debug('handleSocketError: %j', error);
    if (this.state === STATE_CLOSED) {
		// See https://github.com/theturtle32/WebSocket-Node/issues/288
        this._debug('  --- Socket \'error\' after \'close\'');
        return;
    }
    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;
    this.connected = false;
    this.state = STATE_CLOSED;
    this.fragmentationSize = 0;
    if (utils.eventEmitterListenerCount(this, 'error') > 0) {
        this.emit('error', error);
    }
    this.socket.destroy();
    this._debug.printOutput();
};

WebSocketConnection.prototype.handleSocketEnd = function() {
    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);
    this.receivedEnd = true;
    if (this.state === STATE_CLOSED) {
        // When using the TLS module, sometimes the socket will emit 'end'
        // after it emits 'close'.  I don't think that's correct behavior,
        // but we should deal with it gracefully by ignoring it.
        this._debug('  --- Socket \'end\' after \'close\'');
        return;
    }
    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&
        this.state !== STATE_ENDING) {
      this._debug('  --- UNEXPECTED socket end.');
      this.socket.end();
    }
};

WebSocketConnection.prototype.handleSocketClose = function(hadError) {
    this._debug('handleSocketClose: received socket close');
    this.socketHadError = hadError;
    this.connected = false;
    this.state = STATE_CLOSED;
    // If closeReasonCode is still set to -1 at this point then we must
    // not have received a close frame!!
    if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = 'Connection dropped by remote peer.';
    }
    this.clearCloseTimer();
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();
    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug('-- Emitting WebSocketConnection close event');
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
};

WebSocketConnection.prototype.handleSocketDrain = function() {
    this._debug('handleSocketDrain: socket drain event');
    this.outputBufferFull = false;
    this.emit('drain');
};

WebSocketConnection.prototype.handleSocketPause = function() {
    this._debug('handleSocketPause: socket pause event');
    this.inputPaused = true;
    this.emit('pause');
};

WebSocketConnection.prototype.handleSocketResume = function() {
    this._debug('handleSocketResume: socket resume event');
    this.inputPaused = false;
    this.emit('resume');
    this.processReceivedData();
};

WebSocketConnection.prototype.pause = function() {
    this._debug('pause: pause requested');
    this.socket.pause();
};

WebSocketConnection.prototype.resume = function() {
    this._debug('resume: resume requested');
    this.socket.resume();
};

WebSocketConnection.prototype.close = function(reasonCode, description) {
    if (this.connected) {
        this._debug('close: Initating clean WebSocket close sequence.');
        if ('number' !== typeof reasonCode) {
            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
            throw new Error('Close code ' + reasonCode + ' is not valid.');
        }
        if ('string' !== typeof description) {
            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
    }
};

WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
    this._debug('drop');
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
    }

    if (typeof(description) !== 'string') {
        // If no description is provided, try to look one up based on the
        // specified reasonCode.
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
    }

    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',
        skipCloseFrame, reasonCode, description
    );

    this.closeReasonCode = reasonCode;
    this.closeDescription = description;
    this.frameQueue = [];
    this.fragmentationSize = 0;
    if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
    }
    this.connected = false;
    this.state = STATE_CLOSED;
    this.clearCloseTimer();
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();

    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug('Emitting WebSocketConnection close event');
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
    
    this._debug('Drop: destroying socket');
    this.socket.destroy();
};

WebSocketConnection.prototype.setCloseTimer = function() {
    this._debug('setCloseTimer');
    this.clearCloseTimer();
    this._debug('Setting close timer');
    this.waitingForCloseResponse = true;
    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
};

WebSocketConnection.prototype.clearCloseTimer = function() {
    this._debug('clearCloseTimer');
    if (this.closeTimer) {
        this._debug('Clearing close timer');
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
    }
};

WebSocketConnection.prototype.handleCloseTimer = function() {
    this._debug('handleCloseTimer');
    this.closeTimer = null;
    if (this.waitingForCloseResponse) {
        this._debug('Close response not received from client.  Forcing socket end.');
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
    }
};

WebSocketConnection.prototype.processFrame = function(frame) {
    this._debug('processFrame');
    this._debug(' -- frame: %s', frame);
    
    // Any non-control opcode besides 0x00 (continuation) received in the
    // middle of a fragmented message is illegal.
    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {
        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +
          'received in middle of fragmented message.');
        return;
    }

    switch(frame.opcode) {
        case 0x02: // WebSocketFrame.BINARY_FRAME
            this._debug('-- Binary Frame');
            if (this.assembleFragments) {
                if (frame.fin) {
                    // Complete single-frame message received
                    this._debug('---- Emitting \'message\' event');
                    this.emit('message', {
                        type: 'binary',
                        binaryData: frame.binaryPayload
                    });
                }
                else {
                    // beginning of a fragmented message
                    this.frameQueue.push(frame);
                    this.fragmentationSize = frame.length;
                }
            }
            break;
        case 0x01: // WebSocketFrame.TEXT_FRAME
            this._debug('-- Text Frame');
            if (this.assembleFragments) {
                if (frame.fin) {
                    if (!isValidUTF8(frame.binaryPayload)) {
                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                          'Invalid UTF-8 Data Received');
                        return;
                    }
                    // Complete single-frame message received
                    this._debug('---- Emitting \'message\' event');
                    this.emit('message', {
                        type: 'utf8',
                        utf8Data: frame.binaryPayload.toString('utf8')
                    });
                }
                else {
                    // beginning of a fragmented message
                    this.frameQueue.push(frame);
                    this.fragmentationSize = frame.length;
                }
            }
            break;
        case 0x00: // WebSocketFrame.CONTINUATION
            this._debug('-- Continuation Frame');
            if (this.assembleFragments) {
                if (this.frameQueue.length === 0) {
                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                      'Unexpected Continuation Frame');
                    return;
                }

                this.fragmentationSize += frame.length;

                if (this.fragmentationSize > this.maxReceivedMessageSize) {
                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,
                      'Maximum message size exceeded.');
                    return;
                }

                this.frameQueue.push(frame);

                if (frame.fin) {
                    // end of fragmented message, so we process the whole
                    // message now.  We also have to decode the utf-8 data
                    // for text frames after combining all the fragments.
                    var bytesCopied = 0;
                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
                    var opcode = this.frameQueue[0].opcode;
                    this.frameQueue.forEach(function (currentFrame) {
                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                        bytesCopied += currentFrame.binaryPayload.length;
                    });
                    this.frameQueue = [];
                    this.fragmentationSize = 0;

                    switch (opcode) {
                        case 0x02: // WebSocketOpcode.BINARY_FRAME
                            this.emit('message', {
                                type: 'binary',
                                binaryData: binaryPayload
                            });
                            break;
                        case 0x01: // WebSocketOpcode.TEXT_FRAME
                            if (!isValidUTF8(binaryPayload)) {
                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                                  'Invalid UTF-8 Data Received');
                                return;
                            }
                            this.emit('message', {
                                type: 'utf8',
                                utf8Data: binaryPayload.toString('utf8')
                            });
                            break;
                        default:
                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));
                            return;
                    }
                }
            }
            break;
        case 0x09: // WebSocketFrame.PING
            this._debug('-- Ping Frame');

            if (this._pingListenerCount > 0) {
                // logic to emit the ping frame: this is only done when a listener is known to exist
                // Expose a function allowing the user to override the default ping() behavior
                var cancelled = false;
                var cancel = function() { 
                  cancelled = true; 
                };
                this.emit('ping', cancel, frame.binaryPayload);

                // Only send a pong if the client did not indicate that he would like to cancel
                if (!cancelled) {
                    this.pong(frame.binaryPayload);
                }
            }
            else {
                this.pong(frame.binaryPayload);
            }

            break;
        case 0x0A: // WebSocketFrame.PONG
            this._debug('-- Pong Frame');
            this.emit('pong', frame.binaryPayload);
            break;
        case 0x08: // WebSocketFrame.CONNECTION_CLOSE
            this._debug('-- Close Frame');
            if (this.waitingForCloseResponse) {
                // Got response to our request to close the connection.
                // Close is complete, so we just hang up.
                this._debug('---- Got close response from peer.  Completing closing handshake.');
                this.clearCloseTimer();
                this.waitingForCloseResponse = false;
                this.state = STATE_CLOSED;
                this.socket.end();
                return;
            }
            
            this._debug('---- Closing handshake initiated by peer.');
            // Got request from other party to close connection.
            // Send back acknowledgement and then hang up.
            this.state = STATE_PEER_REQUESTED_CLOSE;
            var respondCloseReasonCode;

            // Make sure the close reason provided is legal according to
            // the protocol spec.  Providing no close status is legal.
            // WebSocketFrame sets closeStatus to -1 by default, so if it
            // is still -1, then no status was provided.
            if (frame.invalidCloseFrameLength) {
                this.closeReasonCode = 1005; // 1005 = No reason provided.
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
            }
            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
                this.closeReasonCode = frame.closeStatus;
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
            }
            else {
                this.closeReasonCode = frame.closeStatus;
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
            }
            
            // If there is a textual description in the close frame, extract it.
            if (frame.binaryPayload.length > 1) {
                if (!isValidUTF8(frame.binaryPayload)) {
                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                      'Invalid UTF-8 Data Received');
                    return;
                }
                this.closeDescription = frame.binaryPayload.toString('utf8');
            }
            else {
                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
            }
            this._debug(
                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',
                this.remoteAddress, this.closeReasonCode,
                this.closeDescription, frame.length
            );
            this._debug('------ responding to remote peer\'s close request.');
            this.sendCloseFrame(respondCloseReasonCode, null);
            this.connected = false;
            break;
        default:
            this._debug('-- Unrecognized Opcode %d', frame.opcode);
            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));
            break;
    }
};

WebSocketConnection.prototype.send = function(data, cb) {
    this._debug('send');
    if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
    }
    else if (typeof(data['toString']) === 'function') {
        this.sendUTF(data, cb);
    }
    else {
        throw new Error('Data provided must either be a Node Buffer or implement toString()');
    }
};

WebSocketConnection.prototype.sendUTF = function(data, cb) {
    data = bufferFromString(data.toString(), 'utf8');
    this._debug('sendUTF: %d bytes', data.length);
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME
    frame.binaryPayload = data;
    this.fragmentAndSend(frame, cb);
};

WebSocketConnection.prototype.sendBytes = function(data, cb) {
    this._debug('sendBytes');
    if (!Buffer.isBuffer(data)) {
        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');
    }
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME
    frame.binaryPayload = data;
    this.fragmentAndSend(frame, cb);
};

WebSocketConnection.prototype.ping = function(data) {
    this._debug('ping');
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x09; // WebSocketOpcode.PING
    frame.fin = true;
    if (data) {
        if (!Buffer.isBuffer(data)) {
            data = bufferFromString(data.toString(), 'utf8');
        }
        if (data.length > 125) {
            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');
            data = data.slice(0,124);
        }
        frame.binaryPayload = data;
    }
    this.sendFrame(frame);
};

// Pong frames have to echo back the contents of the data portion of the
// ping frame exactly, byte for byte.
WebSocketConnection.prototype.pong = function(binaryPayload) {
    this._debug('pong');
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x0A; // WebSocketOpcode.PONG
    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');
        binaryPayload = binaryPayload.slice(0,124);
    }
    frame.binaryPayload = binaryPayload;
    frame.fin = true;
    this.sendFrame(frame);
};

WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
    this._debug('fragmentAndSend');
    if (frame.opcode > 0x07) {
        throw new Error('You cannot fragment control frames.');
    }

    var threshold = this.config.fragmentationThreshold;
    var length = frame.binaryPayload.length;

    // Send immediately if fragmentation is disabled or the message is not
    // larger than the fragmentation threshold.
    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
    }
    
    var numFragments = Math.ceil(length / threshold);
    var sentFragments = 0;
    var sentCallback = function fragmentSentCallback(err) {
        if (err) {
            if (typeof cb === 'function') {
                // pass only the first error
                cb(err);
                cb = null;
            }
            return;
        }
        ++sentFragments;
        if ((sentFragments === numFragments) && (typeof cb === 'function')) {
            cb();
        }
    };
    for (var i=1; i <= numFragments; i++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        
        // continuation opcode except for first frame.
        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;
        
        // fin set on last frame only
        currentFrame.fin = (i === numFragments);
        
        // length is likely to be shorter on the last fragment
        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;
        var sliceStart = threshold * (i-1);
        
        // Slice the right portion of the original payload
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        
        this.sendFrame(currentFrame, sentCallback);
    }
};

WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
    }
    
    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);
    
    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }
    
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.fin = true;
    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE
    frame.closeStatus = reasonCode;
    if (typeof(description) === 'string') {
        frame.binaryPayload = bufferFromString(description, 'utf8');
    }
    
    this.sendFrame(frame, cb);
    this.socket.end();
};

WebSocketConnection.prototype.sendFrame = function(frame, cb) {
    this._debug('sendFrame');
    frame.mask = this.maskOutgoingPackets;
    var flushed = this.socket.write(frame.toBuffer(), cb);
    this.outputBufferFull = !flushed;
    return flushed;
};

module.exports = WebSocketConnection;



function instrumentSocketForDebugging(connection, socket) {
    /* jshint loopfunc: true */
    if (!connection._debug.enabled) { return; }
    
    var originalSocketEmit = socket.emit;
    socket.emit = function(event) {
        connection._debug('||| Socket Event  \'%s\'', event);
        originalSocketEmit.apply(this, arguments);
    };
    
    for (var key in socket) {
        if ('function' !== typeof(socket[key])) { continue; }
        if (['emit'].indexOf(key) !== -1) { continue; }
        (function(key) {
            var original = socket[key];
            if (key === 'on') {
                socket[key] = function proxyMethod__EventEmitter__On() {
                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);
                    return original.apply(this, arguments);
                };
                return;
            }
            socket[key] = function proxyMethod() {
                connection._debug('||| Socket method called:  %s', key);
                return original.apply(this, arguments);
            };
        })(key);
    }
}


/***/ }),

/***/ 57834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var bufferUtil = __webpack_require__(86544);
var bufferAllocUnsafe = (__webpack_require__(76093).bufferAllocUnsafe);

const DECODE_HEADER = 1;
const WAITING_FOR_16_BIT_LENGTH = 2;
const WAITING_FOR_64_BIT_LENGTH = 3;
const WAITING_FOR_MASK_KEY = 4;
const WAITING_FOR_PAYLOAD = 5;
const COMPLETE = 6;

// WebSocketConnection will pass shared buffer objects for maskBytes and
// frameHeader into the constructor to avoid tons of small memory allocations
// for each frame we have to parse.  This is only used for parsing frames
// we receive off the wire.
function WebSocketFrame(maskBytes, frameHeader, config) {
    this.maskBytes = maskBytes;
    this.frameHeader = frameHeader;
    this.config = config;
    this.maxReceivedFrameSize = config.maxReceivedFrameSize;
    this.protocolError = false;
    this.frameTooLarge = false;
    this.invalidCloseFrameLength = false;
    this.parseState = DECODE_HEADER;
    this.closeStatus = -1;
}

WebSocketFrame.prototype.addData = function(bufferList) {
    if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
            bufferList.joinInto(this.frameHeader, 0, 0, 2);
            bufferList.advance(2);
            var firstByte = this.frameHeader[0];
            var secondByte = this.frameHeader[1];

            this.fin     = Boolean(firstByte  & 0x80);
            this.rsv1    = Boolean(firstByte  & 0x40);
            this.rsv2    = Boolean(firstByte  & 0x20);
            this.rsv3    = Boolean(firstByte  & 0x10);
            this.mask    = Boolean(secondByte & 0x80);

            this.opcode  = firstByte  & 0x0F;
            this.length = secondByte & 0x7F;

            // Control frame sanity check
            if (this.opcode >= 0x08) {
                if (this.length > 125) {
                    this.protocolError = true;
                    this.dropReason = 'Illegal control frame longer than 125 bytes.';
                    return true;
                }
                if (!this.fin) {
                    this.protocolError = true;
                    this.dropReason = 'Control frames must not be fragmented.';
                    return true;
                }
            }

            if (this.length === 126) {
                this.parseState = WAITING_FOR_16_BIT_LENGTH;
            }
            else if (this.length === 127) {
                this.parseState = WAITING_FOR_64_BIT_LENGTH;
            }
            else {
                this.parseState = WAITING_FOR_MASK_KEY;
            }
        }
    }
    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
            bufferList.joinInto(this.frameHeader, 2, 0, 2);
            bufferList.advance(2);
            this.length = this.frameHeader.readUInt16BE(2);
            this.parseState = WAITING_FOR_MASK_KEY;
        }
    }
    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
            bufferList.joinInto(this.frameHeader, 2, 0, 8);
            bufferList.advance(8);
            var lengthPair = [
              this.frameHeader.readUInt32BE(2),
              this.frameHeader.readUInt32BE(2+4)
            ];

            if (lengthPair[0] !== 0) {
                this.protocolError = true;
                this.dropReason = 'Unsupported 64-bit length frame received';
                return true;
            }
            this.length = lengthPair[1];
            this.parseState = WAITING_FOR_MASK_KEY;
        }
    }

    if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
            if (bufferList.length >= 4) {
                bufferList.joinInto(this.maskBytes, 0, 0, 4);
                bufferList.advance(4);
                this.parseState = WAITING_FOR_PAYLOAD;
            }
        }
        else {
            this.parseState = WAITING_FOR_PAYLOAD;
        }
    }

    if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
            this.frameTooLarge = true;
            this.dropReason = 'Frame size of ' + this.length.toString(10) +
                              ' bytes exceeds maximum accepted frame size';
            return true;
        }

        if (this.length === 0) {
            this.binaryPayload = bufferAllocUnsafe(0);
            this.parseState = COMPLETE;
            return true;
        }
        if (bufferList.length >= this.length) {
            this.binaryPayload = bufferList.take(this.length);
            bufferList.advance(this.length);
            if (this.mask) {
                bufferUtil.unmask(this.binaryPayload, this.maskBytes);
                // xor(this.binaryPayload, this.maskBytes, 0);
            }

            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE
                if (this.length === 1) {
                    // Invalid length for a close frame.  Must be zero or at least two.
                    this.binaryPayload = bufferAllocUnsafe(0);
                    this.invalidCloseFrameLength = true;
                }
                if (this.length >= 2) {
                    this.closeStatus = this.binaryPayload.readUInt16BE(0);
                    this.binaryPayload = this.binaryPayload.slice(2);
                }
            }

            this.parseState = COMPLETE;
            return true;
        }
    }
    return false;
};

WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
    if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
    }
    return false;
};

WebSocketFrame.prototype.toBuffer = function(nullMask) {
    var maskKey;
    var headerLength = 2;
    var data;
    var outputPos;
    var firstByte = 0x00;
    var secondByte = 0x00;

    if (this.fin) {
        firstByte |= 0x80;
    }
    if (this.rsv1) {
        firstByte |= 0x40;
    }
    if (this.rsv2) {
        firstByte |= 0x20;
    }
    if (this.rsv3) {
        firstByte |= 0x10;
    }
    if (this.mask) {
        secondByte |= 0x80;
    }

    firstByte |= (this.opcode & 0x0F);

    // the close frame is a special case because the close reason is
    // prepended to the payload data.
    if (this.opcode === 0x08) {
        this.length = 2;
        if (this.binaryPayload) {
            this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
            this.binaryPayload.copy(data, 2);
        }
    }
    else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
    }
    else {
        this.length = 0;
    }

    if (this.length <= 125) {
        // encode the length directly into the two-byte frame header
        secondByte |= (this.length & 0x7F);
    }
    else if (this.length > 125 && this.length <= 0xFFFF) {
        // Use 16-bit length
        secondByte |= 126;
        headerLength += 2;
    }
    else if (this.length > 0xFFFF) {
        // Use 64-bit length
        secondByte |= 127;
        headerLength += 8;
    }

    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));

    // write the frame header
    output[0] = firstByte;
    output[1] = secondByte;

    outputPos = 2;

    if (this.length > 125 && this.length <= 0xFFFF) {
        // write 16-bit length
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
    }
    else if (this.length > 0xFFFF) {
        // write 64-bit length
        output.writeUInt32BE(0x00000000, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
    }

    if (this.mask) {
        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);
        this.maskBytes.writeUInt32BE(maskKey, 0);

        // write the mask key
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;

        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
    }
    else if (data) {
        data.copy(output, outputPos);
    }

    return output;
};

WebSocketFrame.prototype.toString = function() {
    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;
};


module.exports = WebSocketFrame;


/***/ }),

/***/ 61398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var crypto = __webpack_require__(6113);
var util = __webpack_require__(73837);
var url = __webpack_require__(57310);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var WebSocketConnection = __webpack_require__(16283);

var headerValueSplitRegExp = /,\s*/;
var headerParamSplitRegExp = /;\s*/;
var headerSanitizeRegExp = /[\r\n]/g;
var xForwardedForSeparatorRegExp = /,\s*/;
var separators = [
    '(', ')', '<', '>', '@',
    ',', ';', ':', '\\', '\"',
    '/', '[', ']', '?', '=',
    '{', '}', ' ', String.fromCharCode(9)
];
var controlChars = [String.fromCharCode(127) /* DEL */];
for (var i=0; i < 31; i ++) {
    /* US-ASCII Control Characters */
    controlChars.push(String.fromCharCode(i));
}

var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;

var cookieSeparatorRegEx = /[;,] */;

var httpStatusDescriptions = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    406: 'Not Acceptable',
    407: 'Proxy Authorization Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Long',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Requested Range Not Satisfiable',
    417: 'Expectation Failed',
    426: 'Upgrade Required',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported'
};

function WebSocketRequest(socket, httpRequest, serverConfig) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.socket = socket;
    this.httpRequest = httpRequest;
    this.resource = httpRequest.url;
    this.remoteAddress = socket.remoteAddress;
    this.remoteAddresses = [this.remoteAddress];
    this.serverConfig = serverConfig;

    // Watch for the underlying TCP socket closing before we call accept
    this._socketIsClosing = false;
    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
    this.socket.on('end', this._socketCloseHandler);
    this.socket.on('close', this._socketCloseHandler);

    this._resolved = false;
}

util.inherits(WebSocketRequest, EventEmitter);

WebSocketRequest.prototype.readHandshake = function() {
    var self = this;
    var request = this.httpRequest;

    // Decode URL
    this.resourceURL = url.parse(this.resource, true);

    this.host = request.headers['host'];
    if (!this.host) {
        throw new Error('Client must provide a Host header.');
    }

    this.key = request.headers['sec-websocket-key'];
    if (!this.key) {
        throw new Error('Client must provide a value for Sec-WebSocket-Key.');
    }

    this.webSocketVersion = parseInt(request.headers['sec-websocket-version'], 10);

    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error('Client must provide a value for Sec-WebSocket-Version.');
    }

    switch (this.webSocketVersion) {
        case 8:
        case 13:
            break;
        default:
            var e = new Error('Unsupported websocket client version: ' + this.webSocketVersion +
                              'Only versions 8 and 13 are supported.');
            e.httpCode = 426;
            e.headers = {
                'Sec-WebSocket-Version': '13'
            };
            throw e;
    }

    if (this.webSocketVersion === 13) {
        this.origin = request.headers['origin'];
    }
    else if (this.webSocketVersion === 8) {
        this.origin = request.headers['sec-websocket-origin'];
    }

    // Protocol is optional.
    var protocolString = request.headers['sec-websocket-protocol'];
    this.protocolFullCaseMap = {};
    this.requestedProtocols = [];
    if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
            var lcProtocol = protocol.toLocaleLowerCase();
            self.requestedProtocols.push(lcProtocol);
            self.protocolFullCaseMap[lcProtocol] = protocol;
        });
    }

    if (!this.serverConfig.ignoreXForwardedFor &&
        request.headers['x-forwarded-for']) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers['x-forwarded-for']
            .split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
    }

    // Extensions are optional.
    if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers['sec-websocket-extensions'];
        this.requestedExtensions = this.parseExtensions(extensionsString);
    } else {
        this.requestedExtensions = [];
    }

    // Cookies are optional
    if (this.serverConfig.parseCookies) {
        var cookieString = request.headers['cookie'];
        this.cookies = this.parseCookies(cookieString);
    } else {
        this.cookies = [];
    }
};

WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
    if (!extensionsString || extensionsString.length === 0) {
        return [];
    }
    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
    extensions.forEach(function(extension, index, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index, array) {
            var arr = rawParam.split('=');
            var obj = {
                name: arr[0],
                value: arr[1]
            };
            array.splice(index, 1, obj);
        });
        var obj = {
            name: extensionName,
            params: extensionParams
        };
        array.splice(index, 1, obj);
    });
    return extensions;
};

// This function adapted from node-cookie
// https://github.com/shtylman/node-cookie
WebSocketRequest.prototype.parseCookies = function(str) {
    // Sanity Check
    if (!str || typeof(str) !== 'string') {
        return [];
    }

    var cookies = [];
    var pairs = str.split(cookieSeparatorRegEx);

    pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=');
        if (eq_idx === -1) {
            cookies.push({
                name: pair,
                value: null
            });
            return;
        }

        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();

        // quoted values
        if ('"' === val[0]) {
            val = val.slice(1, -1);
        }

        cookies.push({
            name: key,
            value: decodeURIComponent(val)
        });
    });

    return cookies;
};

WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
    this._verifyResolution();

    // TODO: Handle extensions

    var protocolFullCase;

    if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof(protocolFullCase) === 'undefined') {
            protocolFullCase = acceptedProtocol;
        }
    }
    else {
        protocolFullCase = acceptedProtocol;
    }
    this.protocolFullCaseMap = null;

    // Create key validation hash
    var sha1 = crypto.createHash('sha1');
    sha1.update(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    var acceptKey = sha1.digest('base64');

    var response = 'HTTP/1.1 101 Switching Protocols\r\n' +
                   'Upgrade: websocket\r\n' +
                   'Connection: Upgrade\r\n' +
                   'Sec-WebSocket-Accept: ' + acceptKey + '\r\n';

    if (protocolFullCase) {
        // validate protocol
        for (var i=0; i < protocolFullCase.length; i++) {
            var charCode = protocolFullCase.charCodeAt(i);
            var character = protocolFullCase.charAt(i);
            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {
                this.reject(500);
                throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
            }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
            this.reject(500);
            throw new Error('Specified protocol was not requested by the client.');
        }

        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, '');
        response += 'Sec-WebSocket-Protocol: ' + protocolFullCase + '\r\n';
    }
    this.requestedProtocols = null;

    if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, '');
        if (this.webSocketVersion === 13) {
            response += 'Origin: ' + allowedOrigin + '\r\n';
        }
        else if (this.webSocketVersion === 8) {
            response += 'Sec-WebSocket-Origin: ' + allowedOrigin + '\r\n';
        }
    }

    if (cookies) {
        if (!Array.isArray(cookies)) {
            this.reject(500);
            throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
            if (!cookie.name || !cookie.value) {
                this.reject(500);
                throw new Error('Each cookie to set must at least provide a "name" and "value"');
            }

            // Make sure there are no \r\n sequences inserted
            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, '');
            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, '');

            if (seenCookies[cookie.name]) {
                this.reject(500);
                throw new Error('You may not specify the same cookie name twice.');
            }
            seenCookies[cookie.name] = true;

            // token (RFC 2616, Section 2.2)
            var invalidChar = cookie.name.match(cookieNameValidateRegEx);
            if (invalidChar) {
                this.reject(500);
                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie name');
            }

            // RFC 6265, Section 4.1.1
            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
            } else {
                invalidChar = cookie.value.match(cookieValueValidateRegEx);
            }
            if (invalidChar) {
                this.reject(500);
                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie value');
            }

            var cookieParts = [cookie.name + '=' + cookie.value];

            // RFC 6265, Section 4.1.1
            // 'Path=' path-value | <any CHAR except CTLs or ';'>
            if(cookie.path){
                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
                if (invalidChar) {
                    this.reject(500);
                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie path');
                }
                cookieParts.push('Path=' + cookie.path);
            }

            // RFC 6265, Section 4.1.2.3
            // 'Domain=' subdomain
            if (cookie.domain) {
                if (typeof(cookie.domain) !== 'string') {
                    this.reject(500);
                    throw new Error('Domain must be specified and must be a string.');
                }
                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
                if (invalidChar) {
                    this.reject(500);
                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie domain');
                }
                cookieParts.push('Domain=' + cookie.domain.toLowerCase());
            }

            // RFC 6265, Section 4.1.1
            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch
            if (cookie.expires) {
                if (!(cookie.expires instanceof Date)){
                    this.reject(500);
                    throw new Error('Value supplied for cookie "expires" must be a vaild date object');
                }
                cookieParts.push('Expires=' + cookie.expires.toGMTString());
            }

            // RFC 6265, Section 4.1.1
            //'Max-Age=' non-zero-digit *DIGIT
            if (cookie.maxage) {
                var maxage = cookie.maxage;
                if (typeof(maxage) === 'string') {
                    maxage = parseInt(maxage, 10);
                }
                if (isNaN(maxage) || maxage <= 0 ) {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
                }
                maxage = Math.round(maxage);
                cookieParts.push('Max-Age=' + maxage.toString(10));
            }

            // RFC 6265, Section 4.1.1
            //'Secure;'
            if (cookie.secure) {
                if (typeof(cookie.secure) !== 'boolean') {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "secure" must be of type boolean');
                }
                cookieParts.push('Secure');
            }

            // RFC 6265, Section 4.1.1
            //'HttpOnly;'
            if (cookie.httponly) {
                if (typeof(cookie.httponly) !== 'boolean') {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "httponly" must be of type boolean');
                }
                cookieParts.push('HttpOnly');
            }

            response += ('Set-Cookie: ' + cookieParts.join(';') + '\r\n');
        }.bind(this));
    }

    // TODO: handle negotiated extensions
    // if (negotiatedExtensions) {
    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\r\n';
    // }

    // Mark the request resolved now so that the user can't call accept or
    // reject a second time.
    this._resolved = true;
    this.emit('requestResolved', this);

    response += '\r\n';

    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
    connection.webSocketVersion = this.webSocketVersion;
    connection.remoteAddress = this.remoteAddress;
    connection.remoteAddresses = this.remoteAddresses;

    var self = this;

    if (this._socketIsClosing) {
        // Handle case when the client hangs up before we get a chance to
        // accept the connection and send our side of the opening handshake.
        cleanupFailedConnection(connection);
    }
    else {
        this.socket.write(response, 'ascii', function(error) {
            if (error) {
                cleanupFailedConnection(connection);
                return;
            }

            self._removeSocketCloseListeners();
            connection._addSocketEventListeners();
        });
    }

    this.emit('requestAccepted', connection);
    return connection;
};

WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
    this._verifyResolution();

    // Mark the request resolved now so that the user can't call accept or
    // reject a second time.
    this._resolved = true;
    this.emit('requestResolved', this);

    if (typeof(status) !== 'number') {
        status = 403;
    }
    var response = 'HTTP/1.1 ' + status + ' ' + httpStatusDescriptions[status] + '\r\n' +
                   'Connection: close\r\n';
    if (reason) {
        reason = reason.replace(headerSanitizeRegExp, '');
        response += 'X-WebSocket-Reject-Reason: ' + reason + '\r\n';
    }

    if (extraHeaders) {
        for (var key in extraHeaders) {
            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, '');
            var sanitizedKey = key.replace(headerSanitizeRegExp, '');
            response += (sanitizedKey + ': ' + sanitizedValue + '\r\n');
        }
    }

    response += '\r\n';
    this.socket.end(response, 'ascii');

    this.emit('requestRejected', this);
};

WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
    this._socketIsClosing = true;
    this._removeSocketCloseListeners();
};

WebSocketRequest.prototype._removeSocketCloseListeners = function() {
    this.socket.removeListener('end', this._socketCloseHandler);
    this.socket.removeListener('close', this._socketCloseHandler);
};

WebSocketRequest.prototype._verifyResolution = function() {
    if (this._resolved) {
        throw new Error('WebSocketRequest may only be accepted or rejected one time.');
    }
};

function cleanupFailedConnection(connection) {
    // Since we have to return a connection object even if the socket is
    // already dead in order not to break the API, we schedule a 'close'
    // event on the connection object to occur immediately.
    process.nextTick(function() {
        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006
        // Third param: Skip sending the close frame to a dead socket
        connection.drop(1006, 'TCP connection lost before handshake completed.', true);
    });
}

module.exports = WebSocketRequest;


/***/ }),

/***/ 41955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var extend = (__webpack_require__(76093).extend);
var util = __webpack_require__(73837);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var WebSocketRouterRequest = __webpack_require__(81440);

function WebSocketRouter(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.config = {
        // The WebSocketServer instance to attach to.
        server: null
    };
    if (config) {
        extend(this.config, config);
    }
    this.handlers = [];

    this._requestHandler = this.handleRequest.bind(this);
    if (this.config.server) {
        this.attachServer(this.config.server);
    }
}

util.inherits(WebSocketRouter, EventEmitter);

WebSocketRouter.prototype.attachServer = function(server) {
    if (server) {
        this.server = server;
        this.server.on('request', this._requestHandler);
    }
    else {
        throw new Error('You must specify a WebSocketServer instance to attach to.');
    }
};

WebSocketRouter.prototype.detachServer = function() {
    if (this.server) {
        this.server.removeListener('request', this._requestHandler);
        this.server = null;
    }
    else {
        throw new Error('Cannot detach from server: not attached.');
    }
};

WebSocketRouter.prototype.mount = function(path, protocol, callback) {
    if (!path) {
        throw new Error('You must specify a path for this handler.');
    }
    if (!protocol) {
        protocol = '____no_protocol____';
    }
    if (!callback) {
        throw new Error('You must specify a callback for this handler.');
    }

    path = this.pathToRegExp(path);
    if (!(path instanceof RegExp)) {
        throw new Error('Path must be specified as either a string or a RegExp.');
    }
    var pathString = path.toString();

    // normalize protocol to lower-case
    protocol = protocol.toLocaleLowerCase();

    if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error('You may only mount one handler per path/protocol combination.');
    }

    this.handlers.push({
        'path': path,
        'pathString': pathString,
        'protocol': protocol,
        'callback': callback
    });
};
WebSocketRouter.prototype.unmount = function(path, protocol) {
    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);
    if (index !== -1) {
        this.handlers.splice(index, 1);
    }
    else {
        throw new Error('Unable to find a route matching the specified path and protocol.');
    }
};

WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
    protocol = protocol.toLocaleLowerCase();
    for (var i=0, len=this.handlers.length; i < len; i++) {
        var handler = this.handlers[i];
        if (handler.pathString === pathString && handler.protocol === protocol) {
            return i;
        }
    }
    return -1;
};

WebSocketRouter.prototype.pathToRegExp = function(path) {
    if (typeof(path) === 'string') {
        if (path === '*') {
            path = /^.*$/;
        }
        else {
            path = path.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            path = new RegExp('^' + path + '$');
        }
    }
    return path;
};

WebSocketRouter.prototype.handleRequest = function(request) {
    var requestedProtocols = request.requestedProtocols;
    if (requestedProtocols.length === 0) {
        requestedProtocols = ['____no_protocol____'];
    }

    // Find a handler with the first requested protocol first
    for (var i=0; i < requestedProtocols.length; i++) {
        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();

        // find the first handler that can process this request
        for (var j=0, len=this.handlers.length; j < len; j++) {
            var handler = this.handlers[j];
            if (handler.path.test(request.resourceURL.pathname)) {
                if (requestedProtocol === handler.protocol ||
                    handler.protocol === '*')
                {
                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
                    handler.callback(routerRequest);
                    return;
                }
            }
        }
    }

    // If we get here we were unable to find a suitable handler.
    request.reject(404, 'No handler is available for the given request.');
};

module.exports = WebSocketRouter;


/***/ }),

/***/ 81440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var util = __webpack_require__(73837);
var EventEmitter = (__webpack_require__(82361).EventEmitter);

function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.webSocketRequest = webSocketRequest;
    if (resolvedProtocol === '____no_protocol____') {
        this.protocol = null;
    }
    else {
        this.protocol = resolvedProtocol;
    }
    this.origin = webSocketRequest.origin;
    this.resource = webSocketRequest.resource;
    this.resourceURL = webSocketRequest.resourceURL;
    this.httpRequest = webSocketRequest.httpRequest;
    this.remoteAddress = webSocketRequest.remoteAddress;
    this.webSocketVersion = webSocketRequest.webSocketVersion;
    this.requestedExtensions = webSocketRequest.requestedExtensions;
    this.cookies = webSocketRequest.cookies;
}

util.inherits(WebSocketRouterRequest, EventEmitter);

WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
    this.emit('requestAccepted', connection);
    return connection;
};

WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
    this.webSocketRequest.reject(status, reason, extraHeaders);
    this.emit('requestRejected', this);
};

module.exports = WebSocketRouterRequest;


/***/ }),

/***/ 7478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var extend = (__webpack_require__(76093).extend);
var utils = __webpack_require__(76093);
var util = __webpack_require__(73837);
var debug = __webpack_require__(68099)('websocket:server');
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var WebSocketRequest = __webpack_require__(61398);

var WebSocketServer = function WebSocketServer(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
    };
    this.connections = [];
    this.pendingRequests = [];
    if (config) {
        this.mount(config);
    }
};

util.inherits(WebSocketServer, EventEmitter);

WebSocketServer.prototype.mount = function(config) {
    this.config = {
        // The http server instance to attach to.  Required.
        httpServer: null,

        // 64KiB max frame size.
        maxReceivedFrameSize: 0x10000,

        // 1MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 0x100000,

        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,

        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 0x4000,

        // If true, the server will automatically send a ping to all
        // clients every 'keepaliveInterval' milliseconds.  The timer is
        // reset on any received data from the client.
        keepalive: true,

        // The interval to send keepalive pings to connected clients if the
        // connection is idle.  Any received data will reset the counter.
        keepaliveInterval: 20000,

        // If true, the server will consider any connection that has not
        // received any data within the amount of time specified by
        // 'keepaliveGracePeriod' after a keepalive ping has been sent to
        // be dead, and will drop the connection.
        // Ignored if keepalive is false.
        dropConnectionOnKeepaliveTimeout: true,

        // The amount of time to wait after sending a keepalive ping before
        // closing the connection if the connected peer does not respond.
        // Ignored if keepalive is false.
        keepaliveGracePeriod: 10000,

        // Whether to use native TCP keep-alive instead of WebSockets ping
        // and pong packets.  Native TCP keep-alive sends smaller packets
        // on the wire and so uses bandwidth more efficiently.  This may
        // be more important when talking to mobile devices.
        // If this value is set to true, then these values will be ignored:
        //   keepaliveGracePeriod
        //   dropConnectionOnKeepaliveTimeout
        useNativeKeepalive: false,

        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,

        // If this is true, websocket connections will be accepted
        // regardless of the path and protocol specified by the client.
        // The protocol accepted will be the first that was requested
        // by the client.  Clients from any origin will be accepted.
        // This should only be used in the simplest of cases.  You should
        // probably leave this set to 'false' and inspect the request
        // object to make sure it's acceptable before accepting it.
        autoAcceptConnections: false,

        // Whether or not the X-Forwarded-For header should be respected.
        // It's important to set this to 'true' when accepting connections
        // from untrusted clients, as a malicious client could spoof its
        // IP address by simply setting this header.  It's meant to be added
        // by a trusted proxy or other intermediary within your own
        // infrastructure.
        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For
        ignoreXForwardedFor: false,

        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies
        parseCookies: true,

        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions
        parseExtensions: true,

        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,

        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5000
    };
    extend(this.config, config);

    if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
            this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
            httpServer.on('upgrade', upgradeHandler);
        });
    }
    else {
        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');
    }
};

WebSocketServer.prototype.unmount = function() {
    var upgradeHandler = this._handlers.upgrade;
    this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener('upgrade', upgradeHandler);
    });
};

WebSocketServer.prototype.closeAllConnections = function() {
    this.connections.forEach(function(connection) {
        connection.close();
    });
    this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503); // HTTP 503 Service Unavailable
        });
    });
};

WebSocketServer.prototype.broadcast = function(data) {
    if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
    }
    else if (typeof(data.toString) === 'function') {
        this.broadcastUTF(data);
    }
};

WebSocketServer.prototype.broadcastUTF = function(utfData) {
    this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
    });
};

WebSocketServer.prototype.broadcastBytes = function(binaryData) {
    this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
    });
};

WebSocketServer.prototype.shutDown = function() {
    this.unmount();
    this.closeAllConnections();
};

WebSocketServer.prototype.handleUpgrade = function(request, socket) {
    var self = this;
    var wsRequest = new WebSocketRequest(socket, request, this.config);
    try {
        wsRequest.readHandshake();
    }
    catch(e) {
        wsRequest.reject(
            e.httpCode ? e.httpCode : 400,
            e.message,
            e.headers
        );
        debug('Invalid handshake: %s', e.message);
        this.emit('upgradeError', e);
        return;
    }

    this.pendingRequests.push(wsRequest);

    wsRequest.once('requestAccepted', this._handlers.requestAccepted);
    wsRequest.once('requestResolved', this._handlers.requestResolved);
    socket.once('close', function () {
        self._handlers.requestResolved(wsRequest);
    });

    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {
        this.emit('request', wsRequest);
    }
    else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
    }
    else {
        wsRequest.reject(404, 'No handler is configured to accept the connection.');
    }
};

WebSocketServer.prototype.handleRequestAccepted = function(connection) {
    var self = this;
    connection.once('close', function(closeReason, description) {
        self.handleConnectionClose(connection, closeReason, description);
    });
    this.connections.push(connection);
    this.emit('connect', connection);
};

WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
    var index = this.connections.indexOf(connection);
    if (index !== -1) {
        this.connections.splice(index, 1);
    }
    this.emit('close', connection, closeReason, description);
};

WebSocketServer.prototype.handleRequestResolved = function(request) {
    var index = this.pendingRequests.indexOf(request);
    if (index !== -1) { this.pendingRequests.splice(index, 1); }
};

module.exports = WebSocketServer;


/***/ }),

/***/ 76093:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
var noop = exports.noop = function(){};

exports.extend = function extend(dest, source) {
    for (var prop in source) {
        dest[prop] = source[prop];
    }
};

exports.eventEmitterListenerCount =
    (__webpack_require__(82361).EventEmitter.listenerCount) ||
    function(emitter, type) { return emitter.listeners(type).length; };

exports.bufferAllocUnsafe = Buffer.allocUnsafe ?
    Buffer.allocUnsafe :
    function oldBufferAllocUnsafe(size) { return new Buffer(size); };

exports.bufferFromString = Buffer.from ?
    Buffer.from :
    function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };

exports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
    var logFunction = __webpack_require__(68099)(identifier);
    if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug = logger.log.bind(logger);
        debug.printOutput = logger.printOutput.bind(logger);
        debug.enabled = logFunction.enabled;
        return debug;
    }
    logFunction.printOutput = noop;
    return logFunction;
};

function BufferingLogger(identifier, uniqueID, logFunction) {
    this.logFunction = logFunction;
    this.identifier = identifier;
    this.uniqueID = uniqueID;
    this.buffer = [];
}

BufferingLogger.prototype.log = function() {
  this.buffer.push([ new Date(), Array.prototype.slice.call(arguments) ]);
  return this;
};

BufferingLogger.prototype.clear = function() {
  this.buffer = [];
  return this;
};

BufferingLogger.prototype.printOutput = function(logFunction) {
    if (!logFunction) { logFunction = this.logFunction; }
    var uniqueID = this.uniqueID;
    this.buffer.forEach(function(entry) {
        var date = entry[0].toLocaleString();
        var args = entry[1].slice();
        var formatString = args[0];
        if (formatString !== (void 0) && formatString !== null) {
            formatString = '%s - %s - ' + formatString.toString();
            args.splice(0, 1, formatString, date, uniqueID);
            logFunction.apply(global, args);
        }
    });
};


/***/ }),

/***/ 27755:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(84735).version;


/***/ }),

/***/ 86005:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    'server'       : __webpack_require__(7478),
    'client'       : __webpack_require__(18951),
    'router'       : __webpack_require__(41955),
    'frame'        : __webpack_require__(57834),
    'request'      : __webpack_require__(61398),
    'connection'   : __webpack_require__(16283),
    'w3cwebsocket' : __webpack_require__(81883),
    'deprecation'  : __webpack_require__(30906),
    'version'      : __webpack_require__(27755)
};


/***/ }),

/***/ 96660:
/***/ ((module) => {

"use strict";


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
const mask = (source, mask, output, offset, length) => {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
};

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
const unmask = (buffer, mask) => {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = { mask, unmask };


/***/ }),

/***/ 86544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(89038)(__dirname);
} catch (e) {
  module.exports = __webpack_require__(96660);
}


/***/ }),

/***/ 45690:
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(94055);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 94055:
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(38885);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 68099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(45690);
} else {
  module.exports = __webpack_require__(18108);
}


/***/ }),

/***/ 18108:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(76224);
var util = __webpack_require__(73837);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(94055);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(57147);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(41808);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ 38885:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 11154:
/***/ ((module) => {

"use strict";


/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0  // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;


/***/ }),

/***/ 23284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(89038)(__dirname);
} catch (e) {
  module.exports = __webpack_require__(11154);
}


/***/ }),

/***/ 90266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// This file was copied from https://github.com/substack/node-bufferlist
// and modified to be able to copy bytes from the bufferlist directly into
// a pre-existing fixed-size buffer without an additional memory allocation.

// bufferlist.js
// Treat a linked list of buffers as a single variable-size buffer.
var Buffer = (__webpack_require__(14300).Buffer);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var bufferAllocUnsafe = (__webpack_require__(76093).bufferAllocUnsafe);

module.exports = BufferList;
module.exports.BufferList = BufferList; // backwards compatibility

function BufferList(opts) {
    if (!(this instanceof BufferList)) return new BufferList(opts);
    EventEmitter.call(this);
    var self = this;
    
    if (typeof(opts) == 'undefined') opts = {};
    
    // default encoding to use for take(). Leaving as 'undefined'
    // makes take() return a Buffer instead.
    self.encoding = opts.encoding;
    
    var head = { next : null, buffer : null };
    var last = { next : null, buffer : null };
    
    // length can get negative when advanced past the end
    // and this is the desired behavior
    var length = 0;
    self.__defineGetter__('length', function () {
        return length;
    });
    
    // keep an offset of the head to decide when to head = head.next
    var offset = 0;
    
    // Write to the bufferlist. Emits 'write'. Always returns true.
    self.write = function (buf) {
        if (!head.buffer) {
            head.buffer = buf;
            last = head;
        }
        else {
            last.next = { next : null, buffer : buf };
            last = last.next;
        }
        length += buf.length;
        self.emit('write', buf);
        return true;
    };
    
    self.end = function (buf) {
        if (Buffer.isBuffer(buf)) self.write(buf);
    };
    
    // Push buffers to the end of the linked list. (deprecated)
    // Return this (self).
    self.push = function () {
        var args = [].concat.apply([], arguments);
        args.forEach(self.write);
        return self;
    };
    
    // For each buffer, perform some action.
    // If fn's result is a true value, cut out early.
    // Returns this (self).
    self.forEach = function (fn) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        
        if (head.buffer.length - offset <= 0) return self;
        var firstBuf = head.buffer.slice(offset);
        
        var b = { buffer : firstBuf, next : head.next };
        
        while (b && b.buffer) {
            var r = fn(b.buffer);
            if (r) break;
            b = b.next;
        }
        
        return self;
    };
    
    // Create a single Buffer out of all the chunks or some subset specified by
    // start and one-past the end (like slice) in bytes.
    self.join = function (start, end) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (start == undefined) start = 0;
        if (end == undefined) end = self.length;
        
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self.forEach(function (buffer) {
            if (start < (ix + buffer.length) && ix < end) {
                // at least partially contained in the range
                buffer.copy(
                    big,
                    Math.max(0, ix - start),
                    Math.max(0, start - ix),
                    Math.min(buffer.length, end - ix)
                );
            }
            ix += buffer.length;
            if (ix > end) return true; // stop processing past end
        });
        
        return big;
    };
    
    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer) return new bufferAllocUnsafe(0);
        if (sourceStart == undefined) sourceStart = 0;
        if (sourceEnd == undefined) sourceEnd = self.length;
        
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
            throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self.forEach(function (buffer) {
            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {
                // at least partially contained in the range
                buffer.copy(
                    big,
                    Math.max(targetStart, targetStart + ix - sourceStart),
                    Math.max(0, sourceStart - ix),
                    Math.min(buffer.length, sourceEnd - ix)
                );
            }
            ix += buffer.length;
            if (ix > sourceEnd) return true; // stop processing past end
        });
        
        return big;
    };
    
    // Advance the buffer stream by n bytes.
    // If n the aggregate advance offset passes the end of the buffer list,
    // operations such as .take() will return empty strings until enough data is
    // pushed.
    // Returns this (self).
    self.advance = function (n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
            offset -= head.buffer.length;
            head = head.next
                ? head.next
                : { buffer : null, next : null }
            ;
        }
        if (head.buffer === null) last = { next : null, buffer : null };
        self.emit('advance', n);
        return self;
    };
    
    // Take n bytes from the start of the buffers.
    // Returns a string.
    // If there are less than n bytes in all the buffers or n is undefined,
    // returns the entire concatenated buffer string.
    self.take = function (n, encoding) {
        if (n == undefined) n = self.length;
        else if (typeof n !== 'number') {
            encoding = n;
            n = self.length;
        }
        var b = head;
        if (!encoding) encoding = self.encoding;
        if (encoding) {
            var acc = '';
            self.forEach(function (buffer) {
                if (n <= 0) return true;
                acc += buffer.toString(
                    encoding, 0, Math.min(n,buffer.length)
                );
                n -= buffer.length;
            });
            return acc;
        } else {
            // If no 'encoding' is specified, then return a Buffer.
            return self.join(0, n);
        }
    };
    
    // The entire concatenated buffer as a string.
    self.toString = function () {
        return self.take('binary');
    };
}
(__webpack_require__(73837).inherits)(BufferList, EventEmitter);


/***/ }),

/***/ 66284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
	EventTarget : __webpack_require__(29861),
	Event       : __webpack_require__(58864)
};


/***/ }),

/***/ 58864:
/***/ ((module) => {

/**
 * Expose the Event class.
 */
module.exports = _Event;


function _Event(type) {
	this.type = type;
	this.isTrusted = false;

	// Set a flag indicating this is not a DOM Event object
	this._yaeti = true;
}


/***/ }),

/***/ 29861:
/***/ ((module) => {

/**
 * Expose the _EventTarget class.
 */
module.exports = _EventTarget;

function _EventTarget() {
	// Do nothing if called for a native EventTarget object..
	if (typeof this.addEventListener === 'function') {
		return;
	}

	this._listeners = {};

	this.addEventListener = _addEventListener;
	this.removeEventListener = _removeEventListener;
	this.dispatchEvent = _dispatchEvent;
}

Object.defineProperties(_EventTarget.prototype, {
	listeners: {
		get: function () {
			return this._listeners;
		}
	}
});

function _addEventListener(type, newListener) {
	var
		listenersType,
		i, listener;

	if (!type || !newListener) {
		return;
	}

	listenersType = this._listeners[type];
	if (listenersType === undefined) {
		this._listeners[type] = listenersType = [];
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (listener === newListener) {
			return;
		}
	}

	listenersType.push(newListener);
}

function _removeEventListener(type, oldListener) {
	var
		listenersType,
		i, listener;

	if (!type || !oldListener) {
		return;
	}

	listenersType = this._listeners[type];
	if (listenersType === undefined) {
		return;
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (listener === oldListener) {
			listenersType.splice(i, 1);
			break;
		}
	}

	if (listenersType.length === 0) {
		delete this._listeners[type];
	}
}

function _dispatchEvent(event) {
	var
		type,
		listenersType,
		dummyListener,
		stopImmediatePropagation = false,
		i, listener;

	if (!event || typeof event.type !== 'string') {
		throw new Error('`event` must have a valid `type` property');
	}

	// Do some stuff to emulate DOM Event behavior (just if this is not a
	// DOM Event object)
	if (event._yaeti) {
		event.target = this;
		event.cancelable = true;
	}

	// Attempt to override the stopImmediatePropagation() method
	try {
		event.stopImmediatePropagation = function () {
			stopImmediatePropagation = true;
		};
	} catch (error) {}

	type = event.type;
	listenersType = (this._listeners[type] || []);

	dummyListener = this['on' + type];
	if (typeof dummyListener === 'function') {
		dummyListener.call(this, event);
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (stopImmediatePropagation) {
			break;
		}

		listener.call(this, event);
	}

	return !event.defaultPrevented;
}


/***/ }),

/***/ 38268:
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ 8006:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(38268)(Yallist)
} catch (er) {}


/***/ }),

/***/ 11239:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "yV": () => (/* binding */ fromPrivate),
  "KS": () => (/* binding */ isChecksummed),
  "Cd": () => (/* binding */ isHexAddress),
  "c$": () => (/* binding */ randomAddressType),
  "fS": () => (/* binding */ randomCfxHexAddress),
  "MG": () => (/* binding */ randomHexAddress),
  "UB": () => (/* binding */ randomPrivateKey),
  "RE": () => (/* binding */ toAccountAddress),
  "QS": () => (/* binding */ validatePrivateKey)
});

// UNUSED EXPORTS: create, isBuiltInAddress, isCfxHexAddress, isContractAddress, isNullHexAddress, isUserHexAddress, toChecksum, toContractAddress, validateHexAddress

// EXTERNAL MODULE: ../../node_modules/@ethersproject/address/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(58194);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/transactions/lib.esm/index.js + 3 modules
var transactions_lib_esm = __webpack_require__(11482);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/properties/lib.esm/index.js + 1 modules
var properties_lib_esm = __webpack_require__(84427);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(57036);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
const version = "abstract-provider/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abstract-provider/lib.esm/index.js

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const logger = new logger_lib_esm/* Logger */.Yd(version);
;
;
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
class ForkEvent extends (/* unused pure expression or super */ null && (Description)) {
    static isForkEvent(value) {
        return !!(value && value._isForkEvent);
    }
}
class BlockForkEvent extends (/* unused pure expression or super */ null && (ForkEvent)) {
    constructor(blockHash, expiry) {
        if (!isHexString(blockHash, 32)) {
            logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        }
        super({
            _isForkEvent: true,
            _isBlockForkEvent: true,
            expiry: (expiry || 0),
            blockHash: blockHash
        });
    }
}
class TransactionForkEvent extends (/* unused pure expression or super */ null && (ForkEvent)) {
    constructor(hash, expiry) {
        if (!isHexString(hash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "hash", hash);
        }
        super({
            _isForkEvent: true,
            _isTransactionForkEvent: true,
            expiry: (expiry || 0),
            hash: hash
        });
    }
}
class TransactionOrderForkEvent extends (/* unused pure expression or super */ null && (ForkEvent)) {
    constructor(beforeHash, afterHash, expiry) {
        if (!isHexString(beforeHash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        }
        if (!isHexString(afterHash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        }
        super({
            _isForkEvent: true,
            _isTransactionOrderForkEvent: true,
            expiry: (expiry || 0),
            beforeHash: beforeHash,
            afterHash: afterHash
        });
    }
}
///////////////////////////////
// Exported Abstracts
class Provider {
    constructor() {
        logger.checkAbstract(new.target, Provider);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function* () {
            const { block, gasPrice } = yield (0,properties_lib_esm/* resolveProperties */.mE)({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error) => {
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                maxPriorityFeePerGas = bignumber/* BigNumber.from */.O$.from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
const _version_version = "abstract-signer/5.6.2";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/abstract-signer/lib.esm/index.js

var lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const lib_esm_logger = new logger_lib_esm/* Logger */.Yd(_version_version);
const allowedTransactionKeys = [
    "accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"
];
const forwardErrors = [
    logger_lib_esm/* Logger.errors.INSUFFICIENT_FUNDS */.Yd.errors.INSUFFICIENT_FUNDS,
    logger_lib_esm/* Logger.errors.NONCE_EXPIRED */.Yd.errors.NONCE_EXPIRED,
    logger_lib_esm/* Logger.errors.REPLACEMENT_UNDERPRICED */.Yd.errors.REPLACEMENT_UNDERPRICED,
];
;
;
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor() {
        lib_esm_logger.checkAbstract(new.target, Signer);
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas");
            const tx = yield (0,properties_lib_esm/* resolveProperties */.mE)(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("call");
            const tx = yield (0,properties_lib_esm/* resolveProperties */.mE)(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                lib_esm_logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
        }
        const tx = (0,properties_lib_esm/* shallowCopy */.DC)(transaction);
        if (tx.from == null) {
            tx.from = this.getAddress();
        }
        else {
            // Make sure any provided address matches this signer
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
            ]).then((result) => {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                    lib_esm_logger.throwArgumentError("from address mismatch", "transaction", transaction);
                }
                return result[0];
            });
        }
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return lib_esm_awaiter(this, void 0, void 0, function* () {
            const tx = yield (0,properties_lib_esm/* resolveProperties */.mE)(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to) => lib_esm_awaiter(this, void 0, void 0, function* () {
                    if (to == null) {
                        return null;
                    }
                    const address = yield this.resolveName(to);
                    if (address == null) {
                        lib_esm_logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return address;
                }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error) => { });
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                lib_esm_logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            }
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                lib_esm_logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            }
            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
                // Fully-formed EIP-1559 transaction (skip getFeeData)
                tx.type = 2;
            }
            else if (tx.type === 0 || tx.type === 1) {
                // Explicit Legacy or EIP-2930 transaction
                // Populate missing gasPrice
                if (tx.gasPrice == null) {
                    tx.gasPrice = this.getGasPrice();
                }
            }
            else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        }
                        else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) {
                                tx.maxFeePerGas = feeData.maxFeePerGas;
                            }
                            if (tx.maxPriorityFeePerGas == null) {
                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                            }
                        }
                    }
                    else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) {
                            lib_esm_logger.throwError("network does not support EIP-1559", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                                operation: "populateTransaction"
                            });
                        }
                        // Populate missing fee data
                        if (tx.gasPrice == null) {
                            tx.gasPrice = feeData.gasPrice;
                        }
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    }
                    else {
                        // getFeeData has failed us.
                        lib_esm_logger.throwError("failed to get consistent fee data", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                            operation: "signer.getFeeData"
                        });
                    }
                }
                else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                }
            }
            if (tx.nonce == null) {
                tx.nonce = this.getTransactionCount("pending");
            }
            if (tx.gasLimit == null) {
                tx.gasLimit = this.estimateGas(tx).catch((error) => {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                        throw error;
                    }
                    return lib_esm_logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_lib_esm/* Logger.errors.UNPREDICTABLE_GAS_LIMIT */.Yd.errors.UNPREDICTABLE_GAS_LIMIT, {
                        error: error,
                        tx: tx
                    });
                });
            }
            if (tx.chainId == null) {
                tx.chainId = this.getChainId();
            }
            else {
                tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                ]).then((results) => {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                        lib_esm_logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                });
            }
            return yield (0,properties_lib_esm/* resolveProperties */.mE)(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) {
            lib_esm_logger.throwError("missing provider", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: (operation || "_checkProvider")
            });
        }
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends (/* unused pure expression or super */ null && (Signer)) {
    constructor(address, provider) {
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(() => {
            lib_esm_logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var bytes_lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(59256);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/strings/lib.esm/utf8.js + 1 modules
var utf8 = __webpack_require__(71320);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/hash/lib.esm/message.js



const messagePrefix = "\x19Ethereum Signed Message:\n";
function message_hashMessage(message) {
    if (typeof (message) === "string") {
        message = (0,utf8/* toUtf8Bytes */.Y0)(message);
    }
    return (0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* concat */.zo)([
        (0,utf8/* toUtf8Bytes */.Y0)(messagePrefix),
        (0,utf8/* toUtf8Bytes */.Y0)(String(message.length)),
        message
    ]));
}
//# sourceMappingURL=message.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/hash/lib.esm/_version.js
const lib_esm_version_version = "hash/5.6.1";
//# sourceMappingURL=_version.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/hash/lib.esm/id.js
var id = __webpack_require__(32235);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/hash/lib.esm/typed-data.js
var typed_data_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const typed_data_logger = new logger_lib_esm/* Logger */.Yd(lib_esm_version_version);

const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = bignumber/* BigNumber.from */.O$.from(-1);
const Zero = bignumber/* BigNumber.from */.O$.from(0);
const One = bignumber/* BigNumber.from */.O$.from(1);
const MaxUint256 = bignumber/* BigNumber.from */.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = (0,bytes_lib_esm/* arrayify */.lE)(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return (0,bytes_lib_esm/* hexConcat */.xs)([bytes, padding.slice(padOffset)]);
    }
    return (0,bytes_lib_esm/* hexlify */.Dv)(bytes);
}
const hexTrue = (0,bytes_lib_esm/* hexZeroPad */.$m)(One.toHexString(), 32);
const hexFalse = (0,bytes_lib_esm/* hexZeroPad */.$m)(Zero.toHexString(), 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        if (typeof (value) !== "string") {
            typed_data_logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        }
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (value) {
        try {
            return bignumber/* BigNumber.from */.O$.from(value).toString();
        }
        catch (error) { }
        return typed_data_logger.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function (value) {
        try {
            return (0,lib_esm/* getAddress */.Kn)(value).toLowerCase();
        }
        catch (error) { }
        return typed_data_logger.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function (value) {
        try {
            const bytes = (0,bytes_lib_esm/* arrayify */.lE)(value);
            if (bytes.length !== 32) {
                throw new Error("bad length");
            }
            return (0,bytes_lib_esm/* hexlify */.Dv)(bytes);
        }
        catch (error) { }
        return typed_data_logger.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            const signed = (match[1] === "");
            const width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {
                typed_data_logger.throwArgumentError("invalid numeric width", "type", type);
            }
            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);
            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
            return function (value) {
                const v = bignumber/* BigNumber.from */.O$.from(value);
                if (v.lt(boundsLower) || v.gt(boundsUpper)) {
                    typed_data_logger.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
                }
                return (0,bytes_lib_esm/* hexZeroPad */.$m)(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (width === 0 || width > 32 || match[1] !== String(width)) {
                typed_data_logger.throwArgumentError("invalid bytes width", "type", type);
            }
            return function (value) {
                const bytes = (0,bytes_lib_esm/* arrayify */.lE)(value);
                if (bytes.length !== width) {
                    typed_data_logger.throwArgumentError(`invalid length for ${type}`, "value", value);
                }
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return (0,bytes_lib_esm/* hexZeroPad */.$m)((0,lib_esm/* getAddress */.Kn)(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return (0,keccak256_lib_esm/* keccak256 */.w)(value);
        };
        case "string": return function (value) {
            return (0,id.id)(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => (type + " " + name)).join(",")})`;
}
class TypedDataEncoder {
    constructor(types) {
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "types", Object.freeze((0,properties_lib_esm/* deepCopy */.p$)(types)));
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_encoderCache", {});
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_types", {});
        // Link struct types to their direct child structs
        const links = {};
        // Link structs to structs which contain them as a child
        const parents = {};
        // Link all subtypes within a given struct
        const subtypes = {};
        Object.keys(types).forEach((type) => {
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        for (const name in types) {
            const uniqueNames = {};
            types[name].forEach((field) => {
                // Check each field has a unique name
                if (uniqueNames[field.name]) {
                    typed_data_logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
                }
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name) {
                    typed_data_logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
                }
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    return;
                }
                if (!parents[baseType]) {
                    typed_data_logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
                }
                // Add linkage
                parents[baseType].push(name);
                links[name][baseType] = true;
            });
        }
        // Deduce the primary type
        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));
        if (primaryTypes.length === 0) {
            typed_data_logger.throwArgumentError("missing primary type", "types", types);
        }
        else if (primaryTypes.length > 1) {
            typed_data_logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(", ")}`, "types", types);
        }
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) {
                typed_data_logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
            }
            found[type] = true;
            Object.keys(links[type]).forEach((child) => {
                if (!parents[child]) {
                    return;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach((subtype) => {
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for (const name in subtypes) {
            const st = Object.keys(subtypes[name]);
            st.sort();
            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join("");
        }
    }
    getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
            encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
    }
    _getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            const length = parseInt(match[3]);
            return (value) => {
                if (length >= 0 && value.length !== length) {
                    typed_data_logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                }
                let result = value.map(subEncoder);
                if (this._types[subtype]) {
                    result = result.map(keccak256_lib_esm/* keccak256 */.w);
                }
                return (0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* hexConcat */.xs)(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = (0,id.id)(this._types[type]);
            return (value) => {
                const values = fields.map(({ name, type }) => {
                    const result = this.getEncoder(type)(value[name]);
                    if (this._types[type]) {
                        return (0,keccak256_lib_esm/* keccak256 */.w)(result);
                    }
                    return result;
                });
                values.unshift(encodedType);
                return (0,bytes_lib_esm/* hexConcat */.xs)(values);
            };
        }
        return typed_data_logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name) {
        const result = this._types[name];
        if (!result) {
            typed_data_logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        }
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return (0,keccak256_lib_esm/* keccak256 */.w)(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const length = parseInt(match[3]);
            if (length >= 0 && value.length !== length) {
                typed_data_logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            return value.map((v) => this._visit(subtype, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        return typed_data_logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            const type = domainFieldTypes[name];
            if (!type) {
                typed_data_logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            }
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    static encode(domain, types, value) {
        return (0,bytes_lib_esm/* hexConcat */.xs)([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    static hash(domain, types, value) {
        return (0,keccak256_lib_esm/* keccak256 */.w)(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain, types, value, resolveName) {
        return typed_data_awaiter(this, void 0, void 0, function* () {
            // Make a copy to isolate it from the object passed in
            domain = (0,properties_lib_esm/* shallowCopy */.DC)(domain);
            // Look up all ENS names
            const ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !(0,bytes_lib_esm/* isHexString */.A7)(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
            }
            // We are going to use the encoder to visit all the base values
            const encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, (type, value) => {
                if (type === "address" && !(0,bytes_lib_esm/* isHexString */.A7)(value, 20)) {
                    ensCache[value] = "0x";
                }
                return value;
            });
            // Lookup each name
            for (const name in ensCache) {
                ensCache[name] = yield resolveName(name);
            }
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            // Replace all ENS names with their address
            value = encoder.visit(value, (type, value) => {
                if (type === "address" && ensCache[value]) {
                    return ensCache[value];
                }
                return value;
            });
            return { domain, value };
        });
    }
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = (0,properties_lib_esm/* shallowCopy */.DC)(types);
        if (typesWithDomain.EIP712Domain) {
            typed_data_logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        }
        else {
            typesWithDomain.EIP712Domain = domainTypes;
        }
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return (0,bytes_lib_esm/* hexlify */.Dv)((0,bytes_lib_esm/* arrayify */.lE)(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return bignumber/* BigNumber.from */.O$.from(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof (value) !== "string") {
                            typed_data_logger.throwArgumentError(`invalid string`, "value", value);
                        }
                        return value;
                }
                return typed_data_logger.throwArgumentError("unsupported type", "type", type);
            })
        };
    }
}
//# sourceMappingURL=typed-data.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/hdnode/lib.esm/index.js + 6 modules
var hdnode_lib_esm = __webpack_require__(71173);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/random/lib.esm/random.js + 1 modules
var random = __webpack_require__(62191);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/index.js + 2 modules
var signing_key_lib_esm = __webpack_require__(3378);
// EXTERNAL MODULE: ../../node_modules/aes-js/index.js
var aes_js = __webpack_require__(8202);
var aes_js_default = /*#__PURE__*/__webpack_require__.n(aes_js);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
var pbkdf2 = __webpack_require__(55183);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/json-wallets/lib.esm/_version.js
const json_wallets_lib_esm_version_version = "json-wallets/5.6.1";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/json-wallets/lib.esm/utils.js



function looseArrayify(hexString) {
    if (typeof (hexString) === 'string' && hexString.substring(0, 2) !== '0x') {
        hexString = '0x' + hexString;
    }
    return (0,bytes_lib_esm/* arrayify */.lE)(hexString);
}
function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
        value = '0' + value;
    }
    return value;
}
function getPassword(password) {
    if (typeof (password) === 'string') {
        return (0,utf8/* toUtf8Bytes */.Y0)(password, utf8/* UnicodeNormalizationForm.NFKC */.Uj.NFKC);
    }
    return (0,bytes_lib_esm/* arrayify */.lE)(password);
}
function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split('/');
    for (let i = 0; i < comps.length; i++) {
        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for (const key in currentChild) {
            if (key.toLowerCase() === comps[i]) {
                matchingChild = currentChild[key];
                break;
            }
        }
        // Didn't find one. :'(
        if (matchingChild === null) {
            return null;
        }
        // Now check this child...
        currentChild = matchingChild;
    }
    return currentChild;
}
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
function uuidV4(randomBytes) {
    const bytes = (0,bytes_lib_esm/* arrayify */.lE)(randomBytes);
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    const value = (0,bytes_lib_esm/* hexlify */.Dv)(bytes);
    return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34),
    ].join("-");
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js










const crowdsale_logger = new logger_lib_esm/* Logger */.Yd(json_wallets_lib_esm_version_version);

class CrowdsaleAccount extends properties_lib_esm/* Description */.dk {
    isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
    }
}
// See: https://github.com/ethereum/pyethsaletool
function decrypt(json, password) {
    const data = JSON.parse(json);
    password = getPassword(password);
    // Ethereum Address
    const ethaddr = (0,lib_esm/* getAddress */.Kn)(searchPath(data, "ethaddr"));
    // Encrypted Seed
    const encseed = looseArrayify(searchPath(data, "encseed"));
    if (!encseed || (encseed.length % 16) !== 0) {
        crowdsale_logger.throwArgumentError("invalid encseed", "json", json);
    }
    const key = (0,bytes_lib_esm/* arrayify */.lE)((0,pbkdf2/* pbkdf2 */.n)(password, password, 2000, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    // Decrypt the seed
    const aesCbc = new (aes_js_default()).ModeOfOperation.cbc(key, iv);
    const seed = aes_js_default().padding.pkcs7.strip((0,bytes_lib_esm/* arrayify */.lE)(aesCbc.decrypt(encryptedSeed)));
    // This wallet format is weird... Convert the binary encoded hex to a string.
    let seedHex = "";
    for (let i = 0; i < seed.length; i++) {
        seedHex += String.fromCharCode(seed[i]);
    }
    const seedHexBytes = (0,utf8/* toUtf8Bytes */.Y0)(seedHex);
    const privateKey = (0,keccak256_lib_esm/* keccak256 */.w)(seedHexBytes);
    return new CrowdsaleAccount({
        _isCrowdsaleAccount: true,
        address: ethaddr,
        privateKey: privateKey
    });
}
//# sourceMappingURL=crowdsale.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/json-wallets/lib.esm/inspect.js


function isCrowdsaleWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    }
    catch (error) {
        return false;
    }
    return (data.encseed && data.ethaddr);
}
function isKeystoreWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    }
    catch (error) {
        return false;
    }
    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
        return false;
    }
    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff
    return true;
}
//export function isJsonWallet(json: string): boolean {
//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));
//}
function getJsonWalletAddress(json) {
    if (isCrowdsaleWallet(json)) {
        try {
            return getAddress(JSON.parse(json).ethaddr);
        }
        catch (error) {
            return null;
        }
    }
    if (isKeystoreWallet(json)) {
        try {
            return getAddress(JSON.parse(json).address);
        }
        catch (error) {
            return null;
        }
    }
    return null;
}
//# sourceMappingURL=inspect.js.map
// EXTERNAL MODULE: ../../node_modules/scrypt-js/scrypt.js
var scrypt = __webpack_require__(14689);
var scrypt_default = /*#__PURE__*/__webpack_require__.n(scrypt);
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/json-wallets/lib.esm/keystore.js

var keystore_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};













const keystore_logger = new logger_lib_esm/* Logger */.Yd(json_wallets_lib_esm_version_version);
// Exported Types
function hasMnemonic(value) {
    return (value != null && value.mnemonic && value.mnemonic.phrase);
}
class KeystoreAccount extends properties_lib_esm/* Description */.dk {
    isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
    }
}
function _decrypt(data, key, ciphertext) {
    const cipher = searchPath(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
        const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
        const counter = new (aes_js_default()).Counter(iv);
        const aesCtr = new (aes_js_default()).ModeOfOperation.ctr(key, counter);
        return (0,bytes_lib_esm/* arrayify */.lE)(aesCtr.decrypt(ciphertext));
    }
    return null;
}
function _getAccount(data, key) {
    const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
    const computedMAC = (0,bytes_lib_esm/* hexlify */.Dv)((0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* concat */.zo)([key.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
    }
    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
    if (!privateKey) {
        keystore_logger.throwError("unsupported cipher", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
            operation: "decrypt"
        });
    }
    const mnemonicKey = key.slice(32, 64);
    const address = (0,transactions_lib_esm/* computeAddress */.db)(privateKey);
    if (data.address) {
        let check = data.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") {
            check = "0x" + check;
        }
        if ((0,lib_esm/* getAddress */.Kn)(check) !== address) {
            throw new Error("address mismatch");
        }
    }
    const account = {
        _isKeystoreAccount: true,
        address: address,
        privateKey: (0,bytes_lib_esm/* hexlify */.Dv)(privateKey)
    };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    if (searchPath(data, "x-ethers/version") === "0.1") {
        const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
        const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
        const mnemonicCounter = new (aes_js_default()).Counter(mnemonicIv);
        const mnemonicAesCtr = new (aes_js_default()).ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const path = searchPath(data, "x-ethers/path") || hdnode_lib_esm/* defaultPath */.cD;
        const locale = searchPath(data, "x-ethers/locale") || "en";
        const entropy = (0,bytes_lib_esm/* arrayify */.lE)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
            const mnemonic = (0,hdnode_lib_esm/* entropyToMnemonic */.JJ)(entropy, locale);
            const node = hdnode_lib_esm/* HDNode.fromMnemonic */.m$.fromMnemonic(mnemonic, null, locale).derivePath(path);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
            account.mnemonic = node.mnemonic;
        }
        catch (error) {
            // If we don't have the locale wordlist installed to
            // read this mnemonic, just bail and don't set the
            // mnemonic
            if (error.code !== logger_lib_esm/* Logger.errors.INVALID_ARGUMENT */.Yd.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
                throw error;
            }
        }
    }
    return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return (0,bytes_lib_esm/* arrayify */.lE)((0,pbkdf2/* pbkdf2 */.n)(passwordBytes, salt, count, dkLen, prfFunc));
}
function keystore_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = getPassword(password);
    const kdf = searchPath(data, "crypto/kdf");
    if (kdf && typeof (kdf) === "string") {
        const throwError = function (name, value) {
            return keystore_logger.throwArgumentError("invalid key-derivation function parameters", name, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
            const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
            const N = parseInt(searchPath(data, "crypto/kdfparams/n"));
            const r = parseInt(searchPath(data, "crypto/kdfparams/r"));
            const p = parseInt(searchPath(data, "crypto/kdfparams/p"));
            // Check for all required parameters
            if (!N || !r || !p) {
                throwError("kdf", kdf);
            }
            // Make sure N is a power of 2
            if ((N & (N - 1)) !== 0) {
                throwError("N", N);
            }
            const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        }
        else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
            let prfFunc = null;
            const prf = searchPath(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") {
                prfFunc = "sha256";
            }
            else if (prf === "hmac-sha512") {
                prfFunc = "sha512";
            }
            else {
                throwError("prf", prf);
            }
            const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
            const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
    }
    return keystore_logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
    const data = JSON.parse(json);
    const key = _computeKdfKey(data, password, pbkdf2Sync, (scrypt_default()).syncScrypt);
    return _getAccount(data, key);
}
function keystore_decrypt(json, password, progressCallback) {
    return keystore_awaiter(this, void 0, void 0, function* () {
        const data = JSON.parse(json);
        const key = yield _computeKdfKey(data, password, keystore_pbkdf2, (scrypt_default()).scrypt, progressCallback);
        return _getAccount(data, key);
    });
}
function encrypt(account, password, options, progressCallback) {
    try {
        // Check the address matches the private key
        if ((0,lib_esm/* getAddress */.Kn)(account.address) !== (0,transactions_lib_esm/* computeAddress */.db)(account.privateKey)) {
            throw new Error("address/privateKey mismatch");
        }
        // Check the mnemonic (if any) matches the private key
        if (hasMnemonic(account)) {
            const mnemonic = account.mnemonic;
            const node = hdnode_lib_esm/* HDNode.fromMnemonic */.m$.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_lib_esm/* defaultPath */.cD);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
        }
    }
    catch (e) {
        return Promise.reject(e);
    }
    // The options are optional, so adjust the call as needed
    if (typeof (options) === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    const privateKey = (0,bytes_lib_esm/* arrayify */.lE)(account.privateKey);
    const passwordBytes = getPassword(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic(account)) {
        const srcMnemonic = account.mnemonic;
        entropy = (0,bytes_lib_esm/* arrayify */.lE)((0,hdnode_lib_esm/* mnemonicToEntropy */.oy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path = srcMnemonic.path || hdnode_lib_esm/* defaultPath */.cD;
        locale = srcMnemonic.locale || "en";
    }
    let client = options.client;
    if (!client) {
        client = "ethers.js";
    }
    // Check/generate the salt
    let salt = null;
    if (options.salt) {
        salt = (0,bytes_lib_esm/* arrayify */.lE)(options.salt);
    }
    else {
        salt = (0,random/* randomBytes */.O)(32);
        ;
    }
    // Override initialization vector
    let iv = null;
    if (options.iv) {
        iv = (0,bytes_lib_esm/* arrayify */.lE)(options.iv);
        if (iv.length !== 16) {
            throw new Error("invalid iv");
        }
    }
    else {
        iv = (0,random/* randomBytes */.O)(16);
    }
    // Override the uuid
    let uuidRandom = null;
    if (options.uuid) {
        uuidRandom = (0,bytes_lib_esm/* arrayify */.lE)(options.uuid);
        if (uuidRandom.length !== 16) {
            throw new Error("invalid uuid");
        }
    }
    else {
        uuidRandom = (0,random/* randomBytes */.O)(16);
    }
    // Override the scrypt password-based key derivation function parameters
    let N = (1 << 17), r = 8, p = 1;
    if (options.scrypt) {
        if (options.scrypt.N) {
            N = options.scrypt.N;
        }
        if (options.scrypt.r) {
            r = options.scrypt.r;
        }
        if (options.scrypt.p) {
            p = options.scrypt.p;
        }
    }
    // We take 64 bytes:
    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    return scrypt_default().scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
        key = (0,bytes_lib_esm/* arrayify */.lE)(key);
        // This will be used to encrypt the wallet (as per Web3 secret storage)
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        // This will be used to encrypt the mnemonic phrase (if any)
        const mnemonicKey = key.slice(32, 64);
        // Encrypt the private key
        const counter = new (aes_js_default()).Counter(iv);
        const aesCtr = new (aes_js_default()).ModeOfOperation.ctr(derivedKey, counter);
        const ciphertext = (0,bytes_lib_esm/* arrayify */.lE)(aesCtr.encrypt(privateKey));
        // Compute the message authentication code, used to check the password
        const mac = (0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* concat */.zo)([macPrefix, ciphertext]));
        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
        const data = {
            address: account.address.substring(2).toLowerCase(),
            id: uuidV4(uuidRandom),
            version: 3,
            Crypto: {
                cipher: "aes-128-ctr",
                cipherparams: {
                    iv: (0,bytes_lib_esm/* hexlify */.Dv)(iv).substring(2),
                },
                ciphertext: (0,bytes_lib_esm/* hexlify */.Dv)(ciphertext).substring(2),
                kdf: "scrypt",
                kdfparams: {
                    salt: (0,bytes_lib_esm/* hexlify */.Dv)(salt).substring(2),
                    n: N,
                    dklen: 32,
                    p: p,
                    r: r
                },
                mac: mac.substring(2)
            }
        };
        // If we have a mnemonic, encrypt it into the JSON wallet
        if (entropy) {
            const mnemonicIv = (0,random/* randomBytes */.O)(16);
            const mnemonicCounter = new (aes_js_default()).Counter(mnemonicIv);
            const mnemonicAesCtr = new (aes_js_default()).ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
            const mnemonicCiphertext = (0,bytes_lib_esm/* arrayify */.lE)(mnemonicAesCtr.encrypt(entropy));
            const now = new Date();
            const timestamp = (now.getUTCFullYear() + "-" +
                zpad(now.getUTCMonth() + 1, 2) + "-" +
                zpad(now.getUTCDate(), 2) + "T" +
                zpad(now.getUTCHours(), 2) + "-" +
                zpad(now.getUTCMinutes(), 2) + "-" +
                zpad(now.getUTCSeconds(), 2) + ".0Z");
            data["x-ethers"] = {
                client: client,
                gethFilename: ("UTC--" + timestamp + "--" + data.address),
                mnemonicCounter: (0,bytes_lib_esm/* hexlify */.Dv)(mnemonicIv).substring(2),
                mnemonicCiphertext: (0,bytes_lib_esm/* hexlify */.Dv)(mnemonicCiphertext).substring(2),
                path: path,
                locale: locale,
                version: "0.1"
            };
        }
        return JSON.stringify(data);
    });
}
//# sourceMappingURL=keystore.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/json-wallets/lib.esm/index.js




function decryptJsonWallet(json, password, progressCallback) {
    if (isCrowdsaleWallet(json)) {
        if (progressCallback) {
            progressCallback(0);
        }
        const account = decrypt(json, password);
        if (progressCallback) {
            progressCallback(1);
        }
        return Promise.resolve(account);
    }
    if (isKeystoreWallet(json)) {
        return keystore_decrypt(json, password, progressCallback);
    }
    return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
    if (isCrowdsaleWallet(json)) {
        return decrypt(json, password);
    }
    if (isKeystoreWallet(json)) {
        return decryptSync(json, password);
    }
    throw new Error("invalid JSON wallet");
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/wallet/lib.esm/_version.js
const wallet_lib_esm_version_version = "wallet/5.6.2";
//# sourceMappingURL=_version.js.map
;// CONCATENATED MODULE: ../../node_modules/@ethersproject/wallet/lib.esm/index.js

var wallet_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};














const wallet_lib_esm_logger = new logger_lib_esm/* Logger */.Yd(wallet_lib_esm_version_version);
function isAccount(value) {
    return (value != null && (0,bytes_lib_esm/* isHexString */.A7)(value.privateKey, 32) && value.address != null);
}
function lib_esm_hasMnemonic(value) {
    const mnemonic = value.mnemonic;
    return (mnemonic && mnemonic.phrase);
}
class Wallet extends Signer {
    constructor(privateKey, provider) {
        super();
        if (isAccount(privateKey)) {
            const signingKey = new signing_key_lib_esm/* SigningKey */.Et(privateKey.privateKey);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_signingKey", () => signingKey);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "address", (0,transactions_lib_esm/* computeAddress */.db)(this.publicKey));
            if (this.address !== (0,lib_esm/* getAddress */.Kn)(privateKey.address)) {
                wallet_lib_esm_logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
            }
            if (lib_esm_hasMnemonic(privateKey)) {
                const srcMnemonic = privateKey.mnemonic;
                (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_mnemonic", () => ({
                    phrase: srcMnemonic.phrase,
                    path: srcMnemonic.path || hdnode_lib_esm/* defaultPath */.cD,
                    locale: srcMnemonic.locale || "en"
                }));
                const mnemonic = this.mnemonic;
                const node = hdnode_lib_esm/* HDNode.fromMnemonic */.m$.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
                if ((0,transactions_lib_esm/* computeAddress */.db)(node.privateKey) !== this.address) {
                    wallet_lib_esm_logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
                }
            }
            else {
                (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_mnemonic", () => null);
            }
        }
        else {
            if (signing_key_lib_esm/* SigningKey.isSigningKey */.Et.isSigningKey(privateKey)) {
                /* istanbul ignore if */
                if (privateKey.curve !== "secp256k1") {
                    wallet_lib_esm_logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
                }
                (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_signingKey", () => privateKey);
            }
            else {
                // A lot of common tools do not prefix private keys with a 0x (see: #1166)
                if (typeof (privateKey) === "string") {
                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                        privateKey = "0x" + privateKey;
                    }
                }
                const signingKey = new signing_key_lib_esm/* SigningKey */.Et(privateKey);
                (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_signingKey", () => signingKey);
            }
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "_mnemonic", () => null);
            (0,properties_lib_esm/* defineReadOnly */.zG)(this, "address", (0,transactions_lib_esm/* computeAddress */.db)(this.publicKey));
        }
        /* istanbul ignore if */
        if (provider && !Provider.isProvider(provider)) {
            wallet_lib_esm_logger.throwArgumentError("invalid provider", "provider", provider);
        }
        (0,properties_lib_esm/* defineReadOnly */.zG)(this, "provider", provider || null);
    }
    get mnemonic() { return this._mnemonic(); }
    get privateKey() { return this._signingKey().privateKey; }
    get publicKey() { return this._signingKey().publicKey; }
    getAddress() {
        return Promise.resolve(this.address);
    }
    connect(provider) {
        return new Wallet(this, provider);
    }
    signTransaction(transaction) {
        return (0,properties_lib_esm/* resolveProperties */.mE)(transaction).then((tx) => {
            if (tx.from != null) {
                if ((0,lib_esm/* getAddress */.Kn)(tx.from) !== this.address) {
                    wallet_lib_esm_logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
                }
                delete tx.from;
            }
            const signature = this._signingKey().signDigest((0,keccak256_lib_esm/* keccak256 */.w)((0,transactions_lib_esm/* serialize */.qC)(tx)));
            return (0,transactions_lib_esm/* serialize */.qC)(tx, signature);
        });
    }
    signMessage(message) {
        return wallet_lib_esm_awaiter(this, void 0, void 0, function* () {
            return (0,bytes_lib_esm/* joinSignature */.gV)(this._signingKey().signDigest(message_hashMessage(message)));
        });
    }
    _signTypedData(domain, types, value) {
        return wallet_lib_esm_awaiter(this, void 0, void 0, function* () {
            // Populate any ENS names
            const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
                if (this.provider == null) {
                    wallet_lib_esm_logger.throwError("cannot resolve ENS names without a provider", logger_lib_esm/* Logger.errors.UNSUPPORTED_OPERATION */.Yd.errors.UNSUPPORTED_OPERATION, {
                        operation: "resolveName",
                        value: name
                    });
                }
                return this.provider.resolveName(name);
            });
            return (0,bytes_lib_esm/* joinSignature */.gV)(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
    }
    encrypt(password, options, progressCallback) {
        if (typeof (options) === "function" && !progressCallback) {
            progressCallback = options;
            options = {};
        }
        if (progressCallback && typeof (progressCallback) !== "function") {
            throw new Error("invalid callback");
        }
        if (!options) {
            options = {};
        }
        return encrypt(this, password, options, progressCallback);
    }
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options) {
        let entropy = (0,random/* randomBytes */.O)(16);
        if (!options) {
            options = {};
        }
        if (options.extraEntropy) {
            entropy = (0,bytes_lib_esm/* arrayify */.lE)((0,bytes_lib_esm/* hexDataSlice */.p3)((0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* concat */.zo)([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = (0,hdnode_lib_esm/* entropyToMnemonic */.JJ)(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
            return new Wallet(account);
        });
    }
    static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
            path = hdnode_lib_esm/* defaultPath */.cD;
        }
        return new Wallet(hdnode_lib_esm/* HDNode.fromMnemonic */.m$.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    }
}
function verifyMessage(message, signature) {
    return recoverAddress(hashMessage(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../packages/utils/index.js
var utils = __webpack_require__(11818);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/compose/thread-first.js
/**
 * Takes an `init` value and a number of functions and/or function
 * tuples, consisting of: `[fn, ...args]`. Executes each function
 * (or tuple) with the return value of the previous expression inserted
 * as first argument, using `init` for the first expression.
 *
 * @example
 * ```ts
 * const neg = (x) => -x;
 * const sub = (a, b) => a - b;
 * const div = (a, b) => a / b;
 *
 * threadFirst(
 *   5,
 *   neg,       // -5
 *   [sub, 20], // -5 - 20 = -25
 *   [div, 10]  // -25 / 10 = -2.5
 * );
 *
 * // -2.5
 * ```
 *
 * {@link threadLast}
 *
 * @param init - start value
 * @param fns - functions / S-expressions
 */
const threadFirst = (init, ...fns) => fns.reduce((acc, expr) => typeof expr === "function"
    ? expr(acc)
    : expr[0](acc, ...expr.slice(1)), init);

// EXTERNAL MODULE: ../../node_modules/@thi.ng/compose/comp.js
var comp = __webpack_require__(4088);
// EXTERNAL MODULE: ../../packages/consts/index.js
var consts = __webpack_require__(9414);
;// CONCATENATED MODULE: ../../packages/account/index.js
const create=({pk}={})=>{const kp=pk?new Wallet(pk):Wallet.createRandom();return kp;};const toChecksum=(0,comp/* compL */.zv)(utils/* addHexPrefix */.L_,lib_esm/* getAddress */.Kn);const isChecksummed=(0,comp/* compL */.zv)(utils/* addHexPrefix */.L_,addr=>{try{return Boolean((0,lib_esm/* getAddress */.Kn)(addr));}catch(err){return false;}});const fromPrivate=pk=>({address:threadFirst(pk,utils/* addHexPrefix */.L_,transactions_lib_esm/* computeAddress */.db),privateKey:(0,utils/* addHexPrefix */.L_)(pk)});const toAccountAddress=address=>{return address.replace(/^0x./,'0x1');};const toContractAddress=address=>{return address.replace(/^0x./,'0x8');};const randomHexAddress=(type,checksum=false)=>{if(type&&!consts/* ADDRESS_TYPES.includes */._t.includes(type))throw new Error(`Invalid address type ${type}`);if(type==='builtin')return consts/* INTERNAL_CONTRACTS_HEX_ADDRESS */.kg[(0,utils/* randomInt */.Iy)(consts/* INTERNAL_CONTRACTS_HEX_ADDRESS.length */.kg.length)];if(type==='null')return consts/* NULL_HEX_ADDRESS */.JV;const addr=create().address;if(type==='user')return toAccountAddress(addr);if(type==='contract')return toContractAddress(addr);if(checksum)return toChecksum(addr);return addr;};const isHexAddress=address=>/^0x[0-9a-fA-F]{40}$/.test(address);const isUserHexAddress=address=>address.startsWith('0x1');const isContractAddress=address=>address.startsWith('0x8');const isBuiltInAddress=address=>INTERNAL_CONTRACTS_HEX_ADDRESS.includes(address.toLowerCase());const isNullHexAddress=address=>address===NULL_HEX_ADDRESS;const isCfxHexAddress=address=>isUserHexAddress(address)||isContractAddress(address)||isBuiltInAddress(address)||isNullHexAddress(address);const validateHexAddress=(address,type)=>{if(typeof address!=='string')throw new Error('Invalid address, must be a 0x-prefixed string');if(!address.startsWith('0x'))throw new Error('Invalid address, must be a 0x-prefixed string');if(!isHexAddress(address))return false;if(type==='eth')return true;if(type==='user')return isUserHexAddress(address);if(type==='contract')return isContractAddress(address);if(type==='builtin')return isBuiltInAddress(address);if(type==='null')return isNullHexAddress(address);return isCfxHexAddress(address);};const randomAddressType=()=>{return consts/* ADDRESS_TYPES */._t[(0,utils/* randomInt */.Iy)(consts/* ADDRESS_TYPES.length */._t.length)];};const randomCfxHexAddress=()=>{return randomHexAddress(randomAddressType());};const randomPrivateKey=()=>{return create().privateKey;};const validatePrivateKey=privateKey=>{let valid=false;try{const rst=fromPrivate(privateKey);valid=Boolean(rst.address);}catch(err){valid=false;}return valid;};

/***/ }),

/***/ 64347:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9414);
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11239);
const ADDR_TYPE_TO_PREFIX={user:'0x1',contract:'0x8',null:'0x0',builtin:'0x0'};const addrByNetwork=({address,networkType,networkId,addressType,privateKey}={})=>{if(typeof address!=='string')throw new Error('Invalid address, must be a string');if(!['cfx','eth'].includes(networkType))throw new Error('Invalid networkType, must be cfx or eth');if(networkId!==undefined&&networkId!==null&&!Number.isSafeInteger(networkId))throw new Error('Invalid networkId, must be a safe integer');if(networkType==='cfx'&&!Number.isSafeInteger(networkId))throw new Error('Invalid networkId, must be a safe integer');if(addressType&&!_fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__/* .ADDRESS_TYPES.includes */ ._t.includes(addressType))throw new Error('Invalid addressType, must be one of '+_fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__/* .ADDRESS_TYPES.toString */ ._t.toString());if(networkType==='cfx'){if(addressType==='null')address='0x0000000000000000000000000000000000000000';if((0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_0__/* .validateBase32Address */ .pd)(address,networkId,addressType))return address;if(address.includes(':')){if(addressType&&!(0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_0__/* .validateBase32Address */ .pd)(address,addressType))throw new Error('Invalid base32 address, address type is invalid');return (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_0__/* .encode */ .cv)((0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_0__/* .decode */ .Jx)(address).hexAddress,networkId);}if(!addressType)addressType='user';return (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_0__/* .encode */ .cv)(address.toLowerCase().replace(/0x./,ADDR_TYPE_TO_PREFIX[addressType]),networkId);}if(networkType==='eth'){if(address.includes(':')){if(privateKey)return (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_2__/* .fromPrivate */ .yV)(privateKey).address;else throw new Error('Unable to convert base32 address into eth hex address without private key');}else return address;}};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addrByNetwork);

/***/ }),

/***/ 2723:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Jx": () => (/* binding */ decode),
  "cv": () => (/* binding */ encode),
  "TW": () => (/* binding */ randomBase32Address),
  "pd": () => (/* binding */ validateBase32Address)
});

// EXTERNAL MODULE: ../../packages/account/index.js + 16 modules
var account = __webpack_require__(11239);
// EXTERNAL MODULE: ../../packages/utils/index.js
var utils = __webpack_require__(11818);
// EXTERNAL MODULE: ../../node_modules/js-conflux-sdk/src/index.js
var src = __webpack_require__(11293);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/memoize/memoize.js
function memoize(fn, cache) {
    return (...args) => {
        let res;
        return cache.has(args)
            ? cache.get(args)
            : (cache.set(args, (res = fn.apply(null, args))), res);
    };
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/memoize/memoize1.js
/**
 * Optimized memoization for single arg functions. If the function
 * expects args other than strings or numbers, you MUST provide a `Map`
 * implementation which supports value (rather than object) equality,
 * e.g. one of those provided by
 * {@link @thi.ng/associative# | @thi.ng/associative}. Using a native
 * `Map` type here will lead to memory leaks! Alternatively, use
 * {@link (memoizeJ:1)}.
 *
 * @param fn -
 * @param cache -
 */
const memoize1 = (fn, cache) => {
    !cache && (cache = new Map());
    return (x) => {
        let res;
        return cache.has(x)
            ? cache.get(x)
            : (cache.set(x, (res = fn(x))), res);
    };
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/dcons/dcons.js + 3 modules
var dcons = __webpack_require__(80872);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/map.js
var map = __webpack_require__(84900);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/cache/lru.js


class LRUCache {
    constructor(pairs, opts) {
        const _opts = Object.assign({
            maxlen: Infinity,
            maxsize: Infinity,
            map: () => new Map(),
            ksize: () => 0,
            vsize: () => 0,
        }, opts);
        this.map = _opts.map();
        this.items = new dcons/* DCons */.K5();
        this._size = 0;
        this.opts = _opts;
        if (pairs) {
            this.into(pairs);
        }
    }
    get length() {
        return this.items.length;
    }
    get size() {
        return this._size;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        return (0,map/* map */.U)((e) => [e.k, e], this.items);
    }
    keys() {
        return (0,map/* map */.U)((e) => e.k, this.items);
    }
    values() {
        return (0,map/* map */.U)((e) => e.v, this.items);
    }
    copy() {
        const c = this.empty();
        c.items = this.items.copy();
        let cell = c.items.head;
        while (cell) {
            c.map.set(cell.value.k, cell);
            cell = cell.next;
        }
        return c;
    }
    empty() {
        return new LRUCache(null, this.opts);
    }
    release() {
        this._size = 0;
        this.map.clear();
        const release = this.opts.release;
        if (release) {
            let e;
            while ((e = this.items.drop())) {
                release(e.k, e.v);
            }
            return true;
        }
        return this.items.release();
    }
    has(key) {
        return this.map.has(key);
    }
    get(key, notFound) {
        const e = this.map.get(key);
        if (e) {
            return this.resetEntry(e);
        }
        return notFound;
    }
    set(key, value) {
        const size = this.opts.ksize(key) + this.opts.vsize(value);
        const e = this.map.get(key);
        this._size += Math.max(0, size - (e ? e.value.s : 0));
        this.ensureSize() && this.doSetEntry(e, key, value, size);
        return value;
    }
    into(pairs) {
        for (let p of pairs) {
            this.set(p[0], p[1]);
        }
        return this;
    }
    getSet(key, retrieve) {
        const e = this.map.get(key);
        if (e) {
            return Promise.resolve(this.resetEntry(e));
        }
        return retrieve().then((v) => this.set(key, v));
    }
    delete(key) {
        const e = this.map.get(key);
        if (e) {
            this.removeEntry(e);
            return true;
        }
        return false;
    }
    resetEntry(e) {
        this.items.asTail(e);
        return e.value.v;
    }
    ensureSize() {
        const release = this.opts.release;
        const maxs = this.opts.maxsize;
        const maxl = this.opts.maxlen;
        while (this._size > maxs || this.length >= maxl) {
            const e = this.items.drop();
            if (!e) {
                return false;
            }
            this.map.delete(e.k);
            release && release(e.k, e.v);
            this._size -= e.s;
        }
        return true;
    }
    removeEntry(e) {
        const ee = e.value;
        this.map.delete(ee.k);
        this.items.remove(e);
        this.opts.release && this.opts.release(ee.k, ee.v);
        this._size -= ee.s;
    }
    doSetEntry(e, k, v, s) {
        if (e) {
            e.value.v = v;
            e.value.s = s;
            this.items.asTail(e);
        }
        else {
            this.items.push({ k, v, s });
            this.map.set(k, this.items.tail);
        }
    }
}

// EXTERNAL MODULE: ../../packages/consts/index.js
var consts = __webpack_require__(9414);
;// CONCATENATED MODULE: ../../packages/base32-address/index.js
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
const encode=memoize((hexAddress,netId,verbose)=>src.address.encodeCfxAddress((0,utils/* addHexPrefix */.L_)(hexAddress),netId,verbose),new LRUCache(null,{maxlen:200}));const decodeRaw=a=>{try{const rst=src.address.decodeCfxAddress(a);rst.hexAddress=(0,utils/* addHexPrefix */.L_)(rst.hexAddress.toString('hex'));return rst;}catch(err){var _err$message;if(err!==null&&err!==void 0&&(_err$message=err.message)!==null&&_err$message!==void 0&&_err$message.includes('Invalid attempt to destructure non-iterable instance'))throw new Error('Invalid checksum');throw err;}};const decode=memoize1(decodeRaw,new LRUCache(null,{maxlen:200}));function validateBase32Address(address,...args){let netId,type,decoded;let valid=false;if(args[0]!==undefined&&args[0]!==null){if(Number.isSafeInteger(args[0]))netId=args[0];else if(typeof args[0]==='string')type=args[0];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');}if(args[1]!==undefined&&args[1]!==null){if(Number.isSafeInteger(args[1]))netId=args[1];else if(typeof args[1]==='string')type=args[1];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');}try{decoded=decode(address);valid=true;if(netId!==undefined&&netId!==decoded.netId)valid=false;if(type!==undefined&&type!==decoded.type)valid=false;}catch(err){valid=false;}return valid;}const randomBase32Address=(...args)=>{let netId,type;if(args[0]!==undefined&&args[0]!==null){if(Number.isSafeInteger(args[0]))netId=args[0];else if(typeof args[0]==='string')type=args[0];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');}if(args[1]!==undefined&&args[1]!==null){if(Number.isSafeInteger(args[1]))netId=args[1];else if(typeof args[1]==='string')type=args[1];else throw new Error('Invalid type or networkId, type must be string, networkId must be number');}if(type===undefined)type=(0,account/* randomAddressType */.c$)();if(netId===undefined)netId=consts/* CFX_MAINNET_NETID */.sU;const hexAddress=(0,utils/* stripHexPrefix */.MT)((0,account/* randomHexAddress */.MG)(type));return encode(Buffer.from(hexAddress,'hex'),netId);};

/***/ }),

/***/ 34577:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "jn": () => (/* reexport */ isBoolean),
  "mf": () => (/* reexport */ is_function/* isFunction */.m),
  "o8": () => (/* reexport */ isUndefined)
});

// UNUSED EXPORTS: exists, existsAndNotNull, hasBigInt, hasCrypto, hasMaxLength, hasMinLength, hasPerformance, hasWASM, hasWebGL, hasWebSocket, implementsFunction, isASCII, isAlpha, isAlphaNum, isArray, isArrayLike, isAsyncFunction, isAsyncIterable, isBlob, isChrome, isDataURL, isDate, isEven, isFalse, isFile, isFirefox, isFloatString, isHex, isHexColor, isIE, isIllegalKey, isInRange, isInt32, isIntString, isIterable, isMap, isMobile, isNaN, isNegative, isNil, isNode, isNotStringAndIterable, isNull, isNumber, isNumeric, isNumericFloat, isNumericInt, isObject, isOdd, isPlainObject, isPositive, isPrimitive, isPrintableASCII, isPromise, isPromiseLike, isProtoPath, isRegExp, isSafari, isSet, isString, isSymbol, isTransferable, isTrue, isTypedArray, isUUID, isUUIDv4, isUint32, isZero

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/checks/is-boolean.js
const isBoolean = (x) => typeof x === "boolean";

// EXTERNAL MODULE: ../../node_modules/@thi.ng/checks/is-function.js
var is_function = __webpack_require__(49040);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/checks/is-undefined.js
const isUndefined = (x) => x === undefined;

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/checks/index.js


































































;// CONCATENATED MODULE: ../../packages/checks/index.js
/**
 * @fileOverview extends @thi.ng/checks
 * @name index.js
 */const AsyncFunction=(async()=>{}).constructor;// this can't detect a normal function that returns a promise
const isAsyncFunction=fn=>isFunction(fn)&&fn instanceof AsyncFunction;

/***/ }),

/***/ 95895:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "h": () => (/* binding */ fetch)
});

;// CONCATENATED MODULE: ../../node_modules/ky/distribution/errors/HTTPError.js
// eslint-lint-disable-next-line @typescript-eslint/naming-convention
class HTTPError extends Error {
    constructor(response, request, options) {
        const code = (response.status || response.status === 0) ? response.status : '';
        const title = response.statusText || '';
        const status = `${code} ${title}`.trim();
        const reason = status ? `status code ${status}` : 'an unknown error';
        super(`Request failed with ${reason}`);
        this.name = 'HTTPError';
        this.response = response;
        this.request = request;
        this.options = options;
    }
}
//# sourceMappingURL=HTTPError.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/errors/TimeoutError.js
class TimeoutError extends Error {
    constructor(request) {
        super('Request timed out');
        this.name = 'TimeoutError';
        this.request = request;
    }
}
//# sourceMappingURL=TimeoutError.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/utils/is.js
// eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (value) => value !== null && typeof value === 'object';
//# sourceMappingURL=is.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/utils/merge.js

const validateAndMerge = (...sources) => {
    for (const source of sources) {
        if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {
            throw new TypeError('The `options` argument must be an object');
        }
    }
    return deepMerge({}, ...sources);
};
const mergeHeaders = (source1 = {}, source2 = {}) => {
    const result = new globalThis.Headers(source1);
    const isHeadersInstance = source2 instanceof globalThis.Headers;
    const source = new globalThis.Headers(source2);
    for (const [key, value] of source.entries()) {
        if ((isHeadersInstance && value === 'undefined') || value === undefined) {
            result.delete(key);
        }
        else {
            result.set(key, value);
        }
    }
    return result;
};
// TODO: Make this strongly-typed (no `any`).
const deepMerge = (...sources) => {
    let returnValue = {};
    let headers = {};
    for (const source of sources) {
        if (Array.isArray(source)) {
            if (!Array.isArray(returnValue)) {
                returnValue = [];
            }
            returnValue = [...returnValue, ...source];
        }
        else if (isObject(source)) {
            for (let [key, value] of Object.entries(source)) {
                if (isObject(value) && key in returnValue) {
                    value = deepMerge(returnValue[key], value);
                }
                returnValue = { ...returnValue, [key]: value };
            }
            if (isObject(source.headers)) {
                headers = mergeHeaders(headers, source.headers);
                returnValue.headers = headers;
            }
        }
    }
    return returnValue;
};
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/core/constants.js
const supportsAbortController = typeof globalThis.AbortController === 'function';
const supportsStreams = typeof globalThis.ReadableStream === 'function';
const supportsFormData = typeof globalThis.FormData === 'function';
const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
const validate = () => undefined;
validate();
const responseTypes = {
    json: 'application/json',
    text: 'text/*',
    formData: 'multipart/form-data',
    arrayBuffer: '*/*',
    blob: '*/*',
};
// The maximum value of a 32bit int (see issue #117)
const maxSafeTimeout = 2147483647;
const stop = Symbol('stop');
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/utils/normalize.js

const normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
const retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
const retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
const retryAfterStatusCodes = [413, 429, 503];
const defaultRetryOptions = {
    limit: 2,
    methods: retryMethods,
    statusCodes: retryStatusCodes,
    afterStatusCodes: retryAfterStatusCodes,
    maxRetryAfter: Number.POSITIVE_INFINITY,
};
const normalizeRetryOptions = (retry = {}) => {
    if (typeof retry === 'number') {
        return {
            ...defaultRetryOptions,
            limit: retry,
        };
    }
    if (retry.methods && !Array.isArray(retry.methods)) {
        throw new Error('retry.methods must be an array');
    }
    if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
        throw new Error('retry.statusCodes must be an array');
    }
    return {
        ...defaultRetryOptions,
        ...retry,
        afterStatusCodes: retryAfterStatusCodes,
    };
};
//# sourceMappingURL=normalize.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/utils/time.js

// `Promise.race()` workaround (#91)
const timeout = async (request, abortController, options) => new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
        if (abortController) {
            abortController.abort();
        }
        reject(new TimeoutError(request));
    }, options.timeout);
    void options
        .fetch(request)
        .then(resolve)
        .catch(reject)
        .then(() => {
        clearTimeout(timeoutId);
    });
});
const delay = async (ms) => new Promise(resolve => {
    setTimeout(resolve, ms);
});
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/core/Ky.js






class Ky {
    // eslint-disable-next-line complexity
    constructor(input, options = {}) {
        var _a, _b, _c;
        this._retryCount = 0;
        this._input = input;
        this._options = {
            // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
            credentials: this._input.credentials || 'same-origin',
            ...options,
            headers: mergeHeaders(this._input.headers, options.headers),
            hooks: deepMerge({
                beforeRequest: [],
                beforeRetry: [],
                beforeError: [],
                afterResponse: [],
            }, options.hooks),
            method: normalizeRequestMethod((_a = options.method) !== null && _a !== void 0 ? _a : this._input.method),
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            prefixUrl: String(options.prefixUrl || ''),
            retry: normalizeRetryOptions(options.retry),
            throwHttpErrors: options.throwHttpErrors !== false,
            timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,
            fetch: (_b = options.fetch) !== null && _b !== void 0 ? _b : globalThis.fetch.bind(globalThis),
        };
        if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
            throw new TypeError('`input` must be a string, URL, or Request');
        }
        if (this._options.prefixUrl && typeof this._input === 'string') {
            if (this._input.startsWith('/')) {
                throw new Error('`input` must not begin with a slash when using `prefixUrl`');
            }
            if (!this._options.prefixUrl.endsWith('/')) {
                this._options.prefixUrl += '/';
            }
            this._input = this._options.prefixUrl + this._input;
        }
        if (supportsAbortController) {
            this.abortController = new globalThis.AbortController();
            if (this._options.signal) {
                this._options.signal.addEventListener('abort', () => {
                    this.abortController.abort();
                });
            }
            this._options.signal = this.abortController.signal;
        }
        this.request = new globalThis.Request(this._input, this._options);
        if (this._options.searchParams) {
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const textSearchParams = typeof this._options.searchParams === 'string'
                ? this._options.searchParams.replace(/^\?/, '')
                : new URLSearchParams(this._options.searchParams).toString();
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const searchParams = '?' + textSearchParams;
            const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
            // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one
            if (((supportsFormData && this._options.body instanceof globalThis.FormData)
                || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
                this.request.headers.delete('content-type');
            }
            this.request = new globalThis.Request(new globalThis.Request(url, this.request), this._options);
        }
        if (this._options.json !== undefined) {
            this._options.body = JSON.stringify(this._options.json);
            this.request.headers.set('content-type', (_c = this._options.headers.get('content-type')) !== null && _c !== void 0 ? _c : 'application/json');
            this.request = new globalThis.Request(this.request, { body: this._options.body });
        }
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    static create(input, options) {
        const ky = new Ky(input, options);
        const fn = async () => {
            if (ky._options.timeout > maxSafeTimeout) {
                throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
            }
            // Delay the fetch so that body method shortcuts can set the Accept header
            await Promise.resolve();
            let response = await ky._fetch();
            for (const hook of ky._options.hooks.afterResponse) {
                // eslint-disable-next-line no-await-in-loop
                const modifiedResponse = await hook(ky.request, ky._options, ky._decorateResponse(response.clone()));
                if (modifiedResponse instanceof globalThis.Response) {
                    response = modifiedResponse;
                }
            }
            ky._decorateResponse(response);
            if (!response.ok && ky._options.throwHttpErrors) {
                let error = new HTTPError(response, ky.request, ky._options);
                for (const hook of ky._options.hooks.beforeError) {
                    // eslint-disable-next-line no-await-in-loop
                    error = await hook(error);
                }
                throw error;
            }
            // If `onDownloadProgress` is passed, it uses the stream API internally
            /* istanbul ignore next */
            if (ky._options.onDownloadProgress) {
                if (typeof ky._options.onDownloadProgress !== 'function') {
                    throw new TypeError('The `onDownloadProgress` option must be a function');
                }
                if (!supportsStreams) {
                    throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
                }
                return ky._stream(response.clone(), ky._options.onDownloadProgress);
            }
            return response;
        };
        const isRetriableMethod = ky._options.retry.methods.includes(ky.request.method.toLowerCase());
        const result = (isRetriableMethod ? ky._retry(fn) : fn());
        for (const [type, mimeType] of Object.entries(responseTypes)) {
            result[type] = async () => {
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                ky.request.headers.set('accept', ky.request.headers.get('accept') || mimeType);
                const awaitedResult = await result;
                const response = awaitedResult.clone();
                if (type === 'json') {
                    if (response.status === 204) {
                        return '';
                    }
                    if (options.parseJson) {
                        return options.parseJson(await response.text());
                    }
                }
                return response[type]();
            };
        }
        return result;
    }
    _calculateRetryDelay(error) {
        this._retryCount++;
        if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
            if (error instanceof HTTPError) {
                if (!this._options.retry.statusCodes.includes(error.response.status)) {
                    return 0;
                }
                const retryAfter = error.response.headers.get('Retry-After');
                if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
                    let after = Number(retryAfter);
                    if (Number.isNaN(after)) {
                        after = Date.parse(retryAfter) - Date.now();
                    }
                    else {
                        after *= 1000;
                    }
                    if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {
                        return 0;
                    }
                    return after;
                }
                if (error.response.status === 413) {
                    return 0;
                }
            }
            const BACKOFF_FACTOR = 0.3;
            return BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000;
        }
        return 0;
    }
    _decorateResponse(response) {
        if (this._options.parseJson) {
            response.json = async () => this._options.parseJson(await response.text());
        }
        return response;
    }
    async _retry(fn) {
        try {
            return await fn();
            // eslint-disable-next-line @typescript-eslint/no-implicit-any-catch
        }
        catch (error) {
            const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
            if (ms !== 0 && this._retryCount > 0) {
                await delay(ms);
                for (const hook of this._options.hooks.beforeRetry) {
                    // eslint-disable-next-line no-await-in-loop
                    const hookResult = await hook({
                        request: this.request,
                        options: this._options,
                        error: error,
                        retryCount: this._retryCount,
                    });
                    // If `stop` is returned from the hook, the retry process is stopped
                    if (hookResult === stop) {
                        return;
                    }
                }
                return this._retry(fn);
            }
            throw error;
        }
    }
    async _fetch() {
        for (const hook of this._options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(this.request, this._options);
            if (result instanceof Request) {
                this.request = result;
                break;
            }
            if (result instanceof Response) {
                return result;
            }
        }
        if (this._options.timeout === false) {
            return this._options.fetch(this.request.clone());
        }
        return timeout(this.request.clone(), this.abortController, this._options);
    }
    /* istanbul ignore next */
    _stream(response, onDownloadProgress) {
        const totalBytes = Number(response.headers.get('content-length')) || 0;
        let transferredBytes = 0;
        return new globalThis.Response(new globalThis.ReadableStream({
            async start(controller) {
                const reader = response.body.getReader();
                if (onDownloadProgress) {
                    onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
                }
                async function read() {
                    const { done, value } = await reader.read();
                    if (done) {
                        controller.close();
                        return;
                    }
                    if (onDownloadProgress) {
                        transferredBytes += value.byteLength;
                        const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
                        onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
                    }
                    controller.enqueue(value);
                    await read();
                }
                await read();
            },
        }));
    }
}
//# sourceMappingURL=Ky.js.map
;// CONCATENATED MODULE: ../../node_modules/ky/distribution/index.js
/*! MIT License  Sindre Sorhus */



const createInstance = (defaults) => {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    const ky = (input, options) => Ky.create(input, validateAndMerge(defaults, options));
    for (const method of requestMethods) {
        // eslint-disable-next-line @typescript-eslint/promise-function-async
        ky[method] = (input, options) => Ky.create(input, validateAndMerge(defaults, options, { method }));
    }
    ky.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
    ky.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
    ky.stop = stop;
    return ky;
};
const ky = createInstance();
/* harmony default export */ const distribution = (ky);


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../packages/fetch-rpc/index.js
// eslint-disable-line import/no-unresolved
const DEFAULT_FETCH_OPTS={credentials:'omit',mode:'cors',retry:{limit:2,methods:['get','put','head','delete','options','trace'],statusCode:[408,413,429,500,502,503,504],afterStatusCodes:[413,429,503],maxRetryAfter:Infinity,timeout:10000}};const initFetcher=(opts={})=>{return distribution.create({...DEFAULT_FETCH_OPTS,...opts});};
;// CONCATENATED MODULE: ../../packages/confluxscan-api/fetcher.js
const fetch=initFetcher();

/***/ }),

/***/ 52093:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ getURL),
/* harmony export */   "v": () => (/* binding */ isCoreNetworkId)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9414);
function getURL(networkId,...args){return[_fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_0__/* .CFX_SCAN_API_ENDPOINTS */ .qc[networkId],...args].reduce((acc,s)=>acc+s);}function isCoreNetworkId(networkId){if(networkId===_fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_0__/* .CFX_MAINNET_NETID */ .sU||networkId===_fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_0__/* .CFX_TESTNET_NETID */ .mO)return true;return false;}

/***/ }),

/***/ 9414:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JV": () => (/* binding */ NULL_HEX_ADDRESS),
/* harmony export */   "kg": () => (/* binding */ INTERNAL_CONTRACTS_HEX_ADDRESS),
/* harmony export */   "_t": () => (/* binding */ ADDRESS_TYPES),
/* harmony export */   "ae": () => (/* binding */ CFX_MAINNET_NAME),
/* harmony export */   "sU": () => (/* binding */ CFX_MAINNET_NETID),
/* harmony export */   "Ne": () => (/* binding */ CFX_ESPACE_MAINNET_NETID),
/* harmony export */   "mO": () => (/* binding */ CFX_TESTNET_NETID),
/* harmony export */   "sB": () => (/* binding */ CFX_ESPACE_TESTNET_NETID),
/* harmony export */   "JH": () => (/* binding */ DEFAULT_CFX_HDPATH),
/* harmony export */   "uD": () => (/* binding */ DEFAULT_ETH_HDPATH),
/* harmony export */   "qc": () => (/* binding */ CFX_SCAN_API_ENDPOINTS),
/* harmony export */   "Pp": () => (/* binding */ ETH_TX_TYPES)
/* harmony export */ });
/* unused harmony exports MAINNET, TESTNET, LOCALHOST, CUSTOM, EXT_STORAGE, ADMINE_CONTROL_HEX_ADDRESS, SPONSOR_WHITELIST_CONTROL_HEX_ADDRESS, STAKING_HEX_ADDRESS, DEFAULT_CURRENCY_DECIMALS, CFX_MAINNET_RPC_ENDPOINT, CFX_MAINNET_CHAINID, CFX_MAINNET_CURRENCY_SYMBOL, CFX_MAINNET_CURRENCY_NAME, CFX_MAINNET_EXPLORER_URL, CFX_ESPACE_MAINNET_RPC_ENDPOINT, CFX_ESPACE_MAINNET_NAME, CFX_ESPACE_MAINNET_CHAINID, CFX_ESPACE_MAINNET_CURRENCY_SYMBOL, CFX_ESPACE_MAINNET_CURRENCY_NAME, CFX_ESPACE_MAINNET_EXPLORER_URL, CFX_TESTNET_RPC_ENDPOINT, CFX_TESTNET_NAME, CFX_TESTNET_CHAINID, CFX_TESTNET_CURRENCY_SYMBOL, CFX_TESTNET_CURRENCY_NAME, CFX_TESTNET_EXPLORER_URL, CFX_ESPACE_TESTNET_RPC_ENDPOINT, CFX_ESPACE_TESTNET_NAME, CFX_ESPACE_TESTNET_CHAINID, CFX_ESPACE_TESTNET_CURRENCY_SYMBOL, CFX_ESPACE_TESTNET_CURRENCY_NAME, CFX_ESPACE_TESTNET_EXPLORER_URL, ETH_MAINNET_RPC_ENDPOINT, ETH_MAINNET_NAME, ETH_MAINNET_CHAINID, ETH_MAINNET_NETID, ETH_MAINNET_CURRENCY_SYMBOL, ETH_MAINNET_CURRENCY_NAME, ETH_MAINNET_EXPLORER_URL, ETH_ROPSTEN_RPC_ENDPOINT, ETH_ROPSTEN_NAME, ETH_ROPSTEN_CHAINID, ETH_ROPSTEN_NETID, ETH_ROPSTEN_CURRENCY_SYMBOL, ETH_ROPSTEN_CURRENCY_NAME, ETH_ROPSTEN_EXPLORER_URL, ETH_RINKEBY_RPC_ENDPOINT, ETH_RINKEBY_NAME, ETH_RINKEBY_CHAINID, ETH_RINKEBY_NETID, ETH_RINKEBY_CURRENCY_SYMBOL, ETH_RINKEBY_CURRENCY_NAME, ETH_RINKEBY_EXPLORER_URL, ETH_GOERLI_RPC_ENDPOINT, ETH_GOERLI_NAME, ETH_GOERLI_CHAINID, ETH_GOERLI_NETID, ETH_GOERLI_CURRENCY_SYMBOL, ETH_GOERLI_CURRENCY_NAME, ETH_GOERLI_EXPLORER_URL, ETH_KOVAN_RPC_ENDPOINT, ETH_KOVAN_NAME, ETH_KOVAN_CHAINID, ETH_KOVAN_NETID, ETH_KOVAN_CURRENCY_SYMBOL, ETH_KOVAN_CURRENCY_NAME, ETH_KOVAN_EXPLORER_URL, REGENERATE, CFX_LOCALNET_RPC_ENDPOINT, CFX_LOCALNET_NAME, CFX_LOCALNET_CHAINID, CFX_LOCALNET_NETID, CFX_LOCALNET_CURRENCY_SYMBOL, CFX_LOCALNET_CURRENCY_NAME, ETH_LOCALNET_RPC_ENDPOINT, ETH_LOCALNET_NAME, ETH_LOCALNET_CHAINID, ETH_LOCALNET_NETID, ETH_LOCALNET_CURRENCY_SYMBOL, ETH_LOCALNET_CURRENCY_NAME, ETH_ENDPOINT, CFX_SCAN_DOMAINS, ETH_SCAN_DOMAINS */
/**
 * @fileOverview consts used in extension
 * @name index.js
 */const MAINNET='mainnet';const TESTNET='testnet';const LOCALHOST='localhost';const CUSTOM='custom';const EXT_STORAGE='ext-storage';const NULL_HEX_ADDRESS='0x0000000000000000000000000000000000000000';const ADMINE_CONTROL_HEX_ADDRESS='0x0888000000000000000000000000000000000000';const SPONSOR_WHITELIST_CONTROL_HEX_ADDRESS='0x0888000000000000000000000000000000000001';const STAKING_HEX_ADDRESS='0x0888000000000000000000000000000000000002';const INTERNAL_CONTRACTS_HEX_ADDRESS=[ADMINE_CONTROL_HEX_ADDRESS,SPONSOR_WHITELIST_CONTROL_HEX_ADDRESS,STAKING_HEX_ADDRESS];const ADDRESS_TYPES=['user','contract','builtin','null'];// * network setting
const DEFAULT_CURRENCY_DECIMALS=18;const CFX_MAINNET_RPC_ENDPOINT='https://portal-main.confluxrpc.com';const CFX_MAINNET_NAME='Conflux Mainnet';const CFX_MAINNET_CHAINID='0x405';const CFX_MAINNET_NETID=1029;const CFX_MAINNET_CURRENCY_SYMBOL='CFX';const CFX_MAINNET_CURRENCY_NAME='Conflux';const CFX_MAINNET_EXPLORER_URL='https://confluxscan.io';const CFX_ESPACE_MAINNET_RPC_ENDPOINT='https://evm.confluxrpc.com';const CFX_ESPACE_MAINNET_NAME='Conflux eSpace';const CFX_ESPACE_MAINNET_CHAINID='0x406';const CFX_ESPACE_MAINNET_NETID=1030;const CFX_ESPACE_MAINNET_CURRENCY_SYMBOL='CFX';const CFX_ESPACE_MAINNET_CURRENCY_NAME='Conflux';const CFX_ESPACE_MAINNET_EXPLORER_URL='https://evm.confluxscan.net';const CFX_TESTNET_RPC_ENDPOINT='https://portal-test.confluxrpc.com';const CFX_TESTNET_NAME='Conflux Testnet';const CFX_TESTNET_CHAINID='0x1';const CFX_TESTNET_NETID=1;const CFX_TESTNET_CURRENCY_SYMBOL='CFX';const CFX_TESTNET_CURRENCY_NAME='Conflux';const CFX_TESTNET_EXPLORER_URL='https://testnet.confluxscan.io';const CFX_ESPACE_TESTNET_RPC_ENDPOINT='https://evmtestnet.confluxrpc.com';const CFX_ESPACE_TESTNET_NAME='eSpace Testnet';const CFX_ESPACE_TESTNET_CHAINID='0x47';const CFX_ESPACE_TESTNET_NETID=71;const CFX_ESPACE_TESTNET_CURRENCY_SYMBOL='CFX';const CFX_ESPACE_TESTNET_CURRENCY_NAME='Conflux';const CFX_ESPACE_TESTNET_EXPLORER_URL='https://evmtestnet.confluxscan.net';const ETH_MAINNET_RPC_ENDPOINT='https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161';const ETH_MAINNET_NAME='Ethereum Mainnet';const ETH_MAINNET_CHAINID='0x1';const ETH_MAINNET_NETID=1;const ETH_MAINNET_CURRENCY_SYMBOL='ETH';const ETH_MAINNET_CURRENCY_NAME='Ether';const ETH_MAINNET_EXPLORER_URL='https://etherscan.io';const ETH_ROPSTEN_RPC_ENDPOINT='https://ropsten.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161';const ETH_ROPSTEN_NAME='Ethereum Ropsten';const ETH_ROPSTEN_CHAINID='0x3';const ETH_ROPSTEN_NETID=3;const ETH_ROPSTEN_CURRENCY_SYMBOL='ETH';const ETH_ROPSTEN_CURRENCY_NAME='Ether';const ETH_ROPSTEN_EXPLORER_URL='https://ropsten.etherscan.io';const ETH_RINKEBY_RPC_ENDPOINT='https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161';const ETH_RINKEBY_NAME='Ethereum Rinkeby';const ETH_RINKEBY_CHAINID='0x4';const ETH_RINKEBY_NETID=4;const ETH_RINKEBY_CURRENCY_SYMBOL='ETH';const ETH_RINKEBY_CURRENCY_NAME='Ether';const ETH_RINKEBY_EXPLORER_URL='https://rinkeby.etherscan.io';const ETH_GOERLI_RPC_ENDPOINT='https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161';const ETH_GOERLI_NAME='Ethereum Goerli';const ETH_GOERLI_CHAINID='0x5';const ETH_GOERLI_NETID=5;const ETH_GOERLI_CURRENCY_SYMBOL='ETH';const ETH_GOERLI_CURRENCY_NAME='Ether';const ETH_GOERLI_EXPLORER_URL='https://goerli.etherscan.io';const ETH_KOVAN_RPC_ENDPOINT='https://kovan.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161';const ETH_KOVAN_NAME='Ethereum Kovan';const ETH_KOVAN_CHAINID='0x2a';const ETH_KOVAN_NETID=42;const ETH_KOVAN_CURRENCY_SYMBOL='ETH';const ETH_KOVAN_CURRENCY_NAME='Ether';const ETH_KOVAN_EXPLORER_URL='https://kovan.etherscan.io';const DEFAULT_CFX_HDPATH=`m/44'/503'/0'/0`;const DEFAULT_ETH_HDPATH=`m/44'/60'/0'/0`;const REGENERATE='REGENERATE';const CFX_LOCALNET_RPC_ENDPOINT='http://localhost:12537';const CFX_LOCALNET_NAME='CFX_LOCALNET';const CFX_LOCALNET_CHAINID='0xbb7';const CFX_LOCALNET_NETID=2999;const CFX_LOCALNET_CURRENCY_SYMBOL='CFX';const CFX_LOCALNET_CURRENCY_NAME='CFX';const ETH_LOCALNET_RPC_ENDPOINT='http://localhost:8545';const ETH_LOCALNET_NAME='ETH_LOCALNET';const ETH_LOCALNET_CHAINID='0x539';const ETH_LOCALNET_NETID=1337;const ETH_LOCALNET_CURRENCY_SYMBOL='ETH';const ETH_LOCALNET_CURRENCY_NAME='Ether';// ETH endpoints
const ETH_ENDPOINT={[ETH_MAINNET_NETID]:ETH_MAINNET_RPC_ENDPOINT,[ETH_ROPSTEN_NETID]:ETH_ROPSTEN_RPC_ENDPOINT// Rinkeby: 'https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161',
// Kovan: 'https://kovan.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161',
// Goerli: 'https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161',
};const CFX_SCAN_DOMAINS={[CFX_MAINNET_NETID]:'https://confluxscan.io',[CFX_TESTNET_NETID]:'https://testnet.confluxscan.io'};const ETH_SCAN_DOMAINS={[ETH_MAINNET_NETID]:'https://etherscan.io/',[CFX_TESTNET_NETID]:'https://ropsten.etherscan.io/'};const CFX_SCAN_API_ENDPOINTS={[CFX_MAINNET_NETID]:'https://api.confluxscan.net/',[CFX_TESTNET_NETID]:'https://api-testnet.confluxscan.net/',[CFX_ESPACE_MAINNET_NETID]:'https://evmapi.confluxscan.net/api',[CFX_ESPACE_TESTNET_NETID]:'https://evmapi-testnet.confluxscan.net/api'};const ETH_TX_TYPES={LEGACY:'0x0',EIP2930:'0x1',EIP1559:'0x2'};

/***/ }),

/***/ 58934:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cd": () => (/* binding */ iface),
/* harmony export */   "FU": () => (/* binding */ validateTokenInfo),
/* harmony export */   "ZP": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export ABI */
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64168);
/* harmony import */ var _fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67044);
const ABI=[{inputs:[{internalType:'address',name:'tokenHolder',type:'address'}],name:'balanceOf',outputs:[{internalType:'uint256',name:'',type:'uint256'}],stateMutability:'view',type:'function'},{inputs:[],name:'decimals',outputs:[{internalType:'uint8',name:'',type:'uint8'}],stateMutability:'pure',type:'function'},{inputs:[],name:'name',outputs:[{internalType:'string',name:'',type:'string'}],stateMutability:'view',type:'function'},{inputs:[],name:'symbol',outputs:[{internalType:'string',name:'',type:'string'}],stateMutability:'view',type:'function'},{inputs:[{internalType:'address',name:'recipient',type:'address'},{internalType:'uint256',name:'amount',type:'uint256'}],name:'transfer',outputs:[{internalType:'bool',name:'',type:'bool'}],stateMutability:'nonpayable',type:'function'},{inputs:[{internalType:'address',name:'holder',type:'address'},{internalType:'address',name:'spender',type:'address'}],name:'allowance',outputs:[{internalType:'uint256',name:'',type:'uint256'}],stateMutability:'view',type:'function'},{inputs:[{internalType:'address',name:'spender',type:'address'},{internalType:'uint256',name:'value',type:'uint256'}],name:'approve',outputs:[{internalType:'bool',name:'',type:'bool'}],stateMutability:'nonpayable',type:'function'},{inputs:[],name:'granularity',outputs:[{internalType:'uint256',name:'',type:'uint256'}],stateMutability:'view',type:'function'},{inputs:[{internalType:'address',name:'recipient',type:'address'},{internalType:'uint256',name:'amount',type:'uint256'},{internalType:'bytes',name:'data',type:'bytes'}],name:'send',outputs:[],stateMutability:'nonpayable',type:'function'},{inputs:[{internalType:'address',name:'holder',type:'address'},{internalType:'address',name:'recipient',type:'address'},{internalType:'uint256',name:'amount',type:'uint256'}],name:'transferFrom',outputs:[{internalType:'bool',name:'',type:'bool'}],stateMutability:'nonpayable',type:'function'}];const iface=new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__/* .Interface */ .vU(ABI);const request=(...args)=>{const[methodName,r,to,...rest]=args;if(args.length===2)return (0,_fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_1__/* .partial */ .r)(request,methodName,r);if(args.length===3&&iface.getFunction(methodName).inputs.length>0)return (0,_fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_1__/* .partial */ .r)(request,methodName,r,to);const data=iface.encodeFunctionData(methodName,rest);return r({data,to}).then(res=>{var _res,_res2;if((_res=res)!==null&&_res!==void 0&&_res.jsonrpc&&(_res2=res)!==null&&_res2!==void 0&&_res2.result)res=res.result;const decoded=iface.decodeFunctionResult(methodName,res);return decoded;});};async function validateTokenInfo(...args){const[callMethod,{symbol,name,decimals,address,userAddress}]=args;if(args.length===1)return (0,_fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_1__/* .partial */ .r)(validateTokenInfo,args[0]);let rst={valid:true};try{var _balance$,_balance$$toHexString;const calls=[contractInterface.symbol(callMethod,address),contractInterface.name(callMethod,address),contractInterface.decimals(callMethod,address)];if(userAddress)calls.push(contractInterface.balanceOf(callMethod,address,userAddress));const[[symbolRst],[nameRst],[decimalsRst],balance]=await Promise.all(calls);rst.symbol=symbolRst;if(symbol&&symbolRst!==symbol)rst.valid=false;rst.name=nameRst;if(name&&nameRst!==name)rst.valid=false;rst.decimals=decimalsRst;if(decimals!==undefined&&parseInt(decimalsRst)!==parseInt(decimals))rst.valid=false;if(balance)rst.balance=balance===null||balance===void 0?void 0:(_balance$=balance[0])===null||_balance$===void 0?void 0:(_balance$$toHexString=_balance$.toHexString)===null||_balance$$toHexString===void 0?void 0:_balance$$toHexString.call(_balance$);}catch(err){rst.valid=false;}return rst;}const contractInterface=new Proxy(iface,{get(){const[,methodName]=arguments;const f=iface.getFunction(methodName);if(!f)throw new Error(`Invalid contract method ${methodName}`);return (0,_fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_1__/* .partial */ .r)(request,methodName);}});/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (contractInterface);

/***/ }),

/***/ 80341:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "N": () => (/* reexport */ getCFXContractMethodSignature),
  "A": () => (/* reexport */ getEthContractMethodSignature)
});

// EXTERNAL MODULE: ../../packages/contract-abis/777.js
var _777 = __webpack_require__(58934);
;// CONCATENATED MODULE: ../../packages/contract-method-name/eth-name.js
const getEthContractMethodSignature=async transactionData=>{return _777/* iface.parseTransaction */.cd.parseTransaction({data:transactionData});};
// EXTERNAL MODULE: ../../node_modules/@ethersproject/abi/lib.esm/interface.js + 15 modules
var lib_esm_interface = __webpack_require__(64168);
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
// EXTERNAL MODULE: ../../packages/account/index.js + 16 modules
var account = __webpack_require__(11239);
// EXTERNAL MODULE: ../../packages/confluxscan-api/fetcher.js + 10 modules
var fetcher = __webpack_require__(95895);
// EXTERNAL MODULE: ../../packages/confluxscan-api/utils.js
var utils = __webpack_require__(52093);
;// CONCATENATED MODULE: ../../packages/confluxscan-api/contract.js
async function abi(opts={}){if(!Number.isInteger(opts.networkId))throw new Error('invalid networkId, must be a integer');if((0,utils/* isCoreNetworkId */.v)(opts.networkId))return abiCoreSpace(opts);return abiESpace(opts);}async function abiCoreSpace({networkId=undefined,address=undefined}){try{const res=await (0,fetcher/* fetch */.h)((0,utils/* getURL */.A)(networkId,'contract','/getabi'),{address}).json();if(res.code===0)return JSON.parse(res.data);throw new Error(res.message);}catch(err){return;}}async function abiESpace({networkId=undefined,address=undefined}){try{const res=await (0,fetcher/* fetch */.h)((0,utils/* getURL */.A)(networkId,{module:'contract',action:'getabi',address})).json();if(res.status==='1')return JSON.parse(res.result);throw new Error(res.message);}catch(err){return;}}
;// CONCATENATED MODULE: ../../packages/contract-method-name/cfx-name.js
const eip777AbiSignatures=[// '0x70a08231', // balanceOf
// '0x313ce567', // decimals
// '0x06fdde03', // name
// '0x95d89b41', // symbol
'0xa9059cbb',// transfer
// '0xdd62ed3e', // allowance
'0x095ea7b3',// approve
// '0x556f0dc7', // granularity
'0x9bd9bbc6',// send
'0x23b872dd'// transferFrom
// burn
];const getCFXContractMethodSignature=async(address,transactionData,netId,offlineOnly=false)=>{if(!(0,base32_address/* validateBase32Address */.pd)(address)){throw new Error('invalid base32 address');}try{let abiInterface;if(eip777AbiSignatures.includes(transactionData.substring(0,10))){abiInterface=_777/* iface */.cd;}else if(!offlineOnly){const response=await abi({address,networkId:netId});if(!response)throw new Error('failed to parse transaction data');abiInterface=new lib_esm_interface/* Interface */.vU(response);}else{throw new Error('failed to parse transaction data');}const ret=abiInterface.parseTransaction({data:transactionData});if(ret.args){ret.args=ret.args.map(arg=>(0,account/* isHexAddress */.Cd)(arg)?(0,base32_address/* encode */.cv)(arg.substring(2),netId):arg);}return ret;}catch(e){throw new Error('failed to parse transaction data');}};
;// CONCATENATED MODULE: ../../packages/contract-method-name/index.js


/***/ }),

/***/ 75321:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "zH": () => (/* binding */ chan)
});

// UNUSED EXPORTS: Channel, DroppingBuffer, FixedBuffer, Mult, PubSub, SlidingBuffer, applyTransducer, fromPromise

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/arrays/node_modules/@thi.ng/api/constants.js
const DEFAULT_EPS = 1e-6;
/**
 * Internal use only. **Do NOT use in user land code!**
 *
 * @internal
 */
const SEMAPHORE = Symbol();
/**
 * No-effect placeholder function.
 */
const NO_OP = () => { };
/**
 * Catch-all event ID
 */
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/arrays/node_modules/@thi.ng/api/assert.js

/**
 * Takes a `test` result or predicate function without args and throws
 * error with given `msg` if test failed (i.e. is falsy).
 *
 * @remarks
 * The function is only enabled if `process.env.NODE_ENV != "production"`
 * or if the `UMBRELLA_ASSERTS` env var is set to 1.
 */
const assert = (() => {
    try {
        return ( false ||
            process.env.UMBRELLA_ASSERTS === "1");
    }
    catch (e) { }
    return false;
})()
    ? (test, msg = "assertion failed") => {
        if ((typeof test === "function" && !test()) || !test) {
            throw new Error(typeof msg === "function" ? msg() : msg);
        }
    }
    : NO_OP;

// EXTERNAL MODULE: ../../node_modules/@thi.ng/random/system.js + 1 modules
var system = __webpack_require__(9366);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/arrays/shuffle.js


/**
 * Shuffles the items in the given index range of array `buf` using
 * Fisher-yates and optional `rnd` PRNG.
 *
 * @remarks
 * If neither `start` / `end` are given, the entire array will be
 * shuffled. Mutates original array.
 *
 * See {@link @thi.ng/random#IRandom}
 *
 * @param buf - array
 * @param n - num items
 * @param rnd - PRNG
 */
const shuffleRange = (buf, start = 0, end = buf.length, rnd = system/* SYSTEM */.w) => {
    assert(start >= 0 && end >= start && end <= buf.length, `illegal range ${start}..${end}`);
    let n = end - start;
    const l = n;
    if (l > 1) {
        while (--n >= 0) {
            const a = (start + rnd.float(l)) | 0;
            const b = (start + rnd.float(l)) | 0;
            const t = buf[a];
            buf[a] = buf[b];
            buf[b] = t;
        }
    }
    return buf;
};
/**
 * Applies {@link shuffleRange} to the given array. If `n` is given,
 * only the first `n` items are shuffled. Mutates original array.
 *
 * {@link shuffleRange}
 *
 * @param buf - array
 * @param n - num items
 * @param rnd - PRNG
 */
const shuffle = (buf, n = buf.length, rnd = system/* SYSTEM */.w) => shuffleRange(buf, 0, n, rnd);

// EXTERNAL MODULE: ../../node_modules/@thi.ng/checks/is-function.js
var is_function = __webpack_require__(49040);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/dcons/dcons.js + 3 modules
var dcons = __webpack_require__(80872);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/errors/illegal-arity.js
var illegal_arity = __webpack_require__(83813);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/compose/delayed.js
const delayed = (x, t) => new Promise((resolve) => setTimeout(() => resolve(x), t));

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/map.js
var map = __webpack_require__(84900);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/xform/delayed.js


/**
 * Yields transducer which wraps incoming values in promises, which each
 * resolve after specified delay time (in ms).
 *
 * @remarks
 * Only to be used in async contexts and NOT with {@link (transduce:1)}
 * directly.
 *
 * @param t -
 */
const delayed_delayed = (t) => (0,map/* map */.U)((x) => delayed(x, t));

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/iter/cycle.js
/**
 * Iterator which yields an infinite repetition of given `input`
 * iterable's values. Produces no values if `input` is empty. If `num`
 * is given, only that many cycles will be emitted.
 *
 * @remarks
 * Also see {@link repeat}, {@link repeatedly} for related functions.
 *
 * @example
 * ```ts
 * // take 5 from infinite sequence
 * [...take(5, cycle([1, 2, 3]))]
 * // [1, 2, 3, 1, 2]
 *
 * // only produce 2 cycles
 * [...cycle(range(3), 2)]
 * // [ 0, 1, 2, 0, 1, 2 ]
 * ```
 *
 * @param input -
 * @param num -
 */
function* cycle(input, num = Infinity) {
    if (num < 1)
        return;
    let cache = [];
    for (let i of input) {
        cache.push(i);
        yield i;
    }
    if (cache.length > 0) {
        while (--num > 0) {
            yield* cache;
        }
    }
}

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/reduced.js
var reduced = __webpack_require__(23435);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/iter/range.js

function range(from, to, step) {
    return new Range(from, to, step);
}
/**
 * Simple class wrapper around given range interval and implementing
 * `Iterable` and {@link IReducible} interfaces, the latter is used to
 * accelerate use with {@link (reduce:1)}.
 */
class Range {
    constructor(from, to, step) {
        if (from === undefined) {
            from = 0;
            to = Infinity;
        }
        else if (to === undefined) {
            to = from;
            from = 0;
        }
        step = step === undefined ? (from < to ? 1 : -1) : step;
        this.from = from;
        this.to = to;
        this.step = step;
    }
    *[Symbol.iterator]() {
        let { from, to, step } = this;
        if (step > 0) {
            while (from < to) {
                yield from;
                from += step;
            }
        }
        else if (step < 0) {
            while (from > to) {
                yield from;
                from += step;
            }
        }
    }
    $reduce(rfn, acc) {
        const step = this.step;
        if (step > 0) {
            for (let i = this.from, n = this.to; i < n && !(0,reduced/* isReduced */.Vp)(acc); i += step) {
                acc = rfn(acc, i);
            }
        }
        else {
            for (let i = this.from, n = this.to; i > n && !(0,reduced/* isReduced */.Vp)(acc); i += step) {
                acc = rfn(acc, i);
            }
        }
        return acc;
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/csp/buffer.js

class FixedBuffer {
    constructor(limit = 1) {
        this.buf = new dcons/* DCons */.K5();
        this.limit = limit;
    }
    get length() {
        return this.buf.length;
    }
    isEmpty() {
        return this.buf.length === 0;
    }
    isFull() {
        return this.buf.length >= this.limit;
    }
    release() {
        return this.buf.release();
    }
    push(x) {
        if (!this.isFull()) {
            this.buf.push(x);
            return true;
        }
        return false;
    }
    drop() {
        if (!this.isEmpty()) {
            return this.buf.drop();
        }
    }
}
class DroppingBuffer extends (/* unused pure expression or super */ null && (FixedBuffer)) {
    constructor(limit = 1) {
        super(limit);
    }
    isFull() {
        return false;
    }
    push(x) {
        if (this.buf.length < this.limit) {
            this.buf.push(x);
        }
        return true;
    }
}
class SlidingBuffer extends (/* unused pure expression or super */ null && (FixedBuffer)) {
    constructor(limit = 1) {
        super(limit);
    }
    isFull() {
        return false;
    }
    push(x) {
        if (this.buf.length >= this.limit) {
            this.buf.drop();
        }
        this.buf.push(x);
        return true;
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/csp/channel.js






class channel_Channel {
    constructor(...args) {
        let id, buf, tx, err;
        let [a, b] = args;
        switch (args.length) {
            case 0:
                break;
            case 1:
                if (typeof a === "string") {
                    id = a;
                }
                else if (maybeBuffer(a)) {
                    buf = a;
                }
                else {
                    tx = a;
                }
                break;
            case 2:
                if (typeof a === "string") {
                    id = a;
                    if (maybeBuffer(b)) {
                        buf = b;
                    }
                    else {
                        tx = b;
                    }
                }
                else {
                    [tx, err] = args;
                }
                break;
            case 3:
                if ((0,is_function/* isFunction */.m)(args[1]) && (0,is_function/* isFunction */.m)(args[2])) {
                    [id, tx, err] = args;
                }
                else {
                    [id, buf, tx] = args;
                }
                break;
            case 4:
                [id, buf, tx, err] = args;
                break;
            default:
                (0,illegal_arity/* illegalArity */.N)(args.length);
        }
        this.id = id || `chan-${channel_Channel.NEXT_ID++}`;
        buf = buf || 1;
        this.buf = typeof buf === "number" ? new FixedBuffer(buf) : buf;
        this.writes = new dcons/* DCons */.K5();
        this.reads = new dcons/* DCons */.K5();
        this.txbuf = new dcons/* DCons */.K5();
        this.tx = tx ? tx(channel_Channel.RFN) : null;
        this.onerror = tx && (err || defaultErrorHandler);
        this.state = 0 /* OPEN */;
        this.isBusy = false;
    }
    static constantly(x, delay) {
        const chan = new channel_Channel(delay ? delayed_delayed(delay) : null);
        chan.produce(() => x);
        return chan;
    }
    static repeatedly(fn, delay) {
        const chan = new channel_Channel(delay ? delayed_delayed(delay) : null);
        chan.produce(fn);
        return chan;
    }
    static cycle(src, delay) {
        return channel_Channel.from(cycle(src), delay ? delayed_delayed(delay) : null);
    }
    static range(...args) {
        const [from, to, step, delay] = args;
        return channel_Channel.from(range(from, to, step), delay !== undefined ? delayed_delayed(delay) : null);
    }
    /**
     * Constructs new channel which closes automatically after given period.
     *
     * @param delay - time in ms
     */
    static timeout(delay) {
        const chan = new channel_Channel(`timeout-${channel_Channel.NEXT_ID++}`);
        setTimeout(() => chan.close(), delay);
        return chan;
    }
    /**
     * Shorthand for: `Channel.timeout(delay).take()`
     *
     * @param delay - time in ms
     */
    static sleep(delay) {
        return channel_Channel.timeout(delay).read();
    }
    /**
     * Creates new channel with single value from given promise, then closes
     * automatically iff promise has been resolved.
     *
     * @param p - promise
     */
    static fromPromise(p) {
        const chan = new channel_Channel();
        p.then((x) => (async () => {
            await chan.write(x);
            await chan.close();
            return x;
        })());
        return chan;
    }
    static from(...args) {
        let close, tx;
        switch (args.length) {
            case 1:
                break;
            case 2:
                if (typeof args[1] === "boolean") {
                    close = args[1];
                }
                else {
                    tx = args[1];
                }
                break;
            case 3:
                tx = args[1];
                close = args[2];
                break;
            default:
                (0,illegal_arity/* illegalArity */.N)(args.length);
        }
        const chan = new channel_Channel(tx);
        chan.into(args[0], close);
        return chan;
    }
    /**
     * Takes an array of channels and blocks until any of them becomes
     * readable (or has been closed). The returned promised resolves into
     * an array of `[value, channel]`. Channel order is repeatedly
     * shuffled for each read attempt.
     *
     * @param chans - source channels
     */
    static select(chans) {
        return new Promise((resolve) => {
            const _select = () => {
                for (let c of shuffle(chans)) {
                    if (c.isReadable() || c.isClosed()) {
                        c.read().then((x) => resolve([x, c]));
                        return;
                    }
                }
                channel_Channel.SCHEDULE.call(null, _select, 0);
            };
            channel_Channel.SCHEDULE.call(null, _select, 0);
        });
    }
    /**
     * Takes an array of channels to merge into new channel. Any closed
     * channels will be automatically removed from the input selection.
     * Once all inputs are closed, the target channel will close too (by
     * default).
     *
     * @remarks
     * If `named` is true, the merged channel will have tuples of:
     * `[src-id, val]` If false (default), only received values will be
     * forwarded.
     *
     * @param chans - source channels
     * @param out - result channel
     * @param close - true, if result closes
     * @param named - true, to emit labeled tuples
     */
    static merge(chans, out, close = true, named = false) {
        out = out || new channel_Channel();
        (async () => {
            while (true) {
                let [x, ch] = await channel_Channel.select(chans);
                if (x === undefined) {
                    chans.splice(chans.indexOf(ch), 1);
                    if (!chans.length) {
                        close && (await out.close());
                        break;
                    }
                }
                else {
                    await out.write(named ? [ch.id, x] : x);
                }
            }
        })();
        return out;
    }
    /**
     * Takes an array of channels to merge into new channel of tuples.
     * Whereas `Channel.merge()` realizes a sequential merging with no
     * guarantees about ordering of the output.
     *
     * @remarks
     * The output channel of this function will collect values from all
     * channels and a new tuple is emitted only once a new value has
     * been read from ALL channels. Therefore the overall throughput is
     * dictated by the slowest of the inputs.
     *
     * Once any of the inputs closes, the process is terminated and the
     * output channel is closed too (by default).
     *
     * @example
     * ```ts
     * Channel.mergeTuples([
     *   Channel.from([1, 2, 3]),
     *   Channel.from([10, 20, 30]),
     *   Channel.from([100, 200, 300])
     * ]).consume();
     *
     * // chan-0 : [ 1, 10, 100 ]
     * // chan-0 : [ 2, 20, 200 ]
     * // chan-0 : [ 3, 30, 300 ]
     * // chan-0 done
     *
     * Channel.mergeTuples([
     *   Channel.from([1, 2, 3]),
     *   Channel.from([10, 20, 30]),
     *   Channel.from([100, 200, 300])
     * ], null, false).consume();
     * ```
     *
     * @param chans - source channels
     * @param out - result channel
     * @param closeOnFirst - true, if result closes when first input is done
     * @param closeOutput - true, if result closes when all inputs are done
     */
    static mergeTuples(chans, out, closeOnFirst = true, closeOutput = true) {
        out = out || new channel_Channel();
        (async () => {
            let buf = [];
            let orig = [...chans];
            let sel = new Set(chans);
            let n = chans.length;
            while (true) {
                let [x, ch] = await channel_Channel.select([...sel]);
                let idx = orig.indexOf(ch);
                if (x === undefined) {
                    if (closeOnFirst || chans.length === 1) {
                        break;
                    }
                    chans.splice(idx, 1);
                }
                buf[idx] = x;
                sel.delete(ch);
                if (--n === 0) {
                    await out.write(buf);
                    buf = [];
                    n = chans.length;
                    sel = new Set(chans);
                }
            }
            closeOutput && (await out.close());
        })();
        return out;
    }
    channel() {
        return this;
    }
    write(value) {
        return new Promise((resolve) => {
            if (this.state !== 0 /* OPEN */) {
                resolve(false);
            }
            if (this.writes.length < channel_Channel.MAX_WRITES) {
                this.writes.push({
                    value: this.tx
                        ? async () => {
                            try {
                                if ((0,reduced/* isReduced */.Vp)(this.tx[2](this.txbuf, value))) {
                                    this.state = 1 /* CLOSED */;
                                }
                            }
                            catch (e) {
                                this.onerror(e, this, value);
                            }
                        }
                        : () => value,
                    resolve,
                });
                this.process();
            }
            else {
                throw new Error(`channel stalled (${channel_Channel.MAX_WRITES} unprocessed writes)`);
            }
        });
    }
    read() {
        return new Promise((resolve) => {
            if (this.state === 2 /* DONE */) {
                resolve(undefined);
            }
            this.reads.push(resolve);
            this.process();
        });
    }
    tryRead(timeout = 1000) {
        return new Promise((resolve) => {
            (async () => resolve((await channel_Channel.select([this, channel_Channel.timeout(timeout)]))[0]))();
        });
    }
    close(flush = false) {
        if (this.state === 0 /* OPEN */) {
            this.state = 1 /* CLOSED */;
            flush && this.flush();
            return this.process();
        }
    }
    isClosed() {
        return this.state !== 0 /* OPEN */;
    }
    isReadable() {
        return ((this.state !== 2 /* DONE */ && this.buf && this.buf.length > 0) ||
            (this.writes && this.writes.length > 0) ||
            (this.txbuf && this.txbuf.length > 0));
    }
    consume(fn = (x) => console.log(this.id, ":", x)) {
        return (async () => {
            let x;
            while (((x = null), (x = await this.read())) !== undefined) {
                await fn(x);
            }
        })();
    }
    produce(fn, close = true) {
        return (async () => {
            while (!this.isClosed()) {
                const val = await fn();
                if (val === undefined) {
                    close && (await this.close());
                    break;
                }
                await this.write(val);
            }
        })();
    }
    consumeWhileReadable(fn = (x) => console.log(this.id, ":", x)) {
        return (async () => {
            let x;
            while (this.isReadable()) {
                x = await this.read();
                if (x === undefined) {
                    break;
                }
                await fn(x);
                x = null;
            }
        })();
    }
    reduce(rfn, acc) {
        return (async () => {
            const [init, complete, reduce] = rfn;
            acc = acc != null ? acc : init();
            let x;
            while (((x = null), (x = await this.read())) !== undefined) {
                acc = reduce(acc, x);
                if ((0,reduced/* isReduced */.Vp)(acc)) {
                    acc = acc.deref();
                    break;
                }
            }
            return (0,reduced/* unreduced */.Hw)(complete(acc));
        })();
    }
    transduce(tx, rfn, acc) {
        return (async () => {
            const _rfn = tx(rfn);
            return (0,reduced/* unreduced */.Hw)(_rfn[1](await this.reduce(_rfn, acc)));
        })();
    }
    into(src, close = true) {
        return (async () => {
            for (let x of src) {
                if (this.isClosed()) {
                    break;
                }
                await this.write(x);
            }
            close && (await this.close());
        })();
    }
    pipe(dest, close = true) {
        if (!(dest instanceof channel_Channel)) {
            dest = new channel_Channel(dest);
        }
        this.consume((x) => dest.write(x)) // return undefined here?
            .then(() => {
            close && dest.close();
        });
        return dest;
    }
    split(pred, truthy, falsey, close = true) {
        if (!(truthy instanceof channel_Channel)) {
            truthy = new channel_Channel();
        }
        if (!(falsey instanceof channel_Channel)) {
            falsey = new channel_Channel();
        }
        this.consume((x) => (pred(x) ? truthy : falsey).write(x)).then(() => {
            close && (truthy.close(), falsey.close());
        });
        return [truthy, falsey];
    }
    concat(chans, close = true) {
        return (async () => {
            for (let c of chans) {
                await c.consume((x) => this.write(x));
            }
            close && (await this.close());
        })();
    }
    release() {
        if (this.state === 1 /* CLOSED */) {
            this.state = 2 /* DONE */;
            this.flush();
            this.buf.release();
            delete this.reads;
            delete this.writes;
            delete this.buf;
            delete this.txbuf;
            delete this.tx;
            delete this.isBusy;
            delete this.onerror;
        }
    }
    async process() {
        if (!this.isBusy) {
            this.isBusy = true;
            const { buf, txbuf, reads, writes } = this;
            let doProcess = true;
            while (doProcess) {
                while (reads.length && (txbuf.length || buf.length)) {
                    if (txbuf.length) {
                        const val = txbuf.drop();
                        if (val !== undefined) {
                            reads.drop()(val);
                        }
                    }
                    else {
                        const val = await buf.drop().value();
                        if (val !== undefined) {
                            reads.drop()(val);
                        }
                    }
                }
                while (writes.length && !buf.isFull()) {
                    const put = writes.drop();
                    buf.push(put);
                    put.resolve(true);
                }
                if (this.state === 1 /* CLOSED */) {
                    if (this.tx && !writes.length) {
                        try {
                            // finalize/complete transducer
                            this.tx[1](this.txbuf);
                        }
                        catch (e) {
                            this.onerror(e, this);
                        }
                    }
                    if (!this.isReadable()) {
                        this.release();
                        return;
                    }
                }
                doProcess =
                    (reads.length && (txbuf.length || buf.length)) ||
                        (writes.length && !buf.isFull());
            }
            this.isBusy = false;
        }
    }
    flush() {
        let op;
        while ((op = this.reads.drop())) {
            op();
        }
        while ((op = this.writes.drop())) {
            op.resolve(false);
        }
        this.buf.release();
    }
}
channel_Channel.MAX_WRITES = 1024;
channel_Channel.NEXT_ID = 0;
channel_Channel.SCHEDULE = typeof setImmediate === "function" ? setImmediate : setTimeout;
channel_Channel.RFN = [
    (() => null),
    (acc) => acc,
    (acc, x) => acc.push(x),
];
const defaultErrorHandler = (e, chan, val) => console.log(chan.id, "error occurred", e.message, val !== undefined ? val : "");
const maybeBuffer = (x) => x instanceof FixedBuffer || typeof x === "number";

// EXTERNAL MODULE: ../../packages/checks/index.js + 3 modules
var checks = __webpack_require__(34577);
;// CONCATENATED MODULE: ../../packages/csp/index.js
/**
 * @fileOverview csp for helios
 * @name index.js
 */function chan(){return new channel_Channel(...arguments);}const fromPromise=channel_Channel.fromPromise;const applyTransducer=(c,tx,onerror)=>{c.tx=tx(Channel.RFN);if(isFunction(onerror))c.onerror=onerror;return c;};

/***/ }),

/***/ 11719:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__({map,ethHexAddress,Hash32,Uint,Byte,Bytes,and,eq,chainId,catn,optionalMapKey}){const AccessEntrySpec=[map,{closed:true},['address',{optional:true},ethHexAddress],['storageKeys',{optional:true},[catn,['32BtyeHexValue',Hash32]]]];const AccessListSpec=[catn,['AccessListEntry',AccessEntrySpec]];const TxMapSpecs={from:['from',ethHexAddress],type:['type',{doc:'EIP 2718 Type'},Byte],nonce:['nonce',Uint],to:['to',{doc:'Only optional when creating contract'},ethHexAddress],gas:['gas',{doc:'gas limit'},Uint],gasLimit:['gasLimit',{doc:'gas limit, same as the "gas" key'},Uint],gasPrice:['gasPrice',{doc:'gas price'},Uint],value:['value',Uint],data:['data',{doc:'input data'},Bytes],maxPriorityFeePerGas:['maxPriorityFeePerGas',Uint],maxFeePerGas:['maxFeePerGas',Uint],accessList:['accessList',AccessListSpec],chainId:['chainId',chainId]};// EIP-2930
const Transaction2930Unsigned=[map,{closed:true},TxMapSpecs.from,[TxMapSpecs.type[0],optionalMapKey(TxMapSpecs.type)[1],[and,TxMapSpecs.type[2],[eq,'0x1']]],optionalMapKey(TxMapSpecs.nonce),optionalMapKey(TxMapSpecs.to),optionalMapKey(TxMapSpecs.gas),optionalMapKey(TxMapSpecs.gasLimit),optionalMapKey(TxMapSpecs.value),optionalMapKey(TxMapSpecs.data),optionalMapKey(TxMapSpecs.gasPrice),optionalMapKey(TxMapSpecs.accessList),optionalMapKey(TxMapSpecs.chainId)];// EIP-1559
const Transaction1559Unsigned=[map,{closed:true},TxMapSpecs.from,[TxMapSpecs.type[0],optionalMapKey(TxMapSpecs.type)[1],[and,TxMapSpecs.type[2],[eq,'0x2']]],optionalMapKey(TxMapSpecs.nonce),optionalMapKey(TxMapSpecs.to),optionalMapKey(TxMapSpecs.gas),optionalMapKey(TxMapSpecs.gasLimit),optionalMapKey(TxMapSpecs.value),optionalMapKey(TxMapSpecs.data),optionalMapKey(TxMapSpecs.maxPriorityFeePerGas),optionalMapKey(TxMapSpecs.maxFeePerGas),optionalMapKey(TxMapSpecs.accessList),optionalMapKey(TxMapSpecs.chainId),optionalMapKey(TxMapSpecs.gasPrice)//actually no gasPrice params for EIP-1559 transaction,but sometimes, the dapp developer will pass this param
];// EIP-155
const TransactionLegacyUnsigned=[map,{closed:true},TxMapSpecs.from,[TxMapSpecs.type[0],optionalMapKey(TxMapSpecs.type)[1],[and,TxMapSpecs.type[2],[eq,'0x0']]],optionalMapKey(TxMapSpecs.nonce),optionalMapKey(TxMapSpecs.to),optionalMapKey(TxMapSpecs.gas),optionalMapKey(TxMapSpecs.gasLimit),optionalMapKey(TxMapSpecs.value),optionalMapKey(TxMapSpecs.data),optionalMapKey(TxMapSpecs.gasPrice),optionalMapKey(TxMapSpecs.chainId)];return{AccessEntrySpec,AccessListSpec,TxMapSpecs,Transaction2930Unsigned,Transaction1559Unsigned,TransactionLegacyUnsigned};}

/***/ }),

/***/ 32299:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mu": () => (/* binding */ randomHDPath),
/* harmony export */   "BQ": () => (/* binding */ validateHDPath),
/* harmony export */   "Zr": () => (/* binding */ getNthAccountOfHDKey)
/* harmony export */ });
/* unused harmony exports generateMnemonic, defHDKey */
/* harmony import */ var _fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11818);
/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71173);
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62191);
const DEFAULT_HD_PATH=`m/44'/503'/0'/0`;const generateMnemonic=()=>(0,_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_1__/* .entropyToMnemonic */ .JJ)((0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_2__/* .randomBytes */ .O)(16));const defHDKey=mnemonic=>{const hdnode=_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_1__/* .HDNode.fromMnemonic */ .m$.fromMnemonic(mnemonic);return hdnode;};function randomHDPathIndex(){return (0,_fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_0__/* .randomInt */ .Iy)(0x80000000);}const randomHDPath=()=>{return`m/44'/${randomHDPathIndex()}'/${randomHDPathIndex()}'/${(0,_fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_0__/* .randomInt */ .Iy)(randomHDPathIndex())}`;};const validateHDPath=hdPath=>{let valid=true;try{const paths=hdPath.split('/');valid=valid&&paths.length===5&&paths[0]==='m'&&paths[1]==="44'"&&paths[2].endsWith("'")&&paths[3].endsWith("'");valid=valid&&Boolean(_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_1__/* .HDNode.fromMnemonic */ .m$.fromMnemonic(generateMnemonic()).derivePath(paths.join('/')));}catch(err){valid=false;}return valid;};const getNthAccountOfHDKey=async({mnemonic,hdPath=DEFAULT_HD_PATH,nth,// start from 0
only0x1Prefixed=false})=>{const k=defHDKey(mnemonic);const paths=hdPath.split('/');const result={};let count=0,idx=0;while(count<=nth){await new Promise(resolve=>setTimeout(resolve,1));paths[5]=idx++;const newNode=k.derivePath(paths.join('/'));result.address=newNode.address.toLowerCase();result.privateKey=newNode.privateKey;if(only0x1Prefixed&&result.address.startsWith('0x1'))count++;if(!only0x1Prefixed)count++;}result.index=idx-1;return result;};

/***/ }),

/***/ 83799:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "t5": () => (/* reexport */ Conflux),
  "kJ": () => (/* reexport */ Ethereum),
  "vH": () => (/* reexport */ const_namespaceObject)
});

// NAMESPACE OBJECT: ../../packages/ledger/const.js
var const_namespaceObject = {};
__webpack_require__.r(const_namespaceObject);
__webpack_require__.d(const_namespaceObject, {
  "pn": () => (ERROR),
  "XJ": () => (HDPATH),
  "N5": () => (INS),
  "wB": () => (LEDGER_APP_NAME),
  "VP": () => (LEDGER_CLA),
  "hq": () => (LEDGER_DEVICE),
  "CD": () => (LEDGER_NANOS_NAME),
  "Qx": () => (LEDGER_NANOX_NAME)
});

// EXTERNAL MODULE: ../../node_modules/@docusaurus/core/node_modules/@babel/runtime/helpers/esm/interopRequireWildcard.js
var interopRequireWildcard = __webpack_require__(65370);
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(82361);
var external_events_default = /*#__PURE__*/__webpack_require__.n(external_events_);
// EXTERNAL MODULE: ../../node_modules/@ledgerhq/errors/lib-es/index.js + 1 modules
var lib_es = __webpack_require__(9341);
;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/hw-transport-webusb/node_modules/@ledgerhq/hw-transport/lib-es/Transport.js
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};



/**
 * Transport defines the generic interface to share between node/u2f impl
 * A **Descriptor** is a parametric type that is up to be determined for the implementation.
 * it can be for instance an ID, an file path, a URL,...
 */
var Transport = /** @class */ (function () {
    function Transport() {
        var _this = this;
        this.exchangeTimeout = 30000;
        this.unresponsiveTimeout = 15000;
        this.deviceModel = null;
        this._events = new (external_events_default())();
        /**
         * wrapper on top of exchange to simplify work of the implementation.
         * @param cla
         * @param ins
         * @param p1
         * @param p2
         * @param data
         * @param statusList is a list of accepted status code (shorts). [0x9000] by default
         * @return a Promise of response buffer
         */
        this.send = function (cla, ins, p1, p2, data, statusList) {
            if (data === void 0) { data = Buffer.alloc(0); }
            if (statusList === void 0) { statusList = [lib_es.StatusCodes.OK]; }
            return __awaiter(_this, void 0, void 0, function () {
                var response, sw;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (data.length >= 256) {
                                throw new lib_es.TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
                            }
                            return [4 /*yield*/, this.exchange(Buffer.concat([
                                    Buffer.from([cla, ins, p1, p2]),
                                    Buffer.from([data.length]),
                                    data,
                                ]))];
                        case 1:
                            response = _a.sent();
                            sw = response.readUInt16BE(response.length - 2);
                            if (!statusList.some(function (s) { return s === sw; })) {
                                throw new lib_es.TransportStatusError(sw);
                            }
                            return [2 /*return*/, response];
                    }
                });
            });
        };
        this.exchangeAtomicImpl = function (f) { return __awaiter(_this, void 0, void 0, function () {
            var resolveBusy, busyPromise, unresponsiveReached, timeout, res;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.exchangeBusyPromise) {
                            throw new lib_es.TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
                        }
                        busyPromise = new Promise(function (r) {
                            resolveBusy = r;
                        });
                        this.exchangeBusyPromise = busyPromise;
                        unresponsiveReached = false;
                        timeout = setTimeout(function () {
                            unresponsiveReached = true;
                            _this.emit("unresponsive");
                        }, this.unresponsiveTimeout);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, f()];
                    case 2:
                        res = _a.sent();
                        if (unresponsiveReached) {
                            this.emit("responsive");
                        }
                        return [2 /*return*/, res];
                    case 3:
                        clearTimeout(timeout);
                        if (resolveBusy)
                            resolveBusy();
                        this.exchangeBusyPromise = null;
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        this._appAPIlock = null;
    }
    /**
     * low level api to communicate with the device
     * This method is for implementations to implement but should not be directly called.
     * Instead, the recommanded way is to use send() method
     * @param apdu the data to send
     * @return a Promise of response data
     */
    Transport.prototype.exchange = function (_apdu) {
        throw new Error("exchange not implemented");
    };
    /**
     * set the "scramble key" for the next exchanges with the device.
     * Each App can have a different scramble key and they internally will set it at instanciation.
     * @param key the scramble key
     */
    Transport.prototype.setScrambleKey = function (_key) { };
    /**
     * close the exchange with the device.
     * @return a Promise that ends when the transport is closed.
     */
    Transport.prototype.close = function () {
        return Promise.resolve();
    };
    /**
     * Listen to an event on an instance of transport.
     * Transport implementation can have specific events. Here is the common events:
     * * `"disconnect"` : triggered if Transport is disconnected
     */
    Transport.prototype.on = function (eventName, cb) {
        this._events.on(eventName, cb);
    };
    /**
     * Stop listening to an event on an instance of transport.
     */
    Transport.prototype.off = function (eventName, cb) {
        this._events.removeListener(eventName, cb);
    };
    Transport.prototype.emit = function (event) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this._events).emit.apply(_a, __spreadArray([event], __read(args), false));
    };
    /**
     * Enable or not logs of the binary exchange
     */
    Transport.prototype.setDebugMode = function () {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    };
    /**
     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
     */
    Transport.prototype.setExchangeTimeout = function (exchangeTimeout) {
        this.exchangeTimeout = exchangeTimeout;
    };
    /**
     * Define the delay before emitting "unresponsive" on an exchange that does not respond
     */
    Transport.prototype.setExchangeUnresponsiveTimeout = function (unresponsiveTimeout) {
        this.unresponsiveTimeout = unresponsiveTimeout;
    };
    /**
     * create() allows to open the first descriptor available or
     * throw if there is none or if timeout is reached.
     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
     * @example
    TransportFoo.create().then(transport => ...)
     */
    Transport.create = function (openTimeout, listenTimeout) {
        var _this = this;
        if (openTimeout === void 0) { openTimeout = 3000; }
        return new Promise(function (resolve, reject) {
            var found = false;
            var sub = _this.listen({
                next: function (e) {
                    found = true;
                    if (sub)
                        sub.unsubscribe();
                    if (listenTimeoutId)
                        clearTimeout(listenTimeoutId);
                    _this.open(e.descriptor, openTimeout).then(resolve, reject);
                },
                error: function (e) {
                    if (listenTimeoutId)
                        clearTimeout(listenTimeoutId);
                    reject(e);
                },
                complete: function () {
                    if (listenTimeoutId)
                        clearTimeout(listenTimeoutId);
                    if (!found) {
                        reject(new lib_es.TransportError(_this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
                    }
                }
            });
            var listenTimeoutId = listenTimeout
                ? setTimeout(function () {
                    sub.unsubscribe();
                    reject(new lib_es.TransportError(_this.ErrorMessage_ListenTimeout, "ListenTimeout"));
                }, listenTimeout)
                : null;
        });
    };
    Transport.prototype.decorateAppAPIMethods = function (self, methods, scrambleKey) {
        var e_1, _a;
        try {
            for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {
                var methodName = methods_1_1.value;
                self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (methods_1_1 && !methods_1_1.done && (_a = methods_1["return"])) _a.call(methods_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Transport.prototype.decorateAppAPIMethod = function (methodName, f, ctx, scrambleKey) {
        var _this = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(_this, void 0, void 0, function () {
                var _appAPIlock;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _appAPIlock = this._appAPIlock;
                            if (_appAPIlock) {
                                return [2 /*return*/, Promise.reject(new lib_es.TransportError("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"))];
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 3, 4]);
                            this._appAPIlock = methodName;
                            this.setScrambleKey(scrambleKey);
                            return [4 /*yield*/, f.apply(ctx, args)];
                        case 2: return [2 /*return*/, _a.sent()];
                        case 3:
                            this._appAPIlock = null;
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
    };
    Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
    Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";
    return Transport;
}());
/* harmony default export */ const lib_es_Transport = (Transport);
//# sourceMappingURL=Transport.js.map
// EXTERNAL MODULE: ../../node_modules/@ledgerhq/devices/lib/hid-framing.js
var hid_framing = __webpack_require__(15842);
// EXTERNAL MODULE: ../../node_modules/semver/index.js
var semver = __webpack_require__(97699);
var semver_default = /*#__PURE__*/__webpack_require__.n(semver);
;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/devices/lib-es/index.js
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var _a;

/**
 * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)
 *
 ** Model
 * Ledger Nano S : 0x10
 * Ledger Blue : 0x00
 * Ledger Nano X : 0x40
 *
 ** Interface support bitfield
 * Generic HID : 0x01
 * Keyboard HID : 0x02
 * U2F : 0x04
 * CCID : 0x08
 * WebUSB : 0x10
 */
var IIGenericHID = 0x01;
var IIKeyboardHID = 0x02;
var IIU2F = 0x04;
var IICCID = 0x08;
var IIWebUSB = 0x10;
var DeviceModelId;
(function (DeviceModelId) {
    DeviceModelId["blue"] = "blue";
    DeviceModelId["nanoS"] = "nanoS";
    DeviceModelId["nanoSP"] = "nanoSP";
    DeviceModelId["nanoX"] = "nanoX";
})(DeviceModelId || (DeviceModelId = {}));
var devices = (_a = {},
    _a[DeviceModelId.blue] = {
        id: DeviceModelId.blue,
        productName: "LedgerBlue",
        productIdMM: 0x00,
        legacyUsbProductId: 0x0000,
        usbOnly: true,
        memorySize: 480 * 1024,
        masks: [0x31000000, 0x31010000],
        getBlockSize: function (_firwareVersion) { return 4 * 1024; }
    },
    _a[DeviceModelId.nanoS] = {
        id: DeviceModelId.nanoS,
        productName: "LedgerNanoS",
        productIdMM: 0x10,
        legacyUsbProductId: 0x0001,
        usbOnly: true,
        memorySize: 320 * 1024,
        masks: [0x31100000],
        getBlockSize: function (firmwareVersion) {
            var _a;
            return semver_default().lt((_a = semver_default().coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : "", "2.0.0")
                ? 4 * 1024
                : 2 * 1024;
        }
    },
    _a[DeviceModelId.nanoSP] = {
        id: DeviceModelId.nanoSP,
        productName: "Ledger Nano SP",
        productIdMM: 0x50,
        legacyUsbProductId: 0x0005,
        usbOnly: true,
        memorySize: 1533 * 1024,
        masks: [0x33100000],
        getBlockSize: function (_firmwareVersion) { return 32; }
    },
    _a[DeviceModelId.nanoX] = {
        id: DeviceModelId.nanoX,
        productName: "LedgerNanoX",
        productIdMM: 0x40,
        legacyUsbProductId: 0x0004,
        usbOnly: false,
        memorySize: 2 * 1024 * 1024,
        masks: [0x33000000],
        getBlockSize: function (_firwareVersion) { return 4 * 1024; },
        bluetoothSpec: [
            {
                // this is the legacy one (prototype version). we will eventually drop it.
                serviceUuid: "d973f2e0-b19e-11e2-9e96-0800200c9a66",
                notifyUuid: "d973f2e1-b19e-11e2-9e96-0800200c9a66",
                writeUuid: "d973f2e2-b19e-11e2-9e96-0800200c9a66",
                writeCmdUuid: "d973f2e3-b19e-11e2-9e96-0800200c9a66"
            },
            {
                serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
            },
        ]
    },
    _a);
var productMap = {
    Blue: DeviceModelId.blue,
    "Nano S": DeviceModelId.nanoS,
    "Nano X": DeviceModelId.nanoX
};
var devicesList = Object.values(devices);
/**
 *
 */
var ledgerUSBVendorId = 0x2c97;
/**
 *
 */
var getDeviceModel = function (id) {
    var info = devices[id];
    if (!info)
        throw new Error("device '" + id + "' does not exist");
    return info;
};
/**
 * Given a `targetId`, return the deviceModel associated to it,
 * based on the first two bytes.
 */
var identifyTargetId = function (targetId) {
    var deviceModel = devicesList.find(function (_a) {
        var masks = _a.masks;
        return masks.find(function (mask) { return (targetId & 0xffff0000) === mask; });
    });
    return deviceModel;
};
/**
 *
 */
var identifyUSBProductId = function (usbProductId) {
    var legacy = devicesList.find(function (d) { return d.legacyUsbProductId === usbProductId; });
    if (legacy)
        return legacy;
    var mm = usbProductId >> 8;
    var deviceModel = devicesList.find(function (d) { return d.productIdMM === mm; });
    return deviceModel;
};
var identifyProductName = function (productName) {
    var productId = productMap[productName];
    if (!productId && productName.startsWith("Nano S")) {
        productId = DeviceModelId.nanoSP;
    }
    var deviceModel = devicesList.find(function (d) { return d.id === productId; });
    return deviceModel;
};
var bluetoothServices = [];
var serviceUuidToInfos = {};
for (var id in devices) {
    var deviceModel = devices[id];
    var bluetoothSpec = deviceModel.bluetoothSpec;
    if (bluetoothSpec) {
        for (var i = 0; i < bluetoothSpec.length; i++) {
            var spec = bluetoothSpec[i];
            bluetoothServices.push(spec.serviceUuid);
            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = __assign({ deviceModel: deviceModel }, spec);
        }
    }
}
/**
 *
 */
var getBluetoothServiceUuids = function () { return bluetoothServices; };
/**
 *
 */
var getInfosForServiceUuid = function (uuid) { return serviceUuidToInfos[uuid.toLowerCase()]; };
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/logs/lib-es/index.js
var lib_es_id = 0;
var subscribers = [];
/**
 * log something
 * @param type a namespaced identifier of the log (it is not a level like "debug", "error" but more like "apdu-in", "apdu-out", etc...)
 * @param message a clear message of the log associated to the type
 */
var log = function (type, message, data) {
    var obj = {
        type: type,
        id: String(++lib_es_id),
        date: new Date()
    };
    if (message)
        obj.message = message;
    if (data)
        obj.data = data;
    dispatch(obj);
};
/**
 * listen to logs.
 * @param cb that is called for each future log() with the Log object
 * @return a function that can be called to unsubscribe the listener
 */
var listen = function (cb) {
    subscribers.push(cb);
    return function () {
        var i = subscribers.indexOf(cb);
        if (i !== -1) {
            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952
            subscribers[i] = subscribers[subscribers.length - 1];
            subscribers.pop();
        }
    };
};
function dispatch(log) {
    for (var i = 0; i < subscribers.length; i++) {
        try {
            subscribers[i](log);
        }
        catch (e) {
            console.error(e);
        }
    }
}
if (typeof window !== "undefined") {
    window.__ledgerLogsListen = listen;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js
var webusb_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var webusb_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var ledgerDevices = [
    {
        vendorId: ledgerUSBVendorId
    },
];
function requestLedgerDevice() {
    return webusb_awaiter(this, void 0, void 0, function () {
        var device;
        return webusb_generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, navigator.usb.requestDevice({
                        filters: ledgerDevices
                    })];
                case 1:
                    device = _a.sent();
                    return [2 /*return*/, device];
            }
        });
    });
}
function getLedgerDevices() {
    return webusb_awaiter(this, void 0, void 0, function () {
        var devices;
        return webusb_generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, navigator.usb.getDevices()];
                case 1:
                    devices = _a.sent();
                    return [2 /*return*/, devices.filter(function (d) { return d.vendorId === ledgerUSBVendorId; })];
            }
        });
    });
}
function getFirstLedgerDevice() {
    return webusb_awaiter(this, void 0, void 0, function () {
        var existingDevices;
        return webusb_generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getLedgerDevices()];
                case 1:
                    existingDevices = _a.sent();
                    if (existingDevices.length > 0)
                        return [2 /*return*/, existingDevices[0]];
                    return [2 /*return*/, requestLedgerDevice()];
            }
        });
    });
}
var isSupported = function () {
    return Promise.resolve(!!navigator &&
        !!navigator.usb &&
        typeof navigator.usb.getDevices === "function");
};
//# sourceMappingURL=webusb.js.map
;// CONCATENATED MODULE: ../../node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js
/* provided dependency */ var TransportWebUSB_Buffer = __webpack_require__(14300)["Buffer"];
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TransportWebUSB_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var TransportWebUSB_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};






var configurationValue = 1;
var endpointNumber = 3;
/**
 * WebUSB Transport implementation
 * @example
 * import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
 * ...
 * TransportWebUSB.create().then(transport => ...)
 */
var TransportWebUSB = /** @class */ (function (_super) {
    __extends(TransportWebUSB, _super);
    function TransportWebUSB(device, interfaceNumber) {
        var _this = _super.call(this) || this;
        _this.channel = Math.floor(Math.random() * 0xffff);
        _this.packetSize = 64;
        _this._disconnectEmitted = false;
        _this._emitDisconnect = function (e) {
            if (_this._disconnectEmitted)
                return;
            _this._disconnectEmitted = true;
            _this.emit("disconnect", e);
        };
        _this.device = device;
        _this.interfaceNumber = interfaceNumber;
        _this.deviceModel = identifyUSBProductId(device.productId);
        return _this;
    }
    /**
     * Similar to create() except it will always display the device permission (even if some devices are already accepted).
     */
    TransportWebUSB.request = function () {
        return TransportWebUSB_awaiter(this, void 0, void 0, function () {
            var device;
            return TransportWebUSB_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, requestLedgerDevice()];
                    case 1:
                        device = _a.sent();
                        return [2 /*return*/, TransportWebUSB.open(device)];
                }
            });
        });
    };
    /**
     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
     */
    TransportWebUSB.openConnected = function () {
        return TransportWebUSB_awaiter(this, void 0, void 0, function () {
            var devices;
            return TransportWebUSB_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getLedgerDevices()];
                    case 1:
                        devices = _a.sent();
                        if (devices.length === 0)
                            return [2 /*return*/, null];
                        return [2 /*return*/, TransportWebUSB.open(devices[0])];
                }
            });
        });
    };
    /**
     * Create a Ledger transport with a USBDevice
     */
    TransportWebUSB.open = function (device) {
        return TransportWebUSB_awaiter(this, void 0, void 0, function () {
            var iface, interfaceNumber, e_1, transport, onDisconnect;
            return TransportWebUSB_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, device.open()];
                    case 1:
                        _a.sent();
                        if (!(device.configuration === null)) return [3 /*break*/, 3];
                        return [4 /*yield*/, device.selectConfiguration(configurationValue)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, gracefullyResetDevice(device)];
                    case 4:
                        _a.sent();
                        iface = device.configurations[0].interfaces.find(function (_a) {
                            var alternates = _a.alternates;
                            return alternates.some(function (a) { return a.interfaceClass === 255; });
                        });
                        if (!iface) {
                            throw new lib_es.TransportInterfaceNotAvailable("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
                        }
                        interfaceNumber = iface.interfaceNumber;
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 9]);
                        return [4 /*yield*/, device.claimInterface(interfaceNumber)];
                    case 6:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 7:
                        e_1 = _a.sent();
                        return [4 /*yield*/, device.close()];
                    case 8:
                        _a.sent();
                        throw new lib_es.TransportInterfaceNotAvailable(e_1.message);
                    case 9:
                        transport = new TransportWebUSB(device, interfaceNumber);
                        onDisconnect = function (e) {
                            if (device === e.device) {
                                // $FlowFixMe
                                navigator.usb.removeEventListener("disconnect", onDisconnect);
                                transport._emitDisconnect(new lib_es.DisconnectedDevice());
                            }
                        };
                        // $FlowFixMe
                        navigator.usb.addEventListener("disconnect", onDisconnect);
                        return [2 /*return*/, transport];
                }
            });
        });
    };
    /**
     * Release the transport device
     */
    TransportWebUSB.prototype.close = function () {
        return TransportWebUSB_awaiter(this, void 0, void 0, function () {
            return TransportWebUSB_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.exchangeBusyPromise];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.device.releaseInterface(this.interfaceNumber)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, gracefullyResetDevice(this.device)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.device.close()];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */
    TransportWebUSB.prototype.exchange = function (apdu) {
        return TransportWebUSB_awaiter(this, void 0, void 0, function () {
            var b;
            var _this = this;
            return TransportWebUSB_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.exchangeAtomicImpl(function () { return TransportWebUSB_awaiter(_this, void 0, void 0, function () {
                            var _a, channel, packetSize, framing, blocks, i, result, acc, r, buffer;
                            return TransportWebUSB_generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = this, channel = _a.channel, packetSize = _a.packetSize;
                                        log("apdu", "=> " + apdu.toString("hex"));
                                        framing = (0,hid_framing/* default */.Z)(channel, packetSize);
                                        blocks = framing.makeBlocks(apdu);
                                        i = 0;
                                        _b.label = 1;
                                    case 1:
                                        if (!(i < blocks.length)) return [3 /*break*/, 4];
                                        return [4 /*yield*/, this.device.transferOut(endpointNumber, blocks[i])];
                                    case 2:
                                        _b.sent();
                                        _b.label = 3;
                                    case 3:
                                        i++;
                                        return [3 /*break*/, 1];
                                    case 4:
                                        if (!!(result = framing.getReducedResult(acc))) return [3 /*break*/, 6];
                                        return [4 /*yield*/, this.device.transferIn(endpointNumber, packetSize)];
                                    case 5:
                                        r = _b.sent();
                                        buffer = TransportWebUSB_Buffer.from(r.data.buffer);
                                        acc = framing.reduceResponse(acc, buffer);
                                        return [3 /*break*/, 4];
                                    case 6:
                                        log("apdu", "<= " + result.toString("hex"));
                                        return [2 /*return*/, result];
                                }
                            });
                        }); })["catch"](function (e) {
                            if (e && e.message && e.message.includes("disconnected")) {
                                _this._emitDisconnect(e);
                                throw new lib_es.DisconnectedDeviceDuringOperation(e.message);
                            }
                            throw e;
                        })];
                    case 1:
                        b = _a.sent();
                        return [2 /*return*/, b];
                }
            });
        });
    };
    TransportWebUSB.prototype.setScrambleKey = function () { };
    /**
     * Check if WebUSB transport is supported.
     */
    TransportWebUSB.isSupported = isSupported;
    /**
     * List the WebUSB devices that was previously authorized by the user.
     */
    TransportWebUSB.list = getLedgerDevices;
    /**
     * Actively listen to WebUSB devices and emit ONE device
     * that was either accepted before, if not it will trigger the native permission UI.
     *
     * Important: it must be called in the context of a UI click!
     */
    TransportWebUSB.listen = function (observer) {
        var unsubscribed = false;
        getFirstLedgerDevice().then(function (device) {
            if (!unsubscribed) {
                var deviceModel = identifyUSBProductId(device.productId);
                observer.next({
                    type: "add",
                    descriptor: device,
                    deviceModel: deviceModel
                });
                observer.complete();
            }
        }, function (error) {
            if (window.DOMException &&
                error instanceof window.DOMException &&
                error.code === 18) {
                observer.error(new lib_es.TransportWebUSBGestureRequired(error.message));
            }
            else {
                observer.error(new lib_es.TransportOpenUserCancelled(error.message));
            }
        });
        function unsubscribe() {
            unsubscribed = true;
        }
        return {
            unsubscribe: unsubscribe
        };
    };
    return TransportWebUSB;
}(lib_es_Transport));
/* harmony default export */ const lib_es_TransportWebUSB = (TransportWebUSB);
function gracefullyResetDevice(device) {
    return TransportWebUSB_awaiter(this, void 0, void 0, function () {
        var err_1;
        return TransportWebUSB_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, device.reset()];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    err_1 = _a.sent();
                    console.warn(err_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
//# sourceMappingURL=TransportWebUSB.js.map
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
;// CONCATENATED MODULE: ../../packages/ledger/const.js
const LEDGER_APP_NAME={CONFLUX:'Conflux',ETHEREUM:'Ethereum',ESPACE:'Conflux eSpace'};/**
 * https://developer.mozilla.org/en-US/docs/Web/API/USBDevice/productID
 * Attention: as the doc said, the productId can identify a USB device.
 * But, the productId I get when I open different app using a same NanoS device is different,
 * for example, the productId is 4113 when I open Conflux App,the productId is 4117 when I open Ethereum App.
 */const LEDGER_NANOS_ID=4113;const LEDGER_NANOX_ID=16401;const LEDGER_NANOS_PRODUCT_NAME='Nano S';const LEDGER_NANOX_PRODUCT_NAME='Nano X';const LEDGER_NANOS_NAME='LedgerNanoS';const LEDGER_NANOX_NAME='LedgerNanoX';const LEDGER_DEVICE={[LEDGER_NANOS_PRODUCT_NAME]:{NAME:LEDGER_NANOS_NAME,PRODUCT_NAME:'Nano S',VERDOR_ID:'0x2c97'//11415
},[LEDGER_NANOX_PRODUCT_NAME]:{NAME:LEDGER_NANOX_NAME,PRODUCT_NAME:'Nano X',VERDOR_ID:'0x2c97'//11415
}};const LEDGER_CLA=0xe0;const INS={OPEN_APP:0xd8};const HDPATH={CONFLUX:"44'/503'/0'/0/",ETHEREUM:"44'/60'/0'/0/"};const ERROR={INVALID_CHANNEL:{ID:'InvalidChannel',CODE:'5031'//means that the channel is busy, user should interact with this func a moment later
}};
;// CONCATENATED MODULE: ../../packages/ledger/conflux.js
/* provided dependency */ var conflux_Buffer = __webpack_require__(14300)["Buffer"];
/**
 * Connecting Ledger Conflux App API for fluent
 *
 * @example
 * import {Conflux} from "@fluent-wallet/ledger";
 * const cfx = new Conflux()
 * cfx.getAddress("44'/503'/0'/0/0").then(o => o.publicKey)
 */class Conflux{app=null;transport=null;constuctor(){this.app=null;this.transport=null;}async setApp(){if(!this.app){try{this.transport=await lib_es_TransportWebUSB.create();const App=await Promise.resolve().then(()=>(0,interopRequireWildcard/* default */.Z)(require('@fluent-wallet/hw-app-conflux')));this.app=new App.default(this.transport);}catch(error){console.warn(error);}}}/**
   * get address from ledger
   * @param {*} hdPath
   * @returns
   */async getAddress(hdPath){var _this$app;await this.setApp();return(_this$app=this.app)===null||_this$app===void 0?void 0:_this$app.getAddress(hdPath);}/**
   * sign transaction
   * @param {*} hdPath
   * @param {*} txHex
   * @returns
   */async signTransaction(hdPath,txHex){await this.setApp();try{var _this$app2;const res=await((_this$app2=this.app)===null||_this$app2===void 0?void 0:_this$app2.signTransaction(hdPath,txHex));return res;}catch(error){return Promise.reject(this.handleTheError(error));}finally{await this.cleanUp();}}/**
   * get configuration of ledger app
   * @returns
   */async getAppConfiguration(){var _this$app3;await this.setApp();return(_this$app3=this.app)===null||_this$app3===void 0?void 0:_this$app3.getAppConfiguration();}/**
   * sign personal message
   * @param {*} hdPath the hd path
   * @param {*} messageHex hex string of message
   * @returns Promise
   */async signPersonalMessage(hdPath,messageHex){await this.setApp();try{var _this$app4;return(_this$app4=this.app)===null||_this$app4===void 0?void 0:_this$app4.signPersonalMessage(hdPath,messageHex);}catch(error){return Promise.reject(error);}}async isDeviceAuthed(){const devices=await lib_es_TransportWebUSB.list();return Boolean(devices.length);}async isAppOpen(){try{const isAuthed=await this.isDeviceAuthed();if(!isAuthed)return false;const{name}=await this.getAppConfiguration();return name===LEDGER_APP_NAME.CONFLUX;}catch(error){return false;}finally{await this.cleanUp();}}async openApp(){try{var _this$transport;await((_this$transport=this.transport)===null||_this$transport===void 0?void 0:_this$transport.send(LEDGER_CLA,INS.OPEN_APP,0x00,0x00,conflux_Buffer.from(LEDGER_APP_NAME.CONFLUX,'ascii')));return true;}catch(error){return false;}}/**
   * auth the USBDevice
   * @returns boolean, means that whether user has already authed this hardware
   */async requestAuth(){try{await(lib_es_TransportWebUSB===null||lib_es_TransportWebUSB===void 0?void 0:lib_es_TransportWebUSB.request());return true;}catch(error){return false;}}async getAddressList(indexArray){if(!Array.isArray(indexArray))return[];const isNumber=indexArray.every(function(item){return typeof item==='number';});if(!isNumber)return[];const addressArr=[];try{for(const index of indexArray){const hdPath=`${HDPATH.CONFLUX}${index}`;const{address}=await this.getAddress(hdPath);const{hexAddress}=(0,base32_address/* decode */.Jx)(address);addressArr.push({address:hexAddress,hdPath});}}catch(error){return Promise.reject(this.handleTheError(error));}return addressArr;}async getDeviceInfo(){const devices=await lib_es_TransportWebUSB.list();if(devices.length>0){var _LEDGER_DEVICE$device;const device=devices[0];return{name:(_LEDGER_DEVICE$device=LEDGER_DEVICE[device===null||device===void 0?void 0:device.productName])===null||_LEDGER_DEVICE$device===void 0?void 0:_LEDGER_DEVICE$device.NAME,productId:device===null||device===void 0?void 0:device.productId,productName:device===null||device===void 0?void 0:device.productName};}return{};}/**
   * Close the transport when finish using it
   */async cleanUp(){this.app=null;if(this.transport)await this.transport.close();this.transport=null;}handleTheError(error){var _error$message;if((error===null||error===void 0?void 0:error.id)===ERROR.INVALID_CHANNEL.ID){error.appCode=ERROR.INVALID_CHANNEL.CODE;}if(error!==null&&error!==void 0&&(_error$message=error.message)!==null&&_error$message!==void 0&&_error$message.includes('UNKNOWN_ERROR')){var _error$statusCode;error.message=`Ledger connection error, please make sure the Ledger device is unlocked and open the Conflux App, and reopen this page. ${error!==null&&error!==void 0&&error.statusCode?'(0x'+(error===null||error===void 0?void 0:(_error$statusCode=error.statusCode)===null||_error$statusCode===void 0?void 0:_error$statusCode.toString(16))+')':''}`;}return error;}}
;// CONCATENATED MODULE: ../../packages/ledger/ethereum.js
/* provided dependency */ var ethereum_Buffer = __webpack_require__(14300)["Buffer"];
/**
 * Connecting Ledger Ethereum App API for fluent
 *
 * @example
 * import {Ethereum} from "@fluent-wallet/ledger";
 * const eth = new Ethereum()
 * eth.getAddress("44'/60'/0'/0/0").then(o => o.publicKey)
 */class Ethereum{app=null;transport=null;constuctor(){this.app=null;this.transport=null;}async setApp(){if(!this.app){try{this.transport=await lib_es_TransportWebUSB.create();const App=await Promise.resolve().then(()=>(0,interopRequireWildcard/* default */.Z)(require('@ledgerhq/hw-app-eth')));this.app=new App.default(this.transport);}catch(error){console.warn(error);}}}/**
   * get address from ledger
   * @param {*} hdPath
   * @returns
   */async getAddress(hdPath,boolAddress,boolChainCode){var _this$app;await this.setApp();return(_this$app=this.app)===null||_this$app===void 0?void 0:_this$app.getAddress(hdPath,boolAddress,boolChainCode);}/**
   * sign transaction
   * @param {*} hdPath
   * @param {*} txHex
   * @returns
   */async signTransaction(hdPath,txHex){await this.setApp();try{var _this$app2;const res=await((_this$app2=this.app)===null||_this$app2===void 0?void 0:_this$app2.signTransaction(hdPath,txHex));return res;}catch(error){return Promise.reject(this.handleTheError(error));}finally{await this.cleanUp();}}/**
   * get configuration of ledger app
   * @returns
   */async getAppConfiguration(){await this.setApp();const r=await this.transport.send(0xb0,0x01,0x00,0x00);let i=0;const format=r[i++];if(format!==1){throw new Error('getAppAndVersion: format not supported');}const nameLength=r[i++];const name=r.slice(i,i+=nameLength).toString('ascii');const versionLength=r[i++];const version=r.slice(i,i+=versionLength).toString('ascii');const flagLength=r[i++];const flags=r.slice(i,i+=flagLength);return{name,version,flags};}/**
   * sign personal message
   * @param {*} hdPath the hd path
   * @param {*} messageHex hex string of message
   * @returns Promise
   */async signPersonalMessage(hdPath,messageHex){await this.setApp();try{var _this$app3;return(_this$app3=this.app)===null||_this$app3===void 0?void 0:_this$app3.signPersonalMessage(hdPath,messageHex);}catch(error){return Promise.reject(error);}}async isDeviceAuthed(){const devices=await lib_es_TransportWebUSB.list();return Boolean(devices.length);}/**
   * whether the ledger app for the evm-based or ethereum chain is open
   * You can sign the transaction in the evm-based chain with the evm-based app or the ethereum app
   * @param {String} chainName:'CONFLUX','ETHEREUM','ESPACE'
   * @returns boolean
   */async isAppOpen(chainName){try{const isAuthed=await this.isDeviceAuthed();if(!isAuthed)return false;const config=await this.getAppConfiguration();const name=(config===null||config===void 0?void 0:config.name)||'';return name===LEDGER_APP_NAME[chainName]||name===LEDGER_APP_NAME.ETHEREUM;}catch(error){return false;}finally{await this.cleanUp();}}/**
   *
   * @param {String} ledgerAppName: the name of the ledger app  which you want to open
   * @returns boolean
   */async openApp(ledgerAppName){try{var _this$transport;await((_this$transport=this.transport)===null||_this$transport===void 0?void 0:_this$transport.send(LEDGER_CLA,INS.OPEN_APP,0x00,0x00,ethereum_Buffer.from(ledgerAppName||LEDGER_APP_NAME.ETHEREUM,'ascii')));return true;}catch(error){return false;}}/**
   * auth the USBDevice
   * @returns boolean, means that whether user has already authed this hardware
   */async requestAuth(){try{await(lib_es_TransportWebUSB===null||lib_es_TransportWebUSB===void 0?void 0:lib_es_TransportWebUSB.request());return true;}catch(error){return false;}}async getAddressList(indexArray){if(!Array.isArray(indexArray))return[];const isNumber=indexArray.every(function(item){return typeof item==='number';});if(!isNumber)return[];const addressArr=[];try{for(const index of indexArray){const hdPath=`${HDPATH.ETHEREUM}${index}`;const{address}=await this.getAddress(hdPath);addressArr.push({address,hdPath});}}catch(error){return Promise.reject(this.handleTheError(error));}return addressArr;}async getDeviceInfo(){const devices=await lib_es_TransportWebUSB.list();if(devices.length>0){var _LEDGER_DEVICE$device;const device=devices[0];return{name:(_LEDGER_DEVICE$device=LEDGER_DEVICE[device===null||device===void 0?void 0:device.productName])===null||_LEDGER_DEVICE$device===void 0?void 0:_LEDGER_DEVICE$device.NAME,productId:device===null||device===void 0?void 0:device.productId,productName:device===null||device===void 0?void 0:device.productName};}return{};}/**
   * Close the transport when finish using it
   */async cleanUp(){this.app=null;if(this.transport)await this.transport.close();this.transport=null;}handleTheError(error){var _error$message;if((error===null||error===void 0?void 0:error.id)===ERROR.INVALID_CHANNEL.ID){error.appCode=ERROR.INVALID_CHANNEL.CODE;}if(error!==null&&error!==void 0&&(_error$message=error.message)!==null&&_error$message!==void 0&&_error$message.includes('UNKNOWN_ERROR')){var _error$statusCode;error.message=`Ledger connection error, please make sure the Ledger device is unlocked and open the Ethereum App, and reopen this page. ${error!==null&&error!==void 0&&error.statusCode?'(0x'+(error===null||error===void 0?void 0:(_error$statusCode=error.statusCode)===null||_error$statusCode===void 0?void 0:_error$statusCode.toString(16))+')':''}`;}return error;}}
;// CONCATENATED MODULE: ../../packages/ledger/index.js


/***/ }),

/***/ 51343:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_accounts'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['chainId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.chainId]], _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  db: ['getLocked', 'findAddress', 'getOneNetwork'],
}

const main = async ({
  db: {getLocked, findAddress, getOneNetwork},
  app,
  network,
  _inpage,
  params,
}) => {
  if (getLocked()) return []
  if (_inpage && !app) return []

  if (
    app &&
    app.perms.wallet_crossNetworkTypeGetConfluxBase32Address &&
    getOneNetwork({selected: true}).type !== 'cfx'
  ) {
    const addr = findAddress({
      accountId: app.currentAccount.eid,
      networkId: getOneNetwork({
        type: 'cfx',
        chainId: params?.chainId || '0x405',
      }).eid,
      g: {value: 1},
    })
    if (addr) return [addr.value]
    else return []
  }

  const addrs = findAddress({
    appId: app?.eid,
    networkId: app ? app.currentNetwork.eid : network.eid,
    g: {value: 1},
  })

  if (app) {
    return [addrs.value]
  }

  return addrs.map(({value}) => value)
}


/***/ }),

/***/ 41223:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_call'

const cache = {
  type: 'epoch',
  key: ({params}) => {
    const req = params[0]
    return `${NAME}${JSON.stringify(req)}`
  },
}

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      ['from', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress],
      ['to', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress],
      ['storageLimit', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['gasPrice', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['gas', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['value', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['data', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes],
      ['nonce', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
    ],
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRef,
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 76026:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_chainId'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  db: ['getOneNetwork'],
  locked: true,
  methods: ['cfx_getStatus'],
}

const cache = {
  type: 'ttl',
  ttl: 24 * 60 * 60 * 1000, // 1 day
  key: () => NAME,
  afterGet(_, c) {
    return c ?? 'nocache'
  },
}

const main = async ({
  f,
  db: {getOneNetwork},
  rpcs: {cfx_getStatus},
  _inpage,
  app,
}) => {
  if (
    _inpage &&
    ((app && app.currentNetwork.type === 'eth') ||
      getOneNetwork({selected: true}).type === 'eth')
  ) {
    return '0x' + Number.MAX_SAFE_INTEGER.toString(16)
  }

  const rst = await f()
  if (!rst?.result || rst.result === 'nocache')
    return (await cfx_getStatus())?.chainId
  return rst.result
}


/***/ }),

/***/ 63689:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_checkBalanceAgainstTransaction'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress,
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress,
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint, // gas
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint, // gasPrice
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint, // storageLimit
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined,
  ],
}

const cache = {
  type: 'epoch',
  key: ({params}) =>
    `${NAME}${params[0]}${params[1]}${params[2]}${params[3]}${params[4]}`,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 38820:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_clientVersion'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 50320:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_epochNumber'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochTag], _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nul],
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const cache = {
  type: 'ttl',
  key: ({params}) => `EPOCH${params[0]}`,
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 87021:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_estimateGasAndCollateral'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      [
        'from',
        {optional: true, doc: 'default to random address'},
        _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress,
      ],
      [
        'to',
        {optional: true, doc: 'default to null for contract crateion'},
        _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address,
      ],
      ['chainId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.chainId],
      ['gas', {optional: true, doc: 'default to 0x1dcd6500(500000000)'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['gasPrice', {optional: true, doc: 'default to 0x0'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['value', {optional: true, doc: 'default to 0x0'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['data', {optional: true, doc: 'default to 0x'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes],
      ['nonce', {optional: true, doc: 'default to 0x0'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['storageLimit', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
      ['epochHeight', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
    ],
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined,
  ],
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${JSON.stringify(params[0])}`,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 59068:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9414);



const NAME = 'cfx_gasPrice'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'ttl',
  key: () => NAME,
}

async function gasStationFastest(gasPrice) {
  gasPrice = gasPrice || '0x0'
  if (typeof window?.fetch === 'function') {
    const res = await fetch('https://main.confluxrpc.com/', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        id: 1,
        jsonrpc: '2.0',
        method: 'gasstation_price',
        params: [],
      }),
    }).then(res => res.json())
    if (res && res.result) {
      if (res.result.fastest > gasPrice) {
        gasPrice = res.result.fastest
      }
    } else {
      gasPrice = '0x3b9aca00'
    }
  } else {
    gasPrice = '0x3b9aca00'
  }

  return gasPrice
}

const main = async ({network, f, MODE}) => {
  if (network.name === _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__/* .CFX_MAINNET_NAME */ .ae && !MODE.isTest) {
    return await gasStationFastest()
  }
  return await f()
}


/***/ }),

/***/ 79121:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getAccount'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 89173:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getAccountPendingInfo'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 54724:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getAccountPendingTransactions'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress,
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne, {doc: 'Optional start nonce to return'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne,
      {doc: 'Optional limit of pending transactions to return'},
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint,
    ],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 35904:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getAccumulateInterestRate'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: () => NAME,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 43925:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getAdmin'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 87067:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBalance'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 87161:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBestBlockHash'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: () => NAME,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 91197:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBlockByBlockNumber'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, {doc: 'epoch tag or block number'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochTag, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean,
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 45222:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBlockByEpochNumber'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRef, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[1]}${params[2]}`,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 41212:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBlockByHash'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}${params[1]}`,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 50038:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBlockByHashWithPivotAssumption'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 27172:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBlockRewardInfo'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'latest_checkpoint'], _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 55805:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getBlocksByEpoch'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRef],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: () => NAME,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 98611:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getCode'

const cache = {
  type: 'epoch',
  ttl: 3600,
  key: ({params}) => `${NAME}${params[0]}`,
}

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 82803:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getCollateralForStorage'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 30364:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getConfirmationRiskByHash'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 68613:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getDepositList'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 15237:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getInterestRate'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 70919:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getLogs'

const topicUnitSchema = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nul, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32]
const topicSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
  topicUnitSchema,
  [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.repeat, {min: 1, max: 3}, topicUnitSchema],
]

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      ['fromEpoch', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
      ['toEpoch', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
      ['blockHashes', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.repeat, {min: 0, max: 128}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32]],
      ['address', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.repeat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress]],
      ['topics', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.repeat, {min: 0, max: 4}, topicSchema]],
      ['limit', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
    ],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  if (!params.fromEpoch) params.toEpoch = 'latest_checkpoint'
  if (!params.toEpoch) params.toEpoch = 'latest_state'
  return f(params)
}


/***/ }),

/***/ 31423:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10528);



const NAME = 'cfx_getMaxGasLimit'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_getBestBlockHash', 'cfx_getBlockByHash'],
}

const main = ({rpcs: {cfx_getBestBlockHash, cfx_getBlockByHash}}) => {
  return cfx_getBestBlockHash()
    .then(hash => cfx_getBlockByHash([hash, false]))
    .then(block => block.gasLimit)
    .then(gasLimit => _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__/* .BigNumber.from */ .O$.from(gasLimit).div(2).toHexString())
}


/***/ }),

/***/ 45343:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getNextNonce'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 10826:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getNextUsableNonce'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_getNextNonce', 'txpool_nextNonce'],
}

const main = async ({
  rpcs: {cfx_getNextNonce, txpool_nextNonce},
  params,
}) => {
  try {
    return await txpool_nextNonce({errorFallThrough: true}, params)
  } catch (err) {
    return await cfx_getNextNonce({errorFallThrough: true}, params)
  }
}


/***/ }),

/***/ 97253:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getPoSEconomics'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 52896:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getPoSRewardByEpoch'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 27942:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getSkippedBlocksByEpoch'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 72746:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getSponsorInfo'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 99162:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getStakingBalance'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 57148:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getStatus'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const ONE_DAY_MS = 24 * 60 * 60 * 1000
const chainIdCacheConf = {type: 'ttl', ttl: ONE_DAY_MS, key: 'cfx_chainId'}
const networkIdCacheConf = {type: 'ttl', ttl: ONE_DAY_MS, key: 'cfx_netVersion'}
const cache = {
  type: 'ttl',
  key: () => `${NAME}`,
  afterSet(setCache, req, res) {
    if (!res?.result) return
    setCache({req, res: {result: res.result.chainId}, conf: chainIdCacheConf})
    setCache({
      req,
      res: {result: parseInt(res.result.networkId, 16).toString(10)},
      conf: networkIdCacheConf,
    })
  },
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f}) => {
  return await f()
}


/***/ }),

/***/ 36089:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getStorageAt'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 21244:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getStorageRoot'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 84066:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getSupplyInfo'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 73530:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getTransactionByHash'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32],
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 66911:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getTransactionReceipt'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32],
}

const cache = {
  type: 'epoch',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 96101:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_getVoteList'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRefNoMined],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 7260:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_netVersion'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_getStatus'],
}

const cache = {
  type: 'ttl',
  ttl: 24 * 60 * 60 * 1000,
  key: () => NAME,
  afterGet(_, c) {
    return c ?? 'nocache'
  },
}

const main = async ({f, rpcs: {cfx_getStatus}}) => {
  const rst = await f()
  if (!rst?.result || rst?.result === 'nocache')
    return parseInt((await cfx_getStatus())?.networkId, 16).toString()
  else return rst.result
}


/***/ }),

/***/ 46221:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_openedMethodGroups'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 65834:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_requestAccounts'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['inpage'],
  methods: ['wallet_requestPermissions', 'cfx_accounts'],
  db: ['getOneApp'],
  scope: null,
}

const main = async ({
  db: {getOneApp},
  rpcs: {wallet_requestPermissions, cfx_accounts},
  site,
  app,
}) => {
  if (app) {
    return await cfx_accounts()
  }
  const permissionsToRequest = {
    cfx_accounts: {},
    wallet_crossNetworkTypeGetConfluxBase32Address: {},
  }
  const permsRes = await wallet_requestPermissions([permissionsToRequest])

  if (permsRes && !permsRes.error) {
    const newapp = getOneApp({site: site.eid})
    const addrs = await cfx_accounts({app: newapp}, [])

    return addrs
  }

  return []
}


/***/ }),

/***/ 56309:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'cfx_sendRawTransaction'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes],
}

const permissions = {
  locked: true,
  external: [],
  methods: [],
  db: [],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 78762:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_cfx_sign_transaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46681);



const NAME = 'cfx_sendTransaction'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_cfx_sign_transaction__WEBPACK_IMPORTED_MODULE_1__.txSchema],
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['tx', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_cfx_sign_transaction__WEBPACK_IMPORTED_MODULE_1__.txSchema]]],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  methods: ['wallet_sendTransaction'],
  db: [],
}

const main = ({
  rpcs: {wallet_sendTransaction},
  params,
  _inpage,
  _popup,
  _internal,
}) => {
  return wallet_sendTransaction({_inpage, _popup, _internal}, params)
}


/***/ }),

/***/ 46681:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "txSchema": () => (/* binding */ txSchema),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52206);
/* harmony import */ var _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83799);




const NAME = 'cfx_signTransaction'

const txSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['from', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress],
  ['to', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address],
  ['value', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
  ['nonce', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
  ['data', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes],
  ['gas', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
  ['gasLimit', {doc: 'gas limit, same as the "gas" key', optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
  ['gasPrice', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
  ['storageLimit', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
  ['chainId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.chainId],
  ['epochHeight', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
]

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    txSchema,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne,
      [
        _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
        {closed: true},
        ['epoch', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.epochRef],
        ['returnTxMeta', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
        ['dryRun', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
      ],
    ],
  ],
}

const permissions = {
  external: [],
  methods: [
    'cfx_gasPrice',
    'cfx_signTxWithLedgerNanoS',
    'wallet_getAddressPrivateKey',
    'cfx_getNextUsableNonce',
    'cfx_epochNumber',
    'cfx_estimateGasAndCollateral',
    'wallet_detectAddressType',
  ],
  db: ['findAddress'],
}

const main = async args => {
  const {
    app,
    Err: {InvalidParams},
    db: {findAddress},
    rpcs: {
      wallet_getAddressPrivateKey,
      cfx_epochNumber,
      cfx_gasPrice,
      cfx_estimateGasAndCollateral,
      cfx_getNextUsableNonce,
      wallet_detectAddressType,
    },
    params: [tx, opts = {}],
    network,
    _popup,
  } = args
  if (tx.chainId && tx.chainId !== network.chainId)
    throw InvalidParams(`Invalid chainId ${tx.chainId}`)

  const {epoch, returnTxMeta, dryRun} = opts
  tx.from = tx.from.toLowerCase()
  if (tx.to) tx.to = tx.to.toLowerCase()
  const newTx = {...tx}

  const fromAddr = findAddress({
    appId: app && app.eid,
    selected: _popup && !app ? true : undefined,
    value: newTx.from,
    g: {
      eid: 1,
      _account: {eid: 1, _accountGroup: {vault: {type: 1, device: 1}}},
    },
  })
  // from address is not belong to wallet
  if (!fromAddr) throw InvalidParams(`Invalid from address ${newTx.from}`)

  // tx without to must have data (deploy contract)
  if (!newTx.to && !newTx.data)
    throw InvalidParams(
      `Invalid tx, [to] and [data] can't be omit at the same time`,
    )

  if (!newTx.chainId) newTx.chainId = network.chainId
  if (newTx.data === '0x') newTx.data = undefined

  if (!newTx.value) newTx.value = '0x0'

  if (!newTx.epochHeight)
    newTx.epochHeight = await cfx_epochNumber({errorFallThrough: true}, [
      'latest_state',
    ])

  if (!newTx.nonce) {
    newTx.nonce = await cfx_getNextUsableNonce({errorFallThrough: true}, [
      newTx.from,
    ])
  }

  if (newTx.to && (!newTx.gas || !newTx.storageLimit)) {
    const {type} = await wallet_detectAddressType(
      {errorFallThrough: true},
      {address: newTx.to},
    )
    if (type !== 'contract' && !newTx.data) {
      if (!newTx.gas) newTx.gas = '0x5208'
      if (!newTx.storageLimit) newTx.storageLimit = '0x0'
    }
  }

  if (!newTx.gasPrice) newTx.gasPrice = await cfx_gasPrice()

  if (!newTx.gas || !newTx.storageLimit) {
    try {
      const {gasLimit, storageCollateralized} =
        await cfx_estimateGasAndCollateral({errorFallThrough: true}, [
          newTx,
          epoch,
        ])
      if (!newTx.gas) newTx.gas = gasLimit
      if (!newTx.storageLimit) newTx.storageLimit = storageCollateralized
    } catch (err) {
      err.data = {originalData: err.data, estimateError: true}
      throw err
    }
  }

  let raw
  if (fromAddr.account.accountGroup.vault.type === 'hw') {
    if (dryRun) {
      raw = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__/* .cfxSignTransaction */ .sA)(
        newTx,
        '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
        network.netId,
      )
    } else {
      raw = await signWithHardwareWallet({
        args,
        accountId: fromAddr.account.eid,
        tx: newTx,
        addressId: fromAddr.eid,
        device: fromAddr.account.accountGroup.vault.device,
      })
    }
  } else {
    let pk = await wallet_getAddressPrivateKey({
      address: newTx.from,
      accountId: fromAddr.account.eid,
    })

    if (dryRun)
      pk = '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
    raw = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__/* .cfxSignTransaction */ .sA)(newTx, pk, network.netId)
  }

  if (returnTxMeta) {
    return {txMeta: newTx, raw}
  }

  return raw
}

async function signWithHardwareWallet({
  args: {
    rpcs: {cfx_signTxWithLedgerNanoS},
  },
  tx,
  addressId,
  device,
  accountId,
}) {
  const hwSignMap = {
    [_fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOS_NAME */ .vH.CD]: cfx_signTxWithLedgerNanoS,
    [_fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOX_NAME */ .vH.Qx]: cfx_signTxWithLedgerNanoS,
  }
  const signMethod = hwSignMap[device]
  return await signMethod({errorFallThrough: true}, {tx, addressId, accountId})
}


/***/ }),

/***/ 59582:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83799);
/* harmony import */ var _fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52206);





const NAME = 'cfx_signTxWithLedgerNanoS'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['tx', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp],
    ['addressId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ],
}

const permissions = {
  external: [],
  methods: [],
  db: ['findAddress', 'getPassword'],
}

function getLedgerHDPathFromAddressAndGroupData(groupData, hex) {
  return groupData[hex]
}

const main = async ({
  Err: {InvalidParams, UserRejected},
  db: {findAddress, getPassword},
  params: {tx, addressId, accountId},
}) => {
  const newTx = {...tx}
  const addr = findAddress({
    addressId,
    accountId,
    g: {
      value: 1,
      hex: 1,
      network: {netId: 1},
      _account: {
        _accountGroup: {eid: 1, vault: 1},
      },
    },
  })

  if (!addr) throw InvalidParams(`Invalid address id ${addressId}`)
  if (addr.account.accountGroup.vault.type !== 'hw')
    throw InvalidParams(`Invalid address id ${addressId}`)
  if (
    ![_fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOS_NAME */ .vH.CD, _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOX_NAME */ .vH.Qx].includes(
      addr.account.accountGroup.vault.device,
    )
  )
    throw InvalidParams(`Invalid address id ${addressId}`)

  const decrypted = JSON.parse(
    addr.account.accountGroup.vault.ddata ||
      (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(getPassword(), addr.account.accountGroup.vault.data)),
  )
  const hdPath = getLedgerHDPathFromAddressAndGroupData(decrypted, addr.hex)

  if (!hdPath) throw InvalidParams(`Invalid address id ${addressId}`)

  try {
    const {r, s, v} = await new _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .Conflux */ .t5().signTransaction(
      hdPath,
      (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__/* .cfxEncodeTx */ .To)(newTx, true),
    )
    const recoveredAddr = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__/* .cfxRecoverTransactionToAddress */ .c0)(
      tx,
      {r, s, v},
      addr.network.netId,
    )

    if (recoveredAddr !== addr.value)
      throw InvalidParams(
        `The address in LedgerNanoS (${recoveredAddr}) doesn't match the address in fluent (${addr.value})`,
      )

    const rawTx = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__/* .cfxJoinTransactionAndSignature */ .s)({
      tx: newTx,
      signature: [r, s, v],
    })

    return rawTx
  } catch (err) {
    const newError = UserRejected(
      'error while signing transaction with Ledger Nano S',
    )
    newError.extra.errorFromHardwareWallet = err.message
    throw newError
  }
}


/***/ }),

/***/ 82423:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "gen": () => (/* binding */ gen),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
;// CONCATENATED MODULE: ../../packages/typed-data-spec/index.js
/* harmony default export */ function typed_data_spec(type,spec){if(type!=='cfx'&&type!=='eth')throw new Error('Invalid type ${type}');const{map,mapOf,and,stringp,plus,mapp}=spec;if(!map)throw new Error('Invalid spec instance');const typeValueSpec=[map,{closed:true},['name',stringp],['type',stringp]];const typePropsSpec=[plus,typeValueSpec];const typesSpec=[and,[map,[type==='eth'?'EIP712Domain':'CIP23Domain',typePropsSpec]],[mapOf,stringp,typePropsSpec]];return[map,{closed:true},['types',typesSpec],['primaryType',{doc:'needs to be defined in types'},stringp],['domain',mapp],['message',mapp]];}
// EXTERNAL MODULE: ../../packages/signature/index.js + 15 modules
var signature = __webpack_require__(52206);
;// CONCATENATED MODULE: ../../packages/rpcs/cfx_signTypedData_v4/index.js





const {map, dbid, or} = spec

function validateAndFormatTypedDataString({
  type,
  typedDataString,
  spec,
  InvalidParams,
}) {
  let typedData
  try {
    typedData = JSON.parse(typedDataString)
  } catch (err) {
    throw InvalidParams(
      "Invalid typed data, must be a JSON string, can't parse with JSON.parse",
    )
  }

  const typedDataSpec = typed_data_spec(type, spec)
  if (!spec.validate(typedDataSpec, typedData)) {
    throw InvalidParams(
      `Invalid typed data\n${JSON.stringify(
        spec.explain(typedDataSpec, typedData),
      )}`,
    )
  }

  try {
    (0,signature/* hashTypedData */.Jv)(type, typedData)
  } catch (err) {
    throw InvalidParams(`Error hashing typed data:\n${err.message}`)
  }

  return typedData
}

const {cat, ethHexAddress, base32UserAddress, stringp} = spec

const gen = {
  schemas: type => {
    const publicSchema = [
      cat,
      type === 'cfx' ? base32UserAddress : ethHexAddress,
      [stringp, {doc: 'typedDataString'}],
    ]
    const innerSchema = [
      map,
      {closed: true},
      ['authReqId', dbid],
      ['data', publicSchema],
    ]

    return {
      input: [or, publicSchema, innerSchema],
    }
  },
  main:
    type =>
    async ({
      Err: {InvalidParams, Unauthorized, UserRejected},
      db: {getAuthReqById, findAddress, validateAddrInApp},
      rpcs: {
        wallet_getAddressPrivateKey,
        wallet_addPendingUserAuthRequest,
        wallet_userApprovedAuthRequest,
        wallet_userRejectedAuthRequest,
      },
      app,
      params,
      _inpage,
      _popup,
    }) => {
      if (_inpage) {
        // calling eth_signTypedData_v4 in conflux network
        if (app.currentNetwork.type === 'cfx' && type === 'eth') {
          params[0] = (0,base32_address/* encode */.cv)(params[0], app.currentNetwork.netId)
        }
        const [from, typedDataString] = params

        if (
          !validateAddrInApp({
            appId: app.eid,
            networkId: app.currentNetwork.eid,
            addr: from,
          })
        ) {
          throw Unauthorized()
        }

        const addr = findAddress({
          appId: app.eid,
          value: from,
          g: {hex: 1, _account: {eid: 1, _accountGroup: {vault: {type: 1}}}},
        })

        validateAndFormatTypedDataString({
          type,
          typedDataString,
          spec: spec,
          InvalidParams,
        })

        if (addr.account.accountGroup.vault.type === 'pub') throw UserRejected()

        if (app.currentNetwork.type === 'cfx' && type === 'eth') {
          params[0] = addr.hex
        }
        const req = {method: `${type}_signTypedData_v4`, params}
        return wallet_addPendingUserAuthRequest({appId: app.eid, req})
      }

      if (_popup) {
        const {authReqId} = params

        const authReq = getAuthReqById(authReqId)
        if (!authReq) throw InvalidParams(`Invalid auth req id ${authReqId}`)

        if (authReq.app.currentNetwork.type === 'cfx' && type === 'eth') {
          params.data[0] = (0,base32_address/* encode */.cv)(
            params.data[0].replace(/^0x./, '0x1'),
            authReq.app.currentNetwork.netId,
          )
        }

        const {
          data: [from, typedDataString],
        } = params

        if (
          !validateAddrInApp({
            appId: authReq.app.eid,
            networkId: authReq.app.currentNetwork.eid,
            addr: from,
          })
        ) {
          return wallet_userRejectedAuthRequest({authReqId})
        }

        const addr = findAddress({
          appId: authReq.app.eid,
          value: from,
          g: {pk: 1, _account: {eid: 1, _accountGroup: {vault: {type: 1}}}},
        })

        if (addr.account.accountGroup.vault.type === 'pub')
          return wallet_userRejectedAuthRequest({authReqId})

        const typedData = validateAndFormatTypedDataString({
          type,
          typedDataString,
          spec: spec,
          InvalidParams,
        })

        const pk =
          addr.pk ||
          (await wallet_getAddressPrivateKey({
            address: from,
            accountId: addr.account.eid,
          }))

        const sig = await (0,signature/* signTypedData_v4 */.Qi)(type, pk, typedData)

        return await wallet_userApprovedAuthRequest({authReqId, res: sig})
      }
    },
}

const NAME = 'cfx_signTypedData_v4'

const schemas = gen.schemas('cfx')

const permissions = {
  external: ['inpage', 'popup'],
  db: ['getAuthReqById', 'findAddress', 'validateAddrInApp'],
  methods: [
    'wallet_getAddressPrivateKey',
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_userRejectedAuthRequest',
  ],
  scope: {wallet_accounts: {}},
}

const main = gen.main('cfx')


/***/ }),

/***/ 29394:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_accounts'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  db: ['getLocked', 'findAddress', 'getOneNetwork'],
}

const main = async ({
  db: {getLocked, findAddress, getOneNetwork},
  app,
  network,
  _inpage,
}) => {
  if (getLocked()) return []
  if (_inpage && !app) return []

  if (
    app &&
    app.perms.wallet_crossNetworkTypeGetEthereumHexAddress &&
    getOneNetwork({selected: true}).type !== 'eth'
  ) {
    // find any eth address under this account
    const addrs = findAddress({
      accountId: app.currentAccount.eid,
      networkType: 'eth',
      g: {value: 1},
    })
    const addr = addrs.reduce((rst, addr) => rst || addr?.value, null)
    if (addr) return [addr]
    else return []
  }

  const addrs = findAddress({
    appId: app?.eid,
    networkId: app ? null : network.eid,
    g: {value: 1},
  })

  if (app) {
    return [addrs.value]
  }

  return addrs.map(({value}) => value)
}


/***/ }),

/***/ 31715:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_blockNumber'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const cache = {
  type: 'ttl',
  key: () => NAME,
}

const main = async ({f}) => {
  return await f([])
}


/***/ }),

/***/ 39156:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_eth_transaction_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11719);
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);




const {TxMapSpecs} = (0,_fluent_wallet_eth_transaction_schema__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__)
const NAME = 'eth_call'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      (0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey)(TxMapSpecs.from),
      TxMapSpecs.to,
      (0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey)(TxMapSpecs.gasPrice),
      (0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey)(TxMapSpecs.gas),
      (0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey)(TxMapSpecs.nonce),
      (0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey)(TxMapSpecs.value),
      (0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey)(TxMapSpecs.data),
    ],
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const cache = {
  type: 'block',
  key: ({params}) => {
    const req = params[0]
    return `${NAME}${JSON.stringify(req)}`
  },
}

const main = async ({f, params}) => {
  let [tx, ref] = params
  ref = ref || 'latest'
  return await f([tx, ref])
}


/***/ }),

/***/ 7356:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_chainId'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  db: ['getOneNetwork'],
  locked: true,
}

const cache = {
  type: 'ttl',
  ttl: 24 * 60 * 60 * 1000, // 1 day
  key: () => NAME,
}

const main = async ({f, db: {getOneNetwork}, params, _inpage, app}) => {
  if (
    _inpage &&
    ((app && app.currentNetwork.type === 'cfx') ||
      getOneNetwork({selected: true}).type === 'cfx')
  ) {
    return '0x' + Number.MAX_SAFE_INTEGER.toString(16)
  }
  return await f(params)
}


/***/ }),

/***/ 55722:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "GAS_API_BASE_URL": () => (/* binding */ GAS_API_BASE_URL),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62197);
/* harmony import */ var _ethersproject_units__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77962);




const NAME = 'eth_estimate1559Fee'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [
    'eth_getBlockByNumber',
    'eth_feeHistory',
    'wallet_network1559Compatible',
  ],
  db: [],
}
//Gas station url for EIP1559
const GAS_API_BASE_URL = 'https://gas-api.metaswap.codefi.network'
// How many blocks to consider for priority fee estimation
const FEE_HISTORY_BLOCKS = 5
// Levels of priority fee
const PRIORITY_LEVELS = ['low', 'medium', 'high']
const SETTINGS_BY_PRIORITY_LEVEL = {
  low: {
    percentile: 10,
    baseFeePercentageMultiplier: new bn_js__WEBPACK_IMPORTED_MODULE_1__(110),
    minSuggestedMaxPriorityFeePerGas: new bn_js__WEBPACK_IMPORTED_MODULE_1__(1000000000),
  },
  medium: {
    percentile: 20,
    baseFeePercentageMultiplier: new bn_js__WEBPACK_IMPORTED_MODULE_1__(120),
    minSuggestedMaxPriorityFeePerGas: new bn_js__WEBPACK_IMPORTED_MODULE_1__(1500000000),
  },
  high: {
    percentile: 30,
    baseFeePercentageMultiplier: new bn_js__WEBPACK_IMPORTED_MODULE_1__(125),
    minSuggestedMaxPriorityFeePerGas: new bn_js__WEBPACK_IMPORTED_MODULE_1__(2000000000),
  },
}
// Which percentile of effective priority fees to include
const FEE_HISTORY_PERCENTILES = [
  SETTINGS_BY_PRIORITY_LEVEL.low.percentile,
  SETTINGS_BY_PRIORITY_LEVEL.medium.percentile,
  SETTINGS_BY_PRIORITY_LEVEL.high.percentile,
]
/**
 * A gas fee estimates based on gas fees that have been used in the recent past tx.
 * @param {*} param
 */
const main = async ({
  Err: {InvalidParams},
  rpcs: {eth_feeHistory, eth_getBlockByNumber, wallet_network1559Compatible},
  network,
}) => {
  const network1559Compatible = await wallet_network1559Compatible()
  if (!network1559Compatible)
    throw InvalidParams(
      `Network ${network.name} don't support 1559 transaction`,
    )
  let gasInfo = {}
  //First fetch through gas station,if error occured, then fetch througe the rpc: eth_feeHistory
  try {
    gasInfo = await getGasFeeByGasStation(Number(network.chainId))
  } catch (error) {
    const latestBlock = await eth_getBlockByNumber(['latest', false])
    const baseFeePerGas = new bn_js__WEBPACK_IMPORTED_MODULE_1__(Number(latestBlock?.baseFeePerGas))
    const feeData = await eth_feeHistory([
      FEE_HISTORY_BLOCKS,
      'latest',
      FEE_HISTORY_PERCENTILES,
    ])
    gasInfo = calculateGasFeeEstimatesForPriorityLevels(feeData, baseFeePerGas)
  }
  return gasInfo
}

function calculateGasFeeEstimatesForPriorityLevels(feeData, baseFeePerGas) {
  const levelSpecificEstimates = PRIORITY_LEVELS.reduce(
    (obj, priorityLevel) => {
      const gasEstimatesForPriorityLevel = calculateEstimatesForPriorityLevel(
        priorityLevel,
        feeData,
        baseFeePerGas,
      )
      return {...obj, [priorityLevel]: gasEstimatesForPriorityLevel}
    },
    {},
  )
  return {
    ...levelSpecificEstimates,
    estimatedBaseFee: (0,_ethersproject_units__WEBPACK_IMPORTED_MODULE_2__/* .formatUnits */ .bM)(baseFeePerGas.toString(), 'gwei'),
  }
}

function calculateEstimatesForPriorityLevel(
  priorityLevel,
  feeData,
  baseFeePerGas,
) {
  const settings = SETTINGS_BY_PRIORITY_LEVEL[priorityLevel]
  const adjustedBaseFeePerGas = baseFeePerGas
    .mul(settings.baseFeePercentageMultiplier)
    .divn(100)
  const priorityFees = feeData.reward
    ?.map(
      rewards =>
        new bn_js__WEBPACK_IMPORTED_MODULE_1__(Number(rewards[PRIORITY_LEVELS.indexOf(priorityLevel)])),
    )
    .filter(bn_js__WEBPACK_IMPORTED_MODULE_1__.isBN)
  const adjustedPriorityFee = medianOf(priorityFees)
  const suggestedMaxPriorityFeePerGas = bn_js__WEBPACK_IMPORTED_MODULE_1__.max(
    adjustedPriorityFee,
    settings.minSuggestedMaxPriorityFeePerGas,
  )
  const suggestedMaxFeePerGas = adjustedBaseFeePerGas.add(
    suggestedMaxPriorityFeePerGas,
  )
  return {
    suggestedMaxPriorityFeePerGas: (0,_ethersproject_units__WEBPACK_IMPORTED_MODULE_2__/* .formatUnits */ .bM)(
      suggestedMaxPriorityFeePerGas.toString(),
      'gwei',
    ),
    suggestedMaxFeePerGas: (0,_ethersproject_units__WEBPACK_IMPORTED_MODULE_2__/* .formatUnits */ .bM)(
      suggestedMaxFeePerGas.toString(),
      'gwei',
    ),
  }
}

function medianOf(numbers) {
  const sortedNumbers = numbers.slice().sort((a, b) => a.cmp(b))
  const len = sortedNumbers.length
  const index = Math.floor((len - 1) / 2)
  return sortedNumbers[index]
}

async function getGasFeeByGasStation(chainId) {
  const gaseFeeApiUrl = `${GAS_API_BASE_URL}/networks/${chainId}/suggestedGasFees`
  if (typeof window?.fetch === 'function') {
    const res = await fetch(gaseFeeApiUrl, {
      method: 'GET',
      headers: {'Content-Type': 'application/json'},
    }).then(res => res.json())
    return res
  }

  return {}
}


/***/ }),

/***/ 79108:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_eth_transaction_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11719);



const {blockRef, zeroOrOne} = _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__

const {
  TransactionLegacyUnsigned,
  Transaction1559Unsigned,
  Transaction2930Unsigned,
} = (0,_fluent_wallet_eth_transaction_schema__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__)

const NAME = 'eth_estimateGas'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
      TransactionLegacyUnsigned.map(k =>
        Array.isArray(k) ? _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey(k) : k,
      ),
      Transaction1559Unsigned.map(k =>
        Array.isArray(k) ? _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey(k) : k,
      ),
      Transaction2930Unsigned.map(k =>
        Array.isArray(k) ? _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optionalMapKey(k) : k,
      ),
    ],
    [zeroOrOne, blockRef],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f, params}) => {
  let [tx, ref] = params
  ref = ref || 'latest'
  // network without EIP-1559 support may throw error when estimate with `type`
  if (tx.type === '0x0' || tx.type === null) {
    // eslint-disable-next-line no-unused-vars
    const {type, ...newTx} = tx
    tx = newTx
  }
  return await f([tx, ref])
}


/***/ }),

/***/ 90169:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_feeHistory'
const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.number,
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint],
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.schema, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.number, {max: 100, min: 1}]]],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 47650:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_gasPrice'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f}) => {
  return await f([])
}


/***/ }),

/***/ 50635:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getBalance'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef],
}

const cache = {
  type: 'block',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 85249:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getBlockByHash'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Hash32, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 72665:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getBlockByNumber'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Uint], _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 20902:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getCode'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockTag],
}

const cache = {
  type: 'block',
  key: ({params}) => `${NAME}${params[0]}`,
}
const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 16598:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getLogs'

const singleTopic = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nul, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32]
const topicSchema = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, singleTopic]

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      ['fromBlock', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef],
      ['toBlock', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef],
      [
        'address',
        {optional: true},
        [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
      ],
      ['blockHash', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Hash32],
      ['topics', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, singleTopic, topicSchema]]],
    ],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 41291:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getTransactionByHash'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32],
}

const cache = {
  type: 'block',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 73435:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getTransactionCount'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.blockRef],
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
}

const cache = {
  type: 'block',
  key: ({params}) => `${NAME}${params[0]}`,
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 20795:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_getTransactionReceipt'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32],
}

const cache = {
  type: 'block',
  key: ({params}) => `${NAME}${params[0]}`,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 86693:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_maxPriorityFeePerGas'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f}) => {
  return await f([])
}


/***/ }),

/***/ 24125:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_requestAccounts'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['inpage'],
  methods: ['wallet_requestPermissions', 'eth_accounts'],
  db: ['getOneApp'],
  scope: null,
}

const main = async ({
  db: {getOneApp},
  rpcs: {wallet_requestPermissions, eth_accounts},
  site,
  app,
}) => {
  if (app) {
    return await eth_accounts()
  }
  const permissionsToRequest = {
    eth_accounts: {},
    wallet_crossNetworkTypeGetEthereumHexAddress: {},
  }
  const permsRes = await wallet_requestPermissions([permissionsToRequest])

  if (permsRes && !permsRes.error) {
    const newapp = getOneApp({site: site.eid})
    const addrs = await eth_accounts({app: newapp}, [])

    return addrs
  }

  return []
}


/***/ }),

/***/ 30684:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'eth_sendRawTransaction'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes],
}

const permissions = {
  external: [],
  locked: true,
  methods: [],
  db: [],
}

const main = async ({f, params}) => {
  return await f(params)
}


/***/ }),

/***/ 81316:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_eth_sign_transaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90909);



const NAME = 'eth_sendTransaction'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_eth_sign_transaction__WEBPACK_IMPORTED_MODULE_1__.txSchema],
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['tx', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_eth_sign_transaction__WEBPACK_IMPORTED_MODULE_1__.txSchema]]],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  methods: ['wallet_sendTransaction'],
  db: [],
}

const main = ({rpcs: {wallet_sendTransaction}, params}) => {
  return wallet_sendTransaction(params)
}


/***/ }),

/***/ 90909:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "txSchema": () => (/* binding */ txSchema),
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_eth_transaction_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11719);
/* harmony import */ var _fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52206);
/* harmony import */ var _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83799);
/* harmony import */ var _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9414);
/* harmony import */ var _ethersproject_units__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77962);







const {
  TransactionLegacyUnsigned,
  Transaction1559Unsigned,
  Transaction2930Unsigned,
} = (0,_fluent_wallet_eth_transaction_schema__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__)

const {or, cat, zeroOrOne, map, blockRef, boolean} = _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__

const txSchema = [
  or,
  TransactionLegacyUnsigned,
  Transaction1559Unsigned,
  Transaction2930Unsigned,
]

const NAME = 'eth_signTransaction'

const schemas = {
  input: [
    cat,
    txSchema,
    [
      zeroOrOne,
      [
        map,
        {closed: true},
        ['block', {optional: true}, blockRef],
        ['returnTxMeta', {optional: true}, boolean],
        ['dryRun', {optional: true}, boolean],
      ],
    ],
  ],
}

// ethers.js
// 1. don't allow from in tx
// 2. use `gasLimit` instead of `gas` in tx
// 3. type must be an integer
function toEthersTx(tx) {
  // eslint-disable-next-line no-unused-vars
  const {from, type, gas, chainId, ...ethersTx} = tx
  ethersTx.chainId = parseInt(chainId, 16)
  ethersTx.gasLimit = gas
  ethersTx.type = parseInt(type, 16)
  if (type === _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__/* .ETH_TX_TYPES.EIP1559 */ .Pp.EIP1559) {
    //EIP-1559
    delete ethersTx.gasPrice
  }
  return ethersTx
}

const permissions = {
  external: [],
  methods: [
    'eth_signTxWithLedgerNanoS',
    'wallet_getAddressPrivateKey',
    'eth_getTransactionCount',
    'eth_gasPrice',
    'eth_estimateGas',
    'wallet_detectAddressType',
    'wallet_network1559Compatible',
    'eth_estimate1559Fee',
  ],
  db: ['findAddress'],
}

const main = async args => {
  const {
    Err: {InvalidParams},
    db: {findAddress},
    rpcs: {
      eth_gasPrice,
      wallet_network1559Compatible,
      wallet_getAddressPrivateKey,
      eth_estimateGas,
      eth_getTransactionCount,
      wallet_detectAddressType,
      eth_estimate1559Fee,
    },
    params: [tx, opts = {}],
    app,
    network,
    _popup,
  } = args
  if (tx.chainId && tx.chainId !== network.chainId)
    throw InvalidParams(`Invalid chainId ${tx.chainId}`)

  const {block, returnTxMeta, dryRun} = opts

  tx.from = tx.from.toLowerCase()
  if (tx.to) tx.to = tx.to.toLowerCase()
  const newTx = {...tx}
  const network1559Compatible = await wallet_network1559Compatible()
  if (!newTx.type) {
    if (network1559Compatible) newTx.type = _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__/* .ETH_TX_TYPES.EIP1559 */ .Pp.EIP1559
    else newTx.type = _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__/* .ETH_TX_TYPES.LEGACY */ .Pp.LEGACY
  }

  const fromAddr = findAddress({
    appId: app && app.eid,
    selected: _popup && !app ? true : undefined,
    value: newTx.from,
    g: {
      eid: 1,
      _account: {eid: 1, _accountGroup: {vault: {type: 1, device: 1}}},
    },
  })

  // from address is not belong to wallet
  if (!fromAddr) throw InvalidParams(`Invalid from address ${newTx.from}`)

  // tx without to must have data (deploy contract)
  if (!newTx.to && !newTx.data)
    throw InvalidParams(
      `Invalid tx, [to] and [data] can't be omit at the same time`,
    )

  if (newTx.data === '0x') newTx.data = undefined
  if (!newTx.value) newTx.value = '0x0'

  if (!newTx.nonce) {
    newTx.nonce = await eth_getTransactionCount({errorFallThrough: true}, [
      newTx.from,
      'pending',
    ])
  }
  // EIP-1559
  const is1559Tx = newTx.type === _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__/* .ETH_TX_TYPES.EIP1559 */ .Pp.EIP1559
  if (is1559Tx && !network1559Compatible)
    throw InvalidParams(
      `Network ${network.name} don't support 1559 transaction`,
    )

  if (!is1559Tx && !newTx.gasPrice) newTx.gasPrice = await eth_gasPrice()

  if (newTx.to && !newTx.gas) {
    const {contract: typeContract} = await wallet_detectAddressType(
      {errorFallThrough: true},
      {address: newTx.to},
    )
    if (!typeContract && !newTx.data) {
      if (!newTx.gas) newTx.gas = '0x5208'
    }
  }
  if (!newTx.gas) {
    try {
      newTx.gas = await eth_estimateGas({errorFallThrough: true}, [
        newTx,
        block || 'latest',
      ])
    } catch (err) {
      err.data = {originalData: err.data, estimateError: true}
      throw err
    }
  }

  if (!newTx.chainId) newTx.chainId = network.chainId
  if (is1559Tx && network1559Compatible) {
    const gasInfoEip1559 = await eth_estimate1559Fee()
    const {suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas} =
      gasInfoEip1559?.medium || {}
    if (!newTx.maxPriorityFeePerGas)
      newTx.maxPriorityFeePerGas = (0,_ethersproject_units__WEBPACK_IMPORTED_MODULE_5__/* .parseUnits */ .vz)(
        suggestedMaxPriorityFeePerGas,
        'gwei',
      ).toHexString()
    if (!newTx.maxFeePerGas)
      newTx.maxFeePerGas = (0,_ethersproject_units__WEBPACK_IMPORTED_MODULE_5__/* .parseUnits */ .vz)(
        suggestedMaxFeePerGas,
        'gwei',
      ).toHexString()
  }
  let raw
  if (fromAddr.account.accountGroup.vault.type === 'hw') {
    if (dryRun) {
      raw = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__/* .ethSignTransaction */ .jb)(
        toEthersTx(newTx),
        '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      )
    } else {
      raw = await signWithHardwareWallet({
        args,
        accountId: fromAddr.account.eid,
        tx: toEthersTx(newTx),
        addressId: fromAddr.eid,
        device: fromAddr.account.accountGroup.vault.device,
      })
    }
  } else {
    let pk = await wallet_getAddressPrivateKey({
      address: newTx.from,
      accountId: fromAddr.account.eid,
    })

    if (dryRun)
      pk = '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
    raw = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__/* .ethSignTransaction */ .jb)(toEthersTx(newTx), pk)
  }

  if (returnTxMeta) {
    return {txMeta: newTx, raw}
  }
  return raw
}

async function signWithHardwareWallet({
  args: {
    rpcs: {eth_signTxWithLedgerNanoS},
  },
  tx,
  addressId,
  device,
  accountId,
}) {
  const hwSignMap = {
    [_fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOS_NAME */ .vH.CD]: eth_signTxWithLedgerNanoS,
    [_fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOX_NAME */ .vH.Qx]: eth_signTxWithLedgerNanoS,
  }
  const signMethod = hwSignMap[device]
  return await signMethod({errorFallThrough: true}, {tx, addressId, accountId})
}


/***/ }),

/***/ 83272:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83799);
/* harmony import */ var _fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52206);





const NAME = 'eth_signTxWithLedgerNanoS'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['tx', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp],
    ['addressId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ],
}

const permissions = {
  external: [],
  methods: [],
  db: ['findAddress', 'getPassword'],
}

function getLedgerHDPathFromAddressAndGroupData(groupData, hex) {
  return groupData[hex]
}

const main = async ({
  Err: {InvalidParams, UserRejected},
  db: {findAddress, getPassword},
  params: {tx, addressId, accountId},
}) => {
  const newTx = {...tx}
  const addr = findAddress({
    addressId,
    accountId,
    g: {
      value: 1,
      hex: 1,
      _account: {
        _accountGroup: {eid: 1, vault: 1},
      },
    },
  })

  if (!addr) throw InvalidParams(`Invalid address id ${addressId}`)
  if (addr.account.accountGroup.vault.type !== 'hw')
    throw InvalidParams(`Invalid address id ${addressId}`)
  if (
    ![_fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOS_NAME */ .vH.CD, _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .consts.LEDGER_NANOX_NAME */ .vH.Qx].includes(
      addr.account.accountGroup.vault.device,
    )
  )
    throw InvalidParams(`Invalid address id ${addressId}`)

  const decrypted = JSON.parse(
    addr.account.accountGroup.vault.ddata ||
      (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(getPassword(), addr.account.accountGroup.vault.data)),
  )
  const hdPath = getLedgerHDPathFromAddressAndGroupData(decrypted, addr.hex)

  if (!hdPath) throw InvalidParams(`Invalid address id ${addressId}`)

  try {
    const {r, s, v} = await new _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_2__/* .Ethereum */ .kJ().signTransaction(
      hdPath,
      (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__/* .ethEncodeTx */ .e6)(newTx, true),
    )
    const recoveredAddr = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__/* .ethRecoverTransactionToAddress */ .fP)(tx, {r, s, v})

    if (recoveredAddr.toLowerCase() !== addr.value)
      throw InvalidParams(
        `The address in LedgerNanoS (${recoveredAddr}) doesn't match the address in fluent (${addr.value})`,
      )

    const rawTx = (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_3__/* .ethJoinTransactionAndSignature */ .qf)({
      tx: newTx,
      signature: [r, s, v],
    })

    return rawTx
  } catch (err) {
    const newError = UserRejected(
      'error while signing transaction with Ledger Nano S',
    )
    newError.extra.errorFromHardwareWallet = err.message
    throw newError
  }
}


/***/ }),

/***/ 7272:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "permissions": () => (/* reexport safe */ _fluent_wallet_cfx_sign_typed_data_v4__WEBPACK_IMPORTED_MODULE_0__.permissions),
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_cfx_sign_typed_data_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82423);



const NAME = 'eth_signTypedData_v4'
const schemas = _fluent_wallet_cfx_sign_typed_data_v4__WEBPACK_IMPORTED_MODULE_0__.gen.schemas('eth')
const main = _fluent_wallet_cfx_sign_typed_data_v4__WEBPACK_IMPORTED_MODULE_0__.gen.main('eth')


/***/ }),

/***/ 24853:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'net_version'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  db: ['getOneNetwork'],
  methods: ['cfx_netVersion'],
  locked: true,
}

const cache = {
  type: 'ttl',
  ttl: 24 * 60 * 60 * 1000, // 1 day
  key: () => NAME,
}

const main = ({
  f,
  params,
  db: {getOneNetwork},
  rpcs: {cfx_netVersion},
  _inpage,
  app,
  network: {type},
}) => {
  if (_inpage && app && type !== getOneNetwork({selected: true}).type) {
    return Number.MAX_SAFE_INTEGER
  }
  if (type === 'cfx') return cfx_netVersion()
  return f(params)
}


/***/ }),

/***/ 97194:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52206);



const NAME = 'personal_sign'

const publicSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat,
  [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp, {doc: 'message string to sign'}],
  [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress],
  [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrOne, {doc: 'Ignored optional password for compatibility'}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
]

const innerSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ['data', publicSchema],
]

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, innerSchema, publicSchema],
}

const permissions = {
  external: ['inpage', 'popup'],
  methods: [
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_userRejectedAuthRequest',
    'wallet_getAddressPrivateKey',
  ],
  db: ['getAuthReqById', 'findAddress', 'validateAddrInApp'],
  scope: {wallet_accounts: {}},
}

const main = async ({
  Err: {InvalidParams, Unauthorized, UserRejected},
  db: {getAuthReqById, findAddress, validateAddrInApp},
  rpcs: {
    wallet_getAddressPrivateKey,
    wallet_userApprovedAuthRequest,
    wallet_userRejectedAuthRequest,
    wallet_addPendingUserAuthRequest,
  },
  params,
  _inpage,
  _popup,
  app,
}) => {
  if (_inpage) {
    const type = app.currentNetwork.type
    const [, from] = params
    if (
      type === 'cfx' &&
      !(0,_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.validate)(_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, from, {netId: app.currentNetwork.netId})
    )
      throw InvalidParams(
        `Invalid from ${from} for the target network ${app.currentNetwork.name}`,
      )

    if (
      !validateAddrInApp({
        appId: app.eid,
        networkId: app.currentNetwork.eid,
        addr: from,
      })
    ) {
      throw Unauthorized()
    }

    const addr = findAddress({
      networkId: app.currentNetwork.eid,
      appId: app.eid,
      value: from,
      accountG: {_accountGroup: {vault: {type: 1}}},
    })

    if (addr.account.accountGroup.vault.type === 'pub') throw UserRejected()

    const req = {method: NAME, params}
    return await wallet_addPendingUserAuthRequest({appId: app.eid, req})
  }

  if (_popup) {
    const {
      authReqId,
      data: [message, from],
    } = params

    const authReq = getAuthReqById(authReqId)
    if (!authReq) throw InvalidParams(`Invalid auth req id ${authReqId}`)

    const type = authReq.app.currentNetwork.type
    if (
      !validateAddrInApp({
        appId: authReq.app.eid,
        networkId: authReq.app.currentNetwork.eid,
        addr: from,
      })
    ) {
      return wallet_userRejectedAuthRequest({authReqId})
    }
    const addr = findAddress({
      networkId: authReq.app.currentNetwork.eid,
      appId: authReq.app.eid,
      value: from,
      g: {pk: 1, _account: {eid: 1, _accountGroup: {vault: {type: 1}}}},
    })

    if (addr.account.accountGroup.vault.type === 'pub')
      return wallet_userRejectedAuthRequest({authReqId})

    const pk =
      addr.pk ||
      (await wallet_getAddressPrivateKey(
        {network: authReq.app.currentNetwork},
        {address: from, accountId: addr.account.eid},
      ))
    const sig = await (0,_fluent_wallet_signature__WEBPACK_IMPORTED_MODULE_1__/* .personalSign */ .W0)(type, pk, message)

    return await wallet_userApprovedAuthRequest({authReqId, res: sig})
  }
}


/***/ }),

/***/ 47672:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'txpool_nextNonce'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({f, params}) => {
  return f(params)
}


/***/ }),

/***/ 14914:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_accounts'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_accounts', 'eth_accounts'],
  db: [],
}

const main = ({rpcs: {cfx_accounts, eth_accounts}, network: {type}}) => {
  if (type === 'cfx') {
    return cfx_accounts()
  } else {
    return eth_accounts()
  }
}


/***/ }),

/***/ 24397:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_wallet_add_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16882);


const NAME = 'wallet_addConfluxChain'

const schemas = _fluent_wallet_wallet_add_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__.schemas

const permissions = _fluent_wallet_wallet_add_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__.permissions

const main = _fluent_wallet_wallet_add_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__.main


/***/ }),

/***/ 16882:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_wallet_add_network__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18350);



const NAME = 'wallet_addEthereumChain'

const PublicSchema = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_wallet_add_network__WEBPACK_IMPORTED_MODULE_1__.ChainParameterSchema, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.any]]
const InnerSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ['newChainConfig', PublicSchema],
]
const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, PublicSchema, InnerSchema],
}

const permissions = {
  external: ['inpage', 'popup'],
  methods: [
    'wallet_detectNetworkType',
    'wallet_addNetwork',
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_userRejectedAuthRequest',
  ],
  db: ['getNetwork', 'getAuthReqById', 'getNetworkByEndpoint'],
  scope: null, // allowed to be called before connecting to dapp
}

const main = async ({
  Err: {InvalidParams},
  db: {getAuthReqById, getNetworkByEndpoint, getNetwork},
  rpcs: {
    wallet_detectNetworkType,
    wallet_addNetwork,
    wallet_addPendingUserAuthRequest,
    wallet_userApprovedAuthRequest,
    wallet_userRejectedAuthRequest,
  },
  site,
  app,
  params,
  _popup,
  _inpage,
}) => {
  const chainConf = Array.isArray(params) ? params[0] : params.newChainConfig[0]
  const {chainId, rpcUrls} = chainConf
  const rpcUrl = (0,_fluent_wallet_wallet_add_network__WEBPACK_IMPORTED_MODULE_1__.firstHttpOrHttpsUrl)(rpcUrls)
  const [dupEndpointNetwork] = getNetworkByEndpoint(rpcUrl)
  if (dupEndpointNetwork)
    throw InvalidParams(
      `Duplicate network endpoint with network ${dupEndpointNetwork.eid}`,
    )

  const {chainId: detectedChainId, type: detectedNetworkType} =
    await wallet_detectNetworkType({url: rpcUrl})
  if (chainId !== detectedChainId)
    throw InvalidParams(
      `Invalid chainId ${chainId}, got ${detectedChainId} from remote`,
    )

  const [dupChainIdBuiltInNetwork] = getNetwork({
    chainId,
    builtin: true,
    type: detectedNetworkType,
  })
  if (dupChainIdBuiltInNetwork)
    throw InvalidParams(`Duplicate chainId ${chainId} with builtin network`)

  if (_inpage) {
    const req = {method: NAME, params}
    const authReqParams = {req}
    if (app) authReqParams.appId = app.eid
    else authReqParams.siteId = site.eid
    return await wallet_addPendingUserAuthRequest(authReqParams)
  }

  // add network from popup
  if (_popup && Array.isArray(params)) {
    await wallet_addNetwork(params[0])
    return '__null__'
  }

  if (_popup) {
    const {authReqId} = params
    if (!authReqId) throw InvalidParams(`Invalid auth req id ${authReqId}`)
    const authReq = getAuthReqById(authReqId)
    if (!authReq) throw InvalidParams(`Invalid auth req id ${authReqId}`)
    if (authReq.processed)
      throw InvalidParams(`Already processing auth req ${authReqId}`)
    const rst = await wallet_addNetwork(chainConf)
    if (rst?.error) return await wallet_userRejectedAuthRequest({authReqId})
    return await wallet_userApprovedAuthRequest({authReqId, res: '__null__'})
  }
}


/***/ }),

/***/ 77714:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_addHdPath'
const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['hdPath', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.hdPath],
    ['name', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp, {min: 2, max: 128}]],
  ],
}

const permissions = {
  external: ['popup'],
  db: ['getHdPathByName', 'getHdPathByValue', 't'],
}
const main = ({
  Err: {InvalidParams},
  db: {getHdPathByName, getHdPathByValue, t},
  params: {name, hdPath},
}) => {
  if (getHdPathByName(name).length)
    throw InvalidParams('Duplicate hd path name')

  const [dup] = getHdPathByValue(hdPath)
  if (dup) throw InvalidParams(`hd path already added with name ${dup.name}`)

  const {
    tempids: {newHdPathId},
  } = t({eid: 'newHdPathId', hdPath: {value: hdPath, name}})
  return newHdPathId
}


/***/ }),

/***/ 18350:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "firstHttpOrHttpsUrl": () => (/* binding */ firstHttpOrHttpsUrl),
/* harmony export */   "ChainParameterSchema": () => (/* binding */ ChainParameterSchema),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9414);



const NAME = 'wallet_addNetwork'

const firstHttpOrHttpsUrl = function (urls) {
  return urls.reduce((acc, url) => acc || (url.startsWith('http') && url), null)
}

const nativeCurrencySchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true, doc: 'Config of the native currency of the chain'},
  ['name', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
  ['symbol', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.tokenSymbol],
  ['decimals', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.eq, 18]],
  ['iconUrls', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.atLeastOneHttpUrl],
]

const ChainParameterSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {
    closed: true,
    doc: 'Config of the chain to add, check it at https://docs.metamask.io/guide/rpc-api.html#wallet-addethereumchain',
  },
  ['chainId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.chainId],
  ['chainName', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
  ['nativeCurrency', nativeCurrencySchema],
  ['rpcUrls', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.atLeastOneHttpUrl],
  ['blockExplorerUrls', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.atLeastOneHttpUrl],
  ['iconUrls', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.atLeastOneHttpUrl],
  [
    'hdPath',
    {
      optional: true,
      doc: 'the hd path of this netowrk, default to the detected network type (cfx/eth), can be one of hd path dbid, hd path type "cfx"/"eth" or hd path value',
    },
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'cfx', 'eth'], _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.hdPath],
  ],
]

const schemas = {
  input: ChainParameterSchema,
}

const permissions = {
  external: [],
  db: [
    't',
    'getNetwork',
    'getHdPathById',
    'getNetworkById',
    'getNetworkByName',
    'getNetworkByEndpoint',
    'getOneHdPath',
    'filterAccountGroupByNetworkType',
    'retractAttr',
  ],
  methods: [
    'wallet_addHdPath',
    'wallet_detectNetworkType',
    'wallet_discoverAccounts',
    'wallet_createAddress',
  ],
}

const main = async ({
  Err: {InvalidParams},
  rpcs: {
    wallet_addHdPath,
    wallet_detectNetworkType,
    wallet_discoverAccounts,
    wallet_createAddress,
  },
  db: {
    t,
    retractAttr,
    getNetworkById,
    getHdPathById,
    getNetwork,
    getNetworkByName,
    getNetworkByEndpoint,
    getOneHdPath,
    filterAccountGroupByNetworkType,
  },
  networkName,
  network,
  params: {
    chainId,
    chainName: name,
    nativeCurrency: ticker,
    rpcUrls,
    blockExplorerUrls = [],
    iconUrls = [],
    hdPath,
  },
  // only when called from wallet_updateNetwork
  toUpdateNetwork,
}) => {
  const url = firstHttpOrHttpsUrl(rpcUrls)
  const explorerUrl = firstHttpOrHttpsUrl(blockExplorerUrls)
  const iconUrl = firstHttpOrHttpsUrl(iconUrls)

  // duplidate network name
  const [dupNameNetwork] = getNetworkByName(name)
  if (
    (!toUpdateNetwork && dupNameNetwork) ||
    (dupNameNetwork &&
      toUpdateNetwork &&
      toUpdateNetwork.eid !== dupNameNetwork.eid)
  )
    throw InvalidParams('Duplicate network name')

  // duplicate rpc endpoint
  const [dupEndpointNetwork] = getNetworkByEndpoint(url)
  if (
    (!toUpdateNetwork && dupEndpointNetwork) ||
    (dupEndpointNetwork &&
      toUpdateNetwork &&
      toUpdateNetwork.eid !== dupEndpointNetwork?.eid)
  )
    throw InvalidParams(
      `Duplicate network endpoint with network ${dupEndpointNetwork.eid}`,
    )

  // invalid hdPath id
  if (Number.isInteger(hdPath) && !getHdPathById(hdPath))
    throw InvalidParams(`Invalid hdPath id ${hdPath}`)

  // this returns menas the rpcurl is valid
  const {
    type: networkType,
    chainId: detectedChainId,
    netId,
  } = await wallet_detectNetworkType({url})

  if (chainId !== detectedChainId)
    throw InvalidParams(
      `Invalid chainId ${chainId}, got ${detectedChainId} from remote`,
    )

  // chain id duplicate with builtin network
  const [dupChainIdBuiltInNetwork] = getNetwork({
    chainId,
    builtin: true,
    type: networkType,
  })
  if (
    dupChainIdBuiltInNetwork &&
    toUpdateNetwork?.eid !== dupChainIdBuiltInNetwork.eid
  )
    throw InvalidParams(`Duplicate chainId ${chainId} with builtin network`)

  hdPath = hdPath || networkType

  let hdPathId =
    (Number.isInteger(hdPath) && getHdPathById(hdPath).eid) ||
    (hdPath === 'cfx' && getOneHdPath({value: _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__/* .DEFAULT_CFX_HDPATH */ .JH}).eid) ||
    (hdPath === 'eth' && getOneHdPath({value: _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_1__/* .DEFAULT_ETH_HDPATH */ .uD}).eid) ||
    getOneHdPath({value: hdPath})?.eid ||
    'newHdPath'

  if (hdPathId === 'newHdPath') {
    hdPathId = await wallet_addHdPath({name: `${name}-hdPath`, hdPath})
  }

  const upsertNetworkResult = t([
    {
      eid: toUpdateNetwork?.eid || 'networkId',
      network: {
        isCustom: toUpdateNetwork?.builtin
          ? false
          : toUpdateNetwork?.isCustom ?? true,
        name,
        cacheTime:
          toUpdateNetwork?.cacheTime ?? (networkType === 'cfx' ? 1000 : 15000),
        endpoint: url,
        type: networkType,
        hdPath: hdPathId,
        chainId,
        netId: parseInt(netId, 10),
        ticker,
        builtin: toUpdateNetwork?.builtin ?? false,
      },
    },
    explorerUrl && {
      eid: toUpdateNetwork?.eid || 'networkId',
      network: {scanUrl: explorerUrl},
    },
    iconUrl && {
      eid: toUpdateNetwork?.eid || 'networkId',
      network: {icon: iconUrl},
    },
  ])

  if (toUpdateNetwork?.eid && !explorerUrl) {
    retractAttr({eid: toUpdateNetwork.eid, attr: 'network/scanUrl'})
  }

  const groups = filterAccountGroupByNetworkType(networkType)

  if (!toUpdateNetwork) {
    // create new network address for each group
    await Promise.all(
      groups.map(({eid}) =>
        wallet_createAddress({
          accountGroupId: eid,
          networkId: upsertNetworkResult.tempids.networkId,
        }),
      ),
    )
  }

  let discoverAccounts = ({eid}) =>
    wallet_discoverAccounts({accountGroupId: eid})
  // current network name changed
  if (toUpdateNetwork?.eid === network.eid && name !== networkName) {
    discoverAccounts = ({eid}) =>
      wallet_discoverAccounts(
        {networkName: name, network: getNetworkById(network.eid)},
        {accountGroupId: eid},
      )
  }

  // discover new accounts for each hd group
  await Promise.all(
    groups.filter(({vault: {type}}) => type === 'hd').map(discoverAccounts),
  )

  return toUpdateNetwork?.eid || upsertNetworkResult.tempids.networkId
}


/***/ }),

/***/ 30170:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75321);



const NAME = 'wallet_addPendingUserAuthRequest'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['req', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp], ['siteId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['req', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp], ['appId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
  ],
}

const permissions = {
  methods: ['wallet_userRejectedAuthRequest'],
  db: ['t', 'getSiteById', 'getAppById', 'getAuthReqById', 'getAuthReq'],
}

function getDupAuthReq({
  db: {getAuthReq},
  params: {
    req: {method, params},
    siteId,
    appId,
  },
}) {
  const reqs = getAuthReq({site: siteId, app: appId})
  return reqs.filter(
    r =>
      !r.req.processed &&
      r.req.method === method &&
      JSON.stringify(r.req.params) === JSON.stringify(params),
  )[0]
}

const main = async args => {
  const {
    Err: {InvalidParams},
    db: {t, getSiteById, getAppById, getAuthReqById},
    rpcs: {wallet_userRejectedAuthRequest},
    MODE,
    params: {
      req: {method, params},
      siteId,
      appId,
    },
  } = args
  const site = getSiteById(siteId)
  const app = getAppById(appId)
  if (siteId && !site) throw InvalidParams(`Invalid site id ${siteId}`)
  if (appId && !app) throw InvalidParams(`Invalid app id ${appId}`)

  const dupReq = getDupAuthReq(args)
  if (dupReq) {
    const rst = await dupReq.c.read()
    if (rst instanceof Error) throw rst
    return rst
  }

  const c = (0,_fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_1__/* .chan */ .zH)(1)
  const {
    tempids: {authReqId},
  } = t([
    site && {
      eid: 'authReqId',
      authReq: {site: site.eid, req: {method, params}, c},
    },
    app && {
      eid: 'authReqId',
      authReq: {app: app.eid, req: {method, params}, c},
    },
  ])

  const {popup} = await __webpack_require__.e(/* import() */ 258).then(__webpack_require__.bind(__webpack_require__, 40258))

  const w = await popup.show({
    alwaysOnTop: MODE.isProd ? true : false,
    mode: MODE,
  })
  if (MODE.isProd)
    setTimeout(() => popup.onFocusChanged(w.id, popup.remove), 500)
  popup.onRemoved(w?.id, () => {
    const authReq = getAuthReqById(authReqId)
    if (authReq && !authReq.processed)
      wallet_userRejectedAuthRequest({errorFallThrough: true}, {authReqId})
  })
  const rst = await c.read()
  if (rst instanceof Error) throw rst
  return rst
}


/***/ }),

/***/ 3396:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "newAccounts": () => (/* binding */ newAccounts),
/* harmony export */   "newAccountGroup": () => (/* binding */ newAccountGroup),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87580);
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4088);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11239);
/* harmony import */ var _fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11818);
/* harmony import */ var _fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75321);









const NAME = 'wallet_addVault'

const baseInputSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.map,
  {closed: true},
  ['device', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.stringp],
  ['password', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.password],
  ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.nickname],
]
const menomicSchema = [
  ...baseInputSchema,
  ['mnemonic', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.mnemonic],
  ['waitTillFinish', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.maybe, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.truep]],
  [
    'cfxOnly',
    {
      optional: true,
      doc: 'only derive conflux compatible address from this mnemonic',
    },
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.truep,
  ],
  [
    'force',
    {optional: true, doc: 'set to true to skip duplication check'},
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.truep,
  ],
]

const privateKeySchema = [...baseInputSchema, ['privateKey', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.privateKey]]
const addressSchema = [
  ...baseInputSchema,
  ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.ethHexAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.base32UserAddress]],
]
const hwSchema = [
  ...baseInputSchema,
  ['accountGroupData', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.mapp],
  ['cfxOnly', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.truep],
  [
    'accounts',
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.oneOrMore,
      [
        _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.map,
        {closed: true},
        ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.ethHexAddress]],
        ['nickname', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.stringp],
      ],
    ],
  ],
]

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.or, menomicSchema, privateKeySchema, addressSchema, hwSchema],
}

const permissions = {
  methods: [
    'wallet_unlock',
    'wallet_discoverAccounts',
    'wallet_getBalance',
    'wallet_getNextNonce',
    'wallet_validatePassword',
    'wallet_deleteAccountGroup',
    'wallet_setCurrentAccount',
  ],
  db: [
    'getAddress',
    'findAccount',
    'newAddressTx',
    'getGroupFirstAccountId',
    'getAccountGroupByVaultType',
    't',
    'getOneAccount',
    'getAccount',
    'getVault',
    'getVaultById',
    'createVault',
    'findGroup',
    'getNetwork',
    'getLocked',
    'getPassword',
  ],
}

async function selectNewlyCreatedAccountGroupFirstAccount({
  rpcs: {wallet_setCurrentAccount},
  db: {getGroupFirstAccountId},
  groupId,
}) {
  return await wallet_setCurrentAccount([getGroupFirstAccountId({groupId})])
}

const DefaultGroupNamePrefix = {
  hd: 'Seed-',
  pub: 'Follow-',
  pk: 'Account-',
  hw: 'Hardware Wallet-',
}

async function newAccounts(arg) {
  const {
    allAccountCreatedChan,
    firstAccountCreatedChan,
    groupId,
    groupName,
    rpcs: {wallet_discoverAccounts},
    params: {waitTillFinish, accounts},
    vault,
    db: {getNetwork, t, newAddressTx, findAccount},
  } = arg

  if (vault.type === 'hd') {
    await wallet_discoverAccounts({
      accountGroupId: groupId,
      waitTillFinish,
    })
    if (waitTillFinish) allAccountCreatedChan.write(true)
    firstAccountCreatedChan.write(true)
    return
  }

  const networks = getNetwork()

  // for each network
  // create ONE account and address for pk/pub group
  // or create specified accounts and addrs for hw group
  networks.forEach(({eid, netId, type}) => {
    if (vault.type === 'pk') {
      const [account] = findAccount({groupId, index: 0})
      const addr = (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_4__/* .fromPrivate */ .yV)(vault.ddata).address
      const addrTx = newAddressTx({
        eid: -1,
        value: type === 'cfx' ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .encode */ .cv)((0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_4__/* .toAccountAddress */ .RE)(addr), netId) : addr,
        hex: addr,
        pk: vault.ddata,
        network: eid,
      })
      t([
        addrTx,
        {
          eid: account ?? -2,
          account: {
            address: addrTx.eid,
            index: 0,
            nickname: groupName,
            hidden: false,
          },
        },
        {eid: groupId, accountGroup: {account: account ?? -2}},
      ])
      firstAccountCreatedChan.write(true)

      return
    }

    if (vault.cfxOnly && type !== 'cfx') return

    if (vault.type === 'pub') {
      // vault.type is 'pub'

      const addrTx = newAddressTx({
        eid: -1,
        hex: vault.ddata,
        network: eid,
        value:
          type === 'cfx'
            ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .encode */ .cv)((0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_4__/* .toAccountAddress */ .RE)(vault.ddata), netId)
            : vault.ddata,
      })
      t([
        addrTx,
        {
          eid: -2,
          account: {
            index: 0,
            nickname: groupName,
            address: addrTx.eid,
            hidden: false,
          },
        },
        {
          eid: groupId,
          accountGroup: {account: -2},
        },
      ])
      firstAccountCreatedChan.write(true)
      return
    }

    if (vault.type === 'hw') {
      if (!vault.cfxOnly && type === 'cfx') return
      accounts.forEach(({address, nickname}, idx) => {
        const [account] = findAccount({groupId, index: idx})
        const hex = type === 'cfx' ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .decode */ .Jx)(address).hexAddress : address
        const value =
          type === 'cfx' ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .encode */ .cv)((0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .decode */ .Jx)(address).hexAddress, netId) : address

        const addrTx = newAddressTx({
          eid: -1,
          value,
          hex,
          network: eid,
        })

        t([
          addrTx,
          {
            eid: account ?? -2,
            account: {
              index: idx,
              nickname,
              address: addrTx.eid,
              hidden: false,
            },
          },
          {
            eid: groupId,
            accountGroup: {account: account ?? -2},
          },
        ])
        idx === 0 && firstAccountCreatedChan.write(true)
      })
      return
    }
  })
}

async function newAccountGroup(arg) {
  const {
    selectedAccountSetChan,
    params: {nickname},
    db: {getAccountGroupByVaultType, getVaultById, t},
    vaultId,
  } = arg
  const vault = getVaultById(vaultId)
  const groupIds = getAccountGroupByVaultType(vault.type)
  const groupName =
    nickname || `${DefaultGroupNamePrefix[vault.type]}${groupIds.length + 1}`

  const {tempids} = t([
    {
      eid: -1,
      accountGroup: {nickname: groupName, vault: vaultId, hidden: false},
    },
  ])
  const groupId = tempids['-1']

  const newAccountsPromise = newAccounts({
    ...arg,
    vault,
    groupId,
    groupName,
  }).then(() => {
    selectNewlyCreatedAccountGroupFirstAccount({...arg, groupId}).then(
      selectedAccountSetChan.write(true),
    )
  })

  await newAccountsPromise

  return groupId
}

const processAddress = address => {
  const isBase32 = (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .validateBase32Address */ .pd)(address)
  if (!isBase32) return {address, cfxOnly: false}
  return {
    cfxOnly: true,
    address: (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_3__/* .decode */ .Jx)(address).hexAddress.toString('hex'),
  }
}

const main = async arg => {
  const {
    db: {
      getAddress,
      createVault,
      getVault,
      findGroup,
      getVaultById,
      getPassword,
      getLocked,
    },
    rpcs: {wallet_validatePassword, wallet_deleteAccountGroup, wallet_unlock},
    params: {
      device = 'FluentWebExt',
      password: optionalPassword,
      accountGroupData,
      mnemonic,
      privateKey,
      address,
      cfxOnly,
      force,
    },
    Err: {InvalidParams},
  } = arg
  const isFirstGroup = !findGroup()?.length
  const isLocked = getLocked()
  let password = optionalPassword

  // need password on first import
  if (isLocked && isFirstGroup && !password)
    throw InvalidParams('Invalid password')

  // need wallet to be unlocked on rest import
  if (!isFirstGroup && !password) password = getPassword()

  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  // create vault to be added
  const vault = {cfxOnly: false, device}
  vault.data = mnemonic || privateKey || address || accountGroupData
  if (privateKey) {
    vault.type = 'pk'
    vault.data = (0,_fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_5__/* .stripHexPrefix */ .MT)(privateKey)
  } else if (mnemonic) {
    vault.type = 'hd'
    if (cfxOnly) vault.cfxOnly = true
  } else if (address) {
    const validateResult = processAddress(address)
    vault.type = 'pub'
    vault.data = validateResult.address
    vault.cfxOnly = validateResult.cfxOnly
  } else if (accountGroupData) {
    vault.type = 'hw'
    vault.data = JSON.stringify(accountGroupData)
    vault.cfxOnly = cfxOnly
  }

  const vaults = getVault({type: vault.type}) || []

  // check duplicate vaults
  const anyDuplicateVaults = (
    await Promise.all(
      vaults.map(
        (0,_fluent_wallet_compose__WEBPACK_IMPORTED_MODULE_7__/* .compL */ .zv)(
          async v => [v.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_2__.decrypt)(password, v.data)), v.eid],
          p => p.then(([ddata, eid]) => (ddata === vault.data ? eid : null)),
        ),
      ),
    )
  ).filter(v => Boolean(v))

  if (anyDuplicateVaults.length) {
    const [duplicateVaultId] = anyDuplicateVaults
    const [duplicateAccountGroupId] = findGroup({vault: duplicateVaultId})
    const duplicateVault = getVaultById(duplicateVaultId)

    if (force) {
      if (duplicateVault.type !== 'hd')
        throw InvalidParams("Can't force import none hd vault")
      await wallet_deleteAccountGroup({
        accountGroupId: duplicateAccountGroupId,
        password,
      })
    } else {
      let err
      if (vault.type === 'hd' && duplicateVault.cfxOnly !== vault.cfxOnly) {
        err = InvalidParams(
          `Duplicate credential(with different cfxOnly setting) with account group ${duplicateAccountGroupId}`,
        )
        err.extra.updateCfxOnly = true
      } else {
        err = InvalidParams(
          `Duplicate credential with account group ${duplicateAccountGroupId}`,
        )
      }
      err.extra.duplicateAccountGroupId = duplicateAccountGroupId
      throw err
    }
  }

  vault.ddata = vault.data
  vault.data = await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_2__.encrypt)(password, vault.data)

  const vaultId = createVault(vault)
  if (isFirstGroup) await wallet_unlock({password, waitSideEffects: true})
  const selectedAccountSetChan = (0,_fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_6__/* .chan */ .zH)(1)
  const firstAccountCreatedChan = (0,_fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_6__/* .chan */ .zH)(1)
  const allAccountCreatedChan = (0,_fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_6__/* .chan */ .zH)(1)
  const groupId = newAccountGroup({
    ...arg,
    vaultId,
    allAccountCreatedChan,
    selectedAccountSetChan,
    firstAccountCreatedChan,
  })

  const promises = [
    selectedAccountSetChan.read(),
    firstAccountCreatedChan.read(),
  ]
  if (arg.params.waitTillFinish) promises.push(allAccountCreatedChan.read())

  return await Promise.all(promises).then(() => {
    ;(0,_fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_0__/* .updateUserId */ .O5)(getAddress()?.[0]?.hex)
    if (isFirstGroup) (0,_fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_0__/* .captureMessage */ .uT)('user_created_first_account_group')
    return groupId
  })
}


/***/ }),

/***/ 37665:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/__.js
/**
 * A special placeholder value used to specify "gaps" within curried functions,
 * allowing partial application of any combination of arguments, regardless of
 * their positions.
 *
 * If `g` is a curried ternary function and `_` is `R.__`, the following are
 * equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2, _)(1, 3)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @name __
 * @constant
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @example
 *
 *      const greet = R.replace('{name}', R.__, 'Hello, {name}!');
 *      greet('Alice'); //=> 'Hello, Alice!'
 */
/* harmony default export */ const _ = ({
  '@@functional/placeholder': true
});
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a) {
  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_curry1.js

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curry1_curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_curry2.js


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curry2_curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;

      case 1:
        return _isPlaceholder(a) ? f2 : _curry1_curry1(function (_b) {
          return fn(a, _b);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1_curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1_curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isArray.js
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
/* harmony default export */ const internal_isArray = (Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
});
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isTransformer.js
function _isTransformer_isTransformer(obj) {
  return obj != null && typeof obj['@@transducer/step'] === 'function';
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_dispatchable.js


/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer created by [transducerCreator] to return a new transformer
 * (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} transducerCreator transducer factory if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */

function _dispatchable(methodNames, transducerCreator, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }

    var obj = arguments[arguments.length - 1];

    if (!internal_isArray(obj)) {
      var idx = 0;

      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
        }

        idx += 1;
      }

      if (_isTransformer_isTransformer(obj)) {
        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
        return transducer(obj);
      }
    }

    return fn.apply(this, arguments);
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_reduced.js
function _reduced_reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xfBase.js
/* harmony default export */ const _xfBase = ({
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
});
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xall.js




var XAll =
/*#__PURE__*/
function () {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }

  XAll.prototype['@@transducer/init'] = _xfBase.init;

  XAll.prototype['@@transducer/result'] = function (result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }

    return this.xf['@@transducer/result'](result);
  };

  XAll.prototype['@@transducer/step'] = function (result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced_reduced(this.xf['@@transducer/step'](result, false));
    }

    return result;
  };

  return XAll;
}();

var _xall =
/*#__PURE__*/
_curry2_curry2(function _xall(f, xf) {
  return new XAll(f, xf);
});

/* harmony default export */ const internal_xall = (_xall);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/all.js



/**
 * Returns `true` if all elements of the list match the predicate, `false` if
 * there are any that don't.
 *
 * Dispatches to the `all` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none, R.transduce
 * @example
 *
 *      const equals3 = R.equals(3);
 *      R.all(equals3)([3, 3, 3, 3]); //=> true
 *      R.all(equals3)([3, 3, 1, 3]); //=> false
 */

var all_all =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['all'], internal_xall, function all(fn, list) {
  var idx = 0;

  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }

    idx += 1;
  }

  return true;
}));

/* harmony default export */ const es_all = ((/* unused pure expression or super */ null && (all_all)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_map.js
function _map_map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);

  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }

  return result;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isString.js
function _isString_isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isArrayLike.js



/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 *      _isArrayLike({nodeType: 1, length: 1}) // => false
 */

var _isArrayLike_isArrayLike =
/*#__PURE__*/
_curry1_curry1(function isArrayLike(x) {
  if (internal_isArray(x)) {
    return true;
  }

  if (!x) {
    return false;
  }

  if (typeof x !== 'object') {
    return false;
  }

  if (_isString_isString(x)) {
    return false;
  }

  if (x.length === 0) {
    return true;
  }

  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }

  return false;
});

/* harmony default export */ const internal_isArrayLike = (_isArrayLike_isArrayLike);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xwrap.js
var XWrap =
/*#__PURE__*/
function () {
  function XWrap(fn) {
    this.f = fn;
  }

  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };

  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };

  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap_xwrap(fn) {
  return new XWrap(fn);
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_arity.js
function _arity_arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };

    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };

    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };

    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };

    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };

    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };

    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };

    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };

    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };

    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };

    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };

    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/bind.js


/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      const log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */

var bind =
/*#__PURE__*/
_curry2_curry2(function bind(fn, thisObj) {
  return _arity_arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});

/* harmony default export */ const es_bind = (bind);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_reduce.js




function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    idx += 1;
  }

  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();

  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    step = iter.next();
  }

  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](es_bind(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
function _reduce_reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = _xwrap_xwrap(fn);
  }

  if (internal_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }

  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }

  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }

  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }

  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xmap.js



var XMap =
/*#__PURE__*/
function () {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;

  XMap.prototype['@@transducer/step'] = function (result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return XMap;
}();

var _xmap =
/*#__PURE__*/
_curry2_curry2(function _xmap(f, xf) {
  return new XMap(f, xf);
});

/* harmony default export */ const internal_xmap = (_xmap);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_curryN.js


/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curryN_curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;

    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;

      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }

      combined[combinedIdx] = result;

      if (!_isPlaceholder(result)) {
        left -= 1;
      }

      combinedIdx += 1;
    }

    return left <= 0 ? fn.apply(this, combined) : _arity_arity(left, _curryN_curryN(length, combined, fn));
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/curryN.js




/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      const sumArgs = (...args) => R.sum(args);
 *
 *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */

var curryN_curryN =
/*#__PURE__*/
_curry2_curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1_curry1(fn);
  }

  return _arity_arity(length, _curryN_curryN(length, [], fn));
});

/* harmony default export */ const es_curryN = (curryN_curryN);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_has.js
function _has_has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isArguments.js

var _isArguments_toString = Object.prototype.toString;

var _isArguments_isArguments =
/*#__PURE__*/
function () {
  return _isArguments_toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return _isArguments_toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has_has('callee', x);
  };
}();

/* harmony default export */ const internal_isArguments = (_isArguments_isArguments);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/keys.js


 // cover IE < 9 keys issues

var hasEnumBug = !
/*#__PURE__*/
{
  toString: null
}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

var hasArgsEnumBug =
/*#__PURE__*/
function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;

  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }

    idx += 1;
  }

  return false;
};
/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values, R.toPairs
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */


var keys_keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
/*#__PURE__*/
_curry1_curry1(function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) :
/*#__PURE__*/
_curry1_curry1(function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }

  var prop, nIdx;
  var ks = [];

  var checkArgsLength = hasArgsEnumBug && internal_isArguments(obj);

  for (prop in obj) {
    if (_has_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }

  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;

    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];

      if (_has_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }

      nIdx -= 1;
    }
  }

  return ks;
});
/* harmony default export */ const es_keys = (keys_keys);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/map.js







/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex, R.pluck, R.project
 * @example
 *
 *      const double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */

var map_map =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['fantasy-land/map', 'map'], internal_xmap, function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return es_curryN(functor.length, function () {
        return fn.call(this, functor.apply(this, arguments));
      });

    case '[object Object]':
      return _reduce_reduce(function (acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, es_keys(functor));

    default:
      return _map_map(fn, functor);
  }
}));

/* harmony default export */ const es_map = (map_map);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isInteger.js
/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
/* harmony default export */ const internal_isInteger = (Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
});
;// CONCATENATED MODULE: ../../node_modules/ramda/es/nth.js


/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      const list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */

var nth_nth =
/*#__PURE__*/
_curry2_curry2(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString_isString(list) ? list.charAt(idx) : list[idx];
});

/* harmony default export */ const es_nth = (nth_nth);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/prop.js



/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @typedefn Idx = String | Int | Symbol
 * @sig Idx -> {s: a} -> a | Undefined
 * @param {String|Number} p The property name or array index
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path, R.props, R.pluck, R.project, R.nth
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 *      R.prop(0, [100]); //=> 100
 *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
 */

var prop_prop =
/*#__PURE__*/
_curry2_curry2(function prop(p, obj) {
  if (obj == null) {
    return;
  }

  return internal_isInteger(p) ? es_nth(p, obj) : obj[p];
});

/* harmony default export */ const es_prop = (prop_prop);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pluck.js



/**
 * Returns a new list by plucking the same named property off all objects in
 * the list supplied.
 *
 * `pluck` will work on
 * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
 * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => k -> f {k: v} -> f v
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} f The array or functor to consider.
 * @return {Array} The list of values for the given key.
 * @see R.project, R.prop, R.props
 * @example
 *
 *      var getAges = R.pluck('age');
 *      getAges([{name: 'fred', age: 29}, {name: 'wilma', age: 27}]); //=> [29, 27]
 *
 *      R.pluck(0, [[1, 2], [3, 4]]);               //=> [1, 3]
 *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
 */

var pluck_pluck =
/*#__PURE__*/
_curry2_curry2(function pluck(p, list) {
  return es_map(es_prop(p), list);
});

/* harmony default export */ const es_pluck = (pluck_pluck);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_curry3.js



/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curry3_curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;

      case 1:
        return _isPlaceholder(a) ? f3 : _curry2_curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });

      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2_curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2_curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1_curry1(function (_c) {
          return fn(a, b, _c);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2_curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2_curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2_curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1_curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1_curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1_curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/reduce.js


/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */

var reduce_reduce =
/*#__PURE__*/
_curry3_curry3(_reduce_reduce);

/* harmony default export */ const es_reduce = (reduce_reduce);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/allPass.js





/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if every one of the provided predicates is satisfied
 * by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.anyPass
 * @example
 *
 *      const isQueen = R.propEq('rank', 'Q');
 *      const isSpade = R.propEq('suit', '');
 *      const isQueenOfSpades = R.allPass([isQueen, isSpade]);
 *
 *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
 *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
 */

var allPass =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function allPass(preds) {
  return curryN(reduce(max, 0, pluck('length', preds)), function () {
    var idx = 0;
    var len = preds.length;

    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }

      idx += 1;
    }

    return true;
  });
})));

/* harmony default export */ const es_allPass = ((/* unused pure expression or super */ null && (allPass)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xany.js




var XAny =
/*#__PURE__*/
function () {
  function XAny(f, xf) {
    this.xf = xf;
    this.f = f;
    this.any = false;
  }

  XAny.prototype['@@transducer/init'] = _xfBase.init;

  XAny.prototype['@@transducer/result'] = function (result) {
    if (!this.any) {
      result = this.xf['@@transducer/step'](result, false);
    }

    return this.xf['@@transducer/result'](result);
  };

  XAny.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.any = true;
      result = _reduced_reduced(this.xf['@@transducer/step'](result, true));
    }

    return result;
  };

  return XAny;
}();

var _xany =
/*#__PURE__*/
_curry2_curry2(function _xany(f, xf) {
  return new XAny(f, xf);
});

/* harmony default export */ const internal_xany = (_xany);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/any.js



/**
 * Returns `true` if at least one of the elements of the list match the predicate,
 * `false` otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
 *         otherwise.
 * @see R.all, R.none, R.transduce
 * @example
 *
 *      const lessThan0 = R.flip(R.lt)(0);
 *      const lessThan2 = R.flip(R.lt)(2);
 *      R.any(lessThan0)([1, 2]); //=> false
 *      R.any(lessThan2)([1, 2]); //=> true
 */

var any =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['any'], internal_xany, function any(fn, list) {
  var idx = 0;

  while (idx < list.length) {
    if (fn(list[idx])) {
      return true;
    }

    idx += 1;
  }

  return false;
}));

/* harmony default export */ const es_any = (any);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/anyPass.js





/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if at least one of the provided predicates is
 * satisfied by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.allPass
 * @example
 *
 *      const isClub = R.propEq('suit', '');
 *      const isSpade = R.propEq('suit', '');
 *      const isBlackCard = R.anyPass([isClub, isSpade]);
 *
 *      isBlackCard({rank: '10', suit: ''}); //=> true
 *      isBlackCard({rank: 'Q', suit: ''}); //=> true
 *      isBlackCard({rank: 'Q', suit: ''}); //=> false
 */

var anyPass =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function anyPass(preds) {
  return curryN(reduce(max, 0, pluck('length', preds)), function () {
    var idx = 0;
    var len = preds.length;

    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }

      idx += 1;
    }

    return false;
  });
})));

/* harmony default export */ const es_anyPass = ((/* unused pure expression or super */ null && (anyPass)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_concat.js
/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat_concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];
  idx = 0;

  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }

  idx = 0;

  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }

  return result;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/ap.js




/**
 * ap applies a list of functions to a list of values.
 *
 * Dispatches to the `ap` method of the second argument, if present. Also
 * treats curried functions as applicatives.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig [a -> b] -> [a] -> [b]
 * @sig Apply f => f (a -> b) -> f a -> f b
 * @sig (r -> a -> b) -> (r -> a) -> (r -> b)
 * @param {*} applyF
 * @param {*} applyX
 * @return {*}
 * @example
 *
 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
 *
 *      // R.ap can also be used as S combinator
 *      // when only two functions are passed
 *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
 */

var ap_ap =
/*#__PURE__*/
_curry2_curry2(function ap(applyF, applyX) {
  return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
    return applyF(x)(applyX(x));
  } : _reduce_reduce(function (acc, f) {
    return _concat_concat(acc, es_map(f, applyX));
  }, [], applyF);
});

/* harmony default export */ const es_ap = (ap_ap);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_aperture.js
function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);

  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }

  return acc;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xaperture.js




var XAperture =
/*#__PURE__*/
function () {
  function XAperture(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }

  XAperture.prototype['@@transducer/init'] = _xfBase.init;

  XAperture.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };

  XAperture.prototype['@@transducer/step'] = function (result, input) {
    this.store(input);
    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
  };

  XAperture.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;

    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };

  XAperture.prototype.getCopy = function () {
    return _concat_concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };

  return XAperture;
}();

var _xaperture =
/*#__PURE__*/
_curry2_curry2(function _xaperture(n, xf) {
  return new XAperture(n, xf);
});

/* harmony default export */ const internal_xaperture = (_xaperture);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/aperture.js




/**
 * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
 * greater than the length of the list, an empty list is returned.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @param {Number} n The size of the tuples to create
 * @param {Array} list The list to split into `n`-length tuples
 * @return {Array} The resulting list of `n`-length tuples
 * @see R.transduce
 * @example
 *
 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
 */

var aperture =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xaperture, _aperture));

/* harmony default export */ const es_aperture = ((/* unused pure expression or super */ null && (aperture)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/values.js


/**
 * Returns a list of all the enumerable own properties of the supplied object.
 * Note that the order of the output array is not guaranteed across different
 * JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own properties.
 * @see R.valuesIn, R.keys, R.toPairs
 * @example
 *
 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
 */

var values_values =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function values(obj) {
  var props = keys(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;

  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }

  return vals;
})));

/* harmony default export */ const es_values = ((/* unused pure expression or super */ null && (values_values)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/applySpec.js








 // Use custom mapValues function to avoid issues with specs that include a "map" key and R.map
// delegating calls to .map

function mapValues(fn, obj) {
  return _isArray(obj) ? obj.map(fn) : keys(obj).reduce(function (acc, key) {
    acc[key] = fn(obj[key]);
    return acc;
  }, {});
}
/**
 * Given a spec object recursively mapping properties to functions, creates a
 * function producing an object of the same structure, by mapping each property
 * to the result of calling its associated function with the supplied arguments.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
 * @param {Object} spec an object recursively mapping properties to functions for
 *        producing the values for these properties.
 * @return {Function} A function that returns an object of the same structure
 * as `spec', with each property set to the value returned by calling its
 * associated function with the supplied arguments.
 * @see R.converge, R.juxt
 * @example
 *
 *      const getMetrics = R.applySpec({
 *        sum: R.add,
 *        nested: { mul: R.multiply }
 *      });
 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
 */


var applySpec =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function applySpec(spec) {
  spec = mapValues(function (v) {
    return typeof v == 'function' ? v : applySpec(v);
  }, spec);
  return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
    var args = arguments;
    return mapValues(function (f) {
      return apply(f, args);
    }, spec);
  });
})));

/* harmony default export */ const es_applySpec = ((/* unused pure expression or super */ null && (applySpec)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_assoc.js


/**
 * Makes a shallow clone of an object, setting or overriding the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @private
 * @param {String|Number} prop The property name to set
 * @param {*} val The new value
 * @param {Object|Array} obj The object to clone
 * @return {Object|Array} A new object equivalent to the original except for the changed property.
 */

function _assoc_assoc(prop, val, obj) {
  if (_isInteger(prop) && _isArray(obj)) {
    var arr = [].concat(obj);
    arr[prop] = val;
    return arr;
  }

  var result = {};

  for (var p in obj) {
    result[p] = obj[p];
  }

  result[prop] = val;
  return result;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/assocPath.js





/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Idx = String | Int | Symbol
 * @sig [Idx] -> a -> {a} -> {a}
 * @param {Array} path the path to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except along the specified path.
 * @see R.dissocPath
 * @example
 *
 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
 *
 *      // Any missing or non-object keys in path will be overridden
 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
 */

var assocPath_assocPath =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function assocPath(path, val, obj) {
  if (path.length === 0) {
    return val;
  }

  var idx = path[0];

  if (path.length > 1) {
    var nextObj = !isNil(obj) && _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
  }

  return _assoc(idx, val, obj);
})));

/* harmony default export */ const es_assocPath = ((/* unused pure expression or super */ null && (assocPath_assocPath)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/assoc.js


/**
 * Makes a shallow clone of an object, setting or overriding the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig Idx -> a -> {k: v} -> {k: v}
 * @param {String|Number} prop The property name to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except for the changed property.
 * @see R.dissoc, R.pick
 * @example
 *
 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
 */

var assoc_assoc =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function assoc(prop, val, obj) {
  return assocPath([prop], val, obj);
})));

/* harmony default export */ const es_assoc = ((/* unused pure expression or super */ null && (assoc_assoc)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/liftN.js





/**
 * "lifts" a function to be the specified arity, so that it may "map over" that
 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig Number -> (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.lift, R.ap
 * @example
 *
 *      const madd3 = R.liftN(3, (...args) => R.sum(args));
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 */

var liftN =
/*#__PURE__*/
_curry2_curry2(function liftN(arity, fn) {
  var lifted = es_curryN(arity, fn);
  return es_curryN(arity, function () {
    return _reduce_reduce(es_ap, es_map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});

/* harmony default export */ const es_liftN = (liftN);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/lift.js


/**
 * "lifts" a function of arity >= 1 so that it may "map over" a list, Function or other
 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.liftN
 * @example
 *
 *      const madd3 = R.lift((a, b, c) => a + b + c);
 *
 *      madd3([100, 200], [30, 40], [5, 6, 7]); //=> [135, 136, 137, 145, 146, 147, 235, 236, 237, 245, 246, 247]
 *
 *      const madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
 *
 *      madd5([10, 20], [1], [2, 3], [4], [100, 200]); //=> [117, 217, 118, 218, 127, 227, 128, 228]
 */

var lift_lift =
/*#__PURE__*/
_curry1_curry1(function lift(fn) {
  return es_liftN(fn.length, fn);
});

/* harmony default export */ const es_lift = (lift_lift);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/both.js




/**
 * A function which calls the two provided functions and returns the `&&`
 * of the results.
 * It returns the result of the first function if it is false-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * false-y value.
 *
 * In addition to functions, `R.both` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
 * @see R.either, R.and
 * @example
 *
 *      const gt10 = R.gt(R.__, 10)
 *      const lt20 = R.lt(R.__, 20)
 *      const f = R.both(gt10, lt20);
 *      f(15); //=> true
 *      f(30); //=> false
 *
 *      R.both(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(false)
 *      R.both([false, false, 'a'], [11]); //=> [false, false, 11]
 */

var both =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function both(f, g) {
  return _isFunction(f) ? function _both() {
    return f.apply(this, arguments) && g.apply(this, arguments);
  } : lift(and)(f, g);
})));

/* harmony default export */ const es_both = ((/* unused pure expression or super */ null && (both)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_makeFlat.js

/**
 * `_makeFlat` is a helper function that returns a one-level or fully recursive
 * function based on the flag passed in.
 *
 * @private
 */

function _makeFlat_makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;

    while (idx < ilen) {
      if (internal_isArrayLike(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value.length;

        while (j < jlen) {
          result[result.length] = value[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }

      idx += 1;
    }

    return result;
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_forceReduced.js
function _forceReduced(x) {
  return {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_flatCat.js





var preservingReduced = function (xf) {
  return {
    '@@transducer/init': _xfBase.init,
    '@@transducer/result': function (result) {
      return xf['@@transducer/result'](result);
    },
    '@@transducer/step': function (result, input) {
      var ret = xf['@@transducer/step'](result, input);
      return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
    }
  };
};

var _flatCat = function _xcat(xf) {
  var rxf = preservingReduced(xf);
  return {
    '@@transducer/init': _xfBase.init,
    '@@transducer/result': function (result) {
      return rxf['@@transducer/result'](result);
    },
    '@@transducer/step': function (result, input) {
      return !internal_isArrayLike(input) ? _reduce_reduce(rxf, result, [input]) : _reduce_reduce(rxf, result, input);
    }
  };
};

/* harmony default export */ const internal_flatCat = (_flatCat);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xchain.js




var _xchain =
/*#__PURE__*/
_curry2_curry2(function _xchain(f, xf) {
  return es_map(f, internal_flatCat(xf));
});

/* harmony default export */ const internal_xchain = (_xchain);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/chain.js





/**
 * `chain` maps a function over a list and concatenates the results. `chain`
 * is also known as `flatMap` in some libraries.
 *
 * Dispatches to the `chain` method of the second argument, if present,
 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
 *
 * If second argument is a function, `chain(f, g)(x)` is equivalent to `f(g(x), x)`.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain m => (a -> m b) -> m a -> m b
 * @param {Function} fn The function to map with
 * @param {Array} list The list to map over
 * @return {Array} The result of flat-mapping `list` with `fn`
 * @example
 *
 *      const duplicate = n => [n, n];
 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
 *
 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
 */

var chain =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['fantasy-land/chain', 'chain'], internal_xchain, function chain(fn, monad) {
  if (typeof monad === 'function') {
    return function (x) {
      return fn(monad(x))(x);
    };
  }

  return _makeFlat_makeFlat(false)(es_map(fn, monad));
}));

/* harmony default export */ const es_chain = (chain);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/collectBy.js


/**
 * Splits a list into sub-lists, based on the result of calling a key-returning function on each element,
 * and grouping the results according to values returned.
 *
 * @func
 * @memberOf R
 * @since v0.28.0
 * @category List
 * @typedefn Idx = String | Int | Symbol
 * @sig Idx a => (b -> a) -> [b] -> [[b]]
 * @param {Function} fn Function :: a -> Idx
 * @param {Array} list The array to group
 * @return {Array}
 *    An array of arrays where each sub-array contains items for which
 *    the String-returning function has returned the same value.
 * @see R.groupBy, R.partition
 * @example
 *      R.collectBy(R.prop('type'), [
 *        {type: 'breakfast', item: ''},
 *        {type: 'lunch', item: ''},
 *        {type: 'dinner', item: ''},
 *        {type: 'breakfast', item: ''},
 *        {type: 'lunch', item: ''}
 *      ]);
 *
 *      // [ [ {type: 'breakfast', item: ''},
 *      //     {type: 'breakfast', item: ''} ],
 *      //   [ {type: 'lunch', item: ''},
 *      //     {type: 'lunch', item: ''} ],
 *      //   [ {type: 'dinner', item: ''} ] ]
 */

var collectBy =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function collectBy(fn, list) {
  var group = _reduce(function (o, x) {
    var tag = fn(x);

    if (o[tag] === undefined) {
      o[tag] = [];
    }

    o[tag].push(x);
    return o;
  }, {}, list);

  var newList = [];

  for (var tag in group) {
    newList.push(group[tag]);
  }

  return newList;
})));

/* harmony default export */ const es_collectBy = ((/* unused pure expression or super */ null && (collectBy)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/not.js

/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */

var not =
/*#__PURE__*/
_curry1_curry1(function not(a) {
  return !a;
});

/* harmony default export */ const es_not = (not);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/complement.js


/**
 * Takes a function `f` and returns a function `g` such that if called with the same arguments
 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
 *
 * `R.complement` may be applied to any functor
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> *) -> (*... -> Boolean)
 * @param {Function} f
 * @return {Function}
 * @see R.not
 * @example
 *
 *      const isNotNil = R.complement(R.isNil);
 *      R.isNil(null); //=> true
 *      isNotNil(null); //=> false
 *      R.isNil(7); //=> false
 *      isNotNil(7); //=> true
 */

var complement =
/*#__PURE__*/
es_lift(es_not);
/* harmony default export */ const es_complement = ((/* unused pure expression or super */ null && (complement)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_pipe.js
function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_checkForMethod.js

/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implementation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */

function _checkForMethod_checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;

    if (length === 0) {
      return fn();
    }

    var obj = arguments[length - 1];
    return internal_isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/slice.js


/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */

var slice_slice =
/*#__PURE__*/
_curry3_curry3(
/*#__PURE__*/
_checkForMethod_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

/* harmony default export */ const es_slice = (slice_slice);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/tail.js



/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */

var tail_tail =
/*#__PURE__*/
_curry1_curry1(
/*#__PURE__*/
_checkForMethod_checkForMethod('tail',
/*#__PURE__*/
es_slice(1, Infinity)));

/* harmony default export */ const es_tail = (tail_tail);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pipe.js




/**
 * Performs left-to-right function composition. The first argument may have
 * any arity; the remaining arguments must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      const f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 * @symb R.pipe(f, g, h)(a)(b) = h(g(f(a)))(b)
 */

function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }

  return _arity_arity(arguments[0].length, es_reduce(_pipe, arguments[0], es_tail(arguments)));
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/reverse.js


/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */

var reverse_reverse =
/*#__PURE__*/
_curry1_curry1(function reverse(list) {
  return _isString_isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});

/* harmony default export */ const es_reverse = (reverse_reverse);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/compose.js


/**
 * Performs right-to-left function composition. The last argument may have
 * any arity; the remaining arguments must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 * @symb R.compose(f, g, h)(a)(b) = f(g(h(a)))(b)
 */

function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }

  return pipe.apply(this, es_reverse(arguments));
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pipeWith.js






/**
 * Performs left-to-right function composition using transforming function. The first function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of pipeWith is not automatically curried. Transforming function is not used on the
 * first argument.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category Function
 * @sig ((* -> *), [((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)]) -> ((a, b, ..., n) -> z)
 * @param {Function} transformer The transforming function
 * @param {Array} functions The functions to pipe
 * @return {Function}
 * @see R.composeWith, R.pipe
 * @example
 *
 *      const pipeWhileNotNil = R.pipeWith((f, res) => R.isNil(res) ? res : f(res));
 *      const f = pipeWhileNotNil([Math.pow, R.negate, R.inc])
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipeWith(f)([g, h, i])(...args) = f(i, f(h, g(...args)))
 */

var pipeWith_pipeWith =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function pipeWith(xf, list) {
  if (list.length <= 0) {
    return identity;
  }

  var headList = head(list);
  var tailList = tail(list);
  return _arity(headList.length, function () {
    return _reduce(function (result, f) {
      return xf.call(this, f, result);
    }, headList.apply(this, arguments), tailList);
  });
})));

/* harmony default export */ const es_pipeWith = ((/* unused pure expression or super */ null && (pipeWith_pipeWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/composeWith.js



/**
 * Performs right-to-left function composition using transforming function. The last function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of composeWith is not automatically curried. Transforming function is not used
 * on the last argument.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category Function
 * @sig ((* -> *), [(y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)]) -> ((a, b, ..., n) -> z)
 * @param {Function} transformer The transforming function
 * @param {Array} functions The functions to compose
 * @return {Function}
 * @see R.compose, R.pipeWith
 * @example
 *
 *      const composeWhileNotNil = R.composeWith((f, res) => R.isNil(res) ? res : f(res));
 *
 *      composeWhileNotNil([R.inc, R.prop('age')])({age: 1}) //=> 2
 *      composeWhileNotNil([R.inc, R.prop('age')])({}) //=> undefined
 *
 * @symb R.composeWith(f)([g, h, i])(...args) = f(g, f(h, i(...args)))
 */

var composeWith =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function composeWith(xf, list) {
  return pipeWith.apply(this, [xf, reverse(list)]);
})));

/* harmony default export */ const es_composeWith = ((/* unused pure expression or super */ null && (composeWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_arrayFromIterator.js
function _arrayFromIterator(iter) {
  var list = [];
  var next;

  while (!(next = iter.next()).done) {
    list.push(next.value);
  }

  return list;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_includesWith.js
function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }

    idx += 1;
  }

  return false;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_functionName.js
function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_objectIs.js
// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function _objectIs(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
}

/* harmony default export */ const internal_objectIs = (typeof Object.is === 'function' ? Object.is : _objectIs);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/type.js

/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */

var type =
/*#__PURE__*/
_curry1_curry1(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});

/* harmony default export */ const es_type = (type);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_equals.js







/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparison of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 * */

function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);

  var b = _arrayFromIterator(bIterator);

  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  } // if *a* array contains any element that is not included in *b*


  return !_includesWith(function (b, aItem) {
    return !_includesWith(eq, aItem, b);
  }, b, a);
}

function _equals(a, b, stackA, stackB) {
  if (internal_objectIs(a, b)) {
    return true;
  }

  var typeA = es_type(a);

  if (typeA !== es_type(b)) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
        return a === b;
      }

      break;

    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && internal_objectIs(a.valueOf(), b.valueOf()))) {
        return false;
      }

      break;

    case 'Date':
      if (!internal_objectIs(a.valueOf(), b.valueOf())) {
        return false;
      }

      break;

    case 'Error':
      return a.name === b.name && a.message === b.message;

    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }

      break;
  }

  var idx = stackA.length - 1;

  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }

    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

    case 'Set':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;

    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = es_keys(a);

  if (keysA.length !== es_keys(b).length) {
    return false;
  }

  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;

  while (idx >= 0) {
    var key = keysA[idx];

    if (!(_has_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }

    idx -= 1;
  }

  return true;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/equals.js


/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      const a = {}; a.v = a;
 *      const b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */

var equals_equals =
/*#__PURE__*/
_curry2_curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

/* harmony default export */ const es_equals = (equals_equals);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_indexOf.js

function _indexOf_indexOf(list, a, idx) {
  var inf, item; // Array.prototype.indexOf doesn't exist below IE9

  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;

          while (idx < list.length) {
            item = list[idx];

            if (item === 0 && 1 / item === inf) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];

            if (typeof item === 'number' && item !== item) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } // non-zero numbers can utilise Set


        return list.indexOf(a, idx);
      // all these types can utilise Set

      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }

    }
  } // anything else not covered above, defer to R.equals


  while (idx < list.length) {
    if (es_equals(list[idx], a)) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_includes.js

function _includes_includes(a, list) {
  return _indexOf_indexOf(list, a, 0) >= 0;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_toISOString.js
/**
 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
 */
var pad = function pad(n) {
  return (n < 10 ? '0' : '') + n;
};

var _toISOString_toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
  return d.toISOString();
} : function _toISOString(d) {
  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
};

/* harmony default export */ const internal_toISOString = ((/* unused pure expression or super */ null && (_toISOString_toISOString)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_complement.js
function _complement_complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_filter.js
function _filter_filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }

    idx += 1;
  }

  return result;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_isObject.js
function _isObject_isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xfilter.js



var XFilter =
/*#__PURE__*/
function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;

  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XFilter;
}();

var _xfilter =
/*#__PURE__*/
_curry2_curry2(function _xfilter(f, xf) {
  return new XFilter(f, xf);
});

/* harmony default export */ const internal_xfilter = (_xfilter);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/filter.js







/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      const isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */

var filter =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['fantasy-land/filter', 'filter'], internal_xfilter, function (pred, filterable) {
  return _isObject_isObject(filterable) ? _reduce_reduce(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }

    return acc;
  }, {}, es_keys(filterable)) : // else
  _filter_filter(pred, filterable);
}));

/* harmony default export */ const es_filter = (filter);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/reject.js



/**
 * The complement of [`filter`](#filter).
 *
 * Acts as a transducer if a transformer is given in list position. Filterable
 * objects include plain objects or any object that has a filter method such
 * as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      const isOdd = (n) => n % 2 !== 0;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */

var reject_reject =
/*#__PURE__*/
_curry2_curry2(function reject(pred, filterable) {
  return es_filter(_complement_complement(pred), filterable);
});

/* harmony default export */ const es_reject = (reject_reject);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_toString.js






function _toString_toString(x, seen) {
  var recur = function recur(y) {
    var xs = seen.concat([x]);
    return _includes(y, xs) ? '<Circular>' : _toString_toString(y, xs);
  }; //  mapPairs :: (Object, [String]) -> [String]


  var mapPairs = function (obj, keys) {
    return _map(function (k) {
      return _quote(k) + ': ' + recur(obj[k]);
    }, keys.slice().sort());
  };

  switch (Object.prototype.toString.call(x)) {
    case '[object Arguments]':
      return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';

    case '[object Array]':
      return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
        return /^\d+$/.test(k);
      }, keys(x)))).join(', ') + ']';

    case '[object Boolean]':
      return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();

    case '[object Date]':
      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';

    case '[object Null]':
      return 'null';

    case '[object Number]':
      return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);

    case '[object String]':
      return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);

    case '[object Undefined]':
      return 'undefined';

    default:
      if (typeof x.toString === 'function') {
        var repr = x.toString();

        if (repr !== '[object Object]') {
          return repr;
        }
      }

      return '{' + mapPairs(x, keys(x)).join(', ') + '}';
  }
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/toString.js


/**
 * Returns the string representation of the given value. `eval`'ing the output
 * should result in a value equivalent to the input value. Many of the built-in
 * `toString` methods do not satisfy this requirement.
 *
 * If the given value is an `[object Object]` with a `toString` method other
 * than `Object.prototype.toString`, this method is invoked with no arguments
 * to produce the return value. This means user-defined constructor functions
 * can provide a suitable `toString` method. For example:
 *
 *     function Point(x, y) {
 *       this.x = x;
 *       this.y = y;
 *     }
 *
 *     Point.prototype.toString = function() {
 *       return 'new Point(' + this.x + ', ' + this.y + ')';
 *     };
 *
 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category String
 * @sig * -> String
 * @param {*} val
 * @return {String}
 * @example
 *
 *      R.toString(42); //=> '42'
 *      R.toString('abc'); //=> '"abc"'
 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
 */

var toString_toString =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function toString(val) {
  return _toString(val, []);
})));

/* harmony default export */ const es_toString = ((/* unused pure expression or super */ null && (toString_toString)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/concat.js





/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `R.concat` expects both arguments to be of the same type,
 * unlike the native `Array.prototype.concat` method. It will throw
 * an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 * Can also concatenate two members of a [fantasy-land
 * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} firstList The first list
 * @param {Array|String} secondList The second list
 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
 * `secondList`.
 *
 * @example
 *
 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 *      R.concat([], []); //=> []
 */

var concat_concat =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function concat(a, b) {
  if (_isArray(a)) {
    if (_isArray(b)) {
      return a.concat(b);
    }

    throw new TypeError(toString(b) + ' is not an array');
  }

  if (_isString(a)) {
    if (_isString(b)) {
      return a + b;
    }

    throw new TypeError(toString(b) + ' is not a string');
  }

  if (a != null && _isFunction(a['fantasy-land/concat'])) {
    return a['fantasy-land/concat'](b);
  }

  if (a != null && _isFunction(a.concat)) {
    return a.concat(b);
  }

  throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
})));

/* harmony default export */ const es_concat = ((/* unused pure expression or super */ null && (concat_concat)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/cond.js





/**
 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
 * to `fn` are applied to each of the predicates in turn until one returns a
 * "truthy" value, at which point `fn` returns the result of applying its
 * arguments to the corresponding transformer. If none of the predicates
 * matches, `fn` returns undefined.
 *
 * **Please note**: This is not a direct substitute for a `switch` statement.
 * Remember that both elements of every pair passed to `cond` are *functions*,
 * and `cond` returns a function.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Logic
 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
 * @param {Array} pairs A list of [predicate, transformer]
 * @return {Function}
 * @see R.ifElse, R.unless, R.when
 * @example
 *
 *      const fn = R.cond([
 *        [R.equals(0),   R.always('water freezes at 0C')],
 *        [R.equals(100), R.always('water boils at 100C')],
 *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
 *      ]);
 *      fn(0); //=> 'water freezes at 0C'
 *      fn(50); //=> 'nothing special happens at 50C'
 *      fn(100); //=> 'water boils at 100C'
 */

var cond =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function cond(pairs) {
  var arity = reduce(max, 0, map(function (pair) {
    return pair[0].length;
  }, pairs));
  return _arity(arity, function () {
    var idx = 0;

    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }

      idx += 1;
    }
  });
})));

/* harmony default export */ const es_cond = ((/* unused pure expression or super */ null && (cond)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/max.js

/**
 * Returns the larger of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.maxBy, R.min
 * @example
 *
 *      R.max(789, 123); //=> 789
 *      R.max('a', 'b'); //=> 'b'
 */

var max_max =
/*#__PURE__*/
_curry2_curry2(function max(a, b) {
  return b > a ? b : a;
});

/* harmony default export */ const es_max = (max_max);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/converge.js






/**
 * Accepts a converging function and a list of branching functions and returns
 * a new function. The arity of the new function is the same as the arity of
 * the longest branching function. When invoked, this new function is applied
 * to some arguments, and each branching function is applied to those same
 * arguments. The results of each branching function are passed as arguments
 * to the converging function to produce the return value.
 *
 * @func
 * @memberOf R
 * @since v0.4.2
 * @category Function
 * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} after A function. `after` will be invoked with the return values of
 *        `fn1` and `fn2` as its arguments.
 * @param {Array} functions A list of functions.
 * @return {Function} A new function.
 * @see R.useWith
 * @example
 *
 *      const average = R.converge(R.divide, [R.sum, R.length])
 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
 *
 *      const strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
 *      strangeConcat("Yodel") //=> "YODELyodel"
 *
 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
 */

var converge =
/*#__PURE__*/
_curry2_curry2(function converge(after, fns) {
  return es_curryN(es_reduce(es_max, 0, es_pluck('length', fns)), function () {
    var args = arguments;
    var context = this;
    return after.apply(context, _map_map(function (fn) {
      return fn.apply(context, args);
    }, fns));
  });
});

/* harmony default export */ const es_converge = (converge);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/count.js


/**
 * Returns the number of items in a given `list` matching the predicate `f`
 *
 * @func
 * @memberOf R
 * @since v0.28.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} predicate to match items against
 * @return {Array} list of items to count in
 * @example
 *
 *      const even = x => x % 2 == 0;
 *
 *      R.count(even, [1, 2, 3, 4, 5]); // => 2
 *      R.map(R.count(even), [[1, 1, 1], [2, 3, 4, 5], [6]]); // => [0, 2, 1]
 */

var count =
/*#__PURE__*/
(/* unused pure expression or super */ null && (curry(function (pred, list) {
  return _reduce(function (a, e) {
    return pred(e) ? a + 1 : a;
  }, 0, list);
})));
/* harmony default export */ const es_count = ((/* unused pure expression or super */ null && (count)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_cloneRegExp.js
function _cloneRegExp_cloneRegExp(pattern) {
  return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_clone.js


/**
 * Copies an object.
 *
 * @private
 * @param {*} value The value to be copied
 * @param {Array} refFrom Array containing the source references
 * @param {Array} refTo Array containing the copied source references
 * @param {Boolean} deep Whether or not to perform deep cloning.
 * @return {*} The copied value.
 */

function _clone_clone(value, refFrom, refTo, deep) {
  var copy = function copy(copiedValue) {
    var len = refFrom.length;
    var idx = 0;

    while (idx < len) {
      if (value === refFrom[idx]) {
        return refTo[idx];
      }

      idx += 1;
    }

    refFrom[idx] = value;
    refTo[idx] = copiedValue;

    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        copiedValue[key] = deep ? _clone_clone(value[key], refFrom, refTo, true) : value[key];
      }
    }

    return copiedValue;
  };

  switch (es_type(value)) {
    case 'Object':
      return copy(Object.create(Object.getPrototypeOf(value)));

    case 'Array':
      return copy([]);

    case 'Date':
      return new Date(value.valueOf());

    case 'RegExp':
      return _cloneRegExp_cloneRegExp(value);

    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'BigInt64Array':
    case 'BigUint64Array':
      return value.slice();

    default:
      return value;
  }
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xreduceBy.js




var XReduceBy =
/*#__PURE__*/
function () {
  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }

  XReduceBy.prototype['@@transducer/init'] = _xfBase.init;

  XReduceBy.prototype['@@transducer/result'] = function (result) {
    var key;

    for (key in this.inputs) {
      if (_has_has(key, this.inputs)) {
        result = this.xf['@@transducer/step'](result, this.inputs[key]);

        if (result['@@transducer/reduced']) {
          result = result['@@transducer/value'];
          break;
        }
      }
    }

    this.inputs = null;
    return this.xf['@@transducer/result'](result);
  };

  XReduceBy.prototype['@@transducer/step'] = function (result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };

  return XReduceBy;
}();

var _xreduceBy =
/*#__PURE__*/
_curryN_curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
  return new XReduceBy(valueFn, valueAcc, keyFn, xf);
});

/* harmony default export */ const internal_xreduceBy = (_xreduceBy);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/reduceBy.js







/**
 * Groups the elements of the list according to the result of calling
 * the String-returning function `keyFn` on each element and reduces the elements
 * of each group to a single value via the reducer function `valueFn`.
 *
 * The value function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to short circuit the iteration.
 *
 * This function is basically a more general [`groupBy`](#groupBy) function.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category List
 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
 * @param {Function} valueFn The function that reduces the elements of each group to a single
 *        value. Receives two values, accumulator for a particular group and the current element.
 * @param {*} acc The (initial) accumulator value for each group.
 * @param {Function} keyFn The function that maps the list's element into a key.
 * @param {Array} list The array to group.
 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
 *         `valueFn` for elements which produced that key when passed to `keyFn`.
 * @see R.groupBy, R.reduce, R.reduced
 * @example
 *
 *      const groupNames = (acc, {name}) => acc.concat(name)
 *      const toGrade = ({score}) =>
 *        score < 65 ? 'F' :
 *        score < 70 ? 'D' :
 *        score < 80 ? 'C' :
 *        score < 90 ? 'B' : 'A'
 *
 *      var students = [
 *        {name: 'Abby', score: 83},
 *        {name: 'Bart', score: 62},
 *        {name: 'Curt', score: 88},
 *        {name: 'Dora', score: 92},
 *      ]
 *
 *      reduceBy(groupNames, [], toGrade, students)
 *      //=> {"A": ["Dora"], "B": ["Abby", "Curt"], "F": ["Bart"]}
 */

var reduceBy_reduceBy =
/*#__PURE__*/
_curryN_curryN(4, [],
/*#__PURE__*/
_dispatchable([], internal_xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
  return _reduce_reduce(function (acc, elt) {
    var key = keyFn(elt);
    var value = valueFn(_has_has(key, acc) ? acc[key] : _clone_clone(valueAcc, [], [], false), elt);

    if (value && value['@@transducer/reduced']) {
      return _reduced_reduced(acc);
    }

    acc[key] = value;
    return acc;
  }, {}, list);
}));

/* harmony default export */ const es_reduceBy = ((/* unused pure expression or super */ null && (reduceBy_reduceBy)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/countBy.js

/**
 * Counts the elements of a list according to how many match each value of a
 * key generated by the supplied function. Returns an object mapping the keys
 * produced by `fn` to the number of occurrences in the list. Note that all
 * keys are coerced to strings because of how JavaScript objects work.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> String) -> [a] -> {*}
 * @param {Function} fn The function used to map values to keys.
 * @param {Array} list The list to count elements from.
 * @return {Object} An object mapping keys to number of occurrences in the list.
 * @example
 *
 *      const numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
 *
 *      const letters = ['a', 'b', 'A', 'a', 'B', 'c'];
 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
 */

var countBy =
/*#__PURE__*/
(/* unused pure expression or super */ null && (reduceBy(function (acc, elem) {
  return acc + 1;
}, 0)));
/* harmony default export */ const es_countBy = ((/* unused pure expression or super */ null && (countBy)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_Set.js


var _Set_Set =
/*#__PURE__*/
function () {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function (item) {
    return !hasOrAdd(item, true, this);
  }; //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //


  _Set.prototype.has = function (item) {
    return hasOrAdd(item, false, this);
  }; //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //


  return _Set;
}();

function hasOrAdd(item, shouldAdd, set) {
  var type = typeof item;
  var prevSize, newSize;

  switch (type) {
    case 'string':
    case 'number':
      // distinguish between +0 and -0
      if (item === 0 && 1 / item === -Infinity) {
        if (set._items['-0']) {
          return true;
        } else {
          if (shouldAdd) {
            set._items['-0'] = true;
          }

          return false;
        }
      } // these types can all utilise the native Set


      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;

          set._nativeSet.add(item);

          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = {};
            set._items[type][item] = true;
          }

          return false;
        } else if (item in set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][item] = true;
          }

          return false;
        }
      }

    case 'boolean':
      // set._items['boolean'] holds a two element array
      // representing [ falseExists, trueExists ]
      if (type in set._items) {
        var bIdx = item ? 1 : 0;

        if (set._items[type][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][bIdx] = true;
          }

          return false;
        }
      } else {
        if (shouldAdd) {
          set._items[type] = item ? [false, true] : [true, false];
        }

        return false;
      }

    case 'function':
      // compare functions for reference equality
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;

          set._nativeSet.add(item);

          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }

          return false;
        }

        if (!_includes_includes(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }

          return false;
        }

        return true;
      }

    case 'undefined':
      if (set._items[type]) {
        return true;
      } else {
        if (shouldAdd) {
          set._items[type] = true;
        }

        return false;
      }

    case 'object':
      if (item === null) {
        if (!set._items['null']) {
          if (shouldAdd) {
            set._items['null'] = true;
          }

          return false;
        }

        return true;
      }

    /* falls through */

    default:
      // reduce the search size of heterogeneous sets by creating buckets
      // for each type.
      type = Object.prototype.toString.call(item);

      if (!(type in set._items)) {
        if (shouldAdd) {
          set._items[type] = [item];
        }

        return false;
      } // scan through all previously applied items


      if (!_includes_includes(item, set._items[type])) {
        if (shouldAdd) {
          set._items[type].push(item);
        }

        return false;
      }

      return true;
  }
} // A simple Set type that honours R.equals semantics


/* harmony default export */ const internal_Set = (_Set_Set);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/difference.js


/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Objects and Arrays are compared in terms of
 * value equality, not reference equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
 * @example
 *
 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
 */

var difference_difference =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function difference(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  var secondLen = second.length;
  var toFilterOut = new _Set();

  for (var i = 0; i < secondLen; i += 1) {
    toFilterOut.add(second[i]);
  }

  while (idx < firstLen) {
    if (toFilterOut.add(first[idx])) {
      out[out.length] = first[idx];
    }

    idx += 1;
  }

  return out;
})));

/* harmony default export */ const es_difference = ((/* unused pure expression or super */ null && (difference_difference)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_dissoc.js



/**
 * Returns a new object that does not contain a `prop` property.
 *
 * @private
 * @param {String|Number} prop The name of the property to dissociate
 * @param {Object|Array} obj The object to clone
 * @return {Object} A new object equivalent to the original but without the specified property
 */

function _dissoc_dissoc(prop, obj) {
  if (obj == null) {
    return obj;
  }

  if (_isInteger(prop) && _isArray(obj)) {
    return remove(prop, 1, obj);
  }

  var result = {};

  for (var p in obj) {
    result[p] = obj[p];
  }

  delete result[prop];
  return result;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dissocPath.js





/**
 * Makes a shallow clone of an object. Note that this copies and flattens
 * prototype properties onto the new object as well. All non-primitive
 * properties are copied by reference.
 *
 * @private
 * @param {String|Integer} prop The prop operating
 * @param {Object|Array} obj The object to clone
 * @return {Object|Array} A new object equivalent to the original.
 */

function _shallowCloneObject(prop, obj) {
  if (_isInteger(prop) && _isArray(obj)) {
    return [].concat(obj);
  }

  var result = {};

  for (var p in obj) {
    result[p] = obj[p];
  }

  return result;
}
/**
 * Makes a shallow clone of an object, omitting the property at the given path.
 * Note that this copies and flattens prototype properties onto the new object
 * as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.11.0
 * @category Object
 * @typedefn Idx = String | Int | Symbol
 * @sig [Idx] -> {k: v} -> {k: v}
 * @param {Array} path The path to the value to omit
 * @param {Object} obj The object to clone
 * @return {Object} A new object without the property at path
 * @see R.assocPath
 * @example
 *
 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
 */


var dissocPath_dissocPath =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function dissocPath(path, obj) {
  if (obj == null) {
    return obj;
  }

  switch (path.length) {
    case 0:
      return obj;

    case 1:
      return _dissoc(path[0], obj);

    default:
      var head = path[0];
      var tail = Array.prototype.slice.call(path, 1);

      if (obj[head] == null) {
        return _shallowCloneObject(head, obj);
      } else {
        return assoc(head, dissocPath(tail, obj[head]), obj);
      }

  }
})));

/* harmony default export */ const es_dissocPath = ((/* unused pure expression or super */ null && (dissocPath_dissocPath)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dissoc.js


/**
 * Returns a new object that does not contain a `prop` property.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Object
 * @sig String -> {k: v} -> {k: v}
 * @param {String} prop The name of the property to dissociate
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original but without the specified property
 * @see R.assoc, R.omit
 * @example
 *
 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
 */

var dissoc =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function dissoc(prop, obj) {
  return dissocPath([prop], obj);
})));

/* harmony default export */ const es_dissoc = ((/* unused pure expression or super */ null && (dissoc)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xdrop.js



var XDrop =
/*#__PURE__*/
function () {
  function XDrop(n, xf) {
    this.xf = xf;
    this.n = n;
  }

  XDrop.prototype['@@transducer/init'] = _xfBase.init;
  XDrop.prototype['@@transducer/result'] = _xfBase.result;

  XDrop.prototype['@@transducer/step'] = function (result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }

    return this.xf['@@transducer/step'](result, input);
  };

  return XDrop;
}();

var _xdrop =
/*#__PURE__*/
_curry2_curry2(function _xdrop(n, xf) {
  return new XDrop(n, xf);
});

/* harmony default export */ const internal_xdrop = (_xdrop);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/drop.js




/**
 * Returns all but the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `drop` method).
 *
 * Dispatches to the `drop` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*} A copy of list without the first `n` elements
 * @see R.take, R.transduce, R.dropLast, R.dropWhile
 * @example
 *
 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(3, 'ramda');               //=> 'da'
 */

var drop_drop =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['drop'], internal_xdrop, function drop(n, xs) {
  return es_slice(Math.max(0, n), Infinity, xs);
}));

/* harmony default export */ const es_drop = ((/* unused pure expression or super */ null && (drop_drop)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xtake.js




var XTake =
/*#__PURE__*/
function () {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }

  XTake.prototype['@@transducer/init'] = _xfBase.init;
  XTake.prototype['@@transducer/result'] = _xfBase.result;

  XTake.prototype['@@transducer/step'] = function (result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.n >= 0 && this.i >= this.n ? _reduced_reduced(ret) : ret;
  };

  return XTake;
}();

var _xtake =
/*#__PURE__*/
_curry2_curry2(function _xtake(n, xf) {
  return new XTake(n, xf);
});

/* harmony default export */ const internal_xtake = (_xtake);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/take.js




/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      const personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      const takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */

var take_take =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['take'], internal_xtake, function take(n, xs) {
  return es_slice(0, n < 0 ? Infinity : n, xs);
}));

/* harmony default export */ const es_take = (take_take);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_dropLast.js

function dropLast(n, xs) {
  return es_take(n < xs.length ? xs.length - n : 0, xs);
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xdropLast.js



var XDropLast =
/*#__PURE__*/
function () {
  function XDropLast(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }

  XDropLast.prototype['@@transducer/init'] = _xfBase.init;

  XDropLast.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };

  XDropLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.full) {
      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
    }

    this.store(input);
    return result;
  };

  XDropLast.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;

    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };

  return XDropLast;
}();

var _xdropLast =
/*#__PURE__*/
_curry2_curry2(function _xdropLast(n, xf) {
  return new XDropLast(n, xf);
});

/* harmony default export */ const internal_xdropLast = (_xdropLast);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dropLast.js




/**
 * Returns a list containing all but the last `n` elements of the given `list`.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements of `list` to skip.
 * @param {Array} list The list of elements to consider.
 * @return {Array} A copy of the list with only the first `list.length - n` elements
 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
 * @example
 *
 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(3, 'ramda');               //=> 'ra'
 */

var dropLast_dropLast =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xdropLast, dropLast));

/* harmony default export */ const es_dropLast = ((/* unused pure expression or super */ null && (dropLast_dropLast)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_dropLastWhile.js

function dropLastWhile(pred, xs) {
  var idx = xs.length - 1;

  while (idx >= 0 && pred(xs[idx])) {
    idx -= 1;
  }

  return es_slice(0, idx + 1, xs);
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xdropLastWhile.js




var XDropLastWhile =
/*#__PURE__*/
function () {
  function XDropLastWhile(fn, xf) {
    this.f = fn;
    this.retained = [];
    this.xf = xf;
  }

  XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;

  XDropLastWhile.prototype['@@transducer/result'] = function (result) {
    this.retained = null;
    return this.xf['@@transducer/result'](result);
  };

  XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };

  XDropLastWhile.prototype.flush = function (result, input) {
    result = _reduce_reduce(this.xf['@@transducer/step'], result, this.retained);
    this.retained = [];
    return this.xf['@@transducer/step'](result, input);
  };

  XDropLastWhile.prototype.retain = function (result, input) {
    this.retained.push(input);
    return result;
  };

  return XDropLastWhile;
}();

var _xdropLastWhile =
/*#__PURE__*/
_curry2_curry2(function _xdropLastWhile(fn, xf) {
  return new XDropLastWhile(fn, xf);
});

/* harmony default export */ const internal_xdropLastWhile = (_xdropLastWhile);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dropLastWhile.js




/**
 * Returns a new list excluding all the tailing elements of a given list which
 * satisfy the supplied predicate function. It passes each value from the right
 * to the supplied predicate function, skipping elements until the predicate
 * function returns a `falsy` value. The predicate function is applied to one argument:
 * *(value)*.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} predicate The function to be called on each element
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
 * @example
 *
 *      const lteThree = x => x <= 3;
 *
 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
 *
 *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
 */

var dropLastWhile_dropLastWhile =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xdropLastWhile, dropLastWhile));

/* harmony default export */ const es_dropLastWhile = ((/* unused pure expression or super */ null && (dropLastWhile_dropLastWhile)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xdropRepeatsWith.js



var XDropRepeatsWith =
/*#__PURE__*/
function () {
  function XDropRepeatsWith(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = undefined;
    this.seenFirstValue = false;
  }

  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;

  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
    var sameAsLast = false;

    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }

    this.lastValue = input;
    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
  };

  return XDropRepeatsWith;
}();

var _xdropRepeatsWith =
/*#__PURE__*/
_curry2_curry2(function _xdropRepeatsWith(pred, xf) {
  return new XDropRepeatsWith(pred, xf);
});

/* harmony default export */ const internal_xdropRepeatsWith = (_xdropRepeatsWith);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/last.js

/**
 * Returns the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.init, R.head, R.tail
 * @example
 *
 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
 *      R.last([]); //=> undefined
 *
 *      R.last('abc'); //=> 'c'
 *      R.last(''); //=> ''
 */

var last =
/*#__PURE__*/
es_nth(-1);
/* harmony default export */ const es_last = (last);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dropRepeatsWith.js




/**
 * Returns a new list without any consecutively repeating elements. Equality is
 * determined by applying the supplied predicate to each pair of consecutive elements. The
 * first element in a series of equal elements will be preserved.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig ((a, a) -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *      const l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
 */

var dropRepeatsWith =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xdropRepeatsWith, function dropRepeatsWith(pred, list) {
  var result = [];
  var idx = 1;
  var len = list.length;

  if (len !== 0) {
    result[0] = list[0];

    while (idx < len) {
      if (!pred(es_last(result), list[idx])) {
        result[result.length] = list[idx];
      }

      idx += 1;
    }
  }

  return result;
}));

/* harmony default export */ const es_dropRepeatsWith = (dropRepeatsWith);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dropRepeats.js





/**
 * Returns a new list without any consecutively repeating elements.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
 */

var dropRepeats =
/*#__PURE__*/
_curry1_curry1(
/*#__PURE__*/
_dispatchable([],
/*#__PURE__*/
internal_xdropRepeatsWith(es_equals),
/*#__PURE__*/
es_dropRepeatsWith(es_equals)));

/* harmony default export */ const es_dropRepeats = ((/* unused pure expression or super */ null && (dropRepeats)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xdropWhile.js



var XDropWhile =
/*#__PURE__*/
function () {
  function XDropWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
  XDropWhile.prototype['@@transducer/result'] = _xfBase.result;

  XDropWhile.prototype['@@transducer/step'] = function (result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }

      this.f = null;
    }

    return this.xf['@@transducer/step'](result, input);
  };

  return XDropWhile;
}();

var _xdropWhile =
/*#__PURE__*/
_curry2_curry2(function _xdropWhile(f, xf) {
  return new XDropWhile(f, xf);
});

/* harmony default export */ const internal_xdropWhile = (_xdropWhile);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/dropWhile.js




/**
 * Returns a new list excluding the leading elements of a given list which
 * satisfy the supplied predicate function. It passes each value to the supplied
 * predicate function, skipping elements while the predicate function returns
 * `true`. The predicate function is applied to one argument: *(value)*.
 *
 * Dispatches to the `dropWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.takeWhile, R.transduce, R.addIndex
 * @example
 *
 *      const lteTwo = x => x <= 2;
 *
 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
 *
 *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
 */

var dropWhile =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['dropWhile'], internal_xdropWhile, function dropWhile(pred, xs) {
  var idx = 0;
  var len = xs.length;

  while (idx < len && pred(xs[idx])) {
    idx += 1;
  }

  return es_slice(idx, Infinity, xs);
}));

/* harmony default export */ const es_dropWhile = ((/* unused pure expression or super */ null && (dropWhile)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/either.js




/**
 * A function wrapping calls to the two functions in an `||` operation,
 * returning the result of the first function if it is truth-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * truth-y value.
 *
 * In addition to functions, `R.either` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f a predicate
 * @param {Function} g another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
 * @see R.both, R.or
 * @example
 *
 *      const gt10 = x => x > 10;
 *      const even = x => x % 2 === 0;
 *      const f = R.either(gt10, even);
 *      f(101); //=> true
 *      f(8); //=> true
 *
 *      R.either(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(55)
 *      R.either([false, false, 'a'], [11]) // => [11, 11, "a"]
 */

var either =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function either(f, g) {
  return _isFunction(f) ? function _either() {
    return f.apply(this, arguments) || g.apply(this, arguments);
  } : lift(or)(f, g);
})));

/* harmony default export */ const es_either = ((/* unused pure expression or super */ null && (either)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/empty.js






/**
 * Returns the empty value of its argument's type. Ramda defines the empty
 * value of Array (`[]`), Object (`{}`), String (`''`),
 * TypedArray (`Uint8Array []`, `Float32Array []`, etc), and Arguments. Other
 * types are supported if they define `<Type>.empty`,
 * `<Type>.prototype.empty` or implement the
 * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
 *
 * Dispatches to the `empty` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> a
 * @param {*} x
 * @return {*}
 * @example
 *
 *      R.empty(Just(42));               //=> Nothing()
 *      R.empty([1, 2, 3]);              //=> []
 *      R.empty('unicorns');             //=> ''
 *      R.empty({x: 1, y: 2});           //=> {}
 *      R.empty(Uint8Array.from('123')); //=> Uint8Array []
 */

var empty_empty =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function empty(x) {
  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
    return arguments;
  }() : _isTypedArray(x) ? x.constructor.from('') : void 0 // else
  ;
})));

/* harmony default export */ const es_empty = ((/* unused pure expression or super */ null && (empty_empty)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/takeLast.js


/**
 * Returns a new list containing the last `n` elements of the given list.
 * If `n > list.length`, returns a list of `list.length` elements.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements to return.
 * @param {Array} xs The collection to consider.
 * @return {Array}
 * @see R.dropLast
 * @example
 *
 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(3, 'ramda');               //=> 'mda'
 */

var takeLast_takeLast =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function takeLast(n, xs) {
  return drop(n >= 0 ? xs.length - n : 0, xs);
})));

/* harmony default export */ const es_takeLast = ((/* unused pure expression or super */ null && (takeLast_takeLast)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/endsWith.js



/**
 * Checks if a list ends with the provided sublist.
 *
 * Similarly, checks if a string ends with the provided substring.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> [a] -> Boolean
 * @sig String -> String -> Boolean
 * @param {*} suffix
 * @param {*} list
 * @return {Boolean}
 * @see R.startsWith
 * @example
 *
 *      R.endsWith('c', 'abc')                //=> true
 *      R.endsWith('b', 'abc')                //=> false
 *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
 *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
 */

var endsWith =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function (suffix, list) {
  return equals(takeLast(suffix.length, list), suffix);
})));

/* harmony default export */ const es_endsWith = ((/* unused pure expression or super */ null && (endsWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/eqBy.js


/**
 * Takes a function and two values in its domain and returns `true` if the
 * values map to the same value in the codomain; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Relation
 * @sig (a -> b) -> a -> a -> Boolean
 * @param {Function} f
 * @param {*} x
 * @param {*} y
 * @return {Boolean}
 * @example
 *
 *      R.eqBy(Math.abs, 5, -5); //=> true
 */

var eqBy =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function eqBy(f, x, y) {
  return equals(f(x), f(y));
})));

/* harmony default export */ const es_eqBy = ((/* unused pure expression or super */ null && (eqBy)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/eqProps.js


/**
 * Reports whether two objects have the same value, in [`R.equals`](#equals)
 * terms, for the specified property. Useful as a curried predicate.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig k -> {k: v} -> {k: v} -> Boolean
 * @param {String} prop The name of the property to compare
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {Boolean}
 *
 * @example
 *
 *      const o1 = { a: 1, b: 2, c: 3, d: 4 };
 *      const o2 = { a: 10, b: 20, c: 3, d: 40 };
 *      R.eqProps('a', o1, o2); //=> false
 *      R.eqProps('c', o1, o2); //=> true
 */

var eqProps =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function eqProps(prop, obj1, obj2) {
  return equals(obj1[prop], obj2[prop]);
})));

/* harmony default export */ const es_eqProps = ((/* unused pure expression or super */ null && (eqProps)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/evolve.js



/**
 * Creates a new object by recursively evolving a shallow copy of `object`,
 * according to the `transformation` functions. All non-primitive properties
 * are copied by reference.
 *
 * A `transformation` function will not be invoked if its corresponding key
 * does not exist in the evolved object.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
 * @param {Object} transformations The object specifying transformation functions to apply
 *        to the object.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      const tomato = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
 *      const transformations = {
 *        firstName: R.trim,
 *        lastName: R.trim, // Will not get invoked.
 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
 *      };
 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
 */

var evolve =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function evolve(transformations, object) {
  if (!_isObject(object) && !_isArray(object)) {
    return object;
  }

  var result = object instanceof Array ? [] : {};
  var transformation, key, type;

  for (key in object) {
    transformation = transformations[key];
    type = typeof transformation;
    result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
  }

  return result;
})));

/* harmony default export */ const es_evolve = ((/* unused pure expression or super */ null && (evolve)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xfind.js




var XFind =
/*#__PURE__*/
function () {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }

  XFind.prototype['@@transducer/init'] = _xfBase.init;

  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }

    return this.xf['@@transducer/result'](result);
  };

  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced_reduced(this.xf['@@transducer/step'](result, input));
    }

    return result;
  };

  return XFind;
}();

var _xfind =
/*#__PURE__*/
_curry2_curry2(function _xfind(f, xf) {
  return new XFind(f, xf);
});

/* harmony default export */ const internal_xfind = (_xfind);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/find.js



/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */

var find =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['find'], internal_xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }

    idx += 1;
  }
}));

/* harmony default export */ const es_find = ((/* unused pure expression or super */ null && (find)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xfindIndex.js




var XFindIndex =
/*#__PURE__*/
function () {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }

  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

  XFindIndex.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }

    return this.xf['@@transducer/result'](result);
  };

  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;

    if (this.f(input)) {
      this.found = true;
      result = _reduced_reduced(this.xf['@@transducer/step'](result, this.idx));
    }

    return result;
  };

  return XFindIndex;
}();

var _xfindIndex =
/*#__PURE__*/
_curry2_curry2(function _xfindIndex(f, xf) {
  return new XFindIndex(f, xf);
});

/* harmony default export */ const internal_xfindIndex = (_xfindIndex);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/findIndex.js



/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce, R.indexOf
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */

var findIndex =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xfindIndex, function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}));

/* harmony default export */ const es_findIndex = ((/* unused pure expression or super */ null && (findIndex)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xfindLast.js



var XFindLast =
/*#__PURE__*/
function () {
  function XFindLast(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XFindLast.prototype['@@transducer/init'] = _xfBase.init;

  XFindLast.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
  };

  XFindLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.last = input;
    }

    return result;
  };

  return XFindLast;
}();

var _xfindLast =
/*#__PURE__*/
_curry2_curry2(function _xfindLast(f, xf) {
  return new XFindLast(f, xf);
});

/* harmony default export */ const internal_xfindLast = (_xfindLast);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/findLast.js



/**
 * Returns the last element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
 */

var findLast =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xfindLast, function findLast(fn, list) {
  var idx = list.length - 1;

  while (idx >= 0) {
    if (fn(list[idx])) {
      return list[idx];
    }

    idx -= 1;
  }
}));

/* harmony default export */ const es_findLast = ((/* unused pure expression or super */ null && (findLast)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xfindLastIndex.js



var XFindLastIndex =
/*#__PURE__*/
function () {
  function XFindLastIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.lastIdx = -1;
  }

  XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;

  XFindLastIndex.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
  };

  XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;

    if (this.f(input)) {
      this.lastIdx = this.idx;
    }

    return result;
  };

  return XFindLastIndex;
}();

var _xfindLastIndex =
/*#__PURE__*/
_curry2_curry2(function _xfindLastIndex(f, xf) {
  return new XFindLastIndex(f, xf);
});

/* harmony default export */ const internal_xfindLastIndex = (_xfindLastIndex);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/findLastIndex.js



/**
 * Returns the index of the last element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce, R.lastIndexOf
 * @example
 *
 *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
 */

var findLastIndex =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xfindLastIndex, function findLastIndex(fn, list) {
  var idx = list.length - 1;

  while (idx >= 0) {
    if (fn(list[idx])) {
      return idx;
    }

    idx -= 1;
  }

  return -1;
}));

/* harmony default export */ const es_findLastIndex = ((/* unused pure expression or super */ null && (findLastIndex)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/flatten.js


/**
 * Returns a new list by pulling every item out of it (and all its sub-arrays)
 * and putting them in a new array, depth-first.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b]
 * @param {Array} list The array to consider.
 * @return {Array} The flattened list.
 * @see R.unnest
 * @example
 *
 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
 */

var flatten =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(
/*#__PURE__*/
_makeFlat(true))));

/* harmony default export */ const es_flatten = ((/* unused pure expression or super */ null && (flatten)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/forEach.js


/**
 * Iterate over an input `list`, calling a provided function `fn` for each
 * element in the list.
 *
 * `fn` receives one argument: *(value)*.
 *
 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.forEach` method. For more
 * details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
 *
 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
 * the original array. In some libraries this function is named `each`.
 *
 * Dispatches to the `forEach` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> *) -> [a] -> [a]
 * @param {Function} fn The function to invoke. Receives one argument, `value`.
 * @param {Array} list The list to iterate over.
 * @return {Array} The original list.
 * @see R.addIndex
 * @example
 *
 *      const printXPlusFive = x => console.log(x + 5);
 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
 *      // logs 6
 *      // logs 7
 *      // logs 8
 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
 */

var forEach =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(
/*#__PURE__*/
_checkForMethod('forEach', function forEach(fn, list) {
  var len = list.length;
  var idx = 0;

  while (idx < len) {
    fn(list[idx]);
    idx += 1;
  }

  return list;
}))));

/* harmony default export */ const es_forEach = ((/* unused pure expression or super */ null && (forEach)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/forEachObjIndexed.js


/**
 * Iterate over an input `object`, calling a provided function `fn` for each
 * key and value in the object.
 *
 * `fn` receives three argument: *(value, key, obj)*.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Object
 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
 * @param {Object} obj The object to iterate over.
 * @return {Object} The original object.
 * @example
 *
 *      const printKeyConcatValue = (value, key) => console.log(key + ':' + value);
 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
 *      // logs x:1
 *      // logs y:2
 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
 */

var forEachObjIndexed =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function forEachObjIndexed(fn, obj) {
  var keyList = keys(obj);
  var idx = 0;

  while (idx < keyList.length) {
    var key = keyList[idx];
    fn(obj[key], key, obj);
    idx += 1;
  }

  return obj;
})));

/* harmony default export */ const es_forEachObjIndexed = ((/* unused pure expression or super */ null && (forEachObjIndexed)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/groupBy.js



/**
 * Splits a list into sub-lists stored in an object, based on the result of
 * calling a key-returning function on each element, and grouping the
 * results according to values returned.
 *
 * Dispatches to the `groupBy` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @typedefn Idx = String | Int | Symbol
 * @sig Idx a => (b -> a) -> [b] -> {a: [b]}
 * @param {Function} fn Function :: a -> Idx
 * @param {Array} list The array to group
 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
 *         that produced that key when passed to `fn`.
 * @see R.reduceBy, R.transduce, R.indexBy
 * @example
 *
 *      const byGrade = R.groupBy(function(student) {
 *        const score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      const students = [{name: 'Abby', score: 84},
 *                      {name: 'Eddy', score: 58},
 *                      // ...
 *                      {name: 'Jack', score: 69}];
 *      byGrade(students);
 *      // {
 *      //   'A': [{name: 'Dianne', score: 99}],
 *      //   'B': [{name: 'Abby', score: 84}]
 *      //   // ...,
 *      //   'F': [{name: 'Eddy', score: 58}]
 *      // }
 */

var groupBy =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(
/*#__PURE__*/
_checkForMethod('groupBy',
/*#__PURE__*/
reduceBy(function (acc, item) {
  acc.push(item);
  return acc;
}, [])))));

/* harmony default export */ const es_groupBy = ((/* unused pure expression or super */ null && (groupBy)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/identical.js


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * Note this is merely a curried version of ES6 `Object.is`.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      const o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */

var identical =
/*#__PURE__*/
_curry2_curry2(internal_objectIs);

/* harmony default export */ const es_identical = ((/* unused pure expression or super */ null && (identical)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/includes.js


/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 * Also works with strings.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.includes(3, [1, 2, 3]); //=> true
 *      R.includes(4, [1, 2, 3]); //=> false
 *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.includes([42], [[42]]); //=> true
 *      R.includes('ba', 'banana'); //=>true
 */

var includes =
/*#__PURE__*/
_curry2_curry2(_includes_includes);

/* harmony default export */ const es_includes = ((/* unused pure expression or super */ null && (includes)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/indexBy.js

/**
 * Given a function that generates a key, turns a list of objects into an
 * object indexing the objects by the given key. Note that if multiple
 * objects generate the same value for the indexing key only the last value
 * will be included in the generated object.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @typedefn Idx = String | Int | Symbol
 * @sig Idx a => (b -> a) -> [b] -> {a: b}
 * @param {Function} fn Function :: a -> Idx
 * @param {Array} array The array of objects to index
 * @return {Object} An object indexing each array element by the given property.
 * @see R.groupBy
 * @example
 *
 *      const list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
 *      R.indexBy(R.prop('id'), list);
 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
 */

var indexBy =
/*#__PURE__*/
(/* unused pure expression or super */ null && (reduceBy(function (acc, elem) {
  return elem;
}, null)));
/* harmony default export */ const es_indexBy = ((/* unused pure expression or super */ null && (indexBy)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/indexOf.js



/**
 * Returns the position of the first occurrence of an item in an array, or -1
 * if the item is not included in the array. [`R.equals`](#equals) is used to
 * determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.lastIndexOf, R.findIndex
 * @example
 *
 *      R.indexOf(3, [1,2,3,4]); //=> 2
 *      R.indexOf(10, [1,2,3,4]); //=> -1
 */

var indexOf =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function indexOf(target, xs) {
  return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
})));

/* harmony default export */ const es_indexOf = ((/* unused pure expression or super */ null && (indexOf)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/init.js

/**
 * Returns all but the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.last, R.head, R.tail
 * @example
 *
 *      R.init([1, 2, 3]);  //=> [1, 2]
 *      R.init([1, 2]);     //=> [1]
 *      R.init([1]);        //=> []
 *      R.init([]);         //=> []
 *
 *      R.init('abc');  //=> 'ab'
 *      R.init('ab');   //=> 'a'
 *      R.init('a');    //=> ''
 *      R.init('');     //=> ''
 */

var init =
/*#__PURE__*/
(/* unused pure expression or super */ null && (slice(0, -1)));
/* harmony default export */ const es_init = ((/* unused pure expression or super */ null && (init)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_identity.js
function _identity(x) {
  return x;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/identity.js


/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      const obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */

var identity_identity =
/*#__PURE__*/
_curry1_curry1(_identity);

/* harmony default export */ const es_identity = (identity_identity);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xuniqBy.js




var XUniqBy =
/*#__PURE__*/
function () {
  function XUniqBy(f, xf) {
    this.xf = xf;
    this.f = f;
    this.set = new internal_Set();
  }

  XUniqBy.prototype['@@transducer/init'] = _xfBase.init;
  XUniqBy.prototype['@@transducer/result'] = _xfBase.result;

  XUniqBy.prototype['@@transducer/step'] = function (result, input) {
    return this.set.add(this.f(input)) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XUniqBy;
}();

var _xuniqBy =
/*#__PURE__*/
_curry2_curry2(function _xuniqBy(f, xf) {
  return new XUniqBy(f, xf);
});

/* harmony default export */ const internal_xuniqBy = (_xuniqBy);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/uniqBy.js




/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. [`R.equals`](#equals) is used for comparison.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */

var uniqBy =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xuniqBy, function (fn, list) {
  var set = new internal_Set();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);

    if (set.add(appliedItem)) {
      result.push(item);
    }

    idx += 1;
  }

  return result;
}));

/* harmony default export */ const es_uniqBy = (uniqBy);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/uniq.js


/**
 * Returns a new list containing only one copy of each element in the original
 * list. [`R.equals`](#equals) is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */

var uniq_uniq =
/*#__PURE__*/
es_uniqBy(es_identity);
/* harmony default export */ const es_uniq = (uniq_uniq);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/intersection.js





/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The list of elements found in both `list1` and `list2`.
 * @see R.innerJoin
 * @example
 *
 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
 */

var intersection =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function intersection(list1, list2) {
  var lookupList, filteredList;

  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }

  return uniq(_filter(flip(_includes)(lookupList), filteredList));
})));

/* harmony default export */ const es_intersection = ((/* unused pure expression or super */ null && (intersection)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/intersperse.js


/**
 * Creates a new list with the separator interposed between elements.
 *
 * Dispatches to the `intersperse` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} separator The element to add to the list.
 * @param {Array} list The list to be interposed.
 * @return {Array} The new list.
 * @example
 *
 *      R.intersperse('a', ['b', 'n', 'n', 's']); //=> ['b', 'a', 'n', 'a', 'n', 'a', 's']
 */

var intersperse =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(
/*#__PURE__*/
_checkForMethod('intersperse', function intersperse(separator, list) {
  var out = [];
  var idx = 0;
  var length = list.length;

  while (idx < length) {
    if (idx === length - 1) {
      out.push(list[idx]);
    } else {
      out.push(list[idx], separator);
    }

    idx += 1;
  }

  return out;
}))));

/* harmony default export */ const es_intersperse = ((/* unused pure expression or super */ null && (intersperse)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_objectAssign.js
 // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

function _objectAssign_objectAssign(target) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  var idx = 1;
  var length = arguments.length;

  while (idx < length) {
    var source = arguments[idx];

    if (source != null) {
      for (var nextKey in source) {
        if (_has_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }

    idx += 1;
  }

  return output;
}

/* harmony default export */ const internal_objectAssign = (typeof Object.assign === 'function' ? Object.assign : _objectAssign_objectAssign);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/objOf.js

/**
 * Creates an object containing a single key:value pair.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @sig String -> a -> {String:a}
 * @param {String} key
 * @param {*} val
 * @return {Object}
 * @see R.pair
 * @example
 *
 *      const matchPhrases = R.compose(
 *        R.objOf('must'),
 *        R.map(R.objOf('match_phrase'))
 *      );
 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
 */

var objOf =
/*#__PURE__*/
_curry2_curry2(function objOf(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});

/* harmony default export */ const es_objOf = (objOf);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_stepCat.js





var _stepCatArray = {
  '@@transducer/init': Array,
  '@@transducer/step': function (xs, x) {
    xs.push(x);
    return xs;
  },
  '@@transducer/result': _identity
};
var _stepCatString = {
  '@@transducer/init': String,
  '@@transducer/step': function (a, b) {
    return a + b;
  },
  '@@transducer/result': _identity
};
var _stepCatObject = {
  '@@transducer/init': Object,
  '@@transducer/step': function (result, input) {
    return internal_objectAssign(result, internal_isArrayLike(input) ? es_objOf(input[0], input[1]) : input);
  },
  '@@transducer/result': _identity
};
function _stepCat_stepCat(obj) {
  if (_isTransformer(obj)) {
    return obj;
  }

  if (_isArrayLike(obj)) {
    return _stepCatArray;
  }

  if (typeof obj === 'string') {
    return _stepCatString;
  }

  if (typeof obj === 'object') {
    return _stepCatObject;
  }

  throw new Error('Cannot create transformer for ' + obj);
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/into.js





/**
 * Transforms the items of the list with the transducer and appends the
 * transformed items to the accumulator using an appropriate iterator function
 * based on the accumulator type.
 *
 * The accumulator can be an array, string, object or a transformer. Iterated
 * items will be appended to arrays and concatenated to strings. Objects will
 * be merged directly or 2-item arrays will be merged as key, value pairs.
 *
 * The accumulator can also be a transformer object that provides a 2-arity
 * reducing iterator function, step, 0-arity initial value function, init, and
 * 1-arity result extraction function result. The step function is used as the
 * iterator function in reduce. The result function is used to convert the
 * final accumulator into the return type and in most cases is R.identity. The
 * init function is used to provide the initial accumulator.
 *
 * The iteration is performed with [`R.reduce`](#reduce) after initializing the
 * transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig a -> (b -> b) -> [c] -> a
 * @param {*} acc The initial accumulator value.
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.transduce
 * @example
 *
 *      const numbers = [1, 2, 3, 4];
 *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.into([], transducer, numbers); //=> [2, 3]
 *
 *      const intoArray = R.into([]);
 *      intoArray(transducer, numbers); //=> [2, 3]
 */

var into =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function into(acc, xf, list) {
  return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
})));

/* harmony default export */ const es_into = ((/* unused pure expression or super */ null && (into)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/invert.js



/**
 * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
 * duplicate values by putting the values into an array.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: [ s, ... ]}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object with keys in an array.
 * @see R.invertObj
 * @example
 *
 *      const raceResultsByFirstName = {
 *        first: 'alice',
 *        second: 'jake',
 *        third: 'alice',
 *      };
 *      R.invert(raceResultsByFirstName);
 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
 */

var invert =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function invert(obj) {
  var props = keys(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    var val = obj[key];
    var list = _has(val, out) ? out[val] : out[val] = [];
    list[list.length] = key;
    idx += 1;
  }

  return out;
})));

/* harmony default export */ const es_invert = ((/* unused pure expression or super */ null && (invert)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/invertObj.js


/**
 * Returns a new object with the keys of the given object as values, and the
 * values of the given object, which are coerced to strings, as keys. Note
 * that the last key found is preferred when handling the same value.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: s}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object
 * @see R.invert
 * @example
 *
 *      const raceResults = {
 *        first: 'alice',
 *        second: 'jake'
 *      };
 *      R.invertObj(raceResults);
 *      //=> { 'alice': 'first', 'jake':'second' }
 *
 *      // Alternatively:
 *      const raceResults = ['alice', 'jake'];
 *      R.invertObj(raceResults);
 *      //=> { 'alice': '0', 'jake':'1' }
 */

var invertObj =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function invertObj(obj) {
  var props = keys(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    out[obj[key]] = key;
    idx += 1;
  }

  return out;
})));

/* harmony default export */ const es_invertObj = ((/* unused pure expression or super */ null && (invertObj)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/invoker.js




/**
 * Turns a named method with a specified arity into a function that can be
 * called directly supplied with arguments and a target object.
 *
 * The returned function is curried and accepts `arity + 1` parameters where
 * the final parameter is the target object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
 * @param {Number} arity Number of arguments the returned function should take
 *        before the target object.
 * @param {String} method Name of any of the target object's methods to call.
 * @return {Function} A new curried function.
 * @see R.construct
 * @example
 *
 *      const sliceFrom = R.invoker(1, 'slice');
 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
 *      const sliceFrom6 = R.invoker(2, 'slice')(6);
 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
 *
 *      const dog = {
 *        speak: async () => 'Woof!'
 *      };
 *      const speak = R.invoker(0, 'speak');
 *      speak(dog).then(console.log) //~> 'Woof!'
 *
 * @symb R.invoker(0, 'method')(o) = o['method']()
 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
 */

var invoker_invoker =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function invoker(arity, method) {
  return curryN(arity + 1, function () {
    var target = arguments[arity];

    if (target != null && _isFunction(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }

    throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
  });
})));

/* harmony default export */ const es_invoker = ((/* unused pure expression or super */ null && (invoker_invoker)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/isEmpty.js



/**
 * Returns `true` if the given value is its type's empty value; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> Boolean
 * @param {*} x
 * @return {Boolean}
 * @see R.empty
 * @example
 *
 *      R.isEmpty([1, 2, 3]);           //=> false
 *      R.isEmpty([]);                  //=> true
 *      R.isEmpty('');                  //=> true
 *      R.isEmpty(null);                //=> false
 *      R.isEmpty({});                  //=> true
 *      R.isEmpty({length: 0});         //=> false
 *      R.isEmpty(Uint8Array.from('')); //=> true
 */

var isEmpty =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function isEmpty(x) {
  return x != null && equals(x, empty(x));
})));

/* harmony default export */ const es_isEmpty = ((/* unused pure expression or super */ null && (isEmpty)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/join.js

/**
 * Returns a string made by inserting the `separator` between each element and
 * concatenating all the elements into a single string.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig String -> [a] -> String
 * @param {Number|String} separator The string used to separate the elements.
 * @param {Array} xs The elements to join into a string.
 * @return {String} str The string made by concatenating `xs` with `separator`.
 * @see R.split
 * @example
 *
 *      const spacer = R.join(' ');
 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
 */

var join =
/*#__PURE__*/
(/* unused pure expression or super */ null && (invoker(1, 'join')));
/* harmony default export */ const es_join = ((/* unused pure expression or super */ null && (join)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/juxt.js


/**
 * juxt applies a list of functions to a list of values.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Function
 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
 * @param {Array} fns An array of functions
 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
 * @see R.applySpec
 * @example
 *
 *      const getRange = R.juxt([Math.min, Math.max]);
 *      getRange(3, 4, 9, -3); //=> [-3, 9]
 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
 */

var juxt =
/*#__PURE__*/
_curry1_curry1(function juxt(fns) {
  return es_converge(function () {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});

/* harmony default export */ const es_juxt = (juxt);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/lastIndexOf.js



/**
 * Returns the position of the last occurrence of an item in an array, or -1 if
 * the item is not included in the array. [`R.equals`](#equals) is used to
 * determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.indexOf, R.findLastIndex
 * @example
 *
 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
 */

var lastIndexOf =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function lastIndexOf(target, xs) {
  if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
    return xs.lastIndexOf(target);
  } else {
    var idx = xs.length - 1;

    while (idx >= 0) {
      if (equals(xs[idx], target)) {
        return idx;
      }

      idx -= 1;
    }

    return -1;
  }
})));

/* harmony default export */ const es_lastIndexOf = ((/* unused pure expression or super */ null && (lastIndexOf)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/lens.js


/**
 * Returns a lens for the given getter and setter functions. The getter "gets"
 * the value of the focus; the setter "sets" the value of the focus. The setter
 * should not mutate the data structure.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
 * @param {Function} getter
 * @param {Function} setter
 * @return {Lens}
 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
 * @example
 *
 *      const xLens = R.lens(R.prop('x'), R.assoc('x'));
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */

var lens_lens =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function lens(getter, setter) {
  return function (toFunctorFn) {
    return function (target) {
      return map(function (focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
})));

/* harmony default export */ const es_lens = ((/* unused pure expression or super */ null && (lens_lens)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/lensIndex.js




/**
 * Returns a lens whose focus is the specified index.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Number -> Lens s a
 * @param {Number} n
 * @return {Lens}
 * @see R.view, R.set, R.over, R.nth
 * @example
 *
 *      const headLens = R.lensIndex(0);
 *
 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
 */

var lensIndex =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function lensIndex(n) {
  return lens(nth(n), update(n));
})));

/* harmony default export */ const es_lensIndex = ((/* unused pure expression or super */ null && (lensIndex)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/paths.js



/**
 * Retrieves the values at given paths of an object.
 *
 * @func
 * @memberOf R
 * @since v0.27.1
 * @category Object
 * @typedefn Idx = [String | Int | Symbol]
 * @sig [Idx] -> {a} -> [a | Undefined]
 * @param {Array} pathsArray The array of paths to be fetched.
 * @param {Object} obj The object to retrieve the nested properties from.
 * @return {Array} A list consisting of values at paths specified by "pathsArray".
 * @see R.path
 * @example
 *
 *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]
 *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]
 */

var paths_paths =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function paths(pathsArray, obj) {
  return pathsArray.map(function (paths) {
    var val = obj;
    var idx = 0;
    var p;

    while (idx < paths.length) {
      if (val == null) {
        return;
      }

      p = paths[idx];
      val = _isInteger(p) ? nth(p, val) : val[p];
      idx += 1;
    }

    return val;
  });
})));

/* harmony default export */ const es_paths = ((/* unused pure expression or super */ null && (paths_paths)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/path.js


/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int | Symbol
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop, R.nth
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
 *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
 */

var path_path =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function path(pathAr, obj) {
  return paths([pathAr], obj)[0];
})));

/* harmony default export */ const es_path = ((/* unused pure expression or super */ null && (path_path)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/lensPath.js




/**
 * Returns a lens whose focus is the specified path.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @typedefn Idx = String | Int | Symbol
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig [Idx] -> Lens s a
 * @param {Array} path The path to use.
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      const xHeadYLens = R.lensPath(['x', 0, 'y']);
 *
 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> 2
 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
 */

var lensPath =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function lensPath(p) {
  return lens(path(p), assocPath(p));
})));

/* harmony default export */ const es_lensPath = ((/* unused pure expression or super */ null && (lensPath)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/lensProp.js




/**
 * Returns a lens whose focus is the specified property.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig String -> Lens s a
 * @param {String} k
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      const xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */

var lensProp =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function lensProp(k) {
  return lens(prop(k), assoc(k));
})));

/* harmony default export */ const es_lensProp = ((/* unused pure expression or super */ null && (lensProp)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/mapObjIndexed.js



/**
 * An Object-specific version of [`map`](#map). The function is applied to three
 * arguments: *(value, key, obj)*. If only the value is significant, use
 * [`map`](#map) instead.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig ((*, String, Object) -> *) -> Object -> Object
 * @param {Function} fn
 * @param {Object} obj
 * @return {Object}
 * @see R.map
 * @example
 *
 *      const xyz = { x: 1, y: 2, z: 3 };
 *      const prependKeyAndDouble = (num, key, obj) => key + (num * 2);
 *
 *      R.mapObjIndexed(prependKeyAndDouble, xyz); //=> { x: 'x2', y: 'y4', z: 'z6' }
 */

var mapObjIndexed =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function mapObjIndexed(fn, obj) {
  return _reduce(function (acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, keys(obj));
})));

/* harmony default export */ const es_mapObjIndexed = ((/* unused pure expression or super */ null && (mapObjIndexed)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/mathMod.js


/**
 * `mathMod` behaves like the modulo operator should mathematically, unlike the
 * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
 * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
 * arguments, and returns NaN when the modulus is zero or negative.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} m The dividend.
 * @param {Number} p the modulus.
 * @return {Number} The result of `b mod a`.
 * @see R.modulo
 * @example
 *
 *      R.mathMod(-17, 5);  //=> 3
 *      R.mathMod(17, 5);   //=> 2
 *      R.mathMod(17, -5);  //=> NaN
 *      R.mathMod(17, 0);   //=> NaN
 *      R.mathMod(17.2, 5); //=> NaN
 *      R.mathMod(17, 5.3); //=> NaN
 *
 *      const clock = R.mathMod(R.__, 12);
 *      clock(15); //=> 3
 *      clock(24); //=> 0
 *
 *      const seventeenMod = R.mathMod(17);
 *      seventeenMod(3);  //=> 2
 *      seventeenMod(4);  //=> 1
 *      seventeenMod(10); //=> 7
 */

var mathMod =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function mathMod(m, p) {
  if (!_isInteger(m)) {
    return NaN;
  }

  if (!_isInteger(p) || p < 1) {
    return NaN;
  }

  return (m % p + p) % p;
})));

/* harmony default export */ const es_mathMod = ((/* unused pure expression or super */ null && (mathMod)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/add.js

/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */

var add =
/*#__PURE__*/
_curry2_curry2(function add(a, b) {
  return Number(a) + Number(b);
});

/* harmony default export */ const es_add = (add);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/sum.js


/**
 * Adds together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The sum of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.sum([2,4,6,8,100,1]); //=> 121
 */

var sum_sum =
/*#__PURE__*/
es_reduce(es_add, 0);
/* harmony default export */ const es_sum = ((/* unused pure expression or super */ null && (sum_sum)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/mean.js


/**
 * Returns the mean of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @see R.median
 * @example
 *
 *      R.mean([2, 7, 9]); //=> 6
 *      R.mean([]); //=> NaN
 */

var mean_mean =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function mean(list) {
  return sum(list) / list.length;
})));

/* harmony default export */ const es_mean = ((/* unused pure expression or super */ null && (mean_mean)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/median.js


/**
 * Returns the median of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @see R.mean
 * @example
 *
 *      R.median([2, 9, 7]); //=> 7
 *      R.median([7, 2, 10, 9]); //=> 8
 *      R.median([]); //=> NaN
 */

var median =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function median(list) {
  var len = list.length;

  if (len === 0) {
    return NaN;
  }

  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }).slice(idx, idx + width));
})));

/* harmony default export */ const es_median = ((/* unused pure expression or super */ null && (median)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/mergeAll.js


/**
 * Creates one new object with the own properties from a list of objects.
 * If a key exists in more than one object, the value from the last
 * object it exists in will be used.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig [{k: v}] -> {k: v}
 * @param {Array} list An array of objects
 * @return {Object} A merged object.
 * @see R.reduce
 * @example
 *
 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
 */

var mergeAll =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry1(function mergeAll(list) {
  return _objectAssign.apply(null, [{}].concat(list));
})));

/* harmony default export */ const es_mergeAll = ((/* unused pure expression or super */ null && (mergeAll)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/mergeLeft.js


/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the first object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeRight, R.mergeDeepLeft, R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.mergeLeft({ 'age': 40 }, { 'name': 'fred', 'age': 10 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      const resetToDefault = R.mergeLeft({x: 0});
 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
 * @symb R.mergeLeft(a, b) = {...b, ...a}
 */

var mergeLeft =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function mergeLeft(l, r) {
  return _objectAssign({}, r, l);
})));

/* harmony default export */ const es_mergeLeft = ((/* unused pure expression or super */ null && (mergeLeft)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/mergeRight.js


/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeLeft, R.mergeDeepRight, R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.mergeRight({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      const withDefaults = R.mergeRight({x: 0, y: 0});
 *      withDefaults({y: 2}); //=> {x: 0, y: 2}
 * @symb R.mergeRight(a, b) = {...a, ...b}
 */

var mergeRight =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function mergeRight(l, r) {
  return _objectAssign({}, l, r);
})));

/* harmony default export */ const es_mergeRight = ((/* unused pure expression or super */ null && (mergeRight)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_modify.js


/**
 * Makes a shallow clone of an object, applying the given fn to the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @private
 * @param {String|Number} prop The property name to set
 * @param {Function} fn The function to apply to the property
 * @param {Object|Array} obj The object to clone
 * @return {Object|Array} A new object equivalent to the original except for the changed property.
 */

function _modify_modify(prop, fn, obj) {
  if (_isInteger(prop) && _isArray(obj)) {
    var arr = [].concat(obj);
    arr[prop] = fn(arr[prop]);
    return arr;
  }

  var result = {};

  for (var p in obj) {
    result[p] = obj[p];
  }

  result[prop] = fn(result[prop]);
  return result;
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/modifyPath.js






/**
 * Creates a shallow clone of the passed object by applying an `fn` function
 * to the value at the given path.
 *
 * The function will not be invoked, and the object will not change
 * if its corresponding path does not exist in the object.
 * All non-primitive properties are copied to the new object by reference.
 *
 * @func
 * @memberOf R
 * @since v0.28.0
 * @category Object
 * @sig [Idx] -> (v -> v) -> {k: v} -> {k: v}
 * @param {Array} path The path to be modified.
 * @param {Function} fn The function to apply to the path.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      const person = {name: 'James', address: { zipCode: '90216' }};
 *      R.modifyPath(['address', 'zipCode'], R.reverse, person); //=> {name: 'James', address: { zipCode: '61209' }}
 *
 *      // Can handle arrays too
 *      const person = {name: 'James', addresses: [{ zipCode: '90216' }]};
 *      R.modifyPath(['addresses', 0, 'zipCode'], R.reverse, person); //=> {name: 'James', addresses: [{ zipCode: '61209' }]}
 */

var modifyPath_modifyPath =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function modifyPath(path, fn, object) {
  if (!_isObject(object) && !_isArray(object) || path.length === 0) {
    return object;
  }

  var idx = path[0];

  if (!_has(idx, object)) {
    return object;
  }

  if (path.length === 1) {
    return _modify(idx, fn, object);
  }

  var val = modifyPath(Array.prototype.slice.call(path, 1), fn, object[idx]);

  if (val === object[idx]) {
    return object;
  }

  return _assoc(idx, val, object);
})));

/* harmony default export */ const es_modifyPath = ((/* unused pure expression or super */ null && (modifyPath_modifyPath)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/modify.js


/**
 * Creates a copy of the passed object by applying an `fn` function to the given `prop` property.
 *
 * The function will not be invoked, and the object will not change
 * if its corresponding property does not exist in the object.
 * All non-primitive properties are copied to the new object by reference.
 *
 * @func
 * @memberOf R
 * @since v0.28.0
 * @category Object
 * @sig Idx -> (v -> v) -> {k: v} -> {k: v}
 * @param {String|Number} prop The property to be modified.
 * @param {Function} fn The function to apply to the property.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      const person = {name: 'James', age: 20, pets: ['dog', 'cat']};
 *      R.modify('age', R.add(1), person); //=> {name: 'James', age: 21, pets: ['dog', 'cat']}
 *      R.modify('pets', R.append('turtle'), person); //=> {name: 'James', age: 20, pets: ['dog', 'cat', 'turtle']}
 */

var modify =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function modify(prop, fn, object) {
  return modifyPath([prop], fn, object);
})));

/* harmony default export */ const es_modify = ((/* unused pure expression or super */ null && (modify)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/none.js



/**
 * Returns `true` if no elements of the list match the predicate, `false`
 * otherwise.
 *
 * Dispatches to the `all` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
 * @see R.all, R.any
 * @example
 *
 *      const isEven = n => n % 2 === 0;
 *      const isOdd = n => n % 2 !== 0;
 *
 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
 *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
 */

var none =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function none(fn, input) {
  return all(_complement(fn), input);
})));

/* harmony default export */ const es_none = ((/* unused pure expression or super */ null && (none)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_assertPromise.js


function _assertPromise_assertPromise(name, p) {
  if (p == null || !_isFunction(p.then)) {
    throw new TypeError('`' + name + '` expected a Promise, received ' + _toString(p, []));
  }
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/otherwise.js


/**
 * Returns the result of applying the onFailure function to the value inside
 * a failed promise. This is useful for handling rejected promises
 * inside function compositions.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category Function
 * @sig (e -> b) -> (Promise e a) -> (Promise e b)
 * @sig (e -> (Promise f b)) -> (Promise e a) -> (Promise f b)
 * @param {Function} onFailure The function to apply. Can return a value or a promise of a value.
 * @param {Promise} p
 * @return {Promise} The result of calling `p.then(null, onFailure)`
 * @see R.andThen
 * @example
 *
 *      const failedFetch = id => Promise.reject('bad ID');
 *      const useDefault = () => ({ firstName: 'Bob', lastName: 'Loblaw' });
 *
 *      //recoverFromFailure :: String -> Promise ({ firstName, lastName })
 *      const recoverFromFailure = R.pipe(
 *        failedFetch,
 *        R.otherwise(useDefault),
 *        R.andThen(R.pick(['firstName', 'lastName'])),
 *      );
 *      recoverFromFailure(12345).then(console.log);
 */

var otherwise =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function otherwise(f, p) {
  _assertPromise('otherwise', p);

  return p.then(null, f);
})));

/* harmony default export */ const es_otherwise = ((/* unused pure expression or super */ null && (otherwise)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/partition.js



/**
 * Takes a predicate and a list or other `Filterable` object and returns the
 * pair of filterable objects of the same type of elements which do and do not
 * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
 * @param {Function} pred A predicate to determine which side the element belongs to.
 * @param {Array} filterable the list (or other filterable) to partition.
 * @return {Array} An array, containing first the subset of elements that satisfy the
 *         predicate, and second the subset of elements that do not satisfy.
 * @see R.filter, R.reject
 * @example
 *
 *      R.partition(R.includes('s'), ['sss', 'ttt', 'foo', 'bars']);
 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
 *
 *      R.partition(R.includes('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
 */

var partition =
/*#__PURE__*/
es_juxt([es_filter, es_reject]);
/* harmony default export */ const es_partition = ((/* unused pure expression or super */ null && (partition)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pathEq.js



/**
 * Determines whether a nested path on an object has a specific value, in
 * [`R.equals`](#equals) terms. Most likely used to filter a list.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Relation
 * @typedefn Idx = String | Int | Symbol
 * @sig [Idx] -> a -> {a} -> Boolean
 * @param {Array} path The path of the nested property to use
 * @param {*} val The value to compare the nested property with
 * @param {Object} obj The object to check the nested property in
 * @return {Boolean} `true` if the value equals the nested object property,
 *         `false` otherwise.
 * @example
 *
 *      const user1 = { address: { zipCode: 90210 } };
 *      const user2 = { address: { zipCode: 55555 } };
 *      const user3 = { name: 'Bob' };
 *      const users = [ user1, user2, user3 ];
 *      const isFamous = R.pathEq(['address', 'zipCode'], 90210);
 *      R.filter(isFamous, users); //=> [ user1 ]
 */

var pathEq =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function pathEq(_path, val, obj) {
  return equals(path(_path, obj), val);
})));

/* harmony default export */ const es_pathEq = ((/* unused pure expression or super */ null && (pathEq)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pathOr.js



/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @typedefn Idx = String | Int | Symbol
 * @sig a -> [Idx] -> {a} -> a
 * @param {*} d The default value.
 * @param {Array} p The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path` of the supplied object or the default value.
 * @example
 *
 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */

var pathOr =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function pathOr(d, p, obj) {
  return defaultTo(d, path(p, obj));
})));

/* harmony default export */ const es_pathOr = ((/* unused pure expression or super */ null && (pathOr)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pathSatisfies.js


/**
 * Returns `true` if the specified object property at given path satisfies the
 * given predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Logic
 * @typedefn Idx = String | Int | Symbol
 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
 * @param {Function} pred
 * @param {Array} propPath
 * @param {*} obj
 * @return {Boolean}
 * @see R.propSatisfies, R.path
 * @example
 *
 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
 *      R.pathSatisfies(R.is(Object), [], {x: {y: 2}}); //=> true
 */

var pathSatisfies =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function pathSatisfies(pred, propPath, obj) {
  return pred(path(propPath, obj));
})));

/* harmony default export */ const es_pathSatisfies = ((/* unused pure expression or super */ null && (pathSatisfies)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/multiply.js

/**
 * Multiplies two numbers. Equivalent to `a * b` but curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a * b`.
 * @see R.divide
 * @example
 *
 *      const double = R.multiply(2);
 *      const triple = R.multiply(3);
 *      double(3);       //=>  6
 *      triple(4);       //=> 12
 *      R.multiply(2, 5);  //=> 10
 */

var multiply =
/*#__PURE__*/
_curry2_curry2(function multiply(a, b) {
  return a * b;
});

/* harmony default export */ const es_multiply = (multiply);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/product.js


/**
 * Multiplies together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The product of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.product([2,4,6,8,100,1]); //=> 38400
 */

var product =
/*#__PURE__*/
es_reduce(es_multiply, 1);
/* harmony default export */ const es_product = ((/* unused pure expression or super */ null && (product)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/pickAll.js

/**
 * Similar to `pick` except that this one includes a `key: undefined` pair for
 * properties that don't exist.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.pick
 * @example
 *
 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
 */

var pickAll =
/*#__PURE__*/
_curry2_curry2(function pickAll(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;

  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }

  return result;
});

/* harmony default export */ const es_pickAll = (pickAll);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/useWith.js


/**
 * Accepts a function `fn` and a list of transformer functions and returns a
 * new curried function. When the new function is invoked, it calls the
 * function `fn` with parameters consisting of the result of calling each
 * supplied handler on successive arguments to the new function.
 *
 * If more arguments are passed to the returned function than transformer
 * functions, those arguments are passed directly to `fn` as additional
 * parameters. If you expect additional arguments that don't need to be
 * transformed, although you can ignore them, it's best to pass an identity
 * function so that the new function reports the correct arity.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} fn The function to wrap.
 * @param {Array} transformers A list of transformer functions
 * @return {Function} The wrapped function.
 * @see R.converge
 * @example
 *
 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
 */

var useWith =
/*#__PURE__*/
_curry2_curry2(function useWith(fn, transformers) {
  return es_curryN(transformers.length, function () {
    var args = [];
    var idx = 0;

    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }

    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});

/* harmony default export */ const es_useWith = (useWith);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/project.js




/**
 * Reasonable analog to SQL `select` statement.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @category Relation
 * @sig [k] -> [{k: v}] -> [{k: v}]
 * @param {Array} props The property names to project
 * @param {Array} objs The objects to query
 * @return {Array} An array of objects with just the `props` properties.
 * @see R.pluck, R.props, R.prop
 * @example
 *
 *      const abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
 *      const fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
 *      const kids = [abby, fred];
 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
 */

var project =
/*#__PURE__*/
es_useWith(_map_map, [es_pickAll, es_identity]); // passing `identity` gives correct arity

/* harmony default export */ const es_project = ((/* unused pure expression or super */ null && (project)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_promap.js
function _promap(f, g, profunctor) {
  return function (x) {
    return g(profunctor(f(x)));
  };
}
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xpromap.js




var XPromap =
/*#__PURE__*/
function () {
  function XPromap(f, g, xf) {
    this.xf = xf;
    this.f = f;
    this.g = g;
  }

  XPromap.prototype['@@transducer/init'] = _xfBase.init;
  XPromap.prototype['@@transducer/result'] = _xfBase.result;

  XPromap.prototype['@@transducer/step'] = function (result, input) {
    return this.xf['@@transducer/step'](result, _promap(this.f, this.g, input));
  };

  return XPromap;
}();

var _xpromap =
/*#__PURE__*/
_curry3_curry3(function _xpromap(f, g, xf) {
  return new XPromap(f, g, xf);
});

/* harmony default export */ const internal_xpromap = (_xpromap);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/promap.js




/**
 * Takes two functions as pre- and post- processors respectively for a third function,
 * i.e. `promap(f, g, h)(x) === g(h(f(x)))`.
 *
 * Dispatches to the `promap` method of the third argument, if present,
 * according to the [FantasyLand Profunctor spec](https://github.com/fantasyland/fantasy-land#profunctor).
 *
 * Acts as a transducer if a transformer is given in profunctor position.
 *
 * @func
 * @memberOf R
 * @since v0.28.0
 * @category Function
 * @sig (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
 * @sig Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
 * @param {Function} f The preprocessor function, a -> b
 * @param {Function} g The postprocessor function, c -> d
 * @param {Profunctor} profunctor The profunctor instance to be promapped, e.g. b -> c
 * @return {Profunctor} The new profunctor instance, e.g. a -> d
 * @see R.transduce
 * @example
 *
 *      const decodeChar = R.promap(s => s.charCodeAt(), String.fromCharCode, R.add(-8))
 *      const decodeString = R.promap(R.split(''), R.join(''), R.map(decodeChar))
 *      decodeString("ziuli") //=> "ramda"
 *
 * @symb R.promap(f, g, h) = x => g(h(f(x)))
 * @symb R.promap(f, g, profunctor) = profunctor.promap(f, g)
 */

var promap =
/*#__PURE__*/
_curry3_curry3(
/*#__PURE__*/
_dispatchable(['fantasy-land/promap', 'promap'], internal_xpromap, _promap));

/* harmony default export */ const es_promap = ((/* unused pure expression or super */ null && (promap)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/propEq.js



/**
 * Returns `true` if the specified object property is equal, in
 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
 * You can test multiple properties with [`R.whereEq`](#whereEq).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.whereEq, R.propSatisfies, R.equals
 * @example
 *
 *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      const kids = [abby, fred, rusty, alois];
 *      const hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */

var propEq =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function propEq(name, val, obj) {
  return equals(val, prop(name, obj));
})));

/* harmony default export */ const es_propEq = ((/* unused pure expression or super */ null && (propEq)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/propIs.js



/**
 * Returns `true` if the specified object property is of the given type;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Type
 * @sig Type -> String -> Object -> Boolean
 * @param {Function} type
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.is, R.propSatisfies
 * @example
 *
 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
 *      R.propIs(Number, 'x', {});            //=> false
 */

var propIs =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function propIs(type, name, obj) {
  return is(type, prop(name, obj));
})));

/* harmony default export */ const es_propIs = ((/* unused pure expression or super */ null && (propIs)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/propOr.js



/**
 * Return the specified property of the given non-null object if the property
 * is present and it's value is not `null`, `undefined` or `NaN`.
 *
 * Otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Object
 * @sig a -> String -> Object -> a
 * @param {*} val The default value.
 * @param {String} p The name of the property to return.
 * @param {Object} obj The object to query.
 * @return {*} The value of given property of the supplied object or the default value.
 * @example
 *
 *      const alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      const favorite = R.prop('favoriteLibrary');
 *      const favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
 *
 *      favorite(alice);  //=> undefined
 *      favoriteWithDefault(alice);  //=> 'Ramda'
 */

var propOr =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function propOr(val, p, obj) {
  return defaultTo(val, prop(p, obj));
})));

/* harmony default export */ const es_propOr = ((/* unused pure expression or super */ null && (propOr)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/propSatisfies.js


/**
 * Returns `true` if the specified object property satisfies the given
 * predicate; `false` otherwise. You can test multiple properties with
 * [`R.where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Logic
 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
 * @param {Function} pred
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.where, R.propEq, R.propIs
 * @example
 *
 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
 */

var propSatisfies =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function propSatisfies(pred, name, obj) {
  return pred(prop(name, obj));
})));

/* harmony default export */ const es_propSatisfies = ((/* unused pure expression or super */ null && (propSatisfies)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/props.js


/**
 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> [v]
 * @param {Array} ps The property names to fetch
 * @param {Object} obj The object to query
 * @return {Array} The corresponding values or partially applied function.
 * @see R.prop, R.pluck, R.project
 * @example
 *
 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
 *
 *      const fullName = R.compose(R.join(' '), R.props(['first', 'last']));
 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
 */

var props =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function props(ps, obj) {
  return ps.map(function (p) {
    return path([p], obj);
  });
})));

/* harmony default export */ const es_props = ((/* unused pure expression or super */ null && (props)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/reduceWhile.js



/**
 * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
 * through the list, successively calling the iterator function. `reduceWhile`
 * also takes a predicate that is evaluated before each step. If the predicate
 * returns `false`, it "short-circuits" the iteration and returns the current
 * value of the accumulator. `reduceWhile` may alternatively be short-circuited
 * via [`reduced`](#reduced).
 *
 * @func
 * @memberOf R
 * @since v0.22.0
 * @category List
 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} pred The predicate. It is passed the accumulator and the
 *        current element.
 * @param {Function} fn The iterator function. Receives two values, the
 *        accumulator and the current element.
 * @param {*} a The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced
 * @example
 *
 *      const isOdd = (acc, x) => x % 2 !== 0;
 *      const xs = [1, 3, 5, 60, 777, 800];
 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
 *
 *      const ys = [2, 4, 6]
 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
 */

var reduceWhile =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curryN(4, [], function _reduceWhile(pred, fn, a, list) {
  return _reduce(function (acc, x) {
    return pred(acc, x) ? fn(acc, x) : _reduced(acc);
  }, a, list);
})));

/* harmony default export */ const es_reduceWhile = ((/* unused pure expression or super */ null && (reduceWhile)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/sequence.js





/**
 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
 * Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
 * @param {Function} of
 * @param {*} traversable
 * @return {*}
 * @see R.traverse
 * @example
 *
 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
 *
 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
 */

var sequence_sequence =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function sequence(of, traversable) {
  return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
    return ap(map(prepend, x), acc);
  }, of([]), traversable);
})));

/* harmony default export */ const es_sequence = ((/* unused pure expression or super */ null && (sequence_sequence)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/split.js

/**
 * Splits a string into an array of strings based on the given
 * separator.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig (String | RegExp) -> String -> [String]
 * @param {String|RegExp} sep The pattern.
 * @param {String} str The string to separate into an array.
 * @return {Array} The array of strings from `str` separated by `sep`.
 * @see R.join
 * @example
 *
 *      const pathComponents = R.split('/');
 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
 *
 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
 */

var split =
/*#__PURE__*/
(/* unused pure expression or super */ null && (invoker(1, 'split')));
/* harmony default export */ const es_split = ((/* unused pure expression or super */ null && (split)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/splitAt.js



/**
 * Splits a given list or string at a given index.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig Number -> [a] -> [[a], [a]]
 * @sig Number -> String -> [String, String]
 * @param {Number} index The index where the array/string is split.
 * @param {Array|String} array The array/string to be split.
 * @return {Array}
 * @example
 *
 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
 */

var splitAt =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function splitAt(index, array) {
  return [slice(0, index, array), slice(index, length(array), array)];
})));

/* harmony default export */ const es_splitAt = ((/* unused pure expression or super */ null && (splitAt)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/splitEvery.js


/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */

var splitEvery =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }

  var result = [];
  var idx = 0;

  while (idx < list.length) {
    result.push(slice(idx, idx += n, list));
  }

  return result;
})));

/* harmony default export */ const es_splitEvery = ((/* unused pure expression or super */ null && (splitEvery)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/startsWith.js



/**
 * Checks if a list starts with the provided sublist.
 *
 * Similarly, checks if a string starts with the provided substring.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> [a] -> Boolean
 * @sig String -> String -> Boolean
 * @param {*} prefix
 * @param {*} list
 * @return {Boolean}
 * @see R.endsWith
 * @example
 *
 *      R.startsWith('a', 'abc')                //=> true
 *      R.startsWith('b', 'abc')                //=> false
 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
 */

var startsWith =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function (prefix, list) {
  return equals(take(prefix.length, list), prefix);
})));

/* harmony default export */ const es_startsWith = ((/* unused pure expression or super */ null && (startsWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/symmetricDifference.js



/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
 * @example
 *
 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
 */

var symmetricDifference =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function symmetricDifference(list1, list2) {
  return concat(difference(list1, list2), difference(list2, list1));
})));

/* harmony default export */ const es_symmetricDifference = ((/* unused pure expression or super */ null && (symmetricDifference)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/symmetricDifferenceWith.js



/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both. Duplication is determined according to the value
 * returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifference, R.difference, R.differenceWith
 * @example
 *
 *      const eqA = R.eqBy(R.prop('a'));
 *      const l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
 *      const l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
 */

var symmetricDifferenceWith =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function symmetricDifferenceWith(pred, list1, list2) {
  return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
})));

/* harmony default export */ const es_symmetricDifferenceWith = ((/* unused pure expression or super */ null && (symmetricDifferenceWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/takeLastWhile.js


/**
 * Returns a new list containing the last `n` elements of a given list, passing
 * each value to the supplied predicate function, and terminating when the
 * predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropLastWhile, R.addIndex
 * @example
 *
 *      const isNotOne = x => x !== 1;
 *
 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
 *
 *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
 */

var takeLastWhile =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function takeLastWhile(fn, xs) {
  var idx = xs.length - 1;

  while (idx >= 0 && fn(xs[idx])) {
    idx -= 1;
  }

  return slice(idx + 1, Infinity, xs);
})));

/* harmony default export */ const es_takeLastWhile = ((/* unused pure expression or super */ null && (takeLastWhile)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xtakeWhile.js




var XTakeWhile =
/*#__PURE__*/
function () {
  function XTakeWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
  XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;

  XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced_reduced(result);
  };

  return XTakeWhile;
}();

var _xtakeWhile =
/*#__PURE__*/
_curry2_curry2(function _xtakeWhile(f, xf) {
  return new XTakeWhile(f, xf);
});

/* harmony default export */ const internal_xtakeWhile = (_xtakeWhile);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/takeWhile.js




/**
 * Returns a new list containing the first `n` elements of a given list,
 * passing each value to the supplied predicate function, and terminating when
 * the predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * Dispatches to the `takeWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropWhile, R.transduce, R.addIndex
 * @example
 *
 *      const isNotFour = x => x !== 4;
 *
 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
 *
 *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
 */

var takeWhile =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable(['takeWhile'], internal_xtakeWhile, function takeWhile(fn, xs) {
  var idx = 0;
  var len = xs.length;

  while (idx < len && fn(xs[idx])) {
    idx += 1;
  }

  return es_slice(0, idx, xs);
}));

/* harmony default export */ const es_takeWhile = ((/* unused pure expression or super */ null && (takeWhile)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xtap.js



var XTap =
/*#__PURE__*/
function () {
  function XTap(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XTap.prototype['@@transducer/init'] = _xfBase.init;
  XTap.prototype['@@transducer/result'] = _xfBase.result;

  XTap.prototype['@@transducer/step'] = function (result, input) {
    this.f(input);
    return this.xf['@@transducer/step'](result, input);
  };

  return XTap;
}();

var _xtap =
/*#__PURE__*/
_curry2_curry2(function _xtap(f, xf) {
  return new XTap(f, xf);
});

/* harmony default export */ const internal_xtap = (_xtap);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/tap.js



/**
 * Runs the given function with the supplied object, then returns the object.
 *
 * Acts as a transducer if a transformer is given as second parameter.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> *) -> a -> a
 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
 * @param {*} x
 * @return {*} `x`.
 * @example
 *
 *      const sayX = x => console.log('x is ' + x);
 *      R.tap(sayX, 100); //=> 100
 *      // logs 'x is 100'
 * @symb R.tap(f, a) = a
 */

var tap =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xtap, function tap(fn, x) {
  fn(x);
  return x;
}));

/* harmony default export */ const es_tap = ((/* unused pure expression or super */ null && (tap)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/test.js




/**
 * Determines whether a given string matches a given regular expression.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category String
 * @sig RegExp -> String -> Boolean
 * @param {RegExp} pattern
 * @param {String} str
 * @return {Boolean}
 * @see R.match
 * @example
 *
 *      R.test(/^x/, 'xyz'); //=> true
 *      R.test(/^y/, 'xyz'); //=> false
 */

var test =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function test(pattern, str) {
  if (!_isRegExp(pattern)) {
    throw new TypeError('test requires a value of type RegExp as its first argument; received ' + toString(pattern));
  }

  return _cloneRegExp(pattern).test(str);
})));

/* harmony default export */ const es_test = ((/* unused pure expression or super */ null && (test)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/andThen.js


/**
 * Returns the result of applying the onSuccess function to the value inside
 * a successfully resolved promise. This is useful for working with promises
 * inside function compositions.
 *
 * @func
 * @memberOf R
 * @since v0.27.1
 * @category Function
 * @sig (a -> b) -> (Promise e a) -> (Promise e b)
 * @sig (a -> (Promise e b)) -> (Promise e a) -> (Promise e b)
 * @param {Function} onSuccess The function to apply. Can return a value or a promise of a value.
 * @param {Promise} p
 * @return {Promise} The result of calling `p.then(onSuccess)`
 * @see R.otherwise
 * @example
 *
 *      const makeQuery = email => ({ query: { email }});
 *      const fetchMember = request =>
 *        Promise.resolve({ firstName: 'Bob', lastName: 'Loblaw', id: 42 });
 *
 *      //getMemberName :: String -> Promise ({ firstName, lastName })
 *      const getMemberName = R.pipe(
 *        makeQuery,
 *        fetchMember,
 *        R.andThen(R.pick(['firstName', 'lastName']))
 *      );
 *
 *      getMemberName('bob@gmail.com').then(console.log);
 */

var andThen =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function andThen(f, p) {
  _assertPromise('andThen', p);

  return p.then(f);
})));

/* harmony default export */ const es_andThen = ((/* unused pure expression or super */ null && (andThen)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/toLower.js

/**
 * The lower case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to lower case.
 * @return {String} The lower case version of `str`.
 * @see R.toUpper
 * @example
 *
 *      R.toLower('XYZ'); //=> 'xyz'
 */

var toLower =
/*#__PURE__*/
(/* unused pure expression or super */ null && (invoker(0, 'toLowerCase')));
/* harmony default export */ const es_toLower = ((/* unused pure expression or super */ null && (toLower)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/toUpper.js

/**
 * The upper case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to upper case.
 * @return {String} The upper case version of `str`.
 * @see R.toLower
 * @example
 *
 *      R.toUpper('abc'); //=> 'ABC'
 */

var toUpper =
/*#__PURE__*/
(/* unused pure expression or super */ null && (invoker(0, 'toUpperCase')));
/* harmony default export */ const es_toUpper = ((/* unused pure expression or super */ null && (toUpper)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/transduce.js



/**
 * Initializes a transducer using supplied iterator function. Returns a single
 * item by iterating through the list, successively calling the transformed
 * iterator function and passing it an accumulator value and the current value
 * from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It will be
 * wrapped as a transformer to initialize the transducer. A transformer can be
 * passed directly in place of an iterator function. In both cases, iteration
 * may be stopped early with the [`R.reduced`](#reduced) function.
 *
 * A transducer is a function that accepts a transformer and returns a
 * transformer and can be composed directly.
 *
 * A transformer is an object that provides a 2-arity reducing iterator
 * function, step, 0-arity initial value function, init, and 1-arity result
 * extraction function, result. The step function is used as the iterator
 * function in reduce. The result function is used to convert the final
 * accumulator into the return type and in most cases is
 * [`R.identity`](#identity). The init function can be used to provide an
 * initial accumulator, but is ignored by transduce.
 *
 * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array. Wrapped as transformer, if necessary, and used to
 *        initialize the transducer
 * @param {*} acc The initial accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced, R.into
 * @example
 *
 *      const numbers = [1, 2, 3, 4];
 *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
 *
 *      const isOdd = (x) => x % 2 !== 0;
 *      const firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
 *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
 */

var transduce =
/*#__PURE__*/
(/* unused pure expression or super */ null && (curryN(4, function transduce(xf, fn, acc, list) {
  return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
})));
/* harmony default export */ const es_transduce = ((/* unused pure expression or super */ null && (transduce)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/traverse.js



/**
 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
 * into an Applicative of Traversable.
 *
 * Dispatches to the `traverse` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
 * @param {Function} of
 * @param {Function} f
 * @param {*} traversable
 * @return {*}
 * @see R.sequence
 * @example
 *
 *      // Returns `Maybe.Nothing` if the given divisor is `0`
 *      const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)
 *
 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Maybe.Just([5, 2.5, 2])
 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Maybe.Nothing
 */

var traverse =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function traverse(of, f, traversable) {
  return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : typeof traversable.traverse === 'function' ? traversable.traverse(f, of) : sequence(of, map(f, traversable));
})));

/* harmony default export */ const es_traverse = ((/* unused pure expression or super */ null && (traverse)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/trim.js

var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
var zeroWidth = '\u200b';
var hasProtoTrim = typeof String.prototype.trim === 'function';
/**
 * Removes (strips) whitespace from both ends of the string.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to trim.
 * @return {String} Trimmed version of `str`.
 * @example
 *
 *      R.trim('   xyz  '); //=> 'xyz'
 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
 */

var trim = !hasProtoTrim ||
/*#__PURE__*/
ws.trim() || !
/*#__PURE__*/
zeroWidth.trim() ?
/*#__PURE__*/
_curry1_curry1(function trim(str) {
  var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
  var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
  return str.replace(beginRx, '').replace(endRx, '');
}) :
/*#__PURE__*/
_curry1_curry1(function trim(str) {
  return str.trim();
});
/* harmony default export */ const es_trim = ((/* unused pure expression or super */ null && (trim)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/union.js




/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */

var union =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
compose(es_uniq, _concat_concat));

/* harmony default export */ const es_union = ((/* unused pure expression or super */ null && (union)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/internal/_xuniqWith.js




var XUniqWith =
/*#__PURE__*/
function () {
  function XUniqWith(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.items = [];
  }

  XUniqWith.prototype['@@transducer/init'] = _xfBase.init;
  XUniqWith.prototype['@@transducer/result'] = _xfBase.result;

  XUniqWith.prototype['@@transducer/step'] = function (result, input) {
    if (_includesWith(this.pred, input, this.items)) {
      return result;
    } else {
      this.items.push(input);
      return this.xf['@@transducer/step'](result, input);
    }
  };

  return XUniqWith;
}();

var _xuniqWith =
/*#__PURE__*/
_curry2_curry2(function _xuniqWith(pred, xf) {
  return new XUniqWith(pred, xf);
});

/* harmony default export */ const internal_xuniqWith = (_xuniqWith);
;// CONCATENATED MODULE: ../../node_modules/ramda/es/uniqWith.js




/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied predicate to
 * two list elements. Prefers the first item if two items compare equal based
 * on the predicate.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category List
 * @sig ((a, a) -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      const strEq = R.eqBy(String);
 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
 */

var uniqWith_uniqWith =
/*#__PURE__*/
_curry2_curry2(
/*#__PURE__*/
_dispatchable([], internal_xuniqWith, function (pred, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var item;

  while (idx < len) {
    item = list[idx];

    if (!_includesWith(pred, item, result)) {
      result[result.length] = item;
    }

    idx += 1;
  }

  return result;
}));

/* harmony default export */ const es_uniqWith = ((/* unused pure expression or super */ null && (uniqWith_uniqWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/unionWith.js



/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list. Duplication is determined according to the value returned by
 * applying the supplied predicate to two list elements. If an element exists
 * in both lists, the first element from the first list will be used.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @see R.union
 * @example
 *
 *      const l1 = [{a: 1}, {a: 2}];
 *      const l2 = [{a: 1}, {a: 4}];
 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
 */

var unionWith =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry3(function unionWith(pred, list1, list2) {
  return uniqWith(pred, _concat(list1, list2));
})));

/* harmony default export */ const es_unionWith = ((/* unused pure expression or super */ null && (unionWith)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/unnest.js


/**
 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain c => c (c a) -> c a
 * @param {*} list
 * @return {*}
 * @see R.flatten, R.chain
 * @example
 *
 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
 */

var unnest =
/*#__PURE__*/
es_chain(_identity);
/* harmony default export */ const es_unnest = ((/* unused pure expression or super */ null && (unnest)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/unwind.js




/**
 *
 * Deconstructs an array field from the input documents to output a document for each element.
 * Each output document is the input document with the value of the array field replaced by the element.
 *
 * @func
 * @memberOf R
 * @since v0.28.0
 * @category Object
 * @sig String -> {k: [v]} -> [{k: v}]
 * @param {String} key The key to determine which property of the object should be unwind
 * @param {Object} object The object containing list under property named as key which is to unwind
 * @return {List} A new list of object containing the value of input key having list replaced by each element in the object.
 * @example
 *
 * R.unwind('hobbies', {
 *   name: 'alice',
 *   hobbies: ['Golf', 'Hacking'],
 *   colors: ['red', 'green'],
 * });
 * // [
 * //   { name: 'alice', hobbies: 'Golf', colors: ['red', 'green'] },
 * //   { name: 'alice', hobbies: 'Hacking', colors: ['red', 'green'] }
 * // ]
 */

var unwind =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function (key, object) {
  // If key is not in object or key is not as a list in object
  if (!(key in object && _isArray(object[key]))) {
    return [object];
  } // Map over object[key] which is a list and assoc each element with key


  return _map(function (item) {
    return _assoc(key, item, object);
  }, object[key]);
})));

/* harmony default export */ const es_unwind = ((/* unused pure expression or super */ null && (unwind)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/whereEq.js




/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec, false otherwise. An object satisfies the spec if, for each of the
 * spec's own properties, accessing that property of the object gives the same
 * value (in [`R.equals`](#equals) terms) as accessing that property of the
 * spec.
 *
 * `whereEq` is a specialization of [`where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @sig {String: *} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.propEq, R.where
 * @example
 *
 *      // pred :: Object -> Boolean
 *      const pred = R.whereEq({a: 1, b: 2});
 *
 *      pred({a: 1});              //=> false
 *      pred({a: 1, b: 2});        //=> true
 *      pred({a: 1, b: 2, c: 3});  //=> true
 *      pred({a: 1, b: 1});        //=> false
 */

var whereEq =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function whereEq(spec, testObj) {
  return where(map(equals, spec), testObj);
})));

/* harmony default export */ const es_whereEq = ((/* unused pure expression or super */ null && (whereEq)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/without.js




/**
 * Returns a new list without values in the first argument.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce, R.difference, R.remove
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */

var without =
/*#__PURE__*/
(/* unused pure expression or super */ null && (_curry2(function (xs, list) {
  return reject(flip(_includes)(xs), list);
})));

/* harmony default export */ const es_without = ((/* unused pure expression or super */ null && (without)));
;// CONCATENATED MODULE: ../../node_modules/ramda/es/index.js





































































































































































































































































;// CONCATENATED MODULE: ../../packages/rpcs/wallet_afterUnlock/index.js



const NAME = 'wallet_afterUnlock'

const schemas = {
  input: [spec.map, {closed: true}, ['waitSideEffects', {optional: true}, spec.booleanp]],
}

const permissions = {
  external: [],
  methods: [
    'wallet_refetchTokenList',
    'wallet_refetchBalance',
    'wallet_discoverAccounts',
    'wallet_createAddress',
  ],
  db: ['getAccountGroup', 'getNetwork'],
}

async function updateBalanceInfo({
  params: {waitSideEffects},
  db: {getAccountGroup},
  rpcs: {
    wallet_discoverAccounts,
    wallet_refetchTokenList,
    wallet_refetchBalance,
  },
}) {
  let promise = wallet_refetchTokenList()
    .then(() =>
      Promise.all(
        getAccountGroup().map(({eid}) =>
          wallet_discoverAccounts({accountGroupId: eid, waitTillFinish: true}),
        ),
      ),
    )
    .then(() => wallet_refetchBalance({type: 'all', allNetwork: true}))
  if (waitSideEffects) await promise
}

// when there're new networks added while wallet is locked (through migration)
// we need to add misiing addrs to account
async function fillMissingAccountAddress({
  rpcs: {wallet_createAddress},
  db: {getNetwork, getAccountGroup},
}) {
  const networks = getNetwork()
  const cfxNetworks = getNetwork({type: 'cfx'})
  const ethNetworks = getNetwork({type: 'eth'})
  const lackCfxAddr = es_any(
    account => account.address.length < cfxNetworks.length,
  )
  const lackEthAddr = es_any(
    account => account.address.length < ethNetworks.length,
  )
  const lackAddr = es_any(account => account.address.length < networks.length)
  const promises = getAccountGroup().reduce((acc, {vault, account, eid}) => {
    // cfx only account group
    if (vault.cfxOnly && (vault.type === 'pub' || vault.type === 'hw')) {
      //  lack cfx network addrs
      if (lackCfxAddr(account)) {
        return acc.concat(
          cfxNetworks.map(network =>
            wallet_createAddress({
              accountGroupId: eid,
              networkId: network.eid,
            }),
          ),
        )
      } else {
        return acc
      }
    } else if (!vault.cfxOnly && vault.type === 'hw') {
      //  lack eth network addrs
      if (lackEthAddr(account)) {
        return acc.concat(
          ethNetworks.map(network =>
            wallet_createAddress({
              accountGroupId: eid,
              networkId: network.eid,
            }),
          ),
        )
      } else {
        return acc
      }
    } else if (lackAddr(account)) {
      // rest account group, lack addrs
      return acc.concat(
        networks.map(network => {
          wallet_createAddress({accountGroupId: eid, networkId: network.eid})
        }),
      )
    } else {
      return acc
    }
  }, [])

  return Promise.all(promises)
}

const main = async args => {
  await fillMissingAccountAddress(args)
  try {
    await updateBalanceInfo(args)
    // eslint-disable-next-line no-empty
  } catch (err) {}
}


/***/ }),

/***/ 11780:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_chainId'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_chainId', 'eth_chainId'],
  db: [],
}

const main = ({rpcs: {cfx_chainId, eth_chainId}, network: {type}}) => {
  if (type === 'cfx') {
    return cfx_chainId()
  } else {
    return eth_chainId([])
  }
}


/***/ }),

/***/ 32035:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_cleanupTx'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: [],
  locked: true,
  methods: [],
  db: ['cleanupTx'],
}

const main = ({db: {cleanupTx}}) => {
  cleanupTx()
}


/***/ }),

/***/ 7470:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32299);
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11239);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2723);






const NAME = 'wallet_createAccount'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nickname],
    ['select', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
  ],
}

const permissions = {
  db: [
    'findGroup',
    'findAccount',
    'getNetwork',
    'getPassword',
    't',
    'newAddressTx',
  ],
  methods: ['wallet_setCurrentAccount'],
  external: ['popup'],
}

const main = async ({
  rpcs: {wallet_setCurrentAccount},
  db: {findGroup, getPassword, getNetwork, t, findAccount, newAddressTx},
  params: {accountGroupId, nickname, select},
  Err: {InvalidParams},
  _popup,
}) => {
  const group = findGroup({
    groupId: accountGroupId,
    g: {
      account: {nickname: 1},
      vault: {type: 1, ddata: 1, data: 1, cfxOnly: 1},
      nickname: 1,
    },
  })
  if (!group) throw InvalidParams('Invalid account group id')

  const {vault} = group
  if (vault.type !== 'hd')
    throw InvalidParams("Can't add account into none hd vault")

  const existAccounts = group.account || []
  const nextAccountIdx = existAccounts.length
  // const hasDuplicateNicknameInSameAccountGroup = existAccounts.reduce(
  //   (acc, account) => acc || account.nickname === nickname,
  //   false,
  // )
  // if (hasDuplicateNicknameInSameAccountGroup)
  //   throw InvalidParams(
  //     `Invalid nickname "${nickname}", duplicate with other account in the same account group`,
  //   )

  const password = getPassword()
  const decrypted = vault.ddata ?? (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, vault.data))
  const networks = getNetwork()

  const accountId = (
    await Promise.all(
      networks.map(async ({eid, hdPath, netId, type}) => ({
        eid,
        netId,
        type,
        addr: await (0,_fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_2__/* .getNthAccountOfHDKey */ .Zr)({
          mnemonic: decrypted,
          hdPath: hdPath.value,
          nth: nextAccountIdx,
          only0x1Prefixed: vault.cfxOnly,
        }),
      })),
    ).then(params =>
      params.map(({eid, netId, type, addr: {address, privateKey}}) => {
        const accountId =
          findAccount({
            groupId: accountGroupId,
            index: nextAccountIdx,
          })[0] || 'accountId'

        const addrTx = newAddressTx({
          eid: -1,
          network: eid,
          value:
            type === 'cfx' ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_4__/* .encode */ .cv)((0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__/* .toAccountAddress */ .RE)(address), netId) : address,
          hex: address,
          pk: privateKey,
        })

        const {tempids} = t([
          addrTx,
          {
            eid: accountId,
            account: {
              index: nextAccountIdx,
              nickname: nickname ?? `${group.nickname}-${nextAccountIdx + 1}`,
              address: addrTx.eid,
              hidden: false,
            },
          },
          {eid: accountGroupId, accountGroup: {account: accountId}},
        ])

        return tempids.accountId ?? accountId
      }),
    )
  )[0]

  if (_popup && select) {
    await wallet_setCurrentAccount([accountId])
  }
  return accountId
}


/***/ }),

/***/ 95318:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32299);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11239);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89620);






const NAME = 'wallet_createAddress'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['networkId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  methods: [],
  db: [
    'getPassword',
    'findGroup',
    'getNetworkById',
    't',
    'newAddressTx',
    'findAddress',
  ],
}

const main = async ({
  Err: {InvalidParams},
  db: {getNetworkById, findGroup, getPassword, t, newAddressTx, findAddress},
  params: {networkId, accountGroupId},
}) => {
  const network = getNetworkById(networkId)
  if (!network) throw InvalidParams(`Invalid network id ${networkId}`)

  const group = findGroup({
    groupId: accountGroupId,
    g: {
      account: {eid: 1, index: 1},
      vault: {type: 1, cfxOnly: 1, ddata: 1, data: 1},
    },
  })
  if (!group) throw InvalidParams(`Invalid account group id ${accountGroupId}`)

  const {vault} = group
  if (vault.type === 'pub' && vault.cfxOnly && network.type !== 'cfx')
    throw InvalidParams(
      "Can't create address for cfx only vault in eth network",
    )

  if (vault.type === 'hw' && vault.cfxOnly && network.type !== 'cfx')
    throw InvalidParams(
      "Can't create hw account address for cfx only vault in eth network",
    )
  if (vault.type === 'hw' && !vault.cfxOnly && network.type !== 'eth')
    throw InvalidParams(
      "Can't create hw account address for eth only vault in cfx network",
    )

  const pwd = getPassword()

  const decrypted = vault.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_4__.decrypt)(pwd, vault.data))
  if (vault.type === 'pub') {
    const addrTx = newAddressTx({
      eid: 'newAddr',
      hex: decrypted,
      network: networkId,
      value:
        network.type === 'cfx'
          ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__/* .encode */ .cv)((0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__/* .toAccountAddress */ .RE)(decrypted), network.netId)
          : decrypted,
    })
    return [
      t([addrTx, {eid: group.account[0].eid, account: {address: addrTx.eid}}])
        .tempids.newAddr || addrTx.eid,
    ]
  } else if (vault.type === 'pk') {
    const hex = (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__/* .fromPrivate */ .yV)(decrypted).address
    const addrTx = newAddressTx({
      eid: 'newAddr',
      hex: hex.toLowerCase(),
      network: networkId,
      value:
        network.type === 'cfx'
          ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__/* .encode */ .cv)((0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__/* .toAccountAddress */ .RE)(hex), network.netId)
          : hex.toLowerCase(),
    })
    return [
      t([addrTx, {eid: group.account[0].eid, account: {address: addrTx.eid}}])
        .tempids.newAddr || addrTx.eid,
    ]
  } else if (vault.type === 'hw') {
    return group.account.map(account => {
      const [sameNetworkTypeAddress] = findAddress({
        accountId: account.eid,
        networkType: network.type,
        groupId: accountGroupId,
        g: {hex: 1},
      })
      const addrTx = newAddressTx({
        eid: 'newAddr',
        hex: sameNetworkTypeAddress.hex,
        value:
          network.type === 'cfx'
            ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__/* .encode */ .cv)(
                (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__/* .toAccountAddress */ .RE)(sameNetworkTypeAddress.hex),
                network.netId,
              )
            : sameNetworkTypeAddress.hex,
        network: networkId,
      })
      return (
        t([addrTx, {eid: account.eid, account: {address: addrTx.eid}}]).tempids
          .newAddr || addrTx.eid
      )
    })
  } else {
    return await Promise.all(
      group.account.map(async account => ({
        account,
        addr: await (0,_fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_1__/* .getNthAccountOfHDKey */ .Zr)({
          mnemonic: decrypted,
          hdPath: network.hdPath.value,
          nth: account.index,
          only0x1Prefixed: vault.cfxOnly,
        }),
      })),
    ).then(toCreates =>
      toCreates.map(({account, addr: {privateKey, address}}) => {
        const addrTx = newAddressTx({
          eid: 'newAddr',
          hex: address.toLowerCase(),
          pk: privateKey,
          network: networkId,
          value:
            network.type === 'cfx'
              ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__/* .encode */ .cv)((0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_3__/* .toAccountAddress */ .RE)(address), network.netId)
              : address.toLowerCase(),
        })
        return (
          t([addrTx, {eid: account.eid, account: {address: addrTx.eid}}])
            .tempids.newAddr || addrTx.eid
        )
      }),
    )
  }
}


/***/ }),

/***/ 66979:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_dbQuery'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['method', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
    ['params', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp],
  ],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: [],
}

const main = ({Err: {InvalidParams}, db, params: {method, params}}) => {
  if (!db[method]) throw InvalidParams(`Invalid db query method ${method}`)
  return db[method](params)
}


/***/ }),

/***/ 72759:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);



const NAME = 'wallet_deleteAccount'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password]],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_validatePassword', 'wallet_deleteAccountGroup'],
  db: ['retractAccount', 'findAccount'],
}

const main = async ({
  Err: {InvalidParams},
  db: {findAccount, retractAccount},
  rpcs: {wallet_validatePassword, wallet_deleteAccountGroup},
  params: {accountId, password},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  const account = findAccount({
    accountId,
    g: {
      _accountGroup: {eid: 1, vault: {type: 1, data: 1}, account: 1},
      address: {value: 1},
    },
  })
  if (!account) throw InvalidParams(`Invalid account group id ${accountId}`)

  let ddata
  if (account.accountGroup.vault.type === 'hw') {
    ddata = await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, account.accountGroup.vault.data)
    delete ddata[account.address[0].value]
    ddata = await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.encrypt)(password, ddata)
  }

  if (account.accountGroup.account.length === 1) {
    return await wallet_deleteAccountGroup({
      accountGroupId: account.accountGroup.eid,
      password,
    })
  }

  retractAccount({accountId, hwVaultData: ddata})
  return true
}


/***/ }),

/***/ 87555:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_deleteAccountGroup'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
  ],
}

const permissions = {
  db: ['getAccountGroupById', 'retractGroup'],
  external: ['popup'],
  methods: ['wallet_validatePassword'],
}

const main = async ({
  Err: {InvalidParams},
  rpcs: {wallet_validatePassword},
  db: {getAccountGroupById, retractGroup},
  params: {accountGroupId, password},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  const group = getAccountGroupById(accountGroupId)

  if (!group) throw InvalidParams(`Invalid account group id ${accountGroupId}`)

  retractGroup({groupId: group.eid})
  return true
}


/***/ }),

/***/ 6630:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34577);



const NAME = 'wallet_deleteApp'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['appId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['retract', 'getAppById'],
}

const main = ({
  Err: {InvalidParams},
  db: {getAppById, retract},
  params: {appId},
}) => {
  const app = getAppById(appId)
  if (!app) throw InvalidParams(`Invalid app id ${appId}`)
  ;(0,_fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(app.site.post) &&
    app.site.post({event: 'accountsChanged', params: []})
  retract(app.eid)
  return null
}


/***/ }),

/***/ 26990:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_deleteMemo'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['memoId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['retract', 'getMemoById'],
}

const main = ({
  Err: {InvalidParams},
  db: {retract, getMemoById},
  params: {memoId},
}) => {
  if (!getMemoById(memoId)) throw InvalidParams(`Invalid memo id ${memoId}`)
  retract(memoId)

  return
}


/***/ }),

/***/ 53871:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_deleteNetwork'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password], ['networkId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  external: ['popup'],
  db: ['retractNetwork', 'getNetworkById', 'getNetwork'],
  methods: ['wallet_validatePassword', 'wallet_setCurrentNetwork'],
}

const main = async ({
  Err: {InvalidParams},
  db: {getNetworkById, retractNetwork, getNetwork},
  rpcs: {wallet_validatePassword, wallet_setCurrentNetwork},
  params: {password, networkId},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  const network = getNetworkById(networkId)
  if (!network) throw InvalidParams(`Invalid network id ${networkId}`)
  if (network.builtin)
    throw InvalidParams(`Not allowed to delete builtin network`)

  if (network.selected) {
    const networks = getNetwork()
    // select the 'next' network of the to-b deleted one
    const nextNetwork = networks.reduce((_, n, idx) => {
      if (n.eid === networkId) return networks[idx + 1] || networks[0]
    }, undefined)
    await wallet_setCurrentNetwork({errorFallThrough: true}, [nextNetwork.eid])
  }
  retractNetwork({networkId})
  return true
}


/***/ }),

/***/ 26155:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
// EXTERNAL MODULE: ../../packages/checks/index.js + 3 modules
var checks = __webpack_require__(34577);
;// CONCATENATED MODULE: ../../packages/detect-address-type/index.js
const detectCfxAddressType=async address=>{const isBase32=address.includes(':');if(isBase32){const type=(0,base32_address/* decode */.Jx)(address).type;return{type,[type]:true};}throw new Error(`don't support detect hex address with cfx network`);};const detectEthAddressType=async(address,{request}={})=>{if(!(0,checks/* isFunction */.mf)(request))throw new Error('opts.request is not a function');let rst;try{rst=await request({method:'eth_getCode',params:[address]});}catch(err){}// eslint-disable-line no-empty
if(!rst||rst==='0x')return{type:'unknown',contract:false};return{type:'contract',contract:true};};const detectAddressType=async(address,opts={})=>{if(opts.type==='cfx')return await detectCfxAddressType(address);if(opts.type==='eth')return await detectEthAddressType(address,opts);throw new Error(`Invalid opts.type ${opts.type}, must be one of cfx or eth`);};
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_detectAddressType/index.js



const NAME = 'wallet_detectAddressType'

const schemas = {
  input: [spec.map, {closed: true}, ['address', [spec.or, spec.base32Address, spec.ethHexAddress]]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['eth_getCode'],
  db: ['getTokenByAddress'],
}

const main = async ({
  rpcs: {eth_getCode},
  db: {getTokenByAddress},
  params: {address},
  network: {type},
}) => {
  if (getTokenByAddress(address).length > 0)
    return {type: 'contract', contract: true}
  if (type === 'cfx') return await detectCfxAddressType(address)
  if (type === 'eth')
    return await detectEthAddressType(address, {
      request({params}) {
        return eth_getCode({errorFallThrough: true}, params)
      },
    })
}


/***/ }),

/***/ 50027:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_detectNetworkType'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['url', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.url]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = async ({f, Err: {InvalidParams}, params: {url}}) => {
  let rst

  try {
    rst = await f(
      {
        errorFallThrough: true,
        timeout: 5000,
        networkName: url,
        network: {endpoint: url, name: url},
        method: 'cfx_getStatus',
      },
      [],
    )
  } catch (err) {
    if (!(err?.response?.status < 500))
      throw InvalidParams(`Invalid rpc endpoint ${url}`)
  }

  if (rst?.result) {
    return {
      chainId: rst.result.chainId,
      netId: parseInt(rst.result.networkId, 16).toString(),
      type: 'cfx',
    }
  }

  try {
    rst = await f(
      {
        errorFallThrough: true,
        timeout: 5000,
        networkName: url,
        network: {endpoint: url, name: url},
        method: 'eth_chainId',
      },
      [],
    )
  } catch (err) {
    if (!(err?.response?.status < 500))
      throw InvalidParams(`Invalid rpc endpoint ${url}`)
  }

  if (rst?.result) {
    const netId = (
      await f(
        {
          networkName: url,
          network: {endpoint: url, name: url},
          method: 'net_version',
        },
        [],
      )
    ).result

    return {
      netId: parseInt(netId, 10).toString(),
      chainId: rst.result,
      type: 'eth',
    }
  }

  throw InvalidParams(`Unsupported network type`)
}


/***/ }),

/***/ 45164:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
// EXTERNAL MODULE: ../../packages/addr-by-network/index.js
var addr_by_network = __webpack_require__(64347);
// EXTERNAL MODULE: ../../packages/hdkey/index.js
var hdkey = __webpack_require__(32299);
// EXTERNAL MODULE: ../../packages/csp/index.js + 9 modules
var csp = __webpack_require__(75321);
// EXTERNAL MODULE: ../../packages/utils/index.js
var utils = __webpack_require__(11818);
// EXTERNAL MODULE: ../../node_modules/bn.js/lib/bn.js
var bn = __webpack_require__(62197);
// EXTERNAL MODULE: ../../packages/checks/index.js + 3 modules
var checks = __webpack_require__(34577);
;// CONCATENATED MODULE: ../../packages/discover-accounts/index.js
const ZERO=new bn(0,10);const hasTx=async({getTxCount,address})=>{let rst=false;try{const res=await getTxCount([address]);if(new bn((0,utils/* stripHexPrefix */.MT)(res),16).gt(ZERO))rst=true;}catch(err){}// eslint-disable-line no-empty
return rst;};const hasBalance=async({getBalance,address})=>{let rst=false;try{let res=await getBalance(address);res=Object.values(res)[0];rst=Object.values(res).reduce((acc,m)=>{if(acc)return true;return acc||new bn((0,utils/* stripHexPrefix */.MT)(m),16).gt(ZERO);},rst);}catch(err){}// eslint-disable-line no-empty
return rst;};const _discoverAccounts=async({getBalance,getTxCount,mnemonic,hdPath,startFrom=0,max=1000,only0x1Prefixed=false,return0=false,onFindOne,c})=>{const found=[];for(let i=startFrom;i<startFrom+max;i++){const rst=await (0,hdkey/* getNthAccountOfHDKey */.Zr)({mnemonic,hdPath,nth:i,only0x1Prefixed});// no request for first addr
const[txOk,balanceOk]=startFrom===0&&i===0?[true,true]:await Promise.all([hasTx({getTxCount,address:rst.address}),hasBalance({getBalance,address:rst.address})]);// always return the first address
// nth: the try times starts at 0
if(return0&&i===0||txOk||balanceOk){if((0,checks/* isFunction */.mf)(onFindOne))await onFindOne({...rst,nth:i});found.push({...rst,nth:i});c.write({...rst,nth:i});}else{c.close();return found;}}return found;};const discoverAccounts=(args={})=>{const c=(0,csp/* chan */.zH)();_discoverAccounts({...args,c});return c;};
// EXTERNAL MODULE: ../../node_modules/@thi.ng/compose/partial.js
var partial = __webpack_require__(67044);
// EXTERNAL MODULE: ../../node_modules/browser-passworder/index.js
var browser_passworder = __webpack_require__(89620);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_discoverAccounts/index.js







const NAME = 'wallet_discoverAccounts'

const limitSchema = [
  'limit',
  {optional: true},
  [spec.int, {min: 1, max: 100, doc: 'how many derivation we try, default to 10'}],
]

const authedSchema = [
  spec.map,
  {closed: true},
  ['accountGroupId', spec.dbid],
  ['waitTillFinish', {optional: true}, [spec.maybe, spec.truep]],
  limitSchema,
]

const schemas = {
  input: authedSchema,
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_getBalance', 'wallet_getNextNonce', 'wallet_createAccount'],
  db: ['findGroup', 'getNetwork', 'getPassword'],
}

const main = async ({
  rpcs: {wallet_getBalance, wallet_getNextNonce, wallet_createAccount},
  db: {findGroup, getNetwork, getPassword},
  params: {accountGroupId, limit = 1000, waitTillFinish},
  Err: {InvalidParams},
}) => {
  const accountGroup = findGroup({
    groupId: accountGroupId,
    g: {vault: {type: 1, data: 1, ddata: 1}, account: {eid: 1}},
  })
  if (!accountGroup)
    throw InvalidParams('Invalid accountGroupId, account group not found')
  const oldAccountsCount = accountGroup.account?.length ?? 0

  const {vault} = accountGroup
  if (vault.type !== 'hd') return // no need to discover accounts for none hd vault

  const mnemonic = vault.ddata || (await (0,browser_passworder.decrypt)(getPassword(), vault.data))

  const networks = getNetwork()

  const channels = networks.map(({name, hdPath, token, type, netId}) =>
    discoverAccounts({
      getBalance: addr =>
        wallet_getBalance(
          {networkName: name, errorFallThrough: true},
          {
            users: [
              (0,addr_by_network/* default */.Z)({
                address: addr,
                networkType: type,
                networkId: netId,
                addressType: 'user',
              }),
            ],
            tokens: ['0x0'].concat((token || []).map(t => t.address)),
          },
        ),
      getTxCount: (0,partial/* partial */.r)(wallet_getNextNonce, {networkName: name}),
      mnemonic,
      hdPath: hdPath.value,
      return0: oldAccountsCount === 0,
      startFrom: oldAccountsCount,
      max: limit,
    }),
  )

  const discoveredNewAddressOnEachNet = networks.map(() => 0)

  const accountIds = []
  const firstAccountCreatedChan = (0,csp/* chan */.zH)(1)
  const promises = channels.map(async (c, idx) => {
    while (!c.isClosed()) {
      const found = await c.read()
      if (!found) {
        !firstAccountCreatedChan.isClosed() &&
          firstAccountCreatedChan.write(true)
        return
      }
      discoveredNewAddressOnEachNet[idx] += 1
      if (greatThanOthers(idx, discoveredNewAddressOnEachNet)) {
        accountIds.push(await wallet_createAccount({accountGroupId}))
        !firstAccountCreatedChan.isClosed() &&
          firstAccountCreatedChan.write(true)
      }
    }
  })

  if (waitTillFinish) {
    return await Promise.all(promises)
  }

  return await firstAccountCreatedChan.read()
}

function greatThanOthers(idx, arr) {
  const base = arr[idx]
  return arr.reduce(
    (acc, item, innerIdx) => acc && (innerIdx === idx || base > item),
    true,
  )
}


/***/ }),

/***/ 14445:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_contract_method_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80341);




const NAME = 'wallet_enrichConfluxTx'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['txhash', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32]],
}

const permissions = {
  external: [],
  locked: true,
  methods: ['wallet_validate20Token', 'wallet_refetchBalance'],
  db: ['getTxsToEnrich', 't', 'isTokenInAddr', 'newtokenTx'],
}

const main = async ({
  db: {getTxsToEnrich, t, isTokenInAddr, newtokenTx},
  rpcs: {wallet_validate20Token, wallet_refetchBalance},
  params: {txhash},
}) => {
  const txData = getTxsToEnrich({txhash, type: 'cfx'})
  if (!txData) return

  const {tx, address, network, token, app} = txData
  const txExtraEid = tx.txExtra.eid
  const txs = []
  const {to, data, receipt} = tx.txPayload
  let decoded

  let noError = true

  if (token) {
    txs.push({eid: token.eid, token: {tx: tx.eid}})
    if (!isTokenInAddr({tokenId: token.eid, addressId: address.eid})) {
      txs.push({eid: token.eid, token: {tx: tx.eid}})
      if (app) txs.push({eid: token.eid, token: {fromApp: true}})
      else txs.push({eid: token.eid, token: {fromUser: true}})
    }
  }

  if (to) {
    decoded = (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .decode */ .Jx)(to)
    if (
      decoded.type === 'user' ||
      decoded.hexAddress === '0x0000000000000000000000000000000000000000' ||
      !data
    )
      txs.push({eid: txExtraEid, txExtra: {simple: true, ok: true}})
    else if (decoded.type !== 'user')
      txs.push({
        eid: txExtraEid,
        txExtra: {contractInteraction: true, ok: true},
      })
  }

  if (!to && data) {
    if (receipt) txs.push({eid: txExtraEid, txExtra: {contractCreation: true}})
    else
      txs.push({eid: txExtraEid, txExtra: {contractCreation: true, ok: true}})
  }

  if (to && data && decoded.type === 'contract') {
    const contractAddress = to
    try {
      const {valid, symbol, name, decimals} = await wallet_validate20Token(
        {network, networkName: network.name, errorFallThrough: true},
        {tokenAddress: contractAddress},
      )
      if (valid) {
        const tokenTx = newtokenTx({
          eid: 'newtoken',
          name,
          symbol,
          decimals,
          tx: tx.eid,
          network: network.eid,
          address: contractAddress,
        })
        txs.push({eid: txExtraEid, txExtra: {token20: true}}, tokenTx, {
          eid: address.eid,
          address: {token: tokenTx.eid},
        })
        if (app) txs.push({eid: tokenTx.eid, token: {fromApp: true}})
        else txs.push({eid: tokenTx.eid, token: {fromUser: true}})

        try {
          const {name, args} = await (0,_fluent_wallet_contract_method_name__WEBPACK_IMPORTED_MODULE_2__/* .getCFXContractMethodSignature */ .N)(
            to,
            data,
            network.netId,
          )
          switch (name) {
            case 'transfer':
            case 'approve':
            case 'send':
              txs.push({
                eid: txExtraEid,
                txExtra: {
                  // moreInfo: {args: [...args]},
                  address: args[0].toLowerCase(),
                  method: name,
                },
              })
              break
          }
        } catch (err) {} // eslint-disable-line no-empty

        wallet_refetchBalance(
          {
            network,
            networkName: network.name,
            errorFallThrough: true,
          },
          [],
        )
      }
    } catch (err) {
      noError = false
    }
  }

  if (noError) {
    txs.length && t(txs)
  }
}


/***/ }),

/***/ 79461:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_contract_method_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80341);



const NAME = 'wallet_enrichEthereumTx'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['txhash', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32]],
}

const permissions = {
  external: [],
  locked: true,
  methods: [
    'wallet_validate20Token',
    'wallet_refetchBalance',
    'wallet_detectAddressType',
  ],
  db: ['getTxsToEnrich', 't', 'isTokenInAddr', 'newtokenTx'],
}

const main = async ({
  db: {getTxsToEnrich, t, isTokenInAddr, newtokenTx},
  rpcs: {
    wallet_validate20Token,
    wallet_refetchBalance,
    wallet_detectAddressType,
  },
  params: {txhash},
}) => {
  const txData = getTxsToEnrich({txhash, type: 'eth'})
  if (!txData) return

  const {tx, address, network, token, app} = txData
  const txExtraEid = tx.txExtra.eid
  const txs = []
  const {to, data, receipt} = tx.txPayload

  let noError = true

  if (token) {
    txs.push({eid: token.eid, token: {tx: tx.eid}})
    if (!isTokenInAddr({tokenId: token.eid, addressId: address.eid})) {
      txs.push({eid: token.eid, token: {tx: tx.eid}})
      if (app) txs.push({eid: token.eid, token: {fromApp: true}})
      else txs.push({eid: token.eid, token: {fromUser: true}})
    }
  }

  let toAddressType

  if (to) {
    toAddressType = await wallet_detectAddressType(
      {networkName: network.name},
      {address: to},
    )
    if (!toAddressType.contract || !data)
      txs.push({eid: txExtraEid, txExtra: {simple: true, ok: true}})
    else if (toAddressType.contract)
      txs.push({
        eid: txExtraEid,
        txExtra: {contractInteraction: true, ok: true},
      })
  }

  if (!to && data) {
    if (receipt) txs.push({eid: txExtraEid, txExtra: {contractCreation: true}})
    else
      txs.push({eid: txExtraEid, txExtra: {contractCreation: true, ok: true}})
  }

  if (to && data && toAddressType.contract) {
    const contractAddress = to
    try {
      const {valid, symbol, name, decimals} = await wallet_validate20Token(
        {network, networkName: network.name, errorFallThrough: true},
        {tokenAddress: contractAddress},
      )
      if (valid) {
        const tokenTx = newtokenTx({
          eid: 'newtoken',
          name,
          symbol,
          decimals,
          tx: tx.eid,
          network: network.eid,
          address: contractAddress,
        })
        txs.push({eid: txExtraEid, txExtra: {token20: true}}, tokenTx, {
          eid: address.eid,
          address: {token: tokenTx.eid},
        })
        if (app) txs.push({eid: tokenTx.eid, token: {fromApp: true}})
        else txs.push({eid: tokenTx.eid, token: {fromUser: true}})

        try {
          const {name, args} = await (0,_fluent_wallet_contract_method_name__WEBPACK_IMPORTED_MODULE_1__/* .getEthContractMethodSignature */ .A)(data)
          switch (name) {
            case 'transfer':
            case 'approve':
            case 'send':
              txs.push({
                eid: txExtraEid,
                txExtra: {
                  // moreInfo: {args: [...args]},
                  address: args[0].toLowerCase(),
                  method: name,
                },
              })
              break
          }
        } catch (err) {} // eslint-disable-line no-empty

        wallet_refetchBalance(
          {
            network,
            networkName: network.name,
            errorFallThrough: true,
          },
          [],
        )
      }
    } catch (err) {
      noError = false
    }
  }

  if (noError) {
    txs.length && t(txs)
  }
}


/***/ }),

/***/ 32169:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_enrichTxs'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: [],
  locked: true,
  methods: ['wallet_enrichConfluxTx', 'wallet_enrichEthereumTx'],
  db: ['getTxsToEnrich'],
}

const main = ({
  db: {getTxsToEnrich},
  rpcs: {wallet_enrichConfluxTx, wallet_enrichEthereumTx},
}) => {
  const enrichFn = {cfx: wallet_enrichConfluxTx, eth: wallet_enrichEthereumTx}
  const txsToEnrich = getTxsToEnrich()
  txsToEnrich.forEach(({tx, network}) => {
    try {
      enrichFn[network.type]({errorFallThrough: true}, {txhash: tx.hash})
    } catch (err) {} // eslint-disable-line no-empty
  })
}


/***/ }),

/***/ 23490:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32299);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89620);




const NAME = 'wallet_exportAccount'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password]],
}

const permissions = {
  db: ['findAccount'],
  methods: ['wallet_validatePassword', 'wallet_exportAccountGroup'],
  external: ['popup'],
}

const main = async ({
  Err: {InvalidParams},
  db: {findAccount},
  rpcs: {wallet_validatePassword, wallet_exportAccountGroup},
  params: {password, accountId},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  const account = findAccount({
    accountId,
    g: {
      _accountGroup: {vault: {type: 1, cfxOnly: 1, data: 1, ddata: 1}, eid: 1},
      index: 1,
      address: {
        hex: 1,
        value: 1,
        pk: 1,
        network: {hdPath: {value: 1}, name: 1},
      },
    },
  })
  if (!account.accountGroup.vault.type)
    throw InvalidParams(`Invalid account id ${accountId}`)

  const {vault} = account.accountGroup
  if (vault.type !== 'hd')
    return await wallet_exportAccountGroup({
      password,
      accountGroupId: account.accountGroup.eid,
    })

  const decrypted = vault.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_2__.decrypt)(password, vault.data))

  const rst = account.address.map(async ({hex, value, pk, network}) => {
    const hdPath = network.hdPath.value // account.accountGroup.customHdPath?.value ||
    const privateKey =
      pk ||
      (
        await (0,_fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_1__/* .getNthAccountOfHDKey */ .Zr)({
          mnemonic: decrypted,
          hdPath,
          nth: account.index,
          only0x1Prefixed: Boolean(vault.cfxOnly),
        })
      ).privateKey

    return {
      hex,
      value,
      privateKey,
      network,
    }
  })

  return await Promise.all(rst)
}


/***/ }),

/***/ 13334:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9414);





const NAME = 'wallet_exportAccountGroup'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
  ],
}

const permissions = {
  db: ['findGroup'],
  methods: ['wallet_validatePassword'],
  external: ['popup'],
}

const main = async ({
  Err: {InvalidParams},
  db: {findGroup},
  rpcs: {wallet_validatePassword},
  params: {password, accountGroupId},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  const group = findGroup({
    groupId: accountGroupId,
    g: {vault: {data: 1, ddata: 1, type: 1, cfxOnly: 1}},
  })
  if (!group?.vault?.data)
    throw InvalidParams(`Invalid account group id ${accountGroupId}`)

  let decrypted =
    group.vault.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, group.vault.data))

  if (group.vault.type === 'pub' && group.vault.cfxOnly)
    decrypted = (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_2__/* .encode */ .cv)(decrypted, _fluent_wallet_consts__WEBPACK_IMPORTED_MODULE_3__/* .CFX_MAINNET_NETID */ .sU)

  return decrypted
}


/***/ }),

/***/ 39760:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);



const NAME = 'wallet_exportAll'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
    ['encryptPassword', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
  ],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_validatePassword'],
  db: ['getNetwork', 'getAccountGroup', 'getExportAllData'],
}

const main = async ({
  Err: {InvalidParams},
  db: {getExportAllData},
  rpcs: {wallet_validatePassword},
  params: {password, encryptPassword},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')

  return {
    encrypted: await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.encrypt)(
      encryptPassword,
      JSON.stringify(getExportAllData()),
    ),
    wallet: 'fluent',
    version: '0',
  }
}


/***/ }),

/***/ 33206:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11239);




const NAME = 'wallet_generateAddress'

const base = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}]
const hex = ['hex', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep]
const base32 = ['base32', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep]
const addrType = ['type', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.addressType]
const cfx = ['cfx', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep]
const ethAddressSchema = [...base, hex, ['eth', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep]]
const cfxHexAddressSchema = [...base, hex, cfx, addrType]
const cfxBase32AddressSchema = [
  ...base,
  base32,
  cfx,
  addrType,
  ['networkId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.networkId],
]

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, ethAddressSchema, cfxHexAddressSchema, cfxBase32AddressSchema],
}
const permissions = {
  locked: true,
  external: ['popup'],
}

const genRandomCfxHexAddress = type => {
  if (!type) return (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_2__/* .randomCfxHexAddress */ .fS)()
  return (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_2__/* .randomHexAddress */ .MG)(type)
}

const main = function ({params: {eth, base32, hex, networkId, type}}) {
  if (eth) return (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_2__/* .randomHexAddress */ .MG)()
  if (hex) return genRandomCfxHexAddress(type)
  if (base32) return (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .randomBase32Address */ .TW)(type, networkId)
}


/***/ }),

/***/ 47158:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var bip39__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36832);
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27797);



const NAME = 'wallet_generateMnemonic'

const schemas = {
  output: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.mnemonic,
}
const permissions = {
  locked: true,
  external: ['popup'],
}

const main = () => {
  return (0,bip39__WEBPACK_IMPORTED_MODULE_0__/* .generateMnemonic */ .OF)()
}


/***/ }),

/***/ 9013:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11239);
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27797);



const NAME = 'wallet_generatePrivateKey'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.optParam,
  output: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.privateKey,
}
const permissions = {
  locked: true,
  external: ['popup'],
}

async function main() {
  return (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_0__/* .randomPrivateKey */ .UB)()
}


/***/ }),

/***/ 66700:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getAccountAddressByNetwork'

const singleQuerySchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ['networkId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
]

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, singleQuerySchema, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.oneOrMore, singleQuerySchema]],
}

const permissions = {
  external: ['popup'],
  db: ['getAccountById', 'getNetworkById', 'accountAddrByNetwork'],
}

const main = ({
  Err: {InvalidParams},
  db: {getAccountById, getNetworkById, accountAddrByNetwork},
  params,
}) => {
  if (!Array.isArray(params)) params = [params]

  const addrs = params.map(({accountId, networkId}) => {
    const account = getAccountById(accountId)
    if (!account) throw InvalidParams(`Invalid account id ${accountId}`)
    const network = getNetworkById(networkId)
    if (!network) throw InvalidParams(`Invalid network id ${networkId}`)
    return accountAddrByNetwork({account: accountId, network: networkId})
  })

  if (addrs.length === 1) return addrs[0]
  return addrs
}


/***/ }),

/***/ 69131:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getAccountGroup'

const AccountGroupTypeSchema = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'hd', 'pk', 'pub', 'hw']

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.maybe,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      ['accountGroupId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
      ['includeHidden', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep],
      [
        'type',
        {optional: true},
        [
          _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
          AccountGroupTypeSchema,
          [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.oneOrMore, AccountGroupTypeSchema]],
        ],
      ],
    ],
  ],
}

const permissions = {
  db: ['getAccountGroup'],
  external: ['popup'],
}

const main = ({
  Err: {InvalidParams},
  params = {},
  db: {getAccountGroup},
}) => {
  const {accountGroupId, includeHidden, type} = params
  const types = new Set()
  if (Array.isArray(type)) {
    if (type.length > 3) throw InvalidParams(`Invalid type: ${type}`)
    type.forEach(t => types.add(t))
    if (types.size !== type.length)
      throw InvalidParams(`Invalid type: ${type}, duplicate value`)
  } else if (type) {
    types.add(type)
  }
  const query = {}
  if (accountGroupId) query.eid = accountGroupId

  const accoungGroup = getAccountGroup(query) || []

  const notype = !types.size
  return accoungGroup.reduce((acc, g) => {
    if (notype || types.has(g.vault.type)) {
      if (includeHidden) return acc.concat(g)
      return g.hidden ? acc : acc.concat(g)
    }
    return acc
  }, [])
}


/***/ }),

/***/ 700:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);



const NAME = 'wallet_getAccountGroupVaultValue'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    [
      'password',
      {optional: true, doc: 'required when calling from popup'},
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password,
    ],
  ],
}

const permissions = {
  external: ['popup'],
  db: ['getPassword', 'getAccountGroupById'],
}

const main = async ({
  Err: {InvalidParams},
  db: {getPassword, getAccountGroupById},
  params: {password, accountGroupId},
  _popup,
}) => {
  if (_popup && password !== getPassword())
    throw InvalidParams('Invalid password')
  const group = getAccountGroupById(accountGroupId)
  if (!group) throw InvalidParams(`Invalid account group id ${accountGroupId}`)

  password = getPassword()
  return group.vault.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, group.vault.data))
}


/***/ }),

/***/ 60805:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32299);
/* harmony import */ var _fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11818);





const NAME = 'wallet_getAddressPrivateKey'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    [
      'password',
      {optional: true, doc: 'required when calling from popup'},
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password,
    ],
  ],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['findAddress', 'getPassword'],
}

const main = async ({
  Err: {InvalidParams},
  db: {getPassword, findAddress},
  params: {password, address, accountId},
  _popup,
  _internal,
  network,
}) => {
  if (!_internal && _popup && password !== getPassword())
    throw InvalidParams('Invalid password')
  const addr = findAddress({
    value: address,
    accountId,
    networkId: network.eid,
    g: {
      _account: {
        _accountGroup: {vault: {type: 1, ddata: 1, data: 1}},
        index: 1,
      },
      pk: 1,
      network: {hdPath: {value: 1}},
    },
  })
  if (!addr) throw InvalidParams(`Invalid address ${address}`)

  if (addr.pk) return (0,_fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_3__/* .addHexPrefix */ .L_)(addr.pk)

  const {vault} = addr.account.accountGroup

  if (vault.type === 'pub')
    throw InvalidParams(
      `Invalid address ${address}, the address vault is pub only`,
    )

  password = getPassword()

  if (vault.type === 'pk')
    return (0,_fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_3__/* .addHexPrefix */ .L_)(vault.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, vault.data)))

  if (vault.type === 'hd') {
    const mnemonic = vault.ddata || (await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, vault.data))
    const {privateKey} = await (0,_fluent_wallet_hdkey__WEBPACK_IMPORTED_MODULE_2__/* .getNthAccountOfHDKey */ .Zr)({
      mnemonic,
      hdPath: addr.network.hdPath.value,
      nth: addr.account.index,
      only0x1Prefixed: vault.cfxOnly,
    })

    return (0,_fluent_wallet_utils__WEBPACK_IMPORTED_MODULE_3__/* .addHexPrefix */ .L_)(privateKey)
  }
}


/***/ }),

/***/ 15589:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/addr-by-network/index.js
var addr_by_network = __webpack_require__(64347);
// EXTERNAL MODULE: ../../packages/contract-abis/777.js
var _777 = __webpack_require__(58934);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/abi/lib.esm/interface.js + 15 modules
var lib_esm_interface = __webpack_require__(64168);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/compose/partial.js
var partial = __webpack_require__(67044);
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var lib_esm = __webpack_require__(75398);
;// CONCATENATED MODULE: ../../packages/single-call-balance-tracker/index.js
const ABI=[{constant:true,inputs:[{name:'users',type:'address[]'},{name:'tokens',type:'address[]'}],name:'balances',outputs:[{name:'',type:'uint256[]'}],payable:false,stateMutability:'view',type:'function'}];const iface=new lib_esm_interface/* Interface */.vU(ABI);const encode=(users=[],tokens=[])=>iface.encodeFunctionData('balances',[users,tokens]);const decode=data=>iface.decodeFunctionResult('balances',data);const balances=async(...args)=>{const[request,to,users=[],tokens=[]]=args;if(args.length===1)return (0,partial/* partial */.r)(balances,request);if(args.length===2)return (0,partial/* partial */.r)(balances,request,to);const data=await request({data:encode(users.map(u=>u.includes(':')?(0,base32_address/* decode */.Jx)(u).hexAddress:u),tokens.map(t=>{if(t==='0x0')return'0x0000000000000000000000000000000000000000';return t.includes(':')?(0,base32_address/* decode */.Jx)(t).hexAddress:t;})),to});const[decoded]=decode(data);const tl=tokens.length;const rst={};users.forEach((u,uidx)=>{u=u.toLowerCase();rst[u]={};tokens.forEach((t,tidx)=>{t=t.toLowerCase();rst[u][t]=(0,lib_esm/* hexValue */.$P)(decoded[uidx*tl+tidx].toHexString());});});return rst;};const NetworkMetaData={eth:{71:'0x74191f6b288dff3db43b34d3637842c8146e2103',// cfx espace testnet
1030:'0x74191f6b288dff3db43b34d3637842c8146e2103',// cfx espace
1:'0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',// ethereum
3:'0x8D9708f3F514206486D7E988533f770a16d074a7',// ropsten
4:'0x3183B673f4816C94BeF53958BaF93C671B7F8Cf2',// rinkeby
42:'0x55ABBa8d669D60A10c104CC493ec5ef389EC92bb',// kovan
56:'0x2352c63A83f9Fd126af8676146721Fa00924d7e4',// bsc
97:'0x2352c63A83f9Fd126af8676146721Fa00924d7e4',// bsc test
137:'0x2352c63A83f9Fd126af8676146721Fa00924d7e4',// polygon
80001:'0x2352c63A83f9Fd126af8676146721Fa00924d7e4',// mumbai
10:'0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',// optimism
69:'0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',// optimism kovan
42161:'0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c'// arbitrum
},cfx:{1029:'cfx:achxne2gfh8snrstkxn0f32ua2cf19zwky2y66hj2d',// cfx mainnet
1:'cfxtest:achxne2gfh8snrstkxn0f32ua2cf19zwkyw9tpbc6k'// cfx testnet
}};
// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_getBalance/index.js







const NAME = 'wallet_getBalance'

const GetBalanceSchema = [
  spec.or,
  [spec.cat, spec.ethHexAddress, [spec.zeroOrOne, spec.blockRef]],
  [spec.cat, spec.base32UserAddress, [spec.zeroOrOne, spec.epochRefNoMined]],
]

const SingleCallGetBalanceSchema = [
  spec.or,
  [
    spec.map,
    {closed: true},
    ['users', [spec.oneOrMore, spec.base32UserAddress]],
    [
      'tokens',
      [
        spec.oneOrMore,
        [
          spec.or,
          {doc: 'token address, 0x0 represents native token'},
          [spec.eq, '0x0'],
          spec.base32ContractAddress,
        ],
      ],
    ],
  ],
  [
    spec.map,
    {closed: true},
    ['users', [spec.oneOrMore, spec.ethHexAddress]],
    [
      'tokens',
      [
        spec.oneOrMore,
        [
          spec.or,
          {doc: 'token address, 0x0 represents native token'},
          [spec.eq, '0x0'],
          spec.ethHexAddress,
        ],
      ],
    ],
  ],
]

const schemas = {
  input: [spec.or, GetBalanceSchema, SingleCallGetBalanceSchema],
}

const permissions = {
  locked: true,
  methods: ['cfx_getBalance', 'eth_getBalance', 'cfx_call', 'eth_call'],
  external: ['popup', 'inpage'],
}

const fallbackBalanceTracker = async (
  callMethod,
  {
    rpcs: {cfx_getBalance, eth_getBalance},
    params: {users, tokens},
    network: {type},
  },
) => {
  const getBalanceMethod = type === 'cfx' ? cfx_getBalance : eth_getBalance
  const rst = {}
  const promises = users.reduce((acc, u) => {
    u = u.toLowerCase()
    if (!rst[u]) rst[u] = {}
    return acc.concat(
      tokens.map(async t => {
        let res = '0x0'
        t = t.toLowerCase()

        const call =
          t === '0x0'
            ? addr => getBalanceMethod([addr])
            : _777/* default.balanceOf */.ZP.balanceOf(d => callMethod([d]), t)

        try {
          res = await call(
            type === 'cfx' && t !== '0x0' ? (0,base32_address/* decode */.Jx)(u).hexAddress : u,
          )
          if (Array.isArray(res)) res = res[0]
          res = (0,lib_esm/* hexValue */.$P)(res?.toHexString?.() || res)
        } catch (err) {} // eslint-disable-line no-empty
        rst[u][t] = res
        return res
      }),
    )
  }, [])

  await Promise.all(promises)
  return rst
}

const main = async arg => {
  const {
    Err: {InvalidParams},
    rpcs: {cfx_getBalance, eth_getBalance, cfx_call, eth_call},
    params,
    network: {type, netId, balanceChecker},
  } = arg
  // normal get balance
  if (Array.isArray(params)) {
    let [address] = params
    address = (0,addr_by_network/* default */.Z)({
      address,
      networkType: type,
      networkId: netId,
      addressType: 'user',
    })

    const getBalance = type === 'cfx' ? cfx_getBalance : eth_getBalance

    return await getBalance([address])
  }

  // single call get balance
  const callMethod = type === 'cfx' ? cfx_call : eth_call
  const {users, tokens} = params

  if (
    (type === 'cfx' && !users[0].includes(':')) ||
    (type === 'eth' && users[0].includes(':'))
  )
    throw InvalidParams('Invalid address format for current network')

  let rst

  if (!balanceChecker) {
    rst = await fallbackBalanceTracker(callMethod, arg)
    return rst
  }

  try {
    rst = await balances(
      d => callMethod({errorFallThrough: true}, [d]),
      balanceChecker,
      users,
      tokens,
    )
  } catch (err) {} // eslint-disable-line no-empty

  if (rst === undefined) {
    rst = await fallbackBalanceTracker(callMethod, arg)
  }

  return rst
}


/***/ }),

/***/ 4307:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_eth_block_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31715);
/* harmony import */ var _fluent_wallet_cfx_epoch_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50320);




const NAME = 'wallet_getBlockOrEpochNumber'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_eth_block_number__WEBPACK_IMPORTED_MODULE_1__.schemas.input, _fluent_wallet_cfx_epoch_number__WEBPACK_IMPORTED_MODULE_2__.schemas.input],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_epochNumber', 'eth_blockNumber'],
  db: [],
}

const main = ({
  network,
  rpcs: {eth_blockNumber, cfx_epochNumber},
  params,
}) => {
  if (network.type === 'cfx') {
    if (params[0] === 'latest') params[0] = 'latest_state'
    else if (params[0] === 'pending') params[0] = 'latest_mined'
    return cfx_epochNumber(params)
  }

  if (params[0] === 'latest_state') params[0] = 'latest'
  else if (params[0] === 'latest_confirmed') params[0] = 'latest'
  else if (params[0] === 'latest_finalized') params[0] = 'latest'
  else if (params[0] === 'latest_mined') params[0] = 'pending'
  else if (params[0] === 'latest_checkpoint') params[0] = 'earliest'
  return eth_blockNumber(params)
}


/***/ }),

/***/ 27641:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getBlockTime'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_epochNumber', 'eth_blockNumber'],
  db: [],
}

async function waitms(ms = 200) {
  return new Promise(r => setTimeout(r, ms))
}

async function waitTillChanged(initial, getFn, interval) {
  let rst
  let changed = false
  while (!changed) {
    rst = await getFn({_cacheConf: {type: null}}, [])
    if (rst !== initial) {
      changed = true
      break
    }
    await waitms(interval)
  }

  return rst
}

const main = async ({
  rpcs: {cfx_epochNumber, eth_blockNumber},
  network,
}) => {
  const getNumber = network.type === 'cfx' ? cfx_epochNumber : eth_blockNumber
  const waitms = network.type === 'cfx' ? 200 : 500

  let initial = await getNumber({_cacheConf: {type: null}}, [])
  initial = await waitTillChanged(initial, getNumber, waitms)

  const initTime = new Date().getTime()
  initial = await waitTillChanged(initial, getNumber, waitms)
  await waitTillChanged(initial, getNumber, waitms)

  return Math.floor((new Date().getTime() - initTime) / 2)
}


/***/ }),

/***/ 32573:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getBlockchainExplorerUrl'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    [
      'address',
      {optional: true},
      [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ],
    [
      'contract',
      {optional: true},
      [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ],
    [
      'token',
      {optional: true},
      [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ],
    ['transaction', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.zeroOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.Bytes32]],
  ],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({
  params: {address = [], contract = [], token = [], transaction = []},
  network,
}) => {
  const {scanUrl} = network
  const to = {
    address: addr => `${scanUrl}/address/${addr}`,
    contract: addr => `${scanUrl}/contract/${addr}`,
    token: addr => `${scanUrl}/token/${addr}`,
    transaction: txhash => `${scanUrl}/tx/${txhash}`,
  }

  return {
    address: address.map(to.address),
    contract: contract.map(to.contract),
    token: token.map(to.token),
    transaction: transaction.map(to.transaction),
  }
}


/***/ }),

/***/ 65416:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getCurrentAccount'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['getOneAccount'],
}

const main = ({db: {getOneAccount}}) => {
  return getOneAccount({selected: true})
}


/***/ }),

/***/ 47413:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getCurrentNetwork'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['getOneNetwork'],
}

const main = ({db: {getOneNetwork}}) => {
  return getOneNetwork({selected: true})
}


/***/ }),

/***/ 25766:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getCurrentViewingApp'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['getAppBySite', 'getSiteByOrigin'],
}

const main = async ({db: {getAppBySite, getSiteByOrigin}}) => {
  let t
  try {
    const {tab} = await __webpack_require__.e(/* import() */ 258).then(__webpack_require__.bind(__webpack_require__, 40258))
    t = await tab.getCurrent()
    if (!t?.length) return null
    t = t[0]
    if (!t?.url) return null
  } catch (err) {
    return null
  }

  const urlSplit = t.url.split('/')
  const origin = urlSplit[2]
  const [site] = getSiteByOrigin(origin)
  if (!site) return null

  const [app] = getAppBySite(site.eid)

  return {site, app}
}


/***/ }),

/***/ 56543:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getFluentMetadata'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: [],
  db: [],
}

const main = () => {
  return {version: /* unsupported import.meta.env.SNOWPACK_PUBLIC_FLUENT_VERSION */ undefined.SNOWPACK_PUBLIC_FLUENT_VERSION}
}


/***/ }),

/***/ 19482:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);



const NAME = 'wallet_getImportHardwareWalletInfo'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountGroupId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['devices', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.oneOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp]],
  ],
}

const permissions = {
  external: ['popup'],
  db: ['findGroup', 'getPassword'],
}

const main = async ({
  db: {findGroup, getPassword},
  params: {accountGroupId, devices},
}) => {
  const pwd = getPassword()
  const groups = findGroup({
    groupId: accountGroupId,
    devices,
    types: ['hw'],
    g: {
      eid: 1,
      nickname: 1,
      account: {
        index: 1,
        hidden: 1,
        nickname: 1,
        address: {
          value: 1,
          hex: 1,
          network: {name: 1, type: 1, hdPath: {name: 1, value: 1}},
        },
      },
      vault: {data: 1, cfxOnly: 1, device: 1},
    },
  })

  const promises = groups.map(async g => {
    const ddata = JSON.parse(await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(pwd, g.vault.data))
    g.vault.ddata = ddata
    return g
  })

  return await Promise.all(promises)
}


/***/ }),

/***/ 10375:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34577);



const NAME = 'wallet_getNetwork'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      ['type', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'cfx', 'eth']],
      ['builtin', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
      ['chainId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.chainId],
      ['networkId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.networkId],
      ['networkDbId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ],
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
  ],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['getNetwork', 'getNetworkById'],
}

const main = ({
  Err: {InvalidParams},
  db: {getNetwork, getNetworkById},
  params: {type, builtin, networkId, networkDbId, chainId} = {},
}) => {
  const networkDbIdDefined = !(0,_fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__/* .isUndefined */ .o8)(networkDbId)
  const builtinDefined = !(0,_fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__/* .isUndefined */ .o8)(builtin)
  const networkIdDefined = !(0,_fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__/* .isUndefined */ .o8)(networkId)
  if (
    (type || chainId || networkIdDefined || builtinDefined) &&
    networkDbIdDefined
  )
    throw InvalidParams(
      "Can't query type/builtin/chainId/networkId with networkDbId at the same time",
    )
  if (networkDbIdDefined) return getNetworkById(networkDbId)

  const query = {}
  if (type) query.type = type
  if (builtinDefined) query.builtin = builtin
  if (networkIdDefined) query.networkId = networkId
  if (chainId) query.chainId = chainId
  return getNetwork(query)
}


/***/ }),

/***/ 76565:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_addr_by_network__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64347);



const NAME = 'wallet_getNextNonce'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress], [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
}

const permissions = {
  locked: true,
  methods: ['cfx_getNextNonce', 'eth_getTransactionCount'],
  external: ['popup', 'inpage'],
}

const main = async ({
  rpcs: {eth_getTransactionCount, cfx_getNextNonce},
  params: [address],
  network: {netId, type},
}) => {
  address = (0,_fluent_wallet_addr_by_network__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)({address, networkType: type, networkId: netId})
  const getNextNonce =
    type === 'cfx' ? cfx_getNextNonce : eth_getTransactionCount
  const args = type === 'cfx' ? [address] : [address, 'latest']
  return await getNextNonce(args)
}


/***/ }),

/***/ 71145:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getNextUsableNonce'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['cfx_getNextUsableNonce', 'eth_getTransactionCount'],
  db: [],
}

const main = ({
  rpcs: {cfx_getNextUsableNonce, eth_getTransactionCount},
  params: [address],
  network,
}) => {
  if (network.type === 'cfx') return cfx_getNextUsableNonce([address])
  else return eth_getTransactionCount([address, 'pending'])
}


/***/ }),

/***/ 31216:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getPendingAuthRequest'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['getPendingAuthReq'],
}

const main = ({db: {getPendingAuthReq}}) => {
  return getPendingAuthReq()
}


/***/ }),

/***/ 45253:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getPermissions'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['inpage'],
}

const main = ({Err: {InvalidRequest}, app}) => {
  if (!app) throw InvalidRequest()
  const permissions = Object.keys(app.perms).reduce((acc, p) => {
    const perm = [
      {
        invoker: app.site.origin,
        parentCapability: p,
        date: app.permUpdatedAt,
      },
    ]
    if (p.startsWith('wallet_') && !p.includes('crossNetwork')) {
      perm.push({
        invoker: app.site.origin,
        parentCapability: p.replace('wallet_', 'cfx_'),
        date: app.permUpdatedAt,
      })
      perm.push({
        invoker: app.site.origin,
        parentCapability: p.replace('wallet_', 'eth_'),
        date: app.permUpdatedAt,
      })
    }
    return acc.concat(perm)
  }, [])

  return permissions
}


/***/ }),

/***/ 2168:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_getPreferences'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  methods: [],
  locked: true,
  db: ['getPreferences'],
}

const main = ({db: {getPreferences}}) => {
  return getPreferences()
}


/***/ }),

/***/ 64815:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/checks/is-function.js
var is_function = __webpack_require__(49040);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/node_modules/@thi.ng/api/api/logger.js
var logger_LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["FINE"] = 0] = "FINE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["SEVERE"] = 4] = "SEVERE";
    LogLevel[LogLevel["NONE"] = 5] = "NONE";
})(logger_LogLevel || (logger_LogLevel = {}));

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/node_modules/@thi.ng/api/logger.js

const NULL_LOGGER = Object.freeze({
    level: logger_LogLevel.NONE,
    fine() { },
    debug() { },
    info() { },
    warn() { },
    severe() { },
});
class ConsoleLogger {
    constructor(id, level = LogLevel.FINE) {
        this.id = id;
        this.level = level;
    }
    fine(...args) {
        this.level <= LogLevel.FINE && this.log("FINE", args);
    }
    debug(...args) {
        this.level <= LogLevel.DEBUG && this.log("DEBUG", args);
    }
    info(...args) {
        this.level <= LogLevel.INFO && this.log("INFO", args);
    }
    warn(...args) {
        this.level <= LogLevel.WARN && this.log("WARN", args);
    }
    severe(...args) {
        this.level <= LogLevel.SEVERE && this.log("SEVERE", args);
    }
    log(level, args) {
        console.log(`[${level}] ${this.id}:`, ...args);
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/api.js

var State;
(function (State) {
    State[State["IDLE"] = 0] = "IDLE";
    State[State["ACTIVE"] = 1] = "ACTIVE";
    State[State["DONE"] = 2] = "DONE";
    State[State["UNSUBSCRIBED"] = 3] = "UNSUBSCRIBED";
    State[State["ERROR"] = 4] = "ERROR";
})(State || (State = {}));
/**
 * Closing behaviors.
 */
var CloseMode;
(function (CloseMode) {
    /**
     * Never close, even if no more inputs/outputs.
     */
    CloseMode[CloseMode["NEVER"] = 0] = "NEVER";
    /**
     * Close when first input/output is done / removed.
     */
    CloseMode[CloseMode["FIRST"] = 1] = "FIRST";
    /**
     * Close when last input/output is done / removed.
     */
    CloseMode[CloseMode["LAST"] = 2] = "LAST";
})(CloseMode || (CloseMode = {}));
let LOGGER = NULL_LOGGER;
const setLogger = (logger) => (LOGGER = logger);

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/node_modules/@thi.ng/api/constants.js
const DEFAULT_EPS = 1e-6;
/**
 * Internal use only. **Do NOT use in user land code!**
 *
 * @internal
 */
const SEMAPHORE = Symbol();
/**
 * No-effect placeholder function.
 */
const NO_OP = () => { };
/**
 * Catch-all event ID
 */
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/node_modules/@thi.ng/api/assert.js

/**
 * Takes a `test` result or predicate function without args and throws
 * error with given `msg` if test failed (i.e. is falsy).
 *
 * @remarks
 * The function is only enabled if `process.env.NODE_ENV != "production"`
 * or if the `UMBRELLA_ASSERTS` env var is set to 1.
 */
const assert = (() => {
    try {
        return ( false ||
            process.env.UMBRELLA_ASSERTS === "1");
    }
    catch (e) { }
    return false;
})()
    ? (test, msg = "assertion failed") => {
        if ((typeof test === "function" && !test()) || !test) {
            throw new Error(typeof msg === "function" ? msg() : msg);
        }
    }
    : NO_OP;

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/arrays/peek.js
/**
 * Returns first element of given array or `undefined` if array is empty.
 *
 * @param buf - array
 */
const first = (buf) => buf[0];
/**
 * Returns last element of given array or `undefined` if array is empty.
 *
 * @param buf - array
 */
const peek = (buf) => buf[buf.length - 1];

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/checks/is-plain-object.js
const OBJP = Object.getPrototypeOf;
/**
 * Similar to {@link isObject}, but also checks if prototype is that of
 * `Object` (or `null`).
 *
 * @param x -
 */
const isPlainObject = (x) => {
    let p;
    return (x != null &&
        typeof x === "object" &&
        ((p = OBJP(x)) === null || OBJP(p) === null));
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/errors/deferror.js
var deferror = __webpack_require__(90513);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/errors/illegal-state.js

const IllegalStateError = (0,deferror/* defError */.o)(() => "illegal state");
const illegalState = (msg) => {
    throw new IllegalStateError(msg);
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/rfn/push.js
var push = __webpack_require__(56589);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/func/comp.js
var comp = __webpack_require__(32883);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/map.js
var map = __webpack_require__(84900);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/reduced.js
var reduced = __webpack_require__(23435);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/utils/idgen.js
let NEXT_ID = 0;
const nextID = () => NEXT_ID++;
const optsWithID = (prefix, opts) => ((!opts || !opts.id ? Object.assign(Object.assign({}, opts), { id: prefix + "-" + nextID() }) : opts));

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/subscription.js







/**
 * Creates a new {@link Subscription} instance, the fundamental datatype
 * and building block provided by this package.
 *
 * @remarks
 * Most other types in rstream, including {@link Stream}s, are
 * `Subscription`s and all can be:
 *
 * - connected into directed graphs (sync or async & not necessarily
 *   DAGs)
 * - transformed using transducers (incl. support for early termination)
 * - can have any number of subscribers (optionally each w/ their own
 *   transducers)
 * - recursively unsubscribe themselves from parent after their last
 *   subscriber unsubscribed (configurable)
 * - will go into a non-recoverable error state if none of the
 *   subscribers has an error handler itself
 * - implement the {@link @thi.ng/api#IDeref} interface
 *
 * If a transducer is provided (via the `xform` option), all received
 * values will be first processed by the transducer and only its
 * transformed result(s) (if any) will be passed to downstream
 * subscribers. Any uncaught errors *inside* the transducer will cause
 * this subscription's error handler to be called and will stop this
 * subscription from receiving any further values (by default, unless
 * overridden).
 *
 * Subscription behavior can be customized via the additional (optional)
 * options arg. See {@link CommonOpts} and {@link SubscriptionOpts} for
 * further details.
 *
 * @example
 * ```ts
 * // as reactive value mechanism (same as with stream() above)
 * s = subscription();
 * s.subscribe(trace("s1"));
 * s.subscribe(trace("s2"), { xform: tx.filter((x) => x > 25) });
 *
 * // external trigger
 * s.next(23);
 * // s1 23
 * s.next(42);
 * // s1 42
 * // s2 42
 * ```
 *
 * @param sub -
 * @param opts -
 */
const subscription = (sub, opts) => new Subscription(sub, opts);
class Subscription {
    constructor(wrapped, opts) {
        this.wrapped = wrapped;
        this.last = SEMAPHORE;
        this.state = State.IDLE;
        this.subs = [];
        opts = optsWithID(`sub`, Object.assign({ closeIn: CloseMode.LAST, closeOut: CloseMode.LAST, cache: true }, opts));
        this.parent = opts.parent;
        this.id = opts.id;
        this.closeIn = opts.closeIn;
        this.closeOut = opts.closeOut;
        this.cacheLast = opts.cache;
        opts.xform && (this.xform = opts.xform((0,push/* push */.V)()));
    }
    deref() {
        return this.last !== SEMAPHORE ? this.last : undefined;
    }
    getState() {
        return this.state;
    }
    setState(state) {
        this.state = state;
    }
    subscribe(sub, opts = {}) {
        this.ensureState();
        let $sub;
        if (sub instanceof Subscription && !opts.xform) {
            sub.ensureState();
            // ensure sub is still unattached
            assert(!sub.parent, `sub '${sub.id}' already has a parent`);
            sub.parent = this;
            $sub = sub;
        }
        else {
            $sub = new Subscription(sub, Object.assign(Object.assign({}, opts), { parent: this }));
        }
        this.subs.push($sub);
        this.setState(State.ACTIVE);
        $sub.setState(State.ACTIVE);
        this.last != SEMAPHORE && $sub.next(this.last);
        return $sub;
    }
    transform(...args) {
        let sub;
        let opts;
        if (isPlainObject(peek(args))) {
            opts = args.pop();
            sub = { error: opts.error };
        }
        return this.subscribe(sub, optsWithID("xform", args.length > 0
            ? Object.assign(Object.assign({}, opts), { 
                // @ts-ignore
                xform: (0,comp/* comp */.p)(...args) }) : opts));
    }
    /**
     * Syntax sugar for {@link Subscription.transform} when using a
     * single {@link @thi.ng/transducers#map} transducer only. The given
     * function `fn` is used as `map`'s transformation fn.
     *
     * @param fn
     * @param opts
     */
    map(fn, opts) {
        return this.transform((0,map/* map */.U)(fn), opts || {});
    }
    unsubscribe(sub) {
        return sub ? this.unsubscribeChild(sub) : this.unsubscribeSelf();
    }
    unsubscribeSelf() {
        LOGGER.debug(this.id, "unsub self");
        this.parent && this.parent.unsubscribe(this);
        this.state < State.UNSUBSCRIBED && (this.state = State.UNSUBSCRIBED);
        this.release();
        return true;
    }
    unsubscribeChild(sub) {
        LOGGER.debug(this.id, "unsub child", sub.id);
        const idx = this.subs.indexOf(sub);
        if (idx >= 0) {
            this.subs.splice(idx, 1);
            if (this.closeOut === CloseMode.FIRST ||
                (!this.subs.length && this.closeOut !== CloseMode.NEVER)) {
                this.unsubscribe();
            }
            return true;
        }
        return false;
    }
    next(x) {
        if (this.state >= State.DONE)
            return;
        this.xform ? this.dispatchXform(x) : this.dispatch(x);
    }
    done() {
        LOGGER.debug(this.id, "entering done()");
        if (this.state >= State.DONE)
            return;
        if (this.xform) {
            if (!this.dispatchXformDone())
                return;
        }
        this.state = State.DONE;
        // attempt to call .done in wrapped sub
        if (this.dispatchTo("done")) {
            // disconnect from parent & internal cleanup
            this.state < State.UNSUBSCRIBED && this.unsubscribe();
        }
        LOGGER.debug(this.id, "exiting done()");
    }
    error(e) {
        // only the wrapped sub's error handler gets a chance
        // to deal with the error
        const sub = this.wrapped;
        const hasErrorHandler = sub && sub.error;
        hasErrorHandler &&
            LOGGER.debug(this.id, "attempting wrapped error handler");
        // flag success if error handler returns true
        // (i.e. it could handle/recover from the error)
        // else detach this entire sub by going into error state...
        return (hasErrorHandler && sub.error(e)) || this.unhandledError(e);
    }
    unhandledError(e) {
        // ensure error is at least logged to console
        // even if default NULL_LOGGER is used...
        (LOGGER !== NULL_LOGGER ? LOGGER : console).warn(this.id, "unhandled error:", e);
        this.unsubscribe();
        this.state = State.ERROR;
        return false;
    }
    dispatchTo(type, x) {
        let s = this.wrapped;
        if (s) {
            try {
                s[type] && s[type](x);
            }
            catch (e) {
                // give wrapped sub a chance to handle error
                // (if that failed then we're already in error state now & terminate)
                if (!this.error(e))
                    return false;
            }
        }
        // process other child subs
        const subs = type === "next" ? this.subs : [...this.subs];
        for (let i = subs.length; --i >= 0;) {
            s = subs[i];
            try {
                s[type] && s[type](x);
            }
            catch (e) {
                if (type === "error" || !s.error || !s.error(e)) {
                    // if no or failed handler, go into error state
                    return this.unhandledError(e);
                }
            }
        }
        return true;
    }
    dispatch(x) {
        LOGGER.debug(this.id, "dispatch", x);
        this.cacheLast && (this.last = x);
        this.dispatchTo("next", x);
    }
    dispatchXform(x) {
        let acc;
        try {
            acc = this.xform[2]([], x);
        }
        catch (e) {
            // error in transducer can only be handled by the wrapped
            // subscriber's error handler (if avail)
            this.error(e);
            // don't dispatch value(s)
            return;
        }
        if (this.dispatchXformVals(acc)) {
            (0,reduced/* isReduced */.Vp)(acc) && this.done();
        }
    }
    dispatchXformDone() {
        let acc;
        try {
            // collect remaining values from transducer
            acc = this.xform[1]([]);
        }
        catch (e) {
            // error in transducer can only be handled by the wrapped
            // subscriber's error handler (if avail)
            return this.error(e);
        }
        return this.dispatchXformVals(acc);
    }
    dispatchXformVals(acc) {
        const uacc = (0,reduced/* unreduced */.Hw)(acc);
        for (let i = 0, n = uacc.length; i < n && this.state < State.DONE; i++) {
            this.dispatch(uacc[i]);
        }
        return this.state < State.ERROR;
    }
    ensureState() {
        if (this.state >= State.DONE) {
            illegalState(`operation not allowed in state ${this.state}`);
        }
    }
    release() {
        this.subs.length = 0;
        delete this.parent;
        delete this.xform;
        delete this.last;
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/stream.js




function stream(src, opts) {
    return new Stream(src, opts);
}
/**
 * Syntax sugar for {@link stream}. Creates new stream which is
 * immediately seeded with initial `val` and configured with optional
 * `opts`.
 *
 * @param val -
 * @param opts -
 */
const reactive = (val, opts) => {
    const res = new Stream(opts);
    res.next(val);
    return res;
};
/**
 * @see {@link stream} & {@link reactive} for reference & examples.
 */
class Stream extends Subscription {
    constructor(src, opts) {
        const [_src, _opts] = (0,is_function/* isFunction */.m)(src)
            ? [src, opts || {}]
            : [undefined, src || {}];
        super(_opts.error ? { error: _opts.error } : undefined, optsWithID("stream", _opts));
        this.src = _src;
        this._inited = false;
    }
    subscribe(sub, opts = {}) {
        const $sub = super.subscribe(sub, opts);
        if (!this._inited) {
            if (this.src) {
                try {
                    this._cancel = this.src(this) || (() => void 0);
                }
                catch (e) {
                    let s = this.wrapped;
                    if (!s || !s.error || !s.error(e)) {
                        this.unhandledError(e);
                    }
                }
            }
            this._inited = true;
        }
        return $sub;
    }
    unsubscribe(sub) {
        const res = super.unsubscribe(sub);
        if (res &&
            (!sub ||
                ((!this.subs || !this.subs.length) &&
                    this.closeOut !== CloseMode.NEVER))) {
            this.cancel();
        }
        return res;
    }
    done() {
        this.cancel();
        super.done();
        delete this.src;
        delete this._cancel;
    }
    error(e) {
        if (super.error(e))
            return true;
        this.cancel();
        return false;
    }
    cancel() {
        if (this._cancel) {
            LOGGER.debug(this.id, "cancel");
            const f = this._cancel;
            delete this._cancel;
            f();
        }
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/rstream/subs/resolve.js



/**
 * Creates a {@link Subscription} which receives promises, buffers them
 * and then passes their resolved values downstream.
 *
 * @remarks
 * If the optional `fail` handler is provided, it'll be called with the
 * error of each failed promise. If none is provided, the sub's
 * {@link ISubscriber.error} handler is called, which then stops the sub
 * from receiving further values.
 *
 * @example
 * ```ts
 * fromIterable([1, 2, 3], 100)
 *   .transform(tx.delayed(1000))
 *   .subscribe(resolve())
 *   .subscribe(trace("result"))
 * // result 1
 * // result 2
 * // result 3
 * // result done
 * ```
 *
 * @param opts -
 */
const resolve = (opts) => new Resolver(opts);
class Resolver extends Subscription {
    constructor(opts = {}) {
        super(undefined, optsWithID("resolve"));
        this.outstanding = 0;
        this.fail = opts.fail;
    }
    next(x) {
        this.outstanding++;
        x.then((y) => {
            if (this.state < State.DONE) {
                this.dispatch(y);
                if (--this.outstanding === 0) {
                    this.done();
                }
            }
            else {
                LOGGER.warn(`resolved value in state ${this.state} (${x})`);
            }
        }, (e) => {
            if (this.fail) {
                this.fail(e);
            }
            else {
                this.error(e);
            }
        });
    }
    done() {
        if (this.parent &&
            this.parent.getState() === State.DONE &&
            this.outstanding === 0) {
            super.done();
        }
    }
}

// EXTERNAL MODULE: ../../packages/sentry/index.js + 54 modules
var sentry = __webpack_require__(87580);
// EXTERNAL MODULE: ../../packages/transducers/index.js + 9 modules
var transducers = __webpack_require__(32356);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/side-effect.js
var side_effect = __webpack_require__(9572);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/pluck.js
var pluck = __webpack_require__(14848);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/keep.js
var keep = __webpack_require__(75335);
;// CONCATENATED MODULE: ../../packages/conflux-tx-error/index.js
// shouldDiscard means should stop tracking this tx
function processError(err){if(typeof(err===null||err===void 0?void 0:err.data)==='string'){var _err$data,_err$data$match,_err$data2,_err$data2$includes,_err$data3,_err$data3$includes,_err$data4,_err$data4$includes,_err$data5,_err$data5$match,_err$data6,_err$data6$includes,_err$data7,_err$data7$match,_err$data8,_err$data8$includes,_err$data9,_err$data9$includes,_err$data10,_err$data10$includes,_err$data11,_err$data11$includes,_err$data12,_err$data12$includes,_err$data13,_err$data13$includes,_err$data14,_err$data14$includes,_err$data15,_err$data15$includes;if((_err$data=err.data)!==null&&_err$data!==void 0&&(_err$data$match=_err$data.match)!==null&&_err$data$match!==void 0&&_err$data$match.call(_err$data,/pool is full/i))return{errorType:'txPoolFull',shouldDiscard:true};if((_err$data2=err.data)!==null&&_err$data2!==void 0&&(_err$data2$includes=_err$data2.includes)!==null&&_err$data2$includes!==void 0&&_err$data2$includes.call(_err$data2,'too distant future'))return{errorType:'tooDistantFuture',shouldDiscard:true};if((_err$data3=err.data)!==null&&_err$data3!==void 0&&(_err$data3$includes=_err$data3.includes)!==null&&_err$data3$includes!==void 0&&_err$data3$includes.call(_err$data3,'tx already exist'))return{errorType:'duplicateTx',shouldDiscard:false};if((_err$data4=err.data)!==null&&_err$data4!==void 0&&(_err$data4$includes=_err$data4.includes)!==null&&_err$data4$includes!==void 0&&_err$data4$includes.call(_err$data4,'too stale nonce'))return{errorType:'tooStaleNonce',shouldDiscard:true};if((_err$data5=err.data)!==null&&_err$data5!==void 0&&(_err$data5$match=_err$data5.match)!==null&&_err$data5$match!==void 0&&_err$data5$match.call(_err$data5,/same nonce already inserted.*replace.*gas price/))return{errorType:'replacedWithHigherGasPriceTx',shouldDiscard:true};if((_err$data6=err.data)!==null&&_err$data6!==void 0&&(_err$data6$includes=_err$data6.includes)!==null&&_err$data6$includes!==void 0&&_err$data6$includes.call(_err$data6,'EpochHeightOutOfBound'))return{errorType:'epochHeightOutOfBound',shouldDiscard:true};if((_err$data7=err.data)!==null&&_err$data7!==void 0&&(_err$data7$match=_err$data7.match)!==null&&_err$data7$match!==void 0&&_err$data7$match.call(_err$data7,/gas price.*less than the minimum value/))return{errorType:'gasPriceTooLow',shouldDiscard:true};if((_err$data8=err.data)!==null&&_err$data8!==void 0&&(_err$data8$includes=_err$data8.includes)!==null&&_err$data8$includes!==void 0&&_err$data8$includes.call(_err$data8,'exceeds the maximum value'))return{errorType:'gasExceedsLimit',shouldDiscard:true};if((_err$data9=err.data)!==null&&_err$data9!==void 0&&(_err$data9$includes=_err$data9.includes)!==null&&_err$data9$includes!==void 0&&_err$data9$includes.call(_err$data9,'Unsupported receiver address type'))return{errorType:'wrongAddressType',shouldDiscard:true};if((_err$data10=err.data)!==null&&_err$data10!==void 0&&(_err$data10$includes=_err$data10.includes)!==null&&_err$data10$includes!==void 0&&_err$data10$includes.call(_err$data10,'ChainIdMismatch'))return{errorType:'chainIdMismatch',shouldDiscard:true};if((_err$data11=err.data)!==null&&_err$data11!==void 0&&(_err$data11$includes=_err$data11.includes)!==null&&_err$data11$includes!==void 0&&_err$data11$includes.call(_err$data11,'ZeroGasPrice'))return{errorType:'zeroGasPrice',shouldDiscard:true};if((_err$data12=err.data)!==null&&_err$data12!==void 0&&(_err$data12$includes=_err$data12.includes)!==null&&_err$data12$includes!==void 0&&_err$data12$includes.call(_err$data12,'NotEnoughBaseGas'))return{errorType:'notEnoughBaseGas',shouldDiscard:true};if((_err$data13=err.data)!==null&&_err$data13!==void 0&&(_err$data13$includes=_err$data13.includes)!==null&&_err$data13$includes!==void 0&&_err$data13$includes.call(_err$data13,'RlpIncorrectListLen'))return{errorType:'rlpIncorrectListLen',shouldDiscard:true};if((_err$data14=err.data)!==null&&_err$data14!==void 0&&(_err$data14$includes=_err$data14.includes)!==null&&_err$data14$includes!==void 0&&_err$data14$includes.call(_err$data14,'still in the catch up mode'))return{errorType:'nodeInCatchUpMode',shouldDiscard:true};if((_err$data15=err.data)!==null&&_err$data15!==void 0&&(_err$data15$includes=_err$data15.includes)!==null&&_err$data15$includes!==void 0&&_err$data15$includes.call(_err$data15,'Can not recover pubkey'))return{errorType:'canNotRecoverPubKey',shouldDiscard:true};}return{errorType:'unknownError',shouldDiscard:true};}
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/compose/identity.js
var identity = __webpack_require__(94249);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedCFXTx/index.js








const NAME = 'wallet_handleUnfinishedCFXTx'

function defs(...args) {
  const s = stream({
    id: args.length === 2 ? args[0] : undefined,
    closeIn: CloseMode.FIRST,
    closeOut: false,
    cache: true,
  })
  s.next(args.length === 2 ? args[1] : args[0])
  return s
}

let Ext

function getExt() {
  return Ext
    ? Promise.resolve(Ext)
    : __webpack_require__.e(/* import() */ 258).then(__webpack_require__.bind(__webpack_require__, 40258)).then(ext => {
        Ext = ext
        return ext
      })
}

function updateBadge() {
  // count
  return
  // return getExt().then(ext =>
  //   count > 0 ? ext.badge.set({text: count}) : ext.badge.clear(),
  // )
}

const schemas = {
  input: [spec.mapp],
}

const permissions = {
  locked: true,
  methods: [
    'cfx_epochNumber',
    'cfx_sendRawTransaction',
    'cfx_getTransactionByHash',
    'cfx_getTransactionReceipt',
    'wallet_handleUnfinishedCFXTx',
    'wallet_getBlockchainExplorerUrl',
    'cfx_getNextNonce',
  ],
  db: [
    'retractAttr',
    'getUnfinishedTxCount',
    'getAddressById',
    'getTxById',
    'setTxSkipped',
    'setTxFailed',
    'setTxSending',
    'setTxPending',
    'setTxPackaged',
    'setTxExecuted',
    'setTxConfirmed',
    'setTxUnsent',
    'setTxChainSwitched',
  ],
}

const main = ({
  rpcs: {
    cfx_epochNumber,
    cfx_sendRawTransaction,
    cfx_getTransactionByHash,
    cfx_getTransactionReceipt,
    cfx_getNextNonce,
    wallet_getBlockchainExplorerUrl,
    wallet_handleUnfinishedCFXTx,
  },
  db: {
    retractAttr,
    getUnfinishedTxCount,
    getAddressById,
    getTxById,
    setTxSkipped,
    setTxFailed,
    setTxSending,
    setTxPending,
    setTxPackaged,
    setTxExecuted,
    setTxConfirmed,
    setTxUnsent,
    setTxChainSwitched,
  },
  params: {tx, address, okCb, failedCb},
  network,
}) => {
  tx = getTxById(tx)
  // this only happends in integration test
  if (!tx) return
  address = getAddressById(address)
  const cacheTime = network.cacheTime || 1000
  const {status, hash, raw} = tx
  const s = defs(hash, {tx, address})
  const ss = defs(hash, {tx, address})
  const sdone = () => s.done()
  const ssdone = () => ss.done()
  const keepTrack = (delay = cacheTime) => {
    if (!Number.isInteger(delay)) delay = cacheTime
    sdone()
    setTimeout(
      () => wallet_handleUnfinishedCFXTx({tx: tx.eid, address: address.eid}),
      delay,
    )
  }
  const skeepTrack = (delay = cacheTime) => {
    if (!Number.isInteger(delay)) delay = cacheTime
    ssdone()
    setTimeout(
      () => wallet_handleUnfinishedCFXTx({tx: tx.eid, address: address.eid}),
      delay,
    )
  }

  // # detect pivot chain switch
  if (status === 0) {
    // ## unsent
  } else if (status === 1) {
    // ## sending
  } else if (status === 2) {
    // ## pending
  } else if (status === 3) {
    // ## packaged
    ss.map(() => cfx_getTransactionByHash({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: identity/* identity */.y}))
      .transform(
        (0,side_effect/* sideEffect */.j)(rst => {
          if (!rst) {
            if (tx.blockHash) retractAttr({eid: tx.eid, attr: 'tx/blockHash'})
            setTxPending({hash})
            setTxChainSwitched({hash})
            skeepTrack()
          }
        }),
        (0,transducers/* keepTruthy */.te)(),
        (0,side_effect/* sideEffect */.j)(rst => {
          if (rst.blockHash !== tx.blockHash) {
            setTxPackaged({hash, blockHash: rst.blockHash})
            setTxChainSwitched({hash})
          }
          skeepTrack()
        }),
      )
  } else if (status === 4) {
    // ## executed
    ss.map(() => cfx_getTransactionReceipt({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: identity/* identity */.y}))
      .transform(
        (0,side_effect/* sideEffect */.j)(rst => {
          if (!rst) {
            if (tx.receipt) retractAttr({eid: tx.eid, attr: 'tx/receipt'})
            setTxPackaged({hash, blockHash: tx.blockHash})
            setTxChainSwitched({hash})
            ssdone()
          }
        }),
        (0,transducers/* keepTruthy */.te)(),
        (0,side_effect/* sideEffect */.j)(rst => {
          if (
            rst.blockHash !== tx.receipt.blockHash ||
            rst.index !== tx.receipt.index ||
            rst.epochNumber !== tx.receipt.epochNumber
          ) {
            if (tx.receipt) retractAttr({eid: tx.eid, attr: 'tx/receipt'})
            setTxPackaged({hash, blockHash: rst.blockHash})
            setTxChainSwitched({hash})
            skeepTrack()
          }
        }),
      )
  }

  // # process tx
  if (status === 0) {
    // ## unsent
    s.transform(
      (0,side_effect/* sideEffect */.j)(() => setTxSending({hash})),
      (0,side_effect/* sideEffect */.j)(() => updateBadge(getUnfinishedTxCount())),
    )
      .map(() => {
        return cfx_sendRawTransaction({errorFallThrough: true}, [raw])
      })
      .subscribe(
        resolve({
          fail: err => {
            // failed to send
            setTxUnsent({hash})

            const {errorType, shouldDiscard} = processError(err)
            const isDuplicateTx = errorType === 'duplicateTx'
            const resendNonceTooStale =
              tx.resendAt && errorType === 'tooStaleNonce'

            const sameAsSuccess = isDuplicateTx || resendNonceTooStale
            const failed = !sameAsSuccess && shouldDiscard

            if (errorType === 'unknownError')
              (0,sentry/* capture */.IE)(err, {
                tags: {
                  custom_type: 'unknown sendTx error',
                  rpc_network: network.name,
                },
              })

            defs({
              failed: failed && {errorType, err},
              sameAsSuccess,
              resend: !shouldDiscard && !sameAsSuccess,
            })
              .transform(
                (0,transducers/* branchObj */.g8)({
                  failed: [
                    (0,side_effect/* sideEffect */.j)(
                      ({err}) =>
                        typeof failedCb === 'function' && failedCb(err),
                    ),
                    (0,side_effect/* sideEffect */.j)(({errorType}) => {
                      if (setTxFailed({hash, error: errorType})) {
                        getExt().then(ext =>
                          ext.notifications.create(hash, {
                            title: 'Failed transaction',
                            message: `Transaction ${parseInt(
                              tx.txPayload.nonce,
                              16,
                            )} failed! ${err?.data || err?.message || ''}`,
                          }),
                        )
                      }
                    }),
                    (0,side_effect/* sideEffect */.j)(() => {
                      updateBadge(getUnfinishedTxCount())
                    }),
                  ],
                  resend: (0,side_effect/* sideEffect */.j)(keepTrack),
                  // retry in next run
                  sameAsSuccess: [
                    (0,side_effect/* sideEffect */.j)(() => setTxPending({hash})),
                    (0,side_effect/* sideEffect */.j)(() => typeof okCb === 'function' && okCb(hash)),
                    (0,side_effect/* sideEffect */.j)(keepTrack),
                  ],
                }),
              )
              .done()
          },
        }),
      )
      .transform(
        // successfully sent
        (0,side_effect/* sideEffect */.j)(() => setTxPending({hash})),
        (0,side_effect/* sideEffect */.j)(() => typeof okCb === 'function' && okCb(hash)),
        (0,side_effect/* sideEffect */.j)(keepTrack),
      )
  } else if (status === 1) {
    // ## sending
  } else if (status === 2) {
    // ## pending
    s.map(() => cfx_getTransactionByHash({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        // not packaged or no blockhash in getTransactionByHash result
        (0,map/* map */.U)(rst => {
          if (rst && rst.blockHash) return rst
          // getTransactionByHash return null
          cfx_epochNumber({errorFallThrough: true}, ['latest_state'])
            .then(n => {
              if (
                bignumber/* BigNumber.from */.O$.from(n)
                  .sub(bignumber/* BigNumber.from */.O$.from(tx.resendAt || tx.txPayload.epochHeight))
                  .gte(5)
              ) {
                setTxUnsent({hash, resendAt: n})
              }
            })
            .catch(identity/* identity */.y)
          return keepTrack()
        }),
        (0,transducers/* keepTruthy */.te)(),

        // packaged
        (0,map/* map */.U)(rst => {
          setTxPackaged({hash, blockHash: rst.blockHash})
          const {status} = rst
          return {
            failed: status === '0x1',
            skipped: status === '0x2',
            executed: status === '0x0',
            statusNull: status === null,
          }
        }),
      )
      .transform(
        (0,transducers/* branchObj */.g8)({
          failed: (0,map/* map */.U)(() => {
            sdone()
            // get the error message in receipt
            cfx_getTransactionReceipt({errorFallThrough: true}, [hash])
              .then(receipt => {
                let err = ''
                if (receipt?.txExecErrorMsg) {
                  err = receipt.txExecErrorMsg
                }
                setTxFailed({
                  hash,
                  error: err || 'tx failed',
                })
                updateBadge(getUnfinishedTxCount())
                getExt().then(ext =>
                  ext.notifications.create(hash, {
                    title: 'Failed transaction',
                    message: `Transaction ${parseInt(
                      tx.txPayload.nonce,
                      16,
                    )} failed! ${err}`,
                  }),
                )
              })
              .catch(() => {
                setTxPending({hash})
                keepTrack()
              })
          }),
          skipped: (0,map/* map */.U)(() => {
            setTxSkipped({hash, skippedChecked: true})
            updateBadge(getUnfinishedTxCount())
            wallet_getBlockchainExplorerUrl({transaction: [hash]}).then(
              ({transaction: [txUrl]}) => {
                getExt().then(ext =>
                  ext.notifications.create(txUrl, {
                    title: 'Skipped transaction',
                    message: `Transaction ${parseInt(
                      tx.txPayload.nonce,
                      16,
                    )}  skipped! ${txUrl?.length ? 'View on explorer.' : ''}`,
                  }),
                )
              },
            )
            sdone()
          }),
          executed: (0,map/* map */.U)(keepTrack),
          statusNull: (0,map/* map */.U)(() => {
            setTxPending({hash})
            return cfx_getNextNonce({errorFallThrough: true}, [address.value])
          }),
        }),
        (0,pluck/* pluck */.j)('statusNull'),
        (0,transducers/* keepTruthy */.te)(),
      )
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        (0,side_effect/* sideEffect */.j)(nonce => {
          if (bignumber/* BigNumber.from */.O$.from(nonce).gt(bignumber/* BigNumber.from */.O$.from(tx.txPayload.nonce))) {
            if (tx.skippedChecked) {
              if (setTxSkipped({hash, skippedChecked: true})) {
                getExt().then(ext =>
                  ext.notifications.create(hash, {
                    title: 'Skipped transaction',
                    message: `Transaction ${parseInt(
                      tx.txPayload.nonce,
                      16,
                    )}  skipped!`,
                  }),
                )
              }
              updateBadge(getUnfinishedTxCount())
              return sdone()
            } else {
              setTxSkipped({hash})
              return keepTrack(0)
            }
          }
          keepTrack(0)
        }),
      )
  } else if (status === 3) {
    // ## packaged
    s.map(() => cfx_getTransactionReceipt({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        (0,side_effect/* sideEffect */.j)(rst => {
          !rst && keepTrack()
        }),
        (0,keep/* keep */.C)(),
        (0,side_effect/* sideEffect */.j)(rst => {
          const {
            outcomeStatus,
            blockHash,
            index,
            epochNumber,
            txExecErrorMsg,
            contractCreated,
            gasUsed,
            gasFee,
            storageCollateralized,
            storageCoveredBySponsor,
            gasCoveredBySponsor,
            storageReleased, // array
          } = rst
          const receipt = {
            blockHash,
            index,
            epochNumber,
            gasUsed,
            gasFee,
            storageCollateralized,
            gasCoveredBySponsor,
            storageCoveredBySponsor,
          }
          if (storageReleased?.length) receipt.storageReleased = storageReleased
          if (contractCreated) receipt.contractCreated = contractCreated

          if (outcomeStatus === '0x0') {
            setTxExecuted({hash, receipt})
            keepTrack()
          } else {
            if (setTxFailed({hash, error: txExecErrorMsg})) {
              getExt().then(ext =>
                ext.notifications.create(hash, {
                  title: 'Failed transaction',
                  message: `Transaction ${parseInt(
                    tx.txPayload.nonce,
                    16,
                  )} failed! ${txExecErrorMsg}`,
                }),
              )
            }
            updateBadge(getUnfinishedTxCount())
          }
        }),
        (0,side_effect/* sideEffect */.j)(sdone),
      )
  } else if (status === 4) {
    // ## executed
    s.map(() => cfx_epochNumber({errorFallThrough: true}, ['latest_confirmed']))
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        (0,map/* map */.U)(n => {
          if (
            n &&
            bignumber/* BigNumber.from */.O$.from(n).gte(bignumber/* BigNumber.from */.O$.from(tx.receipt.epochNumber))
          ) {
            setTxConfirmed({hash})
            updateBadge(getUnfinishedTxCount())
            return true
          }
          keepTrack()
          return false
        }),
        (0,transducers/* keepTruthy */.te)(), // filter non-null tx
        (0,map/* map */.U)(() => wallet_getBlockchainExplorerUrl({transaction: [hash]})),
      )
      .subscribe(resolve({fail: identity/* identity */.y}))
      .transform(
        (0,side_effect/* sideEffect */.j)(({transaction: [txUrl]}) => {
          getExt().then(ext => {
            ext.notifications.create(txUrl, {
              title: 'Confirmed transaction',
              message: `Transaction ${parseInt(
                tx.txPayload.nonce,
                16,
              )} confirmed! ${txUrl?.length ? 'View on Explorer.' : ''}`,
            })
          })
        }),
        (0,side_effect/* sideEffect */.j)(sdone),
      )
  }
}


/***/ }),

/***/ 49105:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/checks/is-function.js
const isFunction = (x) => typeof x === "function";

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/rstream/api.js
var State;
(function (State) {
    State[State["IDLE"] = 0] = "IDLE";
    State[State["ACTIVE"] = 1] = "ACTIVE";
    State[State["DONE"] = 2] = "DONE";
    State[State["UNSUBSCRIBED"] = 3] = "UNSUBSCRIBED";
    State[State["ERROR"] = 4] = "ERROR";
})(State || (State = {}));
/**
 * Closing behaviors.
 */
var CloseMode;
(function (CloseMode) {
    /**
     * Never close, even if no more inputs/outputs.
     */
    CloseMode[CloseMode["NEVER"] = 0] = "NEVER";
    /**
     * Close when first input/output is done / removed.
     */
    CloseMode[CloseMode["FIRST"] = 1] = "FIRST";
    /**
     * Close when last input/output is done / removed.
     */
    CloseMode[CloseMode["LAST"] = 2] = "LAST";
})(CloseMode || (CloseMode = {}));

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/rstream/idgen.js
let NEXT_ID = 0;
const __nextID = () => NEXT_ID++;
/**
 * @param prefix -
 * @param opts -
 *
 * @internal
 */
const __optsWithID = (prefix, opts) => ((!opts || !opts.id ? { ...opts, id: prefix + "-" + __nextID() } : opts));

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/logger/api.js
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["FINE"] = 0] = "FINE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["SEVERE"] = 4] = "SEVERE";
    LogLevel[LogLevel["NONE"] = 5] = "NONE";
})(LogLevel || (LogLevel = {}));

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/logger/null.js

/**
 * No-op {@link ILogger} implementation, used as default logger for most
 * packages (where used).
 */
const NULL_LOGGER = Object.freeze({
    level: LogLevel.NONE,
    fine() { },
    debug() { },
    info() { },
    warn() { },
    severe() { },
});

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/rstream/logger.js

let LOGGER = NULL_LOGGER;
const setLogger = (logger) => (LOGGER = logger);

// EXTERNAL MODULE: ../../node_modules/@thi.ng/api/api.js
var api = __webpack_require__(70229);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/arrays/peek.js
/**
 * Returns first element of given array or `undefined` if array is empty.
 *
 * @param buf - array
 */
const first = (buf) => buf[0];
/**
 * Returns last element of given array or `undefined` if array is empty.
 *
 * @param buf - array
 */
const peek = (buf) => buf[buf.length - 1];

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/checks/is-plain-object.js
const OBJP = Object.getPrototypeOf;
/**
 * Similar to {@link isObject}, but also checks if prototype is that of
 * `Object` (or `null`).
 *
 * @param x -
 */
const isPlainObject = (x) => {
    let p;
    return (x != null &&
        typeof x === "object" &&
        ((p = OBJP(x)) === null || OBJP(p) === null));
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/errors/deferror.js
const defError = (prefix, suffix = (msg) => (msg !== undefined ? ": " + msg : "")) => class extends Error {
    constructor(msg) {
        super(prefix(msg) + suffix(msg));
    }
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/errors/assert.js

const AssertionError = defError(() => "Assertion failed");
/**
 * Takes a `test` result or predicate function without args and throws
 * error with given `msg` if test failed (i.e. is falsy).
 *
 * @remarks
 * The function is only enabled if `process.env.NODE_ENV != "production"`
 * or if the `UMBRELLA_ASSERTS` env var is set to 1.
 */
const assert = (() => typeof process !== "undefined" && typeof process.env !== "undefined"
    ?  false ||
        !!process.env.UMBRELLA_ASSERTS
    : typeof __SNOWPACK_ENV__ !== "undefined"
        ? __SNOWPACK_ENV__.MODE !== "production" ||
            !!__SNOWPACK_ENV__.UMBRELLA_ASSERTS ||
            !!__SNOWPACK_ENV__.SNOWPACK_PUBLIC_UMBRELLA_ASSERTS
        : true)()
    ? (test, msg) => {
        if ((typeof test === "function" && !test()) || !test) {
            throw new AssertionError(typeof msg === "function" ? msg() : msg);
        }
    }
    : () => { };

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/errors/illegal-state.js

const IllegalStateError = defError(() => "illegal state");
const illegalState = (msg) => {
    throw new IllegalStateError(msg);
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/errors/illegal-arity.js

const IllegalArityError = defError(() => "illegal arity");
const illegal_arity_illegalArity = (n) => {
    throw new IllegalArityError(n);
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/compose/comp.js

function comp(...fns) {
    let [a, b, c, d, e, f, g, h, i, j] = fns;
    switch (fns.length) {
        case 0:
            illegal_arity_illegalArity(0);
        case 1:
            return a;
        case 2:
            return (...xs) => a(b(...xs));
        case 3:
            return (...xs) => a(b(c(...xs)));
        case 4:
            return (...xs) => a(b(c(d(...xs))));
        case 5:
            return (...xs) => a(b(c(d(e(...xs)))));
        case 6:
            return (...xs) => a(b(c(d(e(f(...xs))))));
        case 7:
            return (...xs) => a(b(c(d(e(f(g(...xs)))))));
        case 8:
            return (...xs) => a(b(c(d(e(f(g(h(...xs))))))));
        case 9:
            return (...xs) => a(b(c(d(e(f(g(h(i(...xs)))))))));
        case 10:
        default:
            const fn = (...xs) => a(b(c(d(e(f(g(h(i(j(...xs))))))))));
            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));
    }
}
function compL(...fns) {
    return comp.apply(null, fns.reverse());
}
/**
 * @deprecated renamed to {@link (compL:1)}
 */
const compI = (/* unused pure expression or super */ null && (compL));

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/checks/implements-function.js
const implements_function_implementsFunction = (x, fn) => x != null && typeof x[fn] === "function";

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/ensure.js

const ensure_ensureTransducer = (x) => implements_function_implementsFunction(x, "xform") ? x.xform() : x;

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/comp.js


function comp_comp(...fns) {
    fns = fns.map(ensure_ensureTransducer);
    return comp.apply(null, fns);
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/checks/is-iterable.js
const is_iterable_isIterable = (x) => x != null && typeof x[Symbol.iterator] === "function";

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/compr.js
/**
 * Reducer composition helper, internally used by various transducers
 * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a
 * reducing function `fn`. Returns a new reducer tuple.
 *
 * @remarks
 * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.
 * `fn` accepts values of type `C` and produces interim results of type
 * `B`, which are then (possibly) passed to the "inner" `rfn[2]`
 * function. Therefore the resulting reducer takes inputs of `C` and an
 * accumulator of type `A`.
 *
 * It is assumed that `fn` internally calls `rfn[2]` to pass its own
 * results for further processing by the nested reducer `rfn`.
 *
 * @example
 * ```ts
 * compR(rfn, fn)
 * // [rfn[0], rfn[1], fn]
 * ```
 *
 * @param rfn -
 * @param fn -
 */
const compR = (rfn, fn) => [rfn[0], rfn[1], fn];

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/reduced.js
class Reduced {
    constructor(val) {
        this.value = val;
    }
    deref() {
        return this.value;
    }
}
const reduced = (x) => new Reduced(x);
const reduced_isReduced = (x) => x instanceof Reduced;
const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);
const reduced_unreduced = (x) => (x instanceof Reduced ? x.deref() : x);

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/iterator.js





/**
 * Takes a transducer and input iterable. Returns iterator of
 * transformed results.
 *
 * @param xform -
 * @param xs -
 */
function* iterator(xform, xs) {
    const rfn = ensureTransducer(xform)(push());
    const complete = rfn[1];
    const reduce = rfn[2];
    for (let x of xs) {
        const y = reduce([], x);
        if (isReduced(y)) {
            yield* unreduced(complete(y.deref()));
            return;
        }
        if (y.length) {
            yield* y;
        }
    }
    yield* unreduced(complete([]));
}
/**
 * Optimized version of {@link iterator} for transducers which are
 * guaranteed to:
 *
 * 1) Only produce none or a single result per input
 * 2) Do not require a `completion` reduction step
 *
 * @param xform -
 * @param xs -
 */
function* iterator1(xform, xs) {
    const reduce = (ensure_ensureTransducer(xform)([api/* NO_OP */.Jw, api/* NO_OP */.Jw, (_, x) => x]))[2];
    for (let x of xs) {
        let y = reduce(api/* SEMAPHORE */.fL, x);
        if (reduced_isReduced(y)) {
            y = reduced_unreduced(y.deref());
            if (y !== api/* SEMAPHORE */.fL) {
                yield y;
            }
            return;
        }
        if (y !== api/* SEMAPHORE */.fL) {
            yield y;
        }
    }
}
/**
 * Helper function used by various transducers to wrap themselves as
 * transforming iterators. Delegates to {@link iterator1} by default.
 *
 * @param xform -
 * @param args -
 * @param impl -
 *
 * @internal
 */
const __iter = (xform, args, impl = iterator1) => {
    const n = args.length - 1;
    return isIterable(args[n])
        ? args.length > 1
            ? impl(xform.apply(null, args.slice(0, n)), args[n])
            : impl(xform(), args[0])
        : undefined;
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/map.js



function map(fn, src) {
    return is_iterable_isIterable(src)
        ? iterator1(map(fn), src)
        : (rfn) => {
            const r = rfn[2];
            return compR(rfn, (acc, x) => r(acc, fn(x)));
        };
}
/**
 * Convenience wrapper for {@link map} to transform an iterable with given `fn`
 * and immediatedly collect results into an array.
 */
const mapA = (fn, src) => [
    ...map(fn, src),
];

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/reduce.js





const parseArgs = (args) => args.length === 2
    ? [undefined, args[1]]
    : args.length === 3
        ? [args[1], args[2]]
        : illegalArity(args.length);
function reduce(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce = rfn[2];
    args = parseArgs(args);
    const acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    return unreduced(complete(implementsFunction(xs, "$reduce")
        ? xs.$reduce(reduce, acc)
        : isArrayLike(xs)
            ? reduceArray(reduce, acc, xs)
            : reduceIterable(reduce, acc, xs)));
}
function reduceRight(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce = rfn[2];
    args = parseArgs(args);
    let acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    for (let i = xs.length; i-- > 0;) {
        acc = reduce(acc, xs[i]);
        if (isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return unreduced(complete(acc));
}
const reduceArray = (rfn, acc, xs) => {
    for (let i = 0, n = xs.length; i < n; i++) {
        acc = rfn(acc, xs[i]);
        if (isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reduceIterable = (rfn, acc, xs) => {
    for (let x of xs) {
        acc = rfn(acc, x);
        if (isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
/**
 * Convenience helper for building a full {@link Reducer} using the identity
 * function (i.e. `(x) => x`) as completion step (true for 90% of all
 * bundled transducers).
 *
 * @param init - init step of reducer
 * @param rfn - reduction step of reducer
 */
const reducer = (init, rfn) => [init, (acc) => acc, rfn];
const $$reduce = (rfn, args) => {
    const n = args.length - 1;
    return isIterable(args[n])
        ? args.length > 1
            ? reduce(rfn.apply(null, args.slice(0, n)), args[n])
            : reduce(rfn(), args[0])
        : undefined;
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/transducers/push.js

function push_push(xs) {
    return xs
        ? [...xs]
        : reducer(() => [], (acc, x) => (acc.push(x), acc));
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/rstream/subscription.js













/**
 * Creates a new {@link Subscription} instance, the fundamental datatype
 * and building block provided by this package.
 *
 * @remarks
 * Most other types in rstream, including {@link Stream}s, are
 * `Subscription`s and all can be:
 *
 * - connected into directed graphs (sync or async & not necessarily
 *   DAGs)
 * - transformed using transducers (incl. support for early termination)
 * - can have any number of subscribers (optionally each w/ their own
 *   transducers)
 * - recursively unsubscribe themselves from parent after their last
 *   subscriber unsubscribed (configurable)
 * - will go into a non-recoverable error state if none of the
 *   subscribers has an error handler itself
 * - implement the {@link @thi.ng/api#IDeref} interface
 *
 * If a transducer is provided (via the `xform` option), all received
 * values will be first processed by the transducer and only its
 * transformed result(s) (if any) will be passed to downstream
 * subscribers. Any uncaught errors *inside* the transducer will cause
 * this subscription's error handler to be called and will stop this
 * subscription from receiving any further values (by default, unless
 * overridden).
 *
 * Subscription behavior can be customized via the additional (optional)
 * options arg. See {@link CommonOpts} and {@link SubscriptionOpts} for
 * further details.
 *
 * @example
 * ```ts
 * // as reactive value mechanism (same as with stream() above)
 * s = subscription();
 * s.subscribe(trace("s1"));
 * s.subscribe(trace("s2"), { xform: tx.filter((x) => x > 25) });
 *
 * // external trigger
 * s.next(23);
 * // s1 23
 * s.next(42);
 * // s1 42
 * // s2 42
 * ```
 *
 * @param sub -
 * @param opts -
 */
const subscription = (sub, opts) => new Subscription(sub, opts);
class Subscription {
    constructor(wrapped, opts) {
        this.wrapped = wrapped;
        this.last = api/* SEMAPHORE */.fL;
        this.state = State.IDLE;
        this.subs = [];
        opts = __optsWithID(`sub`, {
            closeIn: CloseMode.LAST,
            closeOut: CloseMode.LAST,
            cache: true,
            ...opts,
        });
        this.parent = opts.parent;
        this.id = opts.id;
        this.closeIn = opts.closeIn;
        this.closeOut = opts.closeOut;
        this.cacheLast = opts.cache;
        opts.xform && (this.xform = opts.xform(push_push()));
    }
    deref() {
        return this.last !== api/* SEMAPHORE */.fL ? this.last : undefined;
    }
    getState() {
        return this.state;
    }
    setState(state) {
        this.state = state;
    }
    subscribe(sub, opts = {}) {
        this.ensureState();
        let $sub;
        if (sub instanceof Subscription && !opts.xform) {
            sub.ensureState();
            // ensure sub is still unattached
            assert(!sub.parent, `sub '${sub.id}' already has a parent`);
            sub.parent = this;
            $sub = sub;
        }
        else {
            $sub = new Subscription(sub, { ...opts, parent: this });
        }
        this.subs.push($sub);
        this.setState(State.ACTIVE);
        $sub.setState(State.ACTIVE);
        this.last != api/* SEMAPHORE */.fL && $sub.next(this.last);
        return $sub;
    }
    transform(...args) {
        let sub;
        let opts;
        if (isPlainObject(peek(args))) {
            opts = args.pop();
            sub = { error: opts.error };
        }
        return this.subscribe(sub, __optsWithID("xform", args.length > 0
            ? {
                ...opts,
                // @ts-ignore
                xform: comp_comp(...args),
            }
            : opts));
    }
    /**
     * Syntax sugar for {@link Subscription.transform} when using a
     * single {@link @thi.ng/transducers#map} transducer only. The given
     * function `fn` is used as `map`'s transformation fn.
     *
     * @param fn -
     * @param opts -
     */
    map(fn, opts) {
        return this.transform(map(fn), opts || {});
    }
    unsubscribe(sub) {
        return sub ? this.unsubscribeChild(sub) : this.unsubscribeSelf();
    }
    unsubscribeSelf() {
        LOGGER.debug(this.id, "unsub self");
        this.parent && this.parent.unsubscribe(this);
        this.state < State.UNSUBSCRIBED && (this.state = State.UNSUBSCRIBED);
        this.release();
        return true;
    }
    unsubscribeChild(sub) {
        LOGGER.debug(this.id, "unsub child", sub.id);
        const idx = this.subs.indexOf(sub);
        if (idx >= 0) {
            this.subs.splice(idx, 1);
            if (this.closeOut === CloseMode.FIRST ||
                (!this.subs.length && this.closeOut !== CloseMode.NEVER)) {
                this.unsubscribe();
            }
            return true;
        }
        return false;
    }
    next(x) {
        if (this.state >= State.DONE)
            return;
        this.xform ? this.dispatchXform(x) : this.dispatch(x);
    }
    done() {
        LOGGER.debug(this.id, "entering done()");
        if (this.state >= State.DONE)
            return;
        if (this.xform) {
            if (!this.dispatchXformDone())
                return;
        }
        this.state = State.DONE;
        // attempt to call .done in wrapped sub
        if (this.dispatchTo("done")) {
            // disconnect from parent & internal cleanup
            this.state < State.UNSUBSCRIBED && this.unsubscribe();
        }
        LOGGER.debug(this.id, "exiting done()");
    }
    error(e) {
        // only the wrapped sub's error handler gets a chance
        // to deal with the error
        const sub = this.wrapped;
        const hasErrorHandler = sub && sub.error;
        hasErrorHandler &&
            LOGGER.debug(this.id, "attempting wrapped error handler");
        // flag success if error handler returns true
        // (i.e. it could handle/recover from the error)
        // else detach this entire sub by going into error state...
        return (hasErrorHandler && sub.error(e)) || this.unhandledError(e);
    }
    unhandledError(e) {
        // ensure error is at least logged to console
        // even if default NULL_LOGGER is used...
        (LOGGER !== NULL_LOGGER ? LOGGER : console).warn(this.id, "unhandled error:", e);
        this.unsubscribe();
        this.state = State.ERROR;
        return false;
    }
    dispatchTo(type, x) {
        let s = this.wrapped;
        if (s) {
            try {
                s[type] && s[type](x);
            }
            catch (e) {
                // give wrapped sub a chance to handle error
                // (if that failed then we're already in error state now & terminate)
                if (!this.error(e))
                    return false;
            }
        }
        // process other child subs
        const subs = type === "next" ? this.subs : [...this.subs];
        for (let i = subs.length; i-- > 0;) {
            s = subs[i];
            try {
                s[type] && s[type](x);
            }
            catch (e) {
                if (type === "error" || !s.error || !s.error(e)) {
                    // if no or failed handler, go into error state
                    return this.unhandledError(e);
                }
            }
        }
        return true;
    }
    dispatch(x) {
        LOGGER.debug(this.id, "dispatch", x);
        this.cacheLast && (this.last = x);
        this.dispatchTo("next", x);
    }
    dispatchXform(x) {
        let acc;
        try {
            acc = this.xform[2]([], x);
        }
        catch (e) {
            // error in transducer can only be handled by the wrapped
            // subscriber's error handler (if avail)
            this.error(e);
            // don't dispatch value(s)
            return;
        }
        if (this.dispatchXformVals(acc)) {
            reduced_isReduced(acc) && this.done();
        }
    }
    dispatchXformDone() {
        let acc;
        try {
            // collect remaining values from transducer
            acc = this.xform[1]([]);
        }
        catch (e) {
            // error in transducer can only be handled by the wrapped
            // subscriber's error handler (if avail)
            return this.error(e);
        }
        return this.dispatchXformVals(acc);
    }
    dispatchXformVals(acc) {
        const uacc = reduced_unreduced(acc);
        for (let i = 0, n = uacc.length; i < n && this.state < State.DONE; i++) {
            this.dispatch(uacc[i]);
        }
        return this.state < State.ERROR;
    }
    ensureState() {
        if (this.state >= State.DONE) {
            illegalState(`operation not allowed in state ${this.state}`);
        }
    }
    release() {
        this.subs.length = 0;
        delete this.parent;
        delete this.xform;
        delete this.last;
    }
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/rstream/stream.js





function stream(src, opts) {
    return new Stream(src, opts);
}
/**
 * Syntax sugar for {@link stream}. Creates new stream which is
 * immediately seeded with initial `val` and configured with optional
 * `opts`.
 *
 * @param val -
 * @param opts -
 */
const reactive = (val, opts) => {
    const res = new Stream(opts);
    res.next(val);
    return res;
};
/**
 * @see {@link stream} & {@link reactive} for reference & examples.
 */
class Stream extends Subscription {
    constructor(src, opts) {
        const [_src, _opts] = isFunction(src)
            ? [src, opts || {}]
            : [undefined, src || {}];
        super(_opts.error ? { error: _opts.error } : undefined, __optsWithID("stream", _opts));
        this.src = _src;
        this._inited = false;
    }
    subscribe(sub, opts = {}) {
        const $sub = super.subscribe(sub, opts);
        if (!this._inited) {
            if (this.src) {
                try {
                    this._cancel = this.src(this) || (() => void 0);
                }
                catch (e) {
                    let s = this.wrapped;
                    if (!s || !s.error || !s.error(e)) {
                        this.unhandledError(e);
                    }
                }
            }
            this._inited = true;
        }
        return $sub;
    }
    unsubscribe(sub) {
        const res = super.unsubscribe(sub);
        if (res &&
            (!sub ||
                ((!this.subs || !this.subs.length) &&
                    this.closeOut !== CloseMode.NEVER))) {
            this.cancel();
        }
        return res;
    }
    done() {
        this.cancel();
        super.done();
        delete this.src;
        delete this._cancel;
    }
    error(e) {
        if (super.error(e))
            return true;
        this.cancel();
        return false;
    }
    cancel() {
        if (this._cancel) {
            LOGGER.debug(this.id, "cancel");
            const f = this._cancel;
            delete this._cancel;
            f();
        }
    }
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/node_modules/@thi.ng/rstream/resolve.js




/**
 * Creates a {@link Subscription} which receives promises, buffers them
 * and then passes their resolved values downstream.
 *
 * @remarks
 * If the optional `fail` handler is provided, it'll be called with the
 * error of each failed promise. If none is provided, the sub's
 * {@link ISubscriber.error} handler is called, which then stops the sub
 * from receiving further values.
 *
 * @example
 * ```ts
 * fromIterable([1, 2, 3], 100)
 *   .transform(tx.delayed(1000))
 *   .subscribe(resolve())
 *   .subscribe(trace("result"))
 * // result 1
 * // result 2
 * // result 3
 * // result done
 * ```
 *
 * @param opts -
 */
const resolve = (opts) => new Resolver(opts);
class Resolver extends Subscription {
    constructor(opts = {}) {
        super(undefined, __optsWithID("resolve"));
        this.outstanding = 0;
        this.fail = opts.fail;
    }
    next(x) {
        this.outstanding++;
        x.then((y) => {
            if (this.state < State.DONE) {
                this.dispatch(y);
                if (--this.outstanding === 0) {
                    this.done();
                }
            }
            else {
                LOGGER.warn(`resolved value in state ${this.state} (${x})`);
            }
        }, (e) => {
            if (this.fail) {
                this.fail(e);
            }
            else {
                this.error(e);
            }
        });
    }
    done() {
        if (this.parent &&
            this.parent.getState() === State.DONE &&
            this.outstanding === 0) {
            super.done();
        }
    }
}

// EXTERNAL MODULE: ../../packages/sentry/index.js + 54 modules
var sentry = __webpack_require__(87580);
// EXTERNAL MODULE: ../../packages/transducers/index.js + 9 modules
var transducers = __webpack_require__(32356);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/side-effect.js
var side_effect = __webpack_require__(9572);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/map.js
var xform_map = __webpack_require__(84900);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/keep.js
var keep = __webpack_require__(75335);
;// CONCATENATED MODULE: ../../packages/ethereum-tx-error/index.js
// shouldDiscard means should stop tracking this tx
// error from geth txpool error
// https://github.com/ethereum/go-ethereum/blob/2d20fed893faa894f50af709349b13b6ad9b45db/core/tx_pool.go#L56
// https://github.com/ethereum/go-ethereum/blob/2d20fed893faa894f50af709349b13b6ad9b45db/light/txpool.go#L356
// https://github.com/ethereum/go-ethereum/blob/2d20fed893faa894f50af709349b13b6ad9b45db/core/error.go#L48
// https://github.com/ethereum/go-ethereum/blob/2d20fed893faa894f50af709349b13b6ad9b45db/core/state_transition.go#L214
function processError(err){if(typeof(err===null||err===void 0?void 0:err.data)==='string'||typeof(err===null||err===void 0?void 0:err.message)==='string'){const errstr=err.data||err.message||'';if(/known transaction/i.test(errstr)||/tx already exist/i.test(errstr)||/already known/i.test(errstr)||/transaction with the same hash was already imported/i.test(errstr))return{errorType:'duplicateTx',shouldDiscard:false};if(/replacement transaction underpriced/i.test(errstr)||/gas price too low to replace/i.test(errstr))return{errorType:'replaceUnderpriced',shouldDiscard:true};// ErrUnderpriced is returned if a transaction's gas price is below the minimum
if(/transaction underpriced/i.test(errstr))return{errorType:'gasTooLow',shouldDiscard:true};if(/pool is full/i.test(errstr))return{errorType:'txPoolFull',shouldDiscard:true};if(/exceeds block gas limit/i.test(errstr))return{errorType:'gasExceedsLimit',shouldDiscard:true};// https://github.com/ethereum/go-ethereum/blob/2d20fed893faa894f50af709349b13b6ad9b45db/core/error.go#L58
if(/gas limit reached/i.test(errstr))return{errorType:'gasLimitReached',shouldDiscard:false};if(/oversized data/i.test(errstr))return{errorType:'oversizedData',shouldDiscard:true};if(/nonce too low/i.test(errstr)||/too stale nonce/i.test(errstr))return{errorType:'tooStaleNonce',shouldDiscard:true};if(/nonce too high/i.test(errstr))return{errorType:'nonceTooHigh',shouldDiscard:true};if(/nonce has max value/i.test(errstr))return{errorType:'nonceMax',shouldDiscard:true};if(/insufficient funds/i.test(errstr))return{errorType:'insufficientFunds',shouldDiscard:true};if(/ZeroGasPrice/.test(errstr))return{errorType:'zeroGasPrice',shouldDiscard:true};if(/gas price.*less than the minimum value/.test(errstr))return{errorType:'gasPriceTooLow',shouldDiscard:true};if(/intrinsic gas too low/i.test(errstr))return{errorType:'intrinsicGas',shouldDiscard:true};if(/transaction type not supported/i.test(errstr))return{errorType:'txTypeNotSupported',shouldDiscard:true};if(/max fee per gas higher than/i.test(errstr))return{errorType:'feeCapVeryHigh',shouldDiscard:true};if(/max fee per gas less than block base fee/i.test(errstr))return{errorType:'feeCapTooLow',shouldDiscard:true};if(/max priority fee per gas higher than max fee per gas/i.test(errstr))return{errorType:'tipAboveFeeCap',shouldDiscard:true};if(/max priority fee per gas higher than/i.test(errstr))return{errorType:'tipVeryHigh',shouldDiscard:true};if(/EpochHeightOutOfBound/.test(errstr))return{errorType:'epochHeightOutOfBound',shouldDiscard:true};if(/exceeds the maximum value/.test(errstr))return{errorType:'gasExceedsLimit',shouldDiscard:true};if(/NotEnoughBaseGas/.test(errstr))return{errorType:'notEnoughBaseGas',shouldDiscard:true};// can't find this error in geth
if(/invalid chainid/i.test(errstr))return{errorType:'chainIdMismatch',shouldDiscard:true};}return{errorType:'unknownError',shouldDiscard:true};}
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/compose/identity.js
var identity = __webpack_require__(94249);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_handleUnfinishedETHTx/index.js








const NAME = 'wallet_handleUnfinishedETHTx'

function defs(...args) {
  const s = stream({
    id: args.length === 2 ? args[0] : undefined,
    closeIn: CloseMode.FIRST,
    closeOut: false,
    cache: true,
  })
  s.next(args.length === 2 ? args[1] : args[0])
  return s
}

let Ext

function getExt() {
  return Ext
    ? Promise.resolve(Ext)
    : __webpack_require__.e(/* import() */ 258).then(__webpack_require__.bind(__webpack_require__, 40258)).then(ext => {
        Ext = ext
        return ext
      })
}

function updateBadge() {
  // count
  return
  // return getExt().then(ext =>
  //   count > 0 ? ext.badge.set({text: count}) : ext.badge.clear(),
  // )
}

const schemas = {
  input: [spec.mapp],
}

const permissions = {
  locked: true,
  methods: [
    'eth_blockNumber',
    'eth_sendRawTransaction',
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
    'wallet_handleUnfinishedETHTx',
    'wallet_getBlockchainExplorerUrl',
    'eth_getTransactionCount',
  ],
  db: [
    'retractAttr',
    'getUnfinishedTxCount',
    'getAddressById',
    'getTxById',
    'setTxSkipped',
    'setTxFailed',
    'setTxSending',
    'setTxPending',
    'setTxPackaged',
    'setTxExecuted',
    'setTxConfirmed',
    'setTxUnsent',
    'setTxChainSwitched',
  ],
}

const main = ({
  rpcs: {
    eth_blockNumber,
    eth_sendRawTransaction,
    eth_getTransactionByHash,
    eth_getTransactionReceipt,
    eth_getTransactionCount,
    wallet_getBlockchainExplorerUrl,
    wallet_handleUnfinishedETHTx,
  },
  db: {
    retractAttr,
    getUnfinishedTxCount,
    getAddressById,
    getTxById,
    setTxSkipped,
    setTxFailed,
    setTxSending,
    setTxPending,
    setTxPackaged,
    setTxExecuted,
    setTxConfirmed,
    setTxUnsent,
    setTxChainSwitched,
  },
  params: {tx, address, okCb, failedCb},
  network,
}) => {
  tx = getTxById(tx)
  // this only happends in integration test
  if (!tx) return
  address = getAddressById(address)
  const cacheTime = Math.min(network.cacheTime || 1000, 4000)
  const {status, hash, raw} = tx

  const s = defs(hash, {tx, address})
  const sdone = () => s.done()
  const keepTrack = (delay = cacheTime) => {
    if (!Number.isInteger(delay)) delay = cacheTime
    sdone()
    setTimeout(
      () => wallet_handleUnfinishedETHTx({tx: tx.eid, address: address.eid}),
      delay,
    )
  }

  const ss = defs(hash, {tx, address})
  const ssdone = () => ss.done()
  const skeepTrack = (delay = cacheTime) => {
    if (!Number.isInteger(delay)) delay = cacheTime
    ssdone()
    setTimeout(
      () => wallet_handleUnfinishedETHTx({tx: tx.eid, address: address.eid}),
      delay,
    )
  }

  // # detect pivot chain switch
  if (status === 0) {
    // ## unsent
  } else if (status === 1) {
    // ## sending
  } else if (status === 2) {
    // ## pending
  } else if (status === 3) {
    // ## packaged
    ss.map(() => eth_getTransactionByHash({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: identity/* identity */.y}))
      .transform(
        (0,side_effect/* sideEffect */.j)(rst => {
          if (!rst) {
            if (tx.blockHash) retractAttr({eid: tx.eid, attr: 'tx/blockHash'})
            setTxPending({hash})
            setTxChainSwitched({hash})
            skeepTrack()
          }
        }),
        (0,transducers/* keepTruthy */.te)(),
        (0,side_effect/* sideEffect */.j)(rst => {
          if (rst.blockHash !== tx.blockHash) {
            setTxPackaged({hash, blockHash: rst.blockHash})
            setTxChainSwitched({hash})
          }
          skeepTrack()
        }),
      )
  } else if (status === 4) {
    // ## executed
    ss.map(() => eth_getTransactionReceipt({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: identity/* identity */.y}))
      .transform(
        (0,side_effect/* sideEffect */.j)(rst => {
          if (!rst) {
            if (tx.receipt) retractAttr({eid: tx.eid, attr: 'tx/receipt'})
            setTxPackaged({hash, blockHash: tx.blockHash})
            setTxChainSwitched({hash})
            ssdone()
          }
        }),
        (0,transducers/* keepTruthy */.te)(),
        (0,side_effect/* sideEffect */.j)(rst => {
          if (
            rst.blockHash !== tx.receipt.blockHash ||
            rst.transactionIndex !== tx.receipt.transactionIndex ||
            rst.blockNumber !== tx.receipt.blockNumber
          ) {
            if (tx.receipt) retractAttr({eid: tx.eid, attr: 'tx/receipt'})
            setTxPackaged({hash, blockHash: rst.blockHash})
            setTxChainSwitched({hash})
            skeepTrack()
          }
        }),
      )
  }

  // # process tx
  if (status === 0) {
    // ## unsent
    s.transform(
      (0,side_effect/* sideEffect */.j)(() => setTxSending({hash})),
      (0,side_effect/* sideEffect */.j)(() => updateBadge(getUnfinishedTxCount())),
    )
      .map(() => {
        return eth_sendRawTransaction({errorFallThrough: true}, [raw])
      })
      .subscribe(
        resolve({
          fail: err => {
            // failed to send
            setTxUnsent({hash})

            let {errorType, shouldDiscard} = processError(err)
            const isDuplicateTx = errorType === 'duplicateTx'
            const resendNonceTooStale =
              tx.resendAt && errorType === 'tooStaleNonce'
            const resendPriceTooLow =
              tx.resendAt && errorType === 'replaceUnderpriced'
            if (resendPriceTooLow) errorType = 'replacedByAnotherTx'

            const sameAsSuccess = isDuplicateTx || resendNonceTooStale
            const failed =
              !sameAsSuccess && (shouldDiscard || resendPriceTooLow)

            if (errorType === 'unknownError')
              (0,sentry/* capture */.IE)(err, {
                tags: {
                  custom_type: 'unknown sendTx error',
                  rpc_network: network.name,
                },
              })

            defs({
              failed: failed && {errorType, err},
              sameAsSuccess,
              resend: !shouldDiscard && !sameAsSuccess,
            })
              .transform(
                (0,transducers/* branchObj */.g8)({
                  failed: [
                    (0,side_effect/* sideEffect */.j)(
                      ({err}) =>
                        typeof failedCb === 'function' && failedCb(err),
                    ),
                    (0,side_effect/* sideEffect */.j)(({errorType}) => {
                      if (setTxFailed({hash, error: errorType})) {
                        getExt().then(ext =>
                          ext.notifications.create(hash, {
                            title: 'Failed transaction',
                            message: `Transaction ${parseInt(
                              tx.txPayload.nonce,
                              16,
                            )} failed! ${err?.data || err?.message || ''}`,
                          }),
                        )
                      }
                    }),
                    (0,side_effect/* sideEffect */.j)(() => {
                      updateBadge(getUnfinishedTxCount())
                    }),
                  ],
                  resend: (0,side_effect/* sideEffect */.j)(keepTrack),
                  // retry in next run
                  sameAsSuccess: [
                    (0,side_effect/* sideEffect */.j)(() => setTxPending({hash})),
                    (0,side_effect/* sideEffect */.j)(() => typeof okCb === 'function' && okCb(hash)),
                    (0,side_effect/* sideEffect */.j)(keepTrack),
                  ],
                }),
              )
              .done()
          },
        }),
      )
      .transform(
        // successfully sent
        (0,side_effect/* sideEffect */.j)(() => setTxPending({hash})),
        (0,side_effect/* sideEffect */.j)(() => typeof okCb === 'function' && okCb(hash)),
        (0,side_effect/* sideEffect */.j)(keepTrack),
      )
  } else if (status === 1) {
    // ## sending
  } else if (status === 2) {
    // ## pending
    s.map(() => eth_getTransactionByHash({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        // not packaged or no blockhash in getTransactionByHash result
        (0,xform_map/* map */.U)(rst => {
          if (rst && rst.blockHash) return rst
          // getTransactionByHash return null
          eth_blockNumber({errorFallThrough: true}, [])
            .then(n => {
              if (!tx.resendAt && !tx.blockNumber) {
                setTxSending({hash, resendAt: n})
              } else if (
                bignumber/* BigNumber.from */.O$.from(n)
                  .sub(bignumber/* BigNumber.from */.O$.from(tx.resendAt || tx.blockNumber))
                  .gte(1)
              ) {
                setTxUnsent({hash, resendAt: n})
              }
            })
            .catch(identity/* identity */.y)
          return keepTrack()
        }),
        (0,transducers/* keepTruthy */.te)(),

        // packaged
        (0,xform_map/* map */.U)(rst => {
          setTxPackaged({hash, blockHash: rst.blockHash})
          return eth_getTransactionCount({errorFallThrough: true}, [
            address.value,
            rst.blockNumber,
          ])
        }),
      )
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        (0,side_effect/* sideEffect */.j)(nonce => {
          if (
            bignumber/* BigNumber.from */.O$.from(nonce).gt(bignumber/* BigNumber.from */.O$.from(tx.txPayload.nonce).add(1))
          ) {
            if (tx.skippedChecked) {
              if (setTxSkipped({hash, skippedChecked: true})) {
                getExt().then(ext =>
                  ext.notifications.create(hash, {
                    title: 'Skipped transaction',
                    message: `Transaction ${parseInt(
                      tx.txPayload.nonce,
                      16,
                    )}  skipped!`,
                  }),
                )
              }
              updateBadge(getUnfinishedTxCount())
              return sdone()
            } else {
              setTxSkipped({hash})
              // check if skipped again immediately
              return keepTrack(0)
            }
          }
          keepTrack(0)
        }),
      )
  } else if (status === 3) {
    // ## packaged
    s.map(() => eth_getTransactionReceipt({errorFallThrough: true}, [hash]))
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        (0,side_effect/* sideEffect */.j)(rst => {
          !rst && keepTrack()
        }),
        (0,keep/* keep */.C)(),
        (0,side_effect/* sideEffect */.j)(rst => {
          const {
            status,
            blockHash,
            transactionIndex,
            blockNumber,
            contractAddress,
            cumulativeGasUsed,
            effectiveGasPrice,
            gasUsed,
            type,
            txExecErrorMsg,
          } = rst
          const receipt = {
            cumulativeGasUsed,
            effectiveGasPrice,
            type: type || '0x0',
            blockHash,
            transactionIndex,
            blockNumber,
            gasUsed,
          }
          if (contractAddress) receipt.contractCreated = contractAddress

          if (status === '0x1') {
            setTxExecuted({hash, receipt})
            keepTrack(0)
          } else {
            let err = ''
            if (txExecErrorMsg) {
              err = txExecErrorMsg
            }
            if (setTxFailed({hash, error: err || 'tx failed'})) {
              getExt().then(ext =>
                ext.notifications.create(hash, {
                  title: 'Failed transaction',
                  message:
                    txExecErrorMsg ||
                    `Transaction ${parseInt(
                      tx.txPayload.nonce,
                      16,
                    )} failed! ${err}`,
                }),
              )
            }
            updateBadge(getUnfinishedTxCount())
          }
        }),
        (0,side_effect/* sideEffect */.j)(sdone),
      )
  } else if (status === 4) {
    // ## executed
    s.map(() => eth_blockNumber({errorFallThrough: true}, []))
      .subscribe(resolve({fail: keepTrack}))
      .transform(
        (0,xform_map/* map */.U)(n => {
          if (
            n &&
            bignumber/* BigNumber.from */.O$.from(n).gte(bignumber/* BigNumber.from */.O$.from(tx.receipt.blockNumber))
          ) {
            setTxConfirmed({hash})
            updateBadge(getUnfinishedTxCount())
            return true
          }
          keepTrack()
          return false
        }),
        (0,transducers/* keepTruthy */.te)(), // filter non-null tx
        (0,xform_map/* map */.U)(() => wallet_getBlockchainExplorerUrl({transaction: [hash]})),
      )
      .subscribe(resolve({fail: identity/* identity */.y}))
      .transform(
        (0,side_effect/* sideEffect */.j)(({transaction: [txUrl]}) => {
          getExt().then(ext => {
            ext.notifications.create(txUrl, {
              title: 'Confirmed transaction',
              message: `Transaction ${parseInt(
                tx.txPayload.nonce,
                16,
              )} confirmed! ${txUrl?.length ? 'View on Explorer.' : ''}`,
            })
          })
        }),
        (0,side_effect/* sideEffect */.j)(sdone),
      )
  }
}


/***/ }),

/***/ 22176:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* eslint-disable no-empty */


const NAME = 'wallet_handleUnfinishedTxs'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  locked: true,
  methods: ['wallet_handleUnfinishedCFXTx', 'wallet_handleUnfinishedETHTx'],
  db: ['getUnfinishedTx'],
}

const main = ({
  db: {getUnfinishedTx},
  rpcs: {wallet_handleUnfinishedCFXTx, wallet_handleUnfinishedETHTx},
}) => {
  const txs = getUnfinishedTx()
  txs.forEach(({tx, address, network}) => {
    if (network.type === 'cfx') {
      try {
        wallet_handleUnfinishedCFXTx({network}, {tx, address: address.eid})
      } catch (err) {}
    } else {
      try {
        wallet_handleUnfinishedETHTx({network}, {tx, address: address.eid})
      } catch (err) {}
    }
  })
}


/***/ }),

/***/ 4165:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_importAddress'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nickname],
    ['password', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
    ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress]],
  ],
}

const permissions = {
  methods: ['wallet_addVault'],
  external: ['popup'],
}

const main = async ({
  params: {password, address, nickname},
  rpcs: {wallet_addVault},
}) => {
  if (nickname)
    return await wallet_addVault({
      password,
      address: address.toLowerCase(),
      nickname,
    })
  else
    return await wallet_addVault({
      password,
      address: address.toLowerCase(),
    })
}


/***/ }),

/***/ 29783:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);



const NAME = 'wallet_importAll'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
    ['decryptPassword', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
    ['vaults', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
  ],
}

const permissions = {
  external: ['popup'],
  locked: true,
  methods: ['wallet_validatePassword', 'wallet_addVault'],
  db: ['t'],
}

const main = async ({
  Err: {InvalidParams, Internal},
  rpcs: {wallet_addVault, wallet_validatePassword},
  params: {password, decryptPassword, vaults},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')
  let data, decrypted

  try {
    data = JSON.parse(vaults)
  } catch (err) {
    throw InvalidParams('Invalid vaults data, must be a valid json string')
  }

  if (!data.wallet || !data.encrypted)
    throw InvalidParams('Invalid vaults data')

  try {
    decrypted = await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(decryptPassword, data.encrypted)
    JSON.parse(decrypted)
  } catch (err) {
    throw InvalidParams('Invalid vaults data')
  }

  if (data.wallet === 'fluent') {
    if (window) {
      const browser = (await __webpack_require__.e(/* import() */ 565).then(__webpack_require__.t.bind(__webpack_require__, 72565, 19))).default
      await browser.storage.local.set({wallet_importAll: decrypted})
      browser?.runtime?.reload?.()
    } else {
      throw Internal('Invalid running env, window is not defined')
    }
    return
  }

  if (data.wallet === 'portal') {
    decrypted = JSON.parse(decrypted)
    if (!Array.isArray(decrypted)) throw InvalidParams('Invalid vaults data')

    const rst = []

    for (const [type, cred] of decrypted) {
      if (type !== 'hd' && type !== 'pk')
        throw InvalidParams(`Invalid type ${type} of credentials`)
      rst.push(
        await wallet_addVault({
          password,
          [type === 'hd' ? 'mnemonic' : 'privateKey']: cred,
        }),
      )
    }

    return rst
  }
}


/***/ }),

/***/ 38886:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2723);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89620);
/* harmony import */ var _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(83799);





const NAME = 'wallet_importHardwareWalletAccountGroupOrAccount'

const AddressSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
  ['nickname', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
]

const BasicSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['password', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
  ['accountGroupData', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp],
  ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.oneOrMore, AddressSchema]],
]

// adding new account group
const NewAccountGroupSchema = [
  ['type', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'cfx', 'eth']],
  [
    'device',
    [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_3__/* .consts.LEDGER_NANOS_NAME */ .vH.CD, _fluent_wallet_ledger__WEBPACK_IMPORTED_MODULE_3__/* .consts.LEDGER_NANOX_NAME */ .vH.Qx],
  ],
  ['accountGroupNickname', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
]

// adding account to existing account group
const OldAccountGroupSchema = [['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]]

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
    BasicSchema.concat(NewAccountGroupSchema),
    BasicSchema.concat(OldAccountGroupSchema),
  ],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_addVault'],
  db: [
    'getPassword',
    'findGroup',
    't',
    'findAddress',
    'newAddressTx',
    'findNetwork',
    'findAccount',
  ],
}

const main = async ({
  Err: {InvalidParams},
  rpcs: {wallet_addVault},
  db: {
    getPassword,
    findGroup,
    t,
    findNetwork,
    newAddressTx,
    findAccount,
    findAddress,
  },
  params: {
    password,
    device,
    type,
    address,
    accountGroupData,
    accountGroupId,
    accountGroupNickname,
  },
}) => {
  if (accountGroupNickname) {
    // crate new account group
    const toImport = {
      accountGroupData,
      nickname: accountGroupNickname,
      password,
      device,
      accounts: address,
    }

    if (type === 'cfx') toImport.cfxOnly = true

    return await wallet_addVault(toImport)
  }

  // add to existing account
  const group = findGroup({
    groupId: accountGroupId,
    g: {vault: {cfxOnly: 1, eid: 1}, account: 1},
  })

  if (!group) throw InvalidParams(`Invalid account group id: ${accountGroupId}`)

  const ddata = JSON.stringify(accountGroupData)
  const data = await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_2__.encrypt)(getPassword(), ddata)

  let txs = [{eid: group.vault.eid, vault: {data, ddata}}]

  const networks = findNetwork({
    type: group.vault.cfxOnly ? 'cfx' : 'eth',
    g: 0,
  })

  // check duplicate address
  networks.forEach(({eid}) =>
    address.forEach(({address}) => {
      try {
        const dupaddr = findAddress({value: address, networkId: eid})
        if (dupaddr) throw InvalidParams(`Address ${address} already exist`)
      } catch (err) {
        if (err.message.includes('already exist')) throw err
      }
    }),
  )

  txs = txs.concat(
    networks.reduce(
      (acc, {eid, netId, type}, idx) =>
        address.reduce((acc, {address, nickname}, jdx) => {
          // hw-vaults.cfxOnly are set explicitly the first time creating the group
          // so hw group can only have 1. cfx network addrs or 2. eth network addrs
          if (group.vault.cfxOnly && type !== 'cfx') return acc
          if (!group.vault.cfxOnly && type === 'cfx') return acc

          const accountIndex = jdx + group.account.length
          const [account] = findAccount({
            groupId: accountGroupId,
            index: accountIndex,
          })
          const accountId = account ?? `newaccount ${jdx}`
          const value = group.vault.cfxOnly
            ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .encode */ .cv)((0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .decode */ .Jx)(address).hexAddress, netId)
            : address
          const hex = group.vault.cfxOnly ? (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .decode */ .Jx)(address).hexAddress : address
          const addrTx = newAddressTx({
            eid: `newaddr ${idx} ${jdx}`,
            value,
            hex,
            network: eid,
          })
          return acc.concat([
            addrTx,
            {
              eid: accountId,
              account: {
                index: accountIndex,
                nickname,
                address: addrTx.eid,
                hidden: false,
              },
            },
            {
              eid: accountGroupId,
              accountGroup: {account: accountId},
            },
          ])
        }, acc),
      [],
    ),
  )

  t(txs)
  return accountGroupId
}


/***/ }),

/***/ 89749:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_importMnemonic'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nickname],
    ['mnemonic', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mnemonic],
    ['password', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
    ['waitTillFinish', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.maybe, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep]],
    [
      'cfxOnly',
      {
        optional: true,
        doc: 'only derive conflux compatible address from this mnemonic',
      },
      [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.maybe, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep],
    ],
    [
      'force',
      {optional: true, doc: 'set to true to skip duplication check'},
      [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.maybe, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep],
    ],
  ],
}

const permissions = {
  methods: ['wallet_addVault'],
  external: ['popup'],
}

const main = ({params, rpcs: {wallet_addVault}}) =>
  wallet_addVault(params)


/***/ }),

/***/ 91145:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_importPrivateKey'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nickname],
    ['privateKey', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.privateKey],
    ['password', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
  ],
}

const permissions = {
  methods: ['wallet_addVault'],
  external: ['popup'],
}

const main = async ({params, rpcs: {wallet_addVault}}) =>
  await wallet_addVault(params)


/***/ }),

/***/ 68219:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
const NAME = 'wallet_isLocked'

const permissions = {
  db: ['getLocked'],
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({db: {getLocked}}) => getLocked()


/***/ }),

/***/ 24038:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
const NAME = 'wallet_lock'

const schemas = {}

const permissions = {
  db: ['setLocked', 'findApp'],
  external: ['popup'],
}

const main = async ({db: {setLocked, findApp}}) => {
  setLocked(true)
  const apps = findApp({g: {site: {post: 1}}})
  apps.forEach(app => {
    try {
      if (!app?.site?.post) return
      const {
        site: {post},
      } = app
      post({event: 'accountsChanged', params: []})
      // eslint-disable-next-line no-empty
    } catch (err) {}
  })
}


/***/ }),

/***/ 39067:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_metadataForPopup'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  locked: true,
  methods: [
    'wallet_zeroAccountGroup',
    'wallet_isLocked',
    'wallet_getPendingAuthRequest',
  ],
  db: [],
}

const main = async ({
  rpcs: {
    wallet_zeroAccountGroup,
    wallet_isLocked,
    wallet_getPendingAuthRequest,
  },
}) => {
  const [locked, zeroGroup] = await Promise.all([
    wallet_isLocked(),
    wallet_zeroAccountGroup(),
  ])

  if (locked) return {locked, zeroGroup}
  return {
    locked,
    zeroGroup,
    pendingAuthReq: await wallet_getPendingAuthRequest(),
  }
}


/***/ }),

/***/ 35723:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "cache": () => (/* binding */ cache),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_network1559Compatible'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
  methods: ['eth_getBlockByNumber'],
  db: [],
}

const cache = {
  type: 'ttl',
  ttl: 24 * 60 * 60 * 1000, // cache for 1 day
  key: ({network}) => `${NAME}${network.endpoint}`,
}

const main = async ({rpcs: {eth_getBlockByNumber}, network}) => {
  if (network.type === 'cfx') return false
  const block = await eth_getBlockByNumber(['latest', false])
  if (block && block.baseFeePerGas) return true
  return false
}


/***/ }),

/***/ 97546:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87580);



const NAME = 'wallet_refetchBalance'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or,
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      {closed: true},
      [
        'type',
        {
          optional: true,
          doc: 'all for fetch balance all accounts rather than selected account',
        },
        [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'all'],
      ],
      [
        'allNetwork',
        {optional: true, doc: 'true to refetch balance of all network'},
        _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep,
      ],
    ],
  ],
}

const permissions = {
  external: ['popup'],
  locked: true,
  methods: ['wallet_getBalance'],
  db: ['getSingleCallBalanceParams', 'upsertBalances'],
}

const main = async ({
  db: {getSingleCallBalanceParams, upsertBalances},
  params,
  rpcs: {wallet_getBalance},
  network,
}) => {
  const refetchBalanceParams = getSingleCallBalanceParams({
    type: params?.type,
    allNetwork: Boolean(params?.allNetwork),
    networkId: network.eid,
  })

  // eslint-disable-next-line no-unused-vars
  const promises = refetchBalanceParams.map(([_, [users, tokens, network]]) =>
    wallet_getBalance(
      {network, networkName: network.name, errorFallThrough: true},
      {users, tokens},
    )
      .then(rst => {
        return rst && upsertBalances({data: rst, networkId: network.id})
      })
      .catch(err =>
        (0,_fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_1__/* .capture */ .IE)(err, {
          tags: {
            custom_type: 'error refetch balance',
            rpc_network: network?.endpoint,
          },
        }),
      ),
  )

  await Promise.all(promises)
  return true
}


/***/ }),

/***/ 32754:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_refetchTokenList'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_updateTokenList'],
  db: ['getNetwork'],
}

const main = async ({
  db: {getNetwork},
  rpcs: {wallet_updateTokenList},
}) => {
  const promises = getNetwork().reduce(
    (acc, n) =>
      n.tokenList
        ? acc.concat([
            wallet_updateTokenList({
              networkId: n.eid,
              tokenList: {url: n.tokenList.url, name: n.tokenList.name},
            }),
          ])
        : acc,
    [],
  )

  return await Promise.all(promises)
}


/***/ }),

/***/ 44549:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
// EXTERNAL MODULE: ../../packages/consts/index.js
var consts = __webpack_require__(9414);
// EXTERNAL MODULE: ../../packages/confluxscan-api/fetcher.js + 10 modules
var fetcher = __webpack_require__(95895);
// EXTERNAL MODULE: ../../packages/confluxscan-api/utils.js
var utils = __webpack_require__(52093);
;// CONCATENATED MODULE: ../../packages/confluxscan-api/account.js
function transaction(opts={}){if(!Number.isInteger(opts.networkId))throw new Error('invalid networkId, must be a integer');if((0,utils/* isCoreNetworkId */.v)(opts.networkId))return transactionsCoreSpace(opts);return transactionsESpace(opts);}function toHex(str){return`0x${parseInt(str,10).toString(16)}`;}function formatCoreTxs(txs,chainId){return txs.map(({input,contractCreated,epochNumber,from,gasFee,gasPrice,hash,// method,
nonce,status,timestamp,to,transactionIndex,value})=>{const tx={hash,created:timestamp*1000,fromScan:true,extra:{ok:false},payload:{from,gasPrice:toHex(gasPrice),nonce:toHex(nonce),to,value:toHex(value),chainId},receipt:{gasFee:toHex(gasFee),index:toHex(transactionIndex),epochNumber:toHex(epochNumber)}};if(status===2){tx.status=-2;}else if(status===1){tx.status=-1;tx.err='tx failed';}else tx.status=5;if(input&&input!=='0x')tx.payload.data=input;if(contractCreated)tx.receipt.contractCreated=contractCreated;return tx;});}async function transactionsCoreSpace({chainId=undefined,networkId=undefined,address=undefined,page=1,size=100,from=undefined,to=undefined,startblock=undefined,endblock=undefined,minTimestamp=undefined,maxTimestamp=undefined,sort='DESC',withInput=true}){try{let searchParams={account:address,limit:size,from,to,minEpochNumber:startblock,maxEpochNumber:endblock,minTimestamp,maxTimestamp,withInput,sort};// remove undefined values
searchParams=Object.keys(searchParams).reduce((acc,k)=>{const v=searchParams[k];if(v!==undefined)acc[k]=v;return acc;},{});let finished=false;let list=[];while(!finished){searchParams.skip=(page-1)*size;const res=await (0,fetcher/* fetch */.h)((0,utils/* getURL */.A)(networkId,'account','/transactions'),{searchParams}).json();if(res.code===0)list=list.concat(res.data.list);else throw new Error(res.message);if(list.length>=res.data.total)finished=true;else page=page+1;}return{list:formatCoreTxs(list,chainId),total:list.length};}catch(err){return;}}function formatEspaceTxs(txs,chainId){return txs.map(({blockHash,blockNumber,contractAddress,from,gas,gasPrice,gasUsed,hash,input,isError,nonce,timestamp,to,transactionIndex,txreceipt_status,value})=>{const tx={fromScan:true,hash,blockHash,blockNumber,created:parseInt(timestamp,10)*1000,extra:{ok:false},payload:{type:'0x0',from,gas,gasPrice:toHex(gasPrice),nonce:toHex(nonce),to,value:toHex(value),chainId},receipt:{blockHash,blockNumber,gasUsed,transactionIndex:toHex(transactionIndex)}};if(isError!=='0'||txreceipt_status!=='1'){tx.status=-1;tx.err='rejected or canceled';}else tx.status=5;if(contractAddress)tx.receipt.contractCreated=contractAddress;if(input&&input!=='0x')tx.payload.data=input;return tx;});}async function transactionsESpace({chainId=undefined,networkId=undefined,address=undefined,startblock=undefined,endblock=undefined,page=1,size=100,sort='desc'}){if(typeof chainId!=='string')throw new Error('chainId is required');try{let finished=false;let list=[];while(!finished){const res=await (0,fetcher/* fetch */.h)((0,utils/* getURL */.A)(networkId),{searchParams:{module:'account',action:'txlist',address,page,offset:size,startblock,endblock,sort:sort.toLowerCase()}}).json();if(res.status==='1')list=list.concat(res.result);else throw new Error(res.message);if(res.result.length===size)page=page+1;else finished=true;}return{list:formatEspaceTxs(list,chainId),total:list.length};}catch(err){return;}}
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/memoize/memoize1.js
/**
 * Optimized memoization for single arg functions. If the function
 * expects args other than strings or numbers, you MUST provide a `Map`
 * implementation which supports value (rather than object) equality,
 * e.g. one of those provided by
 * {@link @thi.ng/associative# | @thi.ng/associative}. Using a native
 * `Map` type here will lead to memory leaks! Alternatively, use
 * {@link (memoizeJ:1)}.
 *
 * @param fn -
 * @param cache -
 */
const memoize1 = (fn, cache) => {
    !cache && (cache = new Map());
    return (x) => {
        let res;
        return cache.has(x)
            ? cache.get(x)
            : (cache.set(x, (res = fn(x))), res);
    };
};

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/compare/compare.js
const compare = (a, b) => {
    if (a === b) {
        return 0;
    }
    if (a == null) {
        return b == null ? 0 : -1;
    }
    if (b == null) {
        return a == null ? 0 : 1;
    }
    if (typeof a.compare === "function") {
        return a.compare(b);
    }
    if (typeof b.compare === "function") {
        return -b.compare(a);
    }
    return a < b ? -1 : a > b ? 1 : 0;
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/errors/deferror.js
const defError = (prefix, suffix = (msg) => (msg !== undefined ? ": " + msg : "")) => class extends Error {
    constructor(msg) {
        super(prefix(msg) + suffix(msg));
    }
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/errors/illegal-arguments.js

const IllegalArgumentError = defError(() => "illegal argument(s)");
const illegalArgs = (msg) => {
    throw new IllegalArgumentError(msg);
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/errors/out-of-bounds.js

const OutOfBoundsError = defError(() => "index out of bounds");
const outOfBounds = (index) => {
    throw new OutOfBoundsError(index);
};
/**
 * Throws an {@link OutOfBoundsError} if `index` outside the `[min..max)` range.
 *
 * @param index -
 * @param min -
 * @param max -
 */
const ensureIndex = (index, min, max) => (index < min || index >= max) && outOfBounds(index);
/**
 * Throws an {@link OutOfBoundsError} if either `x` or `y` is outside their
 * respective `[0..max)` range.
 *
 * @param x -
 * @param y -
 * @param maxX -
 * @param maxY -
 */
const ensureIndex2 = (x, y, maxX, maxY) => (x < 0 || x >= maxX || y < 0 || y >= maxY) && outOfBounds([x, y]);

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/random/arandom.js
const INV_MAX = 1 / 2 ** 32;
class ARandom {
    float(norm = 1) {
        return this.int() * INV_MAX * norm;
    }
    norm(norm = 1) {
        return (this.int() * INV_MAX - 0.5) * 2 * norm;
    }
    minmax(min, max) {
        return this.float() * (max - min) + min;
    }
    minmaxInt(min, max) {
        min |= 0;
        max |= 0;
        return min + ((this.float() * (max - min)) | 0);
    }
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/random/system.js

const random = Math.random;
/**
 * A `Math.random()` based {@link IRandom} implementation. Also @see
 * {@link SYSTEM}.
 */
class SystemRandom extends ARandom {
    int() {
        return (random() * 4294967296) /* 2**32 */ >>> 0;
    }
    float(norm = 1) {
        return random() * norm;
    }
    norm(norm = 1) {
        return (random() - 0.5) * 2 * norm;
    }
}
/**
 * Used as default PRNG throughout most other thi.ng projects, though usually is
 * configurable.
 */
const SYSTEM = new SystemRandom();

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/checks/is-arraylike.js
const isArrayLike = (x) => x != null && typeof x !== "function" && x.length !== undefined;

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/equiv/index.js
const OBJP = Object.getPrototypeOf({});
const FN = "function";
const STR = "string";
const equiv = (a, b) => {
    let proto;
    if (a === b) {
        return true;
    }
    if (a != null) {
        if (typeof a.equiv === FN) {
            return a.equiv(b);
        }
    }
    else {
        return a == b;
    }
    if (b != null) {
        if (typeof b.equiv === FN) {
            return b.equiv(a);
        }
    }
    else {
        return a == b;
    }
    if (typeof a === STR || typeof b === STR) {
        return false;
    }
    if (((proto = Object.getPrototypeOf(a)), proto == null || proto === OBJP) &&
        ((proto = Object.getPrototypeOf(b)), proto == null || proto === OBJP)) {
        return equivObject(a, b);
    }
    if (typeof a !== FN &&
        a.length !== undefined &&
        typeof b !== FN &&
        b.length !== undefined) {
        return equivArrayLike(a, b);
    }
    if (a instanceof Set && b instanceof Set) {
        return equivSet(a, b);
    }
    if (a instanceof Map && b instanceof Map) {
        return equivMap(a, b);
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
        return a.toString() === b.toString();
    }
    // NaN
    return a !== a && b !== b;
};
const equivArrayLike = (a, b, _equiv = equiv) => {
    let l = a.length;
    if (l === b.length) {
        while (l-- > 0 && _equiv(a[l], b[l]))
            ;
    }
    return l < 0;
};
const equivSet = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a.keys()].sort(), [...b.keys()].sort());
const equivMap = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a].sort(), [...b].sort());
const equivObject = (a, b, _equiv = equiv) => {
    if (Object.keys(a).length !== Object.keys(b).length) {
        return false;
    }
    for (let k in a) {
        if (!b.hasOwnProperty(k) || !_equiv(a[k], b[k])) {
            return false;
        }
    }
    return true;
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/transducers/reduced.js
class Reduced {
    constructor(val) {
        this.value = val;
    }
    deref() {
        return this.value;
    }
}
const reduced = (x) => new Reduced(x);
const reduced_isReduced = (x) => x instanceof Reduced;
const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);
const reduced_unreduced = (x) => (x instanceof Reduced ? x.deref() : x);

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/dcons/alist.js





class AList {
    constructor(src) {
        this._length = 0;
        src && this.into(src);
    }
    get length() {
        return this._length;
    }
    get head() {
        return this._head;
    }
    [Symbol.iterator]() {
        return _iterate("next", this._head);
    }
    reverseIterator() {
        return _iterate("prev", this.tail);
    }
    clear() {
        this.release();
    }
    compare(o, cmp = compare) {
        let n = this._length;
        if (n < o._length) {
            return -1;
        }
        else if (n > o._length) {
            return 1;
        }
        else if (n === 0) {
            return 0;
        }
        else {
            let ca = this._head;
            let cb = o._head;
            let res = 0;
            for (; n-- > 0 && res === 0;) {
                res = cmp(ca.value, cb.value);
                ca = ca.next;
                cb = cb.next;
            }
            return res;
        }
    }
    concat(...slices) {
        const res = this.copy();
        for (let slice of slices) {
            res.into(slice);
        }
        return res;
    }
    equiv(o) {
        if (!(o instanceof AList || isArrayLike(o)) ||
            this._length !== o.length) {
            return false;
        }
        if (!this._length || this === o)
            return true;
        const iter = o[Symbol.iterator]();
        let cell = this._head;
        for (let n = this._length; n-- > 0;) {
            if (!equiv(cell.value, iter.next().value)) {
                return false;
            }
            cell = cell.next;
        }
        return true;
    }
    filter(fn) {
        const res = this.empty();
        this.traverse((x) => (fn(x.value) && res.append(x.value), true));
        return res;
    }
    find(value) {
        return this.traverse((x) => x.value !== value);
    }
    findWith(fn) {
        return this.traverse((x) => !fn(x.value));
    }
    first() {
        return this._head && this._head.value;
    }
    insertSorted(value, cmp) {
        cmp = cmp || compare;
        for (let cell = this._head, n = this._length; n-- > 0;) {
            if (cmp(value, cell.value) <= 0) {
                return this.insertBefore(cell, value);
            }
            cell = cell.next;
        }
        return this.append(value);
    }
    into(src) {
        for (let x of src) {
            this.append(x);
        }
        return this;
    }
    nth(n, notFound) {
        const cell = this.nthCell(n);
        return cell ? cell.value : notFound;
    }
    nthCellUnsafe(n) {
        let cell;
        let dir;
        if (n <= this._length >>> 1) {
            cell = this._head;
            dir = "next";
        }
        else {
            cell = this.tail;
            dir = "prev";
            n = this._length - n - 1;
        }
        while (n-- > 0 && cell) {
            cell = cell[dir];
        }
        return cell;
    }
    peek() {
        return this.tail && this.tail.value;
    }
    /** {@inheritDoc @thi.ng/transducers#IReducible.$reduce} */
    $reduce(rfn, acc) {
        let cell = this._head;
        for (let n = this._length; n-- > 0 && !reduced_isReduced(acc);) {
            acc = rfn(acc, cell.value);
            cell = cell.next;
        }
        return acc;
    }
    reduce(rfn, initial) {
        return this.$reduce(rfn, initial);
    }
    release() {
        let cell = this._head;
        if (!cell)
            return true;
        let next;
        for (let i = this._length; i-- > 0;) {
            next = cell.next;
            delete cell.value;
            delete cell.prev;
            delete cell.next;
            cell = next;
        }
        this._head = undefined;
        this._length = 0;
        return true;
    }
    reverse() {
        let head = this._head;
        let tail = this.tail;
        let n = (this._length >>> 1) + (this._length & 1);
        while (head && tail && n > 0) {
            const t = head.value;
            head.value = tail.value;
            tail.value = t;
            head = head.next;
            tail = tail.prev;
            n--;
        }
        return this;
    }
    setHead(v) {
        const cell = this._head;
        if (cell) {
            cell.value = v;
            return cell;
        }
        return this.prepend(v);
    }
    setNth(n, v) {
        const cell = this.nthCell(n);
        !cell && outOfBounds(n);
        cell.value = v;
        return cell;
    }
    setTail(v) {
        const cell = this.tail;
        if (cell) {
            cell.value = v;
            return cell;
        }
        return this.append(v);
    }
    swap(a, b) {
        if (a !== b) {
            const t = a.value;
            a.value = b.value;
            b.value = t;
        }
        return this;
    }
    toArray(out = []) {
        this.traverse((x) => (out.push(x.value), true));
        return out;
    }
    toJSON() {
        return this.toArray();
    }
    toString() {
        let res = [];
        this.traverse((x) => (res.push(String(x.value)), true));
        return res.join(", ");
    }
    traverse(fn, start = this._head, end) {
        if (!this._head)
            return;
        let cell = start;
        do {
            if (!fn(cell))
                break;
            cell = cell.next;
        } while (cell !== end);
        return cell;
    }
    _map(res, fn) {
        this.traverse((x) => (res.append(fn(x.value)), true));
        return res;
    }
}
function* _iterate(dir, cell) {
    while (cell) {
        yield cell.value;
        cell = cell[dir];
    }
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/dcons/dcons.js





class DCons extends AList {
    get tail() {
        return this._tail;
    }
    append(value) {
        if (this._tail) {
            const cell = { value, prev: this._tail };
            this._tail.next = cell;
            this._tail = cell;
            this._length++;
            return cell;
        }
        else {
            return this.prepend(value);
        }
    }
    asHead(cell) {
        if (cell === this._head) {
            return this;
        }
        this.remove(cell);
        this._head.prev = cell;
        cell.next = this._head;
        cell.prev = undefined;
        this._head = cell;
        this._length++;
        return this;
    }
    asTail(cell) {
        if (cell === this._tail) {
            return this;
        }
        this.remove(cell);
        this._tail.next = cell;
        cell.prev = this._tail;
        cell.next = undefined;
        this._tail = cell;
        this._length++;
        return this;
    }
    /** @deprecated use {@link DCons.prepend} */
    cons(value) {
        this.prepend(value);
        return this;
    }
    copy() {
        return new DCons(this);
    }
    *cycle() {
        while (true) {
            yield* this;
        }
    }
    drop() {
        const cell = this._head;
        if (cell) {
            this._head = cell.next;
            if (this._head) {
                this._head.prev = undefined;
            }
            else {
                this._tail = undefined;
            }
            this._length--;
            return cell.value;
        }
    }
    empty() {
        return new DCons();
    }
    insertAfter(cell, value) {
        const newCell = { value, next: cell.next, prev: cell };
        if (cell.next) {
            cell.next.prev = newCell;
        }
        else {
            this._tail = newCell;
        }
        cell.next = newCell;
        this._length++;
        return newCell;
    }
    insertAfterNth(n, x) {
        if (n < 0) {
            n += this._length;
        }
        if (n >= this._length - 1) {
            return this.append(x);
        }
        else {
            ensureIndex(n, 0, this._length);
            return this.insertAfter(this.nthCellUnsafe(n), x);
        }
    }
    insertBefore(cell, value) {
        const newCell = { value, next: cell, prev: cell.prev };
        if (cell.prev) {
            cell.prev.next = newCell;
        }
        else {
            this._head = newCell;
        }
        cell.prev = newCell;
        this._length++;
        return newCell;
    }
    insertBeforeNth(n, x) {
        if (n < 0) {
            n += this._length;
        }
        if (n <= 0) {
            return this.prepend(x);
        }
        else {
            ensureIndex(n, 0, this._length);
            return this.insertBefore(this.nthCellUnsafe(n), x);
        }
    }
    map(fn) {
        return this._map(new DCons(), fn);
    }
    nth(n, notFound) {
        const cell = this.nthCell(n);
        return cell ? cell.value : notFound;
    }
    nthCell(n) {
        if (n < 0) {
            n += this._length;
        }
        if (n < 0 || n >= this._length) {
            return;
        }
        return this.nthCellUnsafe(n);
    }
    pop() {
        const cell = this._tail;
        if (!cell) {
            return;
        }
        this._tail = cell.prev;
        if (this._tail) {
            this._tail.next = undefined;
        }
        else {
            this._head = undefined;
        }
        this._length--;
        return cell.value;
    }
    prepend(value) {
        const cell = { value, next: this._head };
        if (this._head) {
            this._head.prev = cell;
        }
        else {
            this._tail = cell;
        }
        this._head = cell;
        this._length++;
        return cell;
    }
    push(value) {
        this.append(value);
        return this;
    }
    release() {
        this._tail = undefined;
        return super.release();
    }
    remove(cell) {
        if (cell.prev) {
            cell.prev.next = cell.next;
        }
        else {
            this._head = cell.next;
        }
        if (cell.next) {
            cell.next.prev = cell.prev;
        }
        else {
            this._tail = cell.prev;
        }
        this._length--;
        return this;
    }
    rotateLeft() {
        switch (this._length) {
            case 0:
            case 1:
                return this;
            case 2:
                return this.swap(this._head, this._tail);
            default:
                return this.push(this.drop());
        }
    }
    rotateRight() {
        switch (this._length) {
            case 0:
            case 1:
                return this;
            case 2:
                return this.swap(this._head, this._tail);
            default:
                const x = this.peek();
                this.pop();
                return this.cons(x);
        }
    }
    /** {@inheritDoc @thi.ng/api#ISeqable.seq} */
    seq(start = 0, end = this.length) {
        if (start >= end || start < 0)
            return;
        let cell = this.nthCell(start);
        const last = this.nthCell(end - 1);
        const $seq = (cell) => ({
            first() {
                return cell.value;
            },
            next() {
                return cell !== last && cell.next ? $seq(cell.next) : undefined;
            },
        });
        return cell ? $seq(cell) : undefined;
    }
    /**
     * Shuffles list by probabilistically moving cells to head or tail
     * positions.
     *
     * @remarks
     * Supports configurable iterations and custom PRNG via
     * {@link @thi.ng/random#IRandom} (default:
     * {@link @thi.ng/random#SYSTEM}).
     *
     * Default iterations: `ceil(3/2 * log2(n))`
     *
     * @param iter -
     * @param rnd -
     */
    shuffle(iter, rnd = SYSTEM) {
        if (this._length < 2)
            return this;
        for (iter =
            iter !== undefined
                ? iter
                : Math.ceil(1.5 * Math.log2(this._length)); iter > 0; iter--) {
            let cell = this._head;
            while (cell) {
                const next = cell.next;
                rnd.float() < 0.5 ? this.asHead(cell) : this.asTail(cell);
                cell = next;
            }
        }
        return this;
    }
    slice(from = 0, to = this.length) {
        let a = from < 0 ? from + this._length : from;
        let b = to < 0 ? to + this._length : to;
        if (a < 0 || b < 0) {
            illegalArgs("invalid indices: ${from} / ${to}");
        }
        const res = new DCons();
        let cell = this.nthCell(a);
        while (cell && ++a <= b) {
            res.push(cell.value);
            cell = cell.next;
        }
        return res;
    }
    /**
     * Merge sort implementation based on Simon Tatham's algorithm:
     * https://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
     *
     * @remarks
     * Uses {@link @thi.ng/compare#compare} as default comparator.
     *
     * @param cmp -
     */
    sort(cmp = compare) {
        if (!this._length)
            return this;
        let inSize = 1;
        while (true) {
            let p = this._head;
            this._head = undefined;
            this._tail = undefined;
            let numMerges = 0;
            while (p) {
                numMerges++;
                let q = p;
                let psize = 0;
                for (let i = 0; i < inSize; i++) {
                    psize++;
                    q = q.next;
                    if (!q)
                        break;
                }
                let qsize = inSize;
                while (psize > 0 || (qsize > 0 && q)) {
                    let e;
                    if (psize === 0) {
                        e = q;
                        q = q.next;
                        qsize--;
                    }
                    else if (!q || qsize === 0) {
                        e = p;
                        p = p.next;
                        psize--;
                    }
                    else if (cmp(p.value, q.value) <= 0) {
                        e = p;
                        p = p.next;
                        psize--;
                    }
                    else {
                        e = q;
                        q = q.next;
                        qsize--;
                    }
                    if (this._tail) {
                        this._tail.next = e;
                    }
                    else {
                        this._head = e;
                    }
                    e.prev = this._tail;
                    this._tail = e;
                }
                p = q;
            }
            this._tail.next = undefined;
            if (numMerges <= 1) {
                return this;
            }
            inSize *= 2;
        }
    }
    splice(at, del = 0, insert) {
        let cell;
        if (typeof at === "number") {
            if (at < 0) {
                at += this._length;
            }
            ensureIndex(at, 0, this._length);
            cell = this.nthCellUnsafe(at);
        }
        else {
            cell = at;
        }
        const removed = new DCons();
        if (del > 0) {
            while (cell && del-- > 0) {
                this.remove(cell);
                removed.push(cell.value);
                cell = cell.next;
            }
        }
        else if (cell) {
            cell = cell.next;
        }
        if (insert) {
            if (cell) {
                for (let i of insert) {
                    this.insertBefore(cell, i);
                }
            }
            else {
                for (let i of insert) {
                    this.push(i);
                }
            }
        }
        return removed;
    }
}
/**
 * Functional syntax sugar for `new DCons(src?)`.
 *
 * @param src -
 */
const defDCons = (src) => new DCons(src);
/**
 * @deprecated use {@link defDCons} instead
 */
const dcons = (/* unused pure expression or super */ null && (defDCons));

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/checks/is-iterable.js
const is_iterable_isIterable = (x) => x != null && typeof x[Symbol.iterator] === "function";

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/transducers/compr.js
/**
 * Reducer composition helper, internally used by various transducers
 * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a
 * reducing function `fn`. Returns a new reducer tuple.
 *
 * @remarks
 * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.
 * `fn` accepts values of type `C` and produces interim results of type
 * `B`, which are then (possibly) passed to the "inner" `rfn[2]`
 * function. Therefore the resulting reducer takes inputs of `C` and an
 * accumulator of type `A`.
 *
 * It is assumed that `fn` internally calls `rfn[2]` to pass its own
 * results for further processing by the nested reducer `rfn`.
 *
 * @example
 * ```ts
 * compR(rfn, fn)
 * // [rfn[0], rfn[1], fn]
 * ```
 *
 * @param rfn -
 * @param fn -
 */
const compR = (rfn, fn) => [rfn[0], rfn[1], fn];

// EXTERNAL MODULE: ../../node_modules/@thi.ng/api/api.js
var api = __webpack_require__(70229);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/checks/implements-function.js
const implementsFunction = (x, fn) => x != null && typeof x[fn] === "function";

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/transducers/ensure.js

const ensure_ensureTransducer = (x) => implementsFunction(x, "xform") ? x.xform() : x;

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/transducers/iterator.js





/**
 * Takes a transducer and input iterable. Returns iterator of
 * transformed results.
 *
 * @param xform -
 * @param xs -
 */
function* iterator(xform, xs) {
    const rfn = ensureTransducer(xform)(push());
    const complete = rfn[1];
    const reduce = rfn[2];
    for (let x of xs) {
        const y = reduce([], x);
        if (isReduced(y)) {
            yield* unreduced(complete(y.deref()));
            return;
        }
        if (y.length) {
            yield* y;
        }
    }
    yield* unreduced(complete([]));
}
/**
 * Optimized version of {@link iterator} for transducers which are
 * guaranteed to:
 *
 * 1) Only produce none or a single result per input
 * 2) Do not require a `completion` reduction step
 *
 * @param xform -
 * @param xs -
 */
function* iterator1(xform, xs) {
    const reduce = (ensure_ensureTransducer(xform)([api/* NO_OP */.Jw, api/* NO_OP */.Jw, (_, x) => x]))[2];
    for (let x of xs) {
        let y = reduce(api/* SEMAPHORE */.fL, x);
        if (reduced_isReduced(y)) {
            y = reduced_unreduced(y.deref());
            if (y !== api/* SEMAPHORE */.fL) {
                yield y;
            }
            return;
        }
        if (y !== api/* SEMAPHORE */.fL) {
            yield y;
        }
    }
}
/**
 * Helper function used by various transducers to wrap themselves as
 * transforming iterators. Delegates to {@link iterator1} by default.
 *
 * @param xform -
 * @param args -
 * @param impl -
 *
 * @internal
 */
const __iter = (xform, args, impl = iterator1) => {
    const n = args.length - 1;
    return isIterable(args[n])
        ? args.length > 1
            ? impl(xform.apply(null, args.slice(0, n)), args[n])
            : impl(xform(), args[0])
        : undefined;
};

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/transducers/map.js



function map(fn, src) {
    return is_iterable_isIterable(src)
        ? iterator1(map(fn), src)
        : (rfn) => {
            const r = rfn[2];
            return compR(rfn, (acc, x) => r(acc, fn(x)));
        };
}
/**
 * Convenience wrapper for {@link map} to transform an iterable with given `fn`
 * and immediatedly collect results into an array.
 */
const mapA = (fn, src) => [
    ...map(fn, src),
];

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/cache/lru.js


class LRUCache {
    constructor(pairs, opts) {
        const _opts = Object.assign({
            maxlen: Infinity,
            maxsize: Infinity,
            map: () => new Map(),
            ksize: () => 0,
            vsize: () => 0,
        }, opts);
        this.map = _opts.map();
        this.items = new DCons();
        this._size = 0;
        this.opts = _opts;
        if (pairs) {
            this.into(pairs);
        }
    }
    get length() {
        return this.items.length;
    }
    get size() {
        return this._size;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        return map((e) => [e.k, e], this.items);
    }
    keys() {
        return map((e) => e.k, this.items);
    }
    values() {
        return map((e) => e.v, this.items);
    }
    copy() {
        const c = this.empty();
        c.items = this.items.copy();
        let cell = c.items.head;
        while (cell) {
            c.map.set(cell.value.k, cell);
            cell = cell.next;
        }
        return c;
    }
    empty() {
        return new LRUCache(null, this.opts);
    }
    release() {
        this._size = 0;
        this.map.clear();
        const release = this.opts.release;
        if (release) {
            let e;
            while ((e = this.items.drop())) {
                release(e.k, e.v);
            }
            return true;
        }
        return this.items.release();
    }
    has(key) {
        return this.map.has(key);
    }
    get(key, notFound) {
        const e = this.map.get(key);
        if (e) {
            return this.resetEntry(e);
        }
        return notFound;
    }
    set(key, value) {
        const size = this.opts.ksize(key) + this.opts.vsize(value);
        const e = this.map.get(key);
        this._size += Math.max(0, size - (e ? e.value.s : 0));
        this.ensureSize() && this.doSetEntry(e, key, value, size);
        return value;
    }
    into(pairs) {
        for (let p of pairs) {
            this.set(p[0], p[1]);
        }
        return this;
    }
    getSet(key, retrieve) {
        const e = this.map.get(key);
        if (e) {
            return Promise.resolve(this.resetEntry(e));
        }
        return retrieve().then((v) => this.set(key, v));
    }
    delete(key) {
        const e = this.map.get(key);
        if (e) {
            this.removeEntry(e);
            return true;
        }
        return false;
    }
    resetEntry(e) {
        this.items.asTail(e);
        return e.value.v;
    }
    ensureSize() {
        const release = this.opts.release;
        const maxs = this.opts.maxsize;
        const maxl = this.opts.maxlen;
        while (this._size > maxs || this.length >= maxl) {
            const e = this.items.drop();
            if (!e) {
                return false;
            }
            this.map.delete(e.k);
            release && release(e.k, e.v);
            this._size -= e.s;
        }
        return true;
    }
    removeEntry(e) {
        const ee = e.value;
        this.map.delete(ee.k);
        this.items.remove(e);
        this.opts.release && this.opts.release(ee.k, ee.v);
        this._size -= ee.s;
    }
    doSetEntry(e, k, v, s) {
        if (e) {
            e.value.v = v;
            e.value.s = s;
            this.items.asTail(e);
        }
        else {
            this.items.push({ k, v, s });
            this.map.set(k, this.items.tail);
        }
    }
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/node_modules/@thi.ng/cache/tlru.js

/**
 * Time-aware LRU cache. Extends LRU strategy with TTL (time-to-live)
 * values associated to each entry.
 *
 * @remarks
 * {@link ICache.has} will only return true and {@link ICache.get} only
 * returns a cached value if its TTL hasn't yet expired. When adding a
 * new value to the cache, first removes expired entries and if still
 * not sufficient space then removes entries in LRU order.
 *
 * {@link ICache.set} takes an optional entry specific `ttl` arg. If not
 * given, uses the cache instance's default (provided via ctor option
 * arg). If no instance TTL is given, TTL defaults to 1 hour.
 */
class TLRUCache extends LRUCache {
    constructor(pairs, opts) {
        opts = Object.assign({ ttl: 60 * 60 * 1000 }, opts);
        super(pairs, opts);
    }
    empty() {
        return new TLRUCache(null, this.opts);
    }
    has(key) {
        return this.get(key) !== undefined;
    }
    get(key, notFound) {
        const e = this.map.get(key);
        if (e) {
            if (e.value.t >= Date.now()) {
                return this.resetEntry(e);
            }
            this.removeEntry(e);
        }
        return notFound;
    }
    set(key, value, ttl = this.opts.ttl) {
        const size = this.opts.ksize(key) + this.opts.vsize(value);
        const e = this.map.get(key);
        this._size += Math.max(0, size - (e ? e.value.s : 0));
        if (this.ensureSize()) {
            const t = Date.now() + ttl;
            if (e) {
                e.value.v = value;
                e.value.s = size;
                e.value.t = t;
                this.items.asTail(e);
            }
            else {
                this.items.push({
                    k: key,
                    v: value,
                    s: size,
                    t,
                });
                this.map.set(key, this.items.tail);
            }
        }
        return value;
    }
    getSet(key, retrieve, ttl = this.opts.ttl) {
        const e = this.get(key);
        if (e) {
            return Promise.resolve(e);
        }
        return retrieve().then((v) => this.set(key, v, ttl));
    }
    prune() {
        const now = Date.now();
        let cell = this.items.head;
        while (cell) {
            if (cell.value.t < now) {
                this.removeEntry(cell);
            }
            cell = cell.next;
        }
    }
    ensureSize() {
        const maxs = this.opts.maxsize;
        const maxl = this.opts.maxlen;
        const now = Date.now();
        let cell = this.items.head;
        while (cell && (this._size > maxs || this.length >= maxl)) {
            if (cell.value.t < now) {
                this.removeEntry(cell);
            }
            cell = cell.next;
        }
        return super.ensureSize();
    }
}

;// CONCATENATED MODULE: ../../packages/rpcs/wallet_refetchTxList/index.js






const tlruCache = new TLRUCache(null, {ttl: 300000}) // 5 min

const NAME = 'wallet_refetchTxList'

const schemas = {
  input: spec.optParam,
}

const permissions = {
  external: ['popup'],
  locked: true,
  methods: [
    'cfx_getTransactionReceipt',
    'eth_getTransactionReceipt',
    'wallet_getNextNonce',
    'wallet_getBlockOrEpochNumber',
    'wallet_enrichConfluxTx',
    'wallet_enrichEthereumTx',
  ],
  db: ['queryNonceGapTxs', 'getOneNetwork', 'getAddress', 'insertExternalTx'],
}

async function eachTx(
  addr,
  tx,
  {
    db: {insertExternalTx},
    rpcs: {
      wallet_enrichEthereumTx,
      wallet_enrichConfluxTx,
      cfx_getTransactionReceipt,
      eth_getTransactionReceipt,
    },
  },
) {
  const {payload, extra, ...restTx} = tx
  let {receipt} = tx

  if (addr.network.type === 'cfx') {
    const {
      blockHash,
      index,
      epochNumber,
      gasUsed,
      gasFee,
      storageCollateralized,
      gasCoveredBySponsor,
      storageCoveredBySponsor,
      txExecErrorMsg,
    } = await cfx_getTransactionReceipt(
      {networkName: addr.network.name, errorFallThrough: true},
      [tx.hash],
    )
    if (txExecErrorMsg) restTx.err = txExecErrorMsg

    receipt = {
      ...receipt,
      blockHash,
      index,
      epochNumber,
      gasUsed,
      gasFee,
      storageCollateralized,
      gasCoveredBySponsor,
      storageCoveredBySponsor,
    }
  } else {
    const {
      type,
      blockHash,
      transactionIndex,
      blockNumber,
      gasUsed,
      cumulativeGasUsed,
      effectiveGasPrice,
      txExecErrorMsg,
    } = await eth_getTransactionReceipt(
      {networkName: addr.network.name, errorFallThrough: true},
      [tx.hash],
    )
    restTx.type = type || '0x0'
    if (txExecErrorMsg) restTx.err = txExecErrorMsg
    receipt = {
      ...receipt,
      cumulativeGasUsed,
      effectiveGasPrice,
      type: type || '0x0',
      blockHash,
      transactionIndex,
      blockNumber,
      gasUsed,
    }
  }

  insertExternalTx({tx: restTx, receipt, payload, extra, addressId: addr.eid})

  if (addr.network.type === 'cfx')
    await wallet_enrichConfluxTx({txhash: restTx.hash})
  else await wallet_enrichEthereumTx({txhash: restTx.hash})
}

async function eachGap([[, block1], [, block2]], addr, args) {
  const {
    rpcs: {wallet_getBlockOrEpochNumber},
  } = args
  if (block2 === 'latest')
    block2 = await wallet_getBlockOrEpochNumber(
      {errorFallThrough: true, networkName: addr.network.name},
      [],
    )
  if (!block2) return
  const txs = await transaction({
    chainId: addr.network.chainId,
    networkId: addr.network.netId,
    address: addr.value,
    startblock: parseInt(block1, 16),
    endblock: parseInt(block2, 16),
  })
  txs?.list.forEach(tx => eachTx(addr, tx, args))
}

function eachAddress(addr, args) {
  // cache for 5 minutes for each addressId
  const eachAddress1 = memoize1(async addressId => {
    if (!addr.tx?.length) return
    const {
      rpcs: {wallet_getNextNonce},
      db: {queryNonceGapTxs},
    } = args

    try {
      const nonce = await wallet_getNextNonce(
        {
          network: addr.network,
          networkName: addr.network.name,
          errorFallThrough: true,
        },
        [addr.value],
      )
      const gaps = queryNonceGapTxs({addressId, nextNonce: nonce})
      if (gaps) {
        for (const gap of gaps) {
          await eachGap(gap, addr, args)
        }
      }
    } catch (err) {
      console.error(err)
    }
  }, tlruCache)
  return eachAddress1(addr.eid)
}

async function eachNetwork(network, args) {
  const {
    db: {getAddress},
  } = args
  const addrs = getAddress({network: network.eid})
  for (const addr of addrs) {
    await eachAddress(addr, args)
  }
}

async function main1(args) {
  const {
    db: {getOneNetwork},
  } = args
  const networks = [
    getOneNetwork({type: 'eth', netId: consts/* CFX_ESPACE_MAINNET_NETID */.Ne}),
    getOneNetwork({type: 'cfx', netId: consts/* CFX_MAINNET_NETID */.sU}),
    getOneNetwork({type: 'eth', netId: consts/* CFX_ESPACE_TESTNET_NETID */.sB}),
    getOneNetwork({type: 'cfx', netId: consts/* CFX_TESTNET_NETID */.mO}),
  ]
  for (const network of networks) {
    await eachNetwork(network, args)
  }
}

const main = args => {
  try {
    main1(args)
  } catch (err) {} // eslint-disable-line no-empty
  return
}


/***/ }),

/***/ 78008:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_registerSiteMetadata'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['name', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
    ['icon', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.url],
  ],
}

const permissions = {
  external: ['inpage'],
  locked: true,
  methods: ['wallet_requestPermissions', 'wallet_getPreferences'],
  db: ['t', 'findAccount'],
  scope: null,
}

const main = ({
  Err: {InvalidRequest},
  db: {t, findAccount},
  rpcs: {wallet_requestPermissions, wallet_getPreferences},
  params: {name, icon},
  _inpage,
  _origin,
  _post,
  network,
}) => {
  if (_inpage && !_origin) throw InvalidRequest(`no origin found`)
  const {tempids} = t([
    {eid: 'newsite', site: {name, origin: _origin, post: _post}},
    icon && {eid: 'newsite', site: {icon}},
  ])

  wallet_getPreferences().then(p => {
    const {overrideWindowDotEthereum} = p
    return _post({
      event: '__FLUENT_BACKEND_PREFERENCES__',
      params: {
        overrideWindowDotEthereum,
      },
    })
  })

  _post({
    event: 'connect',
    params: {chainId: network.chainId, networkId: network.netId},
  })

  // auto authed app
  // x.fluentwallet.com
  // x-x.fluentwallet.com
  // x.x.fluentwallet.com
  if (
    tempids.newsite &&
    (/^[a-zA-Z0-9-]+\.fluentwallet\.com$/.test(_origin) ||
      /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+\.fluentwallet\.com$/.test(_origin))
  ) {
    wallet_requestPermissions(
      {_popup: true, network},
      {
        siteId: tempids.newsite,
        permissions: [{wallet_accounts: {}}],
        accounts: findAccount(),
      },
    )
  }

  return
}


/***/ }),

/***/ 52894:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_requestAccounts'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['inpage'],
  locked: true,
  methods: ['cfx_requestAccounts', 'eth_requestAccounts'],
  db: [],
}

const main = ({
  rpcs: {cfx_requestAccounts, eth_requestAccounts},
  network: {type},
}) => {
  if (type === 'cfx') return cfx_requestAccounts()
  return eth_requestAccounts()
}


/***/ }),

/***/ 97721:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ wallet_requestPermissions_permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
;// CONCATENATED MODULE: ../../packages/wallet-permission/permissions.js
/* harmony default export */ const permissions = ({// basic rpc methods like cfx_epochNumber, eth_blockNumber
wallet_basic:{},// methods
// to get user addresses like eth_accounts, cfx_accounts
// to request user's signature of these accounts, eg. cfx_sendTransaction, eth_signTypedData_v4
wallet_accounts:{},cfx_accounts:{},eth_accounts:{},// methods to about networks
// eg. wallet_addEthereumChain, wallet_switchConfluxChain
// wallet_networks: {},
wallet_crossNetworkTypeGetConfluxBase32Address:{},wallet_crossNetworkTypeGetEthereumHexAddress:{}});
;// CONCATENATED MODULE: ../../packages/wallet-permission/docs.js
/* harmony default export */ const docs = ({wallet_basic:{en:'permission for basic rpc methods that do not request user address or signature, eg. cfx_epochNumber, eth_blockNumber, wallet_generatePrivateKey, this permission is added by default'},wallet_accounts:{en:'permission for methods that need user address or signature, eg. cfx_sendTransaction, eth_signTypedData_v4'},cfx_accounts:{en:'alias for wallet_account'},eth_accounts:{en:'alias for wallet_account'},wallet_crossNetworkTypeGetConfluxBase32Address:{en:"permission for methods need user's Conflux core space mainnet address on other network"},wallet_crossNetworkTypeGetEthereumHexAddress:{en:"permission for methods need user's Ethereum type address (hex address) on other(Conflux core) network"}// wallet_networks: {
//   en: 'permission for methods related to network change, eg. wallet_switchEthereumChain, wallet_switchConfluxChain, this permission is added by default',
// },
});
;// CONCATENATED MODULE: ../../packages/wallet-permission/index.js
const generateSchema=spec=>{var _docs$wallet_basic,_docs$wallet_crossNet,_docs$wallet_crossNet2,_docs$cfx_accounts,_docs$eth_accounts,_docs$wallet_accounts,_docs$cfx_accounts2,_docs$eth_accounts2,_docs$wallet_accounts2,_docs$cfx_accounts3,_docs$eth_accounts3,_docs$wallet_accounts3;const{mapp,map,and,empty,or}=spec;const emptyMap=[and,mapp,empty];// prettier-ignore
const base=[map,{closed:true},['wallet_basic',{optional:true,doc:((_docs$wallet_basic=docs.wallet_basic)===null||_docs$wallet_basic===void 0?void 0:_docs$wallet_basic.en)||`wallet_basic wallet permission`},emptyMap],['wallet_crossNetworkTypeGetConfluxBase32Address',{optional:true,doc:((_docs$wallet_crossNet=docs.wallet_crossNetworkTypeGetConfluxBase32Address)===null||_docs$wallet_crossNet===void 0?void 0:_docs$wallet_crossNet.en)||`wallet_crossNetworkTypeGetConfluxBase32Address wallet permission`},emptyMap],['wallet_crossNetworkTypeGetEthereumHexAddress',{optional:true,doc:((_docs$wallet_crossNet2=docs.wallet_crossNetworkTypeGetEthereumHexAddress)===null||_docs$wallet_crossNet2===void 0?void 0:_docs$wallet_crossNet2.en)||`wallet_crossNetworkTypeGetEthereumHexAddress wallet permission`},emptyMap]];// prettier-ignore
return[or,[...base,['cfx_accounts',{doc:((_docs$cfx_accounts=docs.cfx_accounts)===null||_docs$cfx_accounts===void 0?void 0:_docs$cfx_accounts.en)||`cfx_accounts wallet permission`},emptyMap],['eth_accounts',{optional:true,doc:((_docs$eth_accounts=docs.eth_accounts)===null||_docs$eth_accounts===void 0?void 0:_docs$eth_accounts.en)||`eth_accounts wallet permission`},emptyMap],['wallet_accounts',{optional:true,doc:((_docs$wallet_accounts=docs.wallet_accounts)===null||_docs$wallet_accounts===void 0?void 0:_docs$wallet_accounts.en)||`wallet_accounts wallet permission`},emptyMap]],[...base,['cfx_accounts',{optional:true,doc:((_docs$cfx_accounts2=docs.cfx_accounts)===null||_docs$cfx_accounts2===void 0?void 0:_docs$cfx_accounts2.en)||`cfx_accounts wallet permission`},emptyMap],['eth_accounts',{doc:((_docs$eth_accounts2=docs.eth_accounts)===null||_docs$eth_accounts2===void 0?void 0:_docs$eth_accounts2.en)||`eth_accounts wallet permission`},emptyMap],['wallet_accounts',{optional:true,doc:((_docs$wallet_accounts2=docs.wallet_accounts)===null||_docs$wallet_accounts2===void 0?void 0:_docs$wallet_accounts2.en)||`wallet_accounts wallet permission`},emptyMap]],[...base,['cfx_accounts',{optional:true,doc:((_docs$cfx_accounts3=docs.cfx_accounts)===null||_docs$cfx_accounts3===void 0?void 0:_docs$cfx_accounts3.en)||`cfx_accounts wallet permission`},emptyMap],['eth_accounts',{optional:true,doc:((_docs$eth_accounts3=docs.eth_accounts)===null||_docs$eth_accounts3===void 0?void 0:_docs$eth_accounts3.en)||`eth_accounts wallet permission`},emptyMap],['wallet_accounts',{doc:((_docs$wallet_accounts3=docs.wallet_accounts)===null||_docs$wallet_accounts3===void 0?void 0:_docs$wallet_accounts3.en)||`wallet_accounts wallet permission`},emptyMap]]];};/* harmony default export */ const wallet_permission = ((/* unused pure expression or super */ null && (perms)));
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_requestPermissions/index.js



const {map, dbid, or, zeroOrMore, oneOrMore} = spec

const NAME = 'wallet_requestPermissions'

const permissionSchema = generateSchema(spec)
const publicSchema = [oneOrMore, permissionSchema]

const responseToAppAuthSchema = [
  map,
  {closed: true, doc: 'used to approve/reject the request'},
  ['authReqId', dbid],
  ['permissions', publicSchema],
  ['accounts', [zeroOrMore, dbid]],
]
const authWithinWalletSchema = [
  map,
  {closed: true, doc: 'used to grant permissions to app from wallet'},
  ['siteId', dbid],
  ['permissions', publicSchema],
  ['accounts', [oneOrMore, dbid]],
]
const innerSchema = [or, responseToAppAuthSchema, authWithinWalletSchema]

const schemas = {
  input: [or, publicSchema, innerSchema],
}

const wallet_requestPermissions_permissions = {
  external: ['inpage', 'popup'],
  methods: [
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_userRejectedAuthRequest',
    'wallet_getPermissions',
  ],
  db: [
    'findApp',
    'findAddress',
    'findAccount',
    'upsertAppPermissions',
    'getSiteById',
    'getOneSite',
    'getAuthReqById',
  ],
  scope: null,
}

const formatPermissions = perms => {
  return perms.map(p =>
    Object.keys(p).reduce(
      (p, key) => {
        if (key === 'cfx_accounts' || key === 'eth_accounts')
          key = 'wallet_accounts'
        return {...p, [key]: {}}
      },
      {wallet_basic: {}},
    ),
  )
}

const main = async ({
  Err: {InvalidRequest, InvalidParams},
  db: {
    findAccount,
    upsertAppPermissions,
    getAuthReqById,
    getSiteById,
    findApp,
    findAddress,
  },
  rpcs: {
    wallet_getPermissions,
    wallet_addPendingUserAuthRequest,
    wallet_userApprovedAuthRequest,
    wallet_userRejectedAuthRequest,
  },
  network,
  params,
  _popup,
  _internal,
  _inpage,
  _origin,
  site,
  app,
}) => {
  if ((_inpage || _internal) && !_origin && !_popup)
    throw InvalidRequest(`no origin found`)

  // called from inpage
  if ((_inpage || _internal) && !_popup) {
    const perms = formatPermissions(params)
    if (app && JSON.stringify(app.perms) === JSON.stringify(perms))
      return app.perms

    const req = {
      method: NAME,
      params: perms,
    }

    const rst = await wallet_addPendingUserAuthRequest({siteId: site.eid, req})

    return rst
  }

  // called from popup
  // 1. confirm app permission request (authReqId is defined)
  // 2. alter/revoke permissions (authReqId is undefined)
  if (_popup) {
    if (params.siteId && !params.accounts.length)
      throw InvalidParams('Must have at least 1 accounts')

    const {authReqId, permissions} = params

    let siteId = params.siteId

    if (authReqId) {
      const authReq = getAuthReqById(authReqId)
      if (!authReq) throw InvalidParams(`Invalid auth req id ${authReqId}`)
      if (!params.accounts.length)
        return await wallet_userRejectedAuthRequest({authReqId})

      siteId = authReq.site.eid
    }

    if (siteId && !getSiteById(siteId))
      throw InvalidParams(`Invalid site id ${siteId}`)

    const accounts = params.accounts.map(accountId => findAccount({accountId}))

    for (let i = 0; i < accounts.length; i++) {
      if (!accounts[i])
        throw InvalidParams(`Invalid account id ${params.accounts[i]}`)
    }

    let [currentAccount] = findAccount({selected: true})
    if (!accounts.includes(currentAccount)) currentAccount = accounts[0]

    const perms = formatPermissions(permissions)
    const {
      app: newPermApp,
      newlyCreated,
      accountsChanged,
    } = upsertAppPermissions({
      siteId,
      accounts,
      currentAccount,
      currentNetwork: network.eid,
      perms: perms[0],
    })

    if (newlyCreated || accountsChanged) {
      app = findApp({
        siteId,
        g: {
          eid: 1,
          currentAccount: {eid: 1},
          site: {post: 1},
          currentNetwork: {eid: 1},
        },
      })
      if (app?.site?.post) {
        const addr = findAddress({
          appId: app.eid,
          g: {value: 1},
        })
        if (addr)
          app.site.post({event: 'accountsChanged', params: [addr.value]})
      }
    }

    if (authReqId)
      return await wallet_userApprovedAuthRequest({
        authReqId,
        res: await wallet_getPermissions({app: newPermApp}, []),
      })
    else {
      if (app) return await wallet_getPermissions({app: newPermApp}, [])
    }
  }
}


/***/ }),

/***/ 2031:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75321);



const NAME = 'wallet_requestUnlockUI'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  locked: true,
  db: ['getLocked', 't', 'getUnlockReq', 'retract'],
}

async function requestUnlockUI({
  Err: {Internal},
  db: {getLocked, getUnlockReq, retract},
  MODE,
}) {
  if (!window) throw Internal('Invalid running env, window is not defined')
  const {browser, popup} = await __webpack_require__.e(/* import() */ 258).then(__webpack_require__.bind(__webpack_require__, 40258))
  const w = await popup.show({
    alwaysOnTop: MODE.isProd ? true : false,
    mode: MODE,
  })

  if (MODE.isProd)
    setTimeout(() => popup.onFocusChanged(w?.id, popup.remove), 500)
  function windowOnRemovedListener() {
    browser.windows.onRemoved.removeListener(windowOnRemovedListener)
    if (!getLocked()) return
    const unlockReqs = getUnlockReq() || []
    unlockReqs.forEach(({eid, req}) =>
      req.write(false).then(() => retract(eid)),
    )
  }

  popup.onRemoved(w?.id, windowOnRemovedListener)
}

const main = async args => {
  const {
    Err: {UserRejected},
    db: {getLocked, getUnlockReq, t},
  } = args
  if (!getLocked()) return
  const unlockReqs = getUnlockReq()

  let unlocked = false
  if (unlockReqs.length) {
    unlocked = await unlockReqs[0].read()
  } else {
    const c = (0,_fluent_wallet_csp__WEBPACK_IMPORTED_MODULE_1__/* .chan */ .zH)(1)
    t([{unlockReq: {req: c}}])
    requestUnlockUI(args)
    unlocked = await c.read()
  }

  if (unlocked) return
  throw UserRejected()
}


/***/ }),

/***/ 64601:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NAME": () => (/* binding */ NAME),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
// EXTERNAL MODULE: ../../packages/rpcs/cfx_sendTransaction/index.js
var cfx_sendTransaction = __webpack_require__(78762);
// EXTERNAL MODULE: ../../packages/rpcs/eth_sendTransaction/index.js
var eth_sendTransaction = __webpack_require__(81316);
// EXTERNAL MODULE: ../../packages/signature/index.js + 15 modules
var signature = __webpack_require__(52206);
;// CONCATENATED MODULE: ../../packages/errors/index.js
/**
 * @fileOverview extends @thi.ng/errors
 * @name index.js
 */const errors_defRpcError=(prefix,suffix=msg=>msg!==undefined?': '+msg:'')=>class extends Error{constructor(msg,rpcData){super(prefix(msg)+suffix(msg));this.rpcData=rpcData;}};
;// CONCATENATED MODULE: ../../packages/json-rpc-error/index.js
const errorStackPop=error=>{if(error!==null&&error!==void 0&&error.stack){const stack=error.stack.split('\n');error.stack=stack.reduce(([s,poped],line)=>{if(!poped&&/^\s*at\s.*\..*:\d+\)?$/.test(line))return[s,true];if(/@thi\.ng/.test(line))return[s,poped];return[s+'\n'+line];},[''])[0];}};const ERROR={PARSE:{code:-32700,name:'ParseError'},INVALID_REQUEST:{code:-32600,name:'InvalidRequest'},METHOD_NOT_FOUND:{code:-32601,name:'MethodNotFound'},INVALID_PARAMS:{code:-32602,name:'InvalidParams'},INTERNAL:{code:-32603,name:'InternalError'},SERVER:{code:-32000,name:'ServerError'},// provider errors https://eips.ethereum.org/EIPS/eip-1193#errors
USER_REJECTED:{code:4001,name:'UserRejected'},UNAUTHORIZED:{code:4100,name:'Unauthorized'},UNSUPPORTED_METHOD:{code:4200,name:'UnsupportedMethod'},// disconnected from all chain
DISCONNECTED:{code:4900,name:'Disconnected'},// disconnected from requested chain
CHAIN_DISCONNECTED:{code:4901,name:'Chain Disconnected'},UNRECOGNIZED_CHAIN_ID:{code:4902,name:'Unrecognized chain ID'}};const Parse=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.PARSE.name} ${ERROR.PARSE.code}]\n`);const InvalidRequest=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.INVALID_REQUEST.name} ${ERROR.INVALID_REQUEST.code}]\n`);const MethodNotFound=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.METHOD_NOT_FOUND.name} ${ERROR.METHOD_NOT_FOUND.code}]\n`);const InvalidParams=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.INVALID_PARAMS.name} ${ERROR.INVALID_PARAMS.code}]\n`);const Internal=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.INTERNAL.name} ${ERROR.INTERNAL.code}]\n`);const Server=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.SERVER.name} ${ERROR.SERVER.code}]\n`);const UserRejected=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.USER_REJECTED.name} ${ERROR.USER_REJECTED.code}]\n`);const Unauthorized=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.UNAUTHORIZED.name} ${ERROR.UNAUTHORIZED.code}]\n`);const UnsupportedMethod=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.UNSUPPORTED_METHOD.name} ${ERROR.UNSUPPORTED_METHOD.code}]\n`);const Disconnected=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.DISCONNECTED.name} ${ERROR.DISCONNECTED.code}]\n`);const ChainDisconnected=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.CHAIN_DISCONNECTED.name} ${ERROR.CHAIN_DISCONNECTED.code}]\n`);const UnrecognizedChainId=errors_defRpcError(()=>``,msg=>`${msg} [${ERROR.UNRECOGNIZED_CHAIN_ID.name} ${ERROR.UNRECOGNIZED_CHAIN_ID.code}]\n`);const errorInstanceToErrorCode=instance=>{if(instance instanceof Parse)return ERROR.PARSE.code;if(instance instanceof InvalidRequest)return ERROR.INVALID_REQUEST.code;if(instance instanceof MethodNotFound)return ERROR.METHOD_NOT_FOUND.code;if(instance instanceof InvalidParams)return ERROR.INVALID_PARAMS.code;if(instance instanceof Internal)return ERROR.INTERNAL.code;if(instance instanceof Server)return ERROR.SERVER.code;if(instance instanceof UserRejected)return ERROR.USER_REJECTED.code;if(instance instanceof Unauthorized)return ERROR.UNAUTHORIZED.code;if(instance instanceof UnsupportedMethod)return ERROR.UNSUPPORTED_METHOD.code;if(instance instanceof Disconnected)return ERROR.DISCONNECTED.code;if(instance instanceof ChainDisconnected)return ERROR.CHAIN_DISCONNECTED.code;if(instance instanceof UnrecognizedChainId)return ERROR.UNRECOGNIZED_CHAIN_ID.code;if(!(instance!==null&&instance!==void 0&&instance.code))return-32000;if(instance.code>=-32099&&instance.code<=-32000)return instance.code;return-32000;};const guessErrorType=err=>{if(!(err!==null&&err!==void 0&&err.code))return Internal;if(err!==null&&err!==void 0&&err.code){if(err.code>=-32099&&err.code<=-32000)return defRpcError(()=>``,msg=>`${msg} [${ERROR.SERVER.name} ${err.code}]\n`);if(err.code===ERROR.PARSE.code)return Parse;if(err.code===ERROR.INVALID_REQUEST.code)return InvalidRequest;if(err.code===ERROR.METHOD_NOT_FOUND.code)return MethodNotFound;if(err.code===ERROR.INVALID_PARAMS.code)return InvalidParams;if(err.code===ERROR.INTERNAL.code)return Internal;if(err.code===ERROR.SERVER.code)return Server;if(err.code===ERROR.USER_REJECTED)return UserRejected;if(err.code===ERROR.UNAUTHORIZED.code)return Unauthorized;if(err.code===ERROR.UNSUPPORTED_METHOD)return UnsupportedMethod;if(err.code===ERROR.DISCONNECTED)return Disconnected;if(err.code===ERROR.CHAIN_DISCON)return ChainDisconnected;}return Internal;};const parseError=(err,prefix='',suffix='')=>{const C=guessErrorType(err);let errmsg=prefix;if(err!==null&&err!==void 0&&err.message)errmsg=errmsg+err.message;if(err!==null&&err!==void 0&&err.data)errmsg=errmsg+' - '+err.data;errmsg=errmsg+suffix;const error=new C(errmsg);error.code=(err===null||err===void 0?void 0:err.code)||error.code;error.data=(err===null||err===void 0?void 0:err.data)||error.data;return error;};
// EXTERNAL MODULE: ../../packages/consts/index.js
var consts = __webpack_require__(9414);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var bignumber = __webpack_require__(10528);
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_sendTransaction/index.js









const NAME = 'wallet_sendTransaction'

const schemas = {
  input: [spec.or, cfx_sendTransaction.schemas.input, eth_sendTransaction.schemas.input],
}

const permissions = {
  external: ['popup', 'inpage'],
  methods: [
    'cfx_signTransaction',
    'eth_signTransaction',
    'eth_blockNumber',
    'cfx_gasPrice',
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_userRejectedAuthRequest',
    'wallet_handleUnfinishedCFXTx',
    'wallet_handleUnfinishedETHTx',
    'wallet_enrichConfluxTx',
    'wallet_enrichEthereumTx',
  ],
  db: ['findAddress', 'getAuthReqById', 'getAddrTxByHash', 't'],
}

const main = async ({
  Err: {InvalidParams, Server},
  db: {findAddress, getAuthReqById, getAddrTxByHash, t},
  rpcs: {
    wallet_userRejectedAuthRequest,
    wallet_enrichConfluxTx,
    wallet_enrichEthereumTx,
    eth_blockNumber,
    cfx_gasPrice,
    cfx_signTransaction,
    eth_signTransaction,
    wallet_addPendingUserAuthRequest,
    wallet_userApprovedAuthRequest,
    wallet_handleUnfinishedCFXTx,
    wallet_handleUnfinishedETHTx,
  },
  params,
  _inpage,
  _popup,
  _sendAction,
  app,
  network,
}) => {
  let handleUnfinishedTxFn, signTxFn, enrichTxFn
  if (network.type === 'cfx') {
    handleUnfinishedTxFn = wallet_handleUnfinishedCFXTx
    signTxFn = cfx_signTransaction
    enrichTxFn = wallet_enrichConfluxTx
  } else {
    handleUnfinishedTxFn = wallet_handleUnfinishedETHTx
    signTxFn = eth_signTransaction
    enrichTxFn = wallet_enrichEthereumTx
  }

  if (_inpage) {
    if (params.authReqId) throw InvalidParams('Invalid tx data')
    if (params[0].gasLimit) {
      if (!params[0].gas) params[0].gas = params[0].gasLimit
      delete params[0].gasLimit
    }

    if (params[0].gas && bignumber/* BigNumber.from */.O$.from(params[0].gas).lt(21000)) {
      params[0].gas = '0x5208'
    }

    const [{from}] = params

    // check that from address is authed to the app
    if (
      !findAddress({
        value: from,
        appId: app.eid,
      })
    )
      throw InvalidParams(`Invalid from address in tx ${from}`)

    delete params[0].nonce
    if (params[0].type === consts/* ETH_TX_TYPES.EIP1559 */.Pp.EIP1559 && params[0].gasPrice) {
      delete params[0].gasPrice
    }
    try {
      // try sign tx
      await signTxFn(
        {app, network: app.currentNetwork, errorFallThrough: true},
        [...params, {dryRun: true}],
      )
    } catch (err) {
      if (err?.code === ERROR.USER_REJECTED.code) throw err
      if (!err?.data?.estimateError) {
        err.message = `Error while processing tx.\nparams:\n${JSON.stringify(
          params,
          null,
          2,
        )}\nerror:\n${err.message}`

        throw err
      }
    }

    if (
      network.type === 'cfx' &&
      app.currentNetwork.name === consts/* CFX_MAINNET_NAME */.ae
    ) {
      try {
        const gasPrice = await cfx_gasPrice({errorFallThrough: true}, [])
        if (
          bignumber/* BigNumber.from */.O$.from(gasPrice).gt(
            bignumber/* BigNumber.from */.O$.from(params[0].gasPrice || '0x0'),
          )
        ) {
          params[0].gasPrice = gasPrice
        }
      } catch (err) {} // eslint-disable-line no-empty
    }

    return await wallet_addPendingUserAuthRequest({
      appId: app.eid,
      req: {method: NAME, accountId: app.currentAccount.eid, params},
    })
  }

  const authReqId = params?.authReqId
  let authReq
  if (authReqId) {
    authReq = getAuthReqById(authReqId)
    if (!authReq) throw InvalidParams(`Invalid authReqId ${authReqId}`)
    if (authReq.processed)
      throw InvalidParams(`Already processing auth req ${authReqId}`)
    t({eid: authReqId, authReq: {processed: true}})
  }

  // tx array [tx]
  const tx = params.authReqId ? params.tx : params
  if (tx[0].gasLimit) {
    if (!tx[0].gas) tx[0].gas = tx[0].gasLimit
    delete tx[0].gasLimit
  }
  const addr = findAddress({
    // filter by app.currentNetwork and app.currentAccount
    appId: authReq?.app?.eid,
    selected: !authReqId ? true : undefined,
    // filter by current network
    networkId: !authReqId ? network.eid : authReq.app.currentNetwork.eid,
    value: tx[0].from,
  })
  if (!addr) throw InvalidParams(`Invalid from address ${tx[0].from}`)

  let signed
  try {
    signed = await signTxFn(
      {
        app: authReqId ? authReq.app : undefined,
        network: authReqId ? authReq.app.currentNetwork : network,
        errorFallThrough: true,
      },
      tx.concat({
        returnTxMeta: true,
      }),
    )
  } catch (err) {
    if (authReqId) await wallet_userRejectedAuthRequest({authReqId})
    throw err
  }

  if (!signed) {
    if (authReqId) await wallet_userRejectedAuthRequest({authReqId})
    throw Server(`Server error while signning tx`)
  }
  const {raw: rawtx, txMeta} = signed
  const txhash = (0,signature/* getTxHashFromRawTx */.PV)(rawtx)
  const duptx = getAddrTxByHash({addressId: addr, txhash})

  if (duptx) {
    if (authReqId) await wallet_userRejectedAuthRequest({authReqId})
    throw InvalidParams('duplicate tx')
  }

  const blockNumber =
    network.type === 'eth' &&
    (await eth_blockNumber({errorFallThrough: true}, []))
  const txExtra = {ok: false}
  if (_popup && _sendAction) txExtra.sendAction = _sendAction
  const dbtxs = [
    {eid: 'newTxPayload', txPayload: txMeta},
    {eid: 'newTxExtra', txExtra},
    {
      eid: 'newTxId',
      tx: {
        fromFluent: true,
        txPayload: 'newTxPayload',
        hash: txhash,
        raw: rawtx,
        status: 0,
        created: new Date().getTime(),
        txExtra: 'newTxExtra',
      },
    },
    blockNumber && {eid: 'newTxId', tx: {blockNumber}},
    {eid: addr, address: {tx: 'newTxId'}},
    authReqId && {eid: authReq.app.eid, app: {tx: 'newTxId'}},
  ]
  const {
    tempids: {newTxId},
  } = t(dbtxs)

  try {
    enrichTxFn(
      {
        errorFallThrough: true,
        network: authReqId ? authReq.app.currentNetwork : network,
      },
      {txhash},
    )

    // eslint-disable-next-line no-empty
  } catch (err) {}
  return await new Promise((resolve, reject) => {
    handleUnfinishedTxFn(
      {network: authReqId ? authReq.app.currentNetwork : network},
      {
        tx: newTxId,
        address: addr,
        okCb: rst => {
          if (params.authReqId) {
            return wallet_userApprovedAuthRequest({
              authReqId: params.authReqId,
              res: rst,
            }).then(resolve)
          }
          resolve(rst)
        },
        failedCb: err => {
          if (params.authReqId) {
            return wallet_userApprovedAuthRequest({
              authReqId: params.authReqId,
              res: err,
            }).then(resolve)
          }
          reject(err)
        },
      },
    )
  })
}


/***/ }),

/***/ 90688:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_wallet_send_transaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64601);




const NAME = 'wallet_sendTransactionWithAction'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['tx', _fluent_wallet_wallet_send_transaction__WEBPACK_IMPORTED_MODULE_1__.schemas.input],
    ['action', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'cancel', 'speedup']],
  ],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_sendTransaction'],
}

const main = ({
  rpcs: {wallet_sendTransaction},
  params: {action, tx},
}) => {
  return wallet_sendTransaction({_sendAction: action}, tx)
}


/***/ }),

/***/ 56831:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_setAppCurrentAccount'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['appId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  external: ['popup'],
  db: ['getAccountById', 'getAppById', 't', 'accountAddrByNetwork'],
}

const main = ({
  Err: {InvalidParams},
  db: {getAccountById, t, accountAddrByNetwork, getAppById},
  params: {accountId, appId},
}) => {
  const account = getAccountById(accountId)
  if (!account) throw InvalidParams(`Invalid accountId ${accountId}`)
  const app = getAppById(appId)
  if (!app) throw InvalidParams(`Invalid app id ${appId}`)
  if (!app.account || !app.account.map(({eid}) => eid).includes(accountId))
    throw InvalidParams(
      `Account ${accountId} not authorized for app ${app.eid}`,
    )

  t([{eid: app.eid, app: {currentAccount: accountId}}])

  const {
    currentNetwork,
    site: {post},
  } = app

  if (post) {
    const addr = accountAddrByNetwork({
      account: accountId,
      network: currentNetwork.eid,
    })

    post({
      event: 'accountsChanged',
      params: [addr.value],
    })
  }

  return
}


/***/ }),

/***/ 76809:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_setAppCurrentNetwork'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['appId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['networkId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_deleteApp', 'wallet_setAppCurrentAccount'],
  db: [
    'getNetworkById',
    'getAppById',
    't',
    'accountAddrByNetwork',
    'getAppAnotherAuthedNoneHWAccount',
  ],
}

const main = async ({
  Err: {InvalidParams},
  db: {
    getNetworkById,
    getAppById,
    t,
    accountAddrByNetwork,
    getAppAnotherAuthedNoneHWAccount,
  },
  rpcs: {wallet_deleteApp, wallet_setAppCurrentAccount},
  params: {appId, networkId},
  network,
}) => {
  const nextNetwork = getNetworkById(networkId)
  if (!nextNetwork) throw InvalidParams(`Invalid network ${networkId}`)
  const app = getAppById(appId)
  if (!app) throw InvalidParams(`Invalid app id ${appId}`)

  t([{eid: app.eid, app: {currentNetwork: networkId}}])

  const {post} = app.site

  if (!post) return

  post({event: 'chainChanged', params: nextNetwork.chainId})
  post({
    event: 'connect',
    params: {chainId: nextNetwork.chainId, networkId: nextNetwork.netId},
  })

  // fire accountsChanged event when
  // eth switch to cfx
  // cfx switch to eth
  // cfx to another cfx network
  if (network.type === 'cfx' || nextNetwork.type === 'cfx') {
    const addr = accountAddrByNetwork({
      account: app.currentAccount.eid,
      network: nextNetwork.eid,
    })
    //sometimes, if you authorize a hardware ledger account under ethereum to dapp, when you switch to conflux network, you cannot get addr
    if (!addr) {
      const anotherAccId = getAppAnotherAuthedNoneHWAccount({appId: app.eid})
      if (anotherAccId) {
        await wallet_setAppCurrentAccount({
          accountId: anotherAccId,
          appId: app.eid,
        })
      } else {
        await wallet_deleteApp({appId: app.eid})
      }
      return
    }
    post({event: 'accountsChanged', params: [addr.value]})
  }
}


/***/ }),

/***/ 87222:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_setCurrentAccount'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.oneOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['setCurrentAccount', 'findAddress', 'findAccount'],
}

const main = ({
  Err: {InvalidParams},
  db: {setCurrentAccount, findAddress, findAccount},
  params: accounts,
}) => {
  const [account] = accounts.map(accountId => findAccount({accountId}))
  if (!account) throw InvalidParams(`Invalid accountId ${accounts[0]}`)

  const apps = setCurrentAccount(account)

  apps.forEach(({eid, site: {post}}) => {
    if (!post) return
    const addr = findAddress({
      appId: eid,
      g: {value: 1},
    })
    post({
      event: 'accountsChanged',
      params: [addr.value],
    })
  })
}


/***/ }),

/***/ 92074:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87580);



const NAME = 'wallet_setCurrentNetwork'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.oneOrMore, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_setAppCurrentNetwork', 'wallet_requestPermissions'],
  db: [
    'setCurrentNetwork',
    'getNetworkById',
    'getAppsWithDifferentSelectedNetwork',
    'getConnectedSitesWithoutApps',
  ],
}

function shouldGivenCrossNetworkAddressLookupPermissonsBasedOnNetworkChange(
  currentNetwork,
  nextNetwork,
) {
  if (currentNetwork.type === nextNetwork.type) return false
  if (nextNetwork.type === 'cfx')
    return 'wallet_crossNetworkTypeGetConfluxBase32Address'
  if (nextNetwork.type === 'eth')
    return 'wallet_crossNetworkTypeGetEthereumHexAddress'
  return false
}

const main = async ({
  Err: {InvalidParams},
  db: {
    setCurrentNetwork,
    getNetworkById,
    getAppsWithDifferentSelectedNetwork,
    getConnectedSitesWithoutApps,
  },
  rpcs: {wallet_setAppCurrentNetwork, wallet_requestPermissions},
  params: networks,
  network,
}) => {
  const [networkId] = networks
  const nextNetwork = getNetworkById(networkId)
  if (!nextNetwork) throw InvalidParams(`Invalid networkId ${networkId}`)
  const apps = getAppsWithDifferentSelectedNetwork(networkId)

  setCurrentNetwork(networkId)

  await Promise.all(
    apps.map(async app => {
      const newPerm =
        shouldGivenCrossNetworkAddressLookupPermissonsBasedOnNetworkChange(
          app.currentNetwork,
          nextNetwork,
        )
      if (newPerm && !app.perms[newPerm]) {
        await wallet_requestPermissions(
          {
            _popup: true,
          },
          {
            siteId: app.site.eid,
            permissions: [{...app.perms, [newPerm]: {}}],
            accounts: app.account.map(a => a.eid),
          },
        )
      }
      await wallet_setAppCurrentNetwork(
        {network},
        {appId: app.eid, networkId: networkId},
      )
      return true
    }),
  )

  getConnectedSitesWithoutApps().forEach(site => {
    site.post({event: 'chainChanged', params: nextNetwork.chainId})
  })

  _fluent_wallet_sentry__WEBPACK_IMPORTED_MODULE_1__/* .Sentry.setTag */ .TF.setTag('current_network', nextNetwork.name)
}


/***/ }),

/***/ 97044:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34577);



const NAME = 'wallet_setPreferences'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['hideTestNetwork', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
    ['overrideWindowDotEthereum', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
  ],
}

const permissions = {
  external: ['popup'],
  methods: ['wallet_getPreferences'],
  db: ['setPreferences', 'getApp'],
}

const main = async ({
  rpcs: {wallet_getPreferences},
  db: {setPreferences, getApp},
  params,
}) => {
  const txRst = setPreferences(params)

  const {overrideWindowDotEthereum} = await wallet_getPreferences()

  // if overrideWindowDotEthereum is set
  if (!(0,_fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__/* .isUndefined */ .o8)(params?.overrideWindowDotEthereum)) {
    const apps = getApp()
    apps.forEach(app => {
      if (!app.site.post) return
      app.site.post({
        event: '__FLUENT_BACKEND_PREFERENCES__',
        // don't pass all preferences to content script
        params: {overrideWindowDotEthereum},
      })
    })
  }

  return txRst
}


/***/ }),

/***/ 89363:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "schemas": () => (/* reexport safe */ _fluent_wallet_wallet_switch_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__.schemas),
/* harmony export */   "permissions": () => (/* reexport safe */ _fluent_wallet_wallet_switch_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__.permissions),
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_wallet_switch_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95655);


const NAME = 'wallet_switchConfluxChain'
const main = (0,_fluent_wallet_wallet_switch_ethereum_chain__WEBPACK_IMPORTED_MODULE_0__.generateMain)('cfx')


/***/ }),

/***/ 95655:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "generateMain": () => (/* binding */ generateMain),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_switchEthereumChain'

const publicSchema = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.cat, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['chainId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.chainId]]]
const innerSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ['chainConfig', publicSchema],
]

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, publicSchema, innerSchema],
}

const permissions = {
  external: ['inpage', 'popup'],
  // TODO: use setAppCurrentNetwork in v2
  methods: [
    'wallet_setCurrentNetwork',
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_userRejectedAuthRequest',
  ],
  db: ['getNetwork', 'getAuthReqById'],
  // scope: {wallet_networks: {}},
}

const generateMain =
  type =>
  async ({
    Err: {InvalidParams, UnrecognizedChainId},
    db: {getNetwork, getAuthReqById},
    rpcs: {
      wallet_setCurrentNetwork,
      wallet_addPendingUserAuthRequest,
      wallet_userApprovedAuthRequest,
      wallet_userRejectedAuthRequest,
    },
    params,
    app,
    _popup,
    _inpage,
    network: currentNetwork,
  }) => {
    const {chainId} = Array.isArray(params) ? params[0] : params.chainConfig[0]
    if (currentNetwork.type === type && currentNetwork.chainId === chainId)
      return '__null__'
    const [network] = getNetwork({chainId, type: type}) || []
    if (!network)
      throw UnrecognizedChainId(
        `Unrecognized chain ID "${chainId}". Try adding the chain using ${
          type === 'eth' ? 'wallet_addEthereumChain' : 'wallet_addConfluxChain'
        } first.`,
      )

    if (_inpage) {
      return await wallet_addPendingUserAuthRequest({
        appId: app.eid,
        req: {
          method: type === 'cfx' ? 'wallet_switchConfluxChain' : NAME,
          params,
        },
      })
    }

    if (_popup) {
      const {authReqId} = params
      const authReq = getAuthReqById(authReqId)
      if (!authReq) throw InvalidParams(`Invalid auth req id ${authReqId}`)
      const rst = await wallet_setCurrentNetwork({app: authReq.app}, [
        network.eid,
      ])
      if (rst?.error) return await wallet_userRejectedAuthRequest({authReqId})
      return await wallet_userApprovedAuthRequest({authReqId, res: '__null__'})
    }
  }

const main = generateMain('eth')


/***/ }),

/***/ 72996:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_unlock'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password],
    ['waitSideEffects', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep],
  ],
}

const permissions = {
  locked: true,
  external: ['popup'],
  methods: ['wallet_afterUnlock', 'wallet_validatePassword'],
  db: ['setPassword', 'getUnlockReq', 'retract', 'findApp', 'findAddress'],
}

const main = async ({
  params: {password, waitSideEffects},
  db: {setPassword, retract, getUnlockReq, findApp, findAddress},
  rpcs: {wallet_validatePassword, wallet_afterUnlock},
  Err: {InvalidParams},
}) => {
  if (!(await wallet_validatePassword({password})))
    throw InvalidParams('Invalid password')
  setPassword(password)

  const unlockReq = getUnlockReq() || []
  unlockReq.forEach(({req, eid}) => req.write(true).then(() => retract(eid)))

  const apps = findApp({
    g: {currentNetwork: {eid: 1}, currentAccount: {eid: 1}, site: {post: 1}},
  })
  apps.forEach(app => {
    if (!app?.site?.post) return
    const {
      site: {post},
      currentAccount: {eid: accountId},
      currentNetwork: {eid: networkId},
    } = app
    try {
      const addr = findAddress({accountId, networkId, g: {value: 1}})
      if (!addr) return
      post &&
        post({
          event: 'accountsChanged',
          params: [addr.value],
        })
      // eslint-disable-next-line no-empty
    } catch (err) {}
  })

  await wallet_afterUnlock({waitSideEffects: Boolean(waitSideEffects)})
}


/***/ }),

/***/ 65197:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_unwatchAsset'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['tokenId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['addressId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['retractAddressToken', 'getAddressById', 'getTokenById'],
}

const main = ({
  Err: {InvalidParams},
  db: {retractAddressToken, getAddressById, getTokenById},
  params: {tokenId, addressId},
}) => {
  if (!getTokenById(tokenId)) throw InvalidParams(`Invalid tokenId ${tokenId}`)
  if (!getAddressById(addressId))
    throw InvalidParams(`Invalid addressId ${addressId}`)
  const rst = retractAddressToken({tokenId, addressId})
  if (rst === 'tokenNotBelongToAddress')
    throw InvalidParams(
      `Token [${tokenId}] not belong to address [${addressId}]`,
    )
  return true
}


/***/ }),

/***/ 68204:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_updateAccount'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nickname],
    ['offline', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
    ['hidden', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
  ],
}

const permissions = {
  db: ['findAccount', 'updateAccountWithHiddenHandler', 'isLastNoneHWAccount'],
  methods: ['wallet_deleteApp', 'wallet_setAppCurrentAccount'],
  external: ['popup'],
}

const main = async ({
  Err: {InvalidParams},
  rpcs,
  db: {findAccount, updateAccountWithHiddenHandler, isLastNoneHWAccount},
  params,
}) => {
  const account = findAccount({
    accountId: params.accountId,
    g: {eid: 1},
  })

  if (!account) throw InvalidParams(`Invalid account id ${params.accountId}`)

  if (params.hidden && isLastNoneHWAccount(account.eid))
    throw InvalidParams(`Account ${account.eid} is last none HW account`)

  const sideEffects = updateAccountWithHiddenHandler(params)

  await Promise.all(sideEffects.map(([method, params]) => rpcs[method](params)))
}


/***/ }),

/***/ 74472:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34577);



const NAME = 'wallet_updateAccountGroup'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['accountGroupId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['nickname', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.nickname],
    ['hidden', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean],
  ],
}

const permissions = {
  db: ['t', 'findGroup', 'getAccountGroupByNickname'],
  external: ['popup'],
}

const main = async ({
  Err: {InvalidParams},
  db: {findGroup, t, getAccountGroupByNickname},
  params: {nickname, hidden, accountGroupId},
}) => {
  const group = findGroup({groupId: accountGroupId})
  if (!group) throw InvalidParams(`Invalid accountGroupId ${accountGroupId}`)
  if (nickname && getAccountGroupByNickname(nickname).length)
    throw InvalidParams(
      `Invalid nickname ${nickname}, duplicate with other account group`,
    )

  t([
    nickname && {eid: accountGroupId, accountGroup: {nickname}},
    (0,_fluent_wallet_checks__WEBPACK_IMPORTED_MODULE_1__/* .isBoolean */ .jn)(hidden) && {eid: accountGroupId, accountGroup: {hidden}},
  ])
}


/***/ }),

/***/ 76163:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_wallet_add_network__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18350);



const NAME = 'wallet_updateNetwork'

const schemas = [..._fluent_wallet_wallet_add_network__WEBPACK_IMPORTED_MODULE_1__.ChainParameterSchema, ['networkId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]]

const permissions = {
  external: ['popup'],
  methods: ['wallet_addNetwork'],
  db: ['getNetworkById'],
}

const main = ({
  Err: {InvalidParams},
  rpcs: {wallet_addNetwork},
  db: {getNetworkById},
  params,
}) => {
  const network = getNetworkById(params.networkId)
  if (!network) throw InvalidParams(`Invalid network id: ${params.networkId}`)
  if (network.builtin && network.endpoint === params.rpcUrls[0])
    throw InvalidParams(`Don't support update builtin network`)

  let newParams
  // only allow changing builtin network's rpcUrls
  if (network.builtin) {
    newParams = {
      rpcUrls: params.rpcUrls,

      chainId: network.chainId,
      chainName: network.name,
      nativeCurrency: {...network.ticker},
      blockExplorerUrls: [network.scanUrl],
      iconUrls: [network.icon],
      hdPath: network.hdPath.eid,
    }
  } else {
    // eslint-disable-next-line no-unused-vars
    let {networkId, ...newParams1} = params
    newParams = newParams1
  }

  return wallet_addNetwork({toUpdateNetwork: network}, newParams)
}


/***/ }),

/***/ 85072:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "InnerTokenListSchema": () => (/* binding */ InnerTokenListSchema),
  "NAME": () => (/* binding */ NAME),
  "TokenListSchema": () => (/* binding */ TokenListSchema),
  "main": () => (/* binding */ main),
  "permissions": () => (/* binding */ permissions),
  "schemas": () => (/* binding */ schemas),
  "validateAndFormatTokenList": () => (/* binding */ validateAndFormatTokenList)
});

// EXTERNAL MODULE: ../../packages/spec/index.js + 1 modules
var spec = __webpack_require__(27797);
;// CONCATENATED MODULE: ../../packages/token-list-schema/index.js
/* harmony default export */ function token_list_schema({map,stringp,and,or,regexp,boolean,int,nil,ethHexAddress,base32ContractAddress,posInt,url,repeat,mapOf,jsinst,tokenSymbol,jssetp,integer}){const VersionSchema=[map,{closed:true},['major',[integer,{min:0}]],['minor',[integer,{min:0}]],['patch',[integer,{min:0}]]];const TagIdentifierSchema=[and,[stringp,{min:1,max:10}],[regexp,'^[\\w]+$']];const ExtensionIdentifierSchema=[and,[stringp,{min:1,max:30}],[regexp,'^[\\w]+$']];const ExtensionValueSchema=[or,nil,boolean,int,[stringp,{min:1,max:42}]];const TagDefinitionSchema=[map,{closed:true},['name',[and,[stringp,{min:1,max:40}],[regexp,'^[ \\w]+$']]],['description',[and,[stringp,{min:1,max:200}],[regexp,'^[ \\w\\.,]+$']]]];const TokenInfoSchema=[map,{closed:true},['chainId',int],['address',[or,ethHexAddress,base32ContractAddress]],['decimals',[posInt,{max:255}]],['name',[and,[regexp,"^[ \\w.'+\\-%\\/---:]+$"],[stringp,{min:1,max:40}]]],['symbol',tokenSymbol],['logoURI',{optional:true},url],['tags',{optional:true},[repeat,{min:0,max:10},TagIdentifierSchema]],['extensions',{optional:true},[mapOf,{min:0,max:20},ExtensionIdentifierSchema,ExtensionValueSchema]]];const TokenListSchema=[map,{closed:true},['name',[and,[stringp,{min:1,max:20}],[regexp,'^[ \\w]+$']]],['timestamp',jsinst],['version',VersionSchema],['tokens',[repeat,{min:1,max:10000},TokenInfoSchema]],['keywords',{optional:true},[and,[repeat,{min:1,max:20},[and,[stringp,{min:1,max:20}],[regexp,'^[ \\w]+$']]],jssetp]],['tags',{optional:true},[mapOf,{min:0,max:20},TagIdentifierSchema,TagDefinitionSchema]],['logoURI',{optional:true},url]];return TokenListSchema;}
;// CONCATENATED MODULE: ../../packages/rpcs/wallet_updateTokenList/index.js



const {map, url, dbid, nickname, validate, explain} = spec
const NAME = 'wallet_updateTokenList'
const TokenListSchema = token_list_schema(spec)

const InnerTokenListSchema = [
  map,
  {closed: true},
  ['url', url],
  ['name', {optional: true}, nickname],
]

const schemas = {
  input: [
    map,
    {closed: true},
    ['tokenList', InnerTokenListSchema],
    ['networkId', dbid],
  ],
}

const permissions = {
  external: ['popup'],
  methods: [],
  db: ['getNetworkById', 'upsertTokenList', 't'],
}

const validateAndFormatTokenList = ({tokenList, InvalidParams}) => {
  if (!validate(TokenListSchema, tokenList)) {
    throw InvalidParams(
      `Invalid token list format.\n${JSON.stringify(
        explain(TokenListSchema, tokenList),
        null,
        4,
      )}`,
    )
  }

  const {logoURI, tokens} = tokenList

  const protocolRegex = new RegExp(/^https?:/, 'i')

  const allUrlHasValidProtocol = tokens.reduce((acc, {logoURI}) => {
    if (!acc) return false
    if (!logoURI) return acc
    return protocolRegex.test(logoURI)
  }, protocolRegex.test(logoURI))

  if (!allUrlHasValidProtocol)
    throw InvalidParams(
      'Unsupported logoURI protocol found in token list, only support http/https for now.',
    )
}

const isNewVersionTokenList = (
  {major: omajor, minor: ominor, patch: opatch},
  {major, minor, patch},
) => {
  if (major > omajor) return true
  if (major === omajor && minor > ominor) return true
  if (major === omajor && minor === ominor && patch > opatch) return true

  return false
}

const main = async ({
  Err: {InvalidParams},
  db: {getNetworkById, upsertTokenList, t},
  params: {
    tokenList: {url, name},
    networkId,
  },
}) => {
  let network = getNetworkById(networkId)
  if (!network) throw InvalidParams(`Invalid network id ${networkId}`)

  let tokenList
  try {
    tokenList = await fetch(url).then(r => r.json())
  } catch (err) {
    throw InvalidParams(`Invalid token list ${url}`)
  }

  validateAndFormatTokenList({tokenList, InvalidParams})
  name = name || tokenList.name

  const oldTokenListVersion = network.tokenList?.value?.version

  // if there's no old version or new version exist
  const isNewVersion =
    !oldTokenListVersion ||
    isNewVersionTokenList(oldTokenListVersion, tokenList.version)
  if (!isNewVersion) return

  upsertTokenList({newList: tokenList.tokens, networkId})
  t([
    // create tokenList
    {eid: -1, tokenList: {url, name, value: tokenList}},
    // add tokenList to network
    {eid: networkId, network: {tokenList: -1}},
  ])
}


/***/ }),

/***/ 75415:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2723);




const NAME = 'wallet_upsertMemo'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32Address, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ['value', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.string, {min: 1}]],
    ['memoId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ],
}

const permissions = {
  external: ['popup'],
  db: ['getMemoById', 'upsertMemo', 'findMemo'],
}

const main = ({
  Err: {InvalidParams},
  db: {getMemoById, upsertMemo, findMemo},
  params: {address, value, memoId},
  network,
}) => {
  if (memoId && !getMemoById(memoId))
    throw InvalidParams(`Invalid memo id ${memoId}`)
  if (findMemo({networkId: network.eid, address, value}).length)
    throw InvalidParams(`Invalid duplicate memo`)

  const isBase32 = (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .validateBase32Address */ .pd)(address)

  if (network.type === 'cfx' && !isBase32)
    throw InvalidParams(`Invalid address ${address}, not valid base32`)

  if (network.type === 'eth' && isBase32)
    throw InvalidParams(`Invalid address ${address}, not valid hex address`)

  address = address.toLowerCase()

  upsertMemo({address, value, memoId, networkId: network.eid})
  return
}


/***/ }),

/***/ 87112:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_userApprovedAuthRequest'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid], ['res', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.anyp]],
}

const permissions = {db: ['getAuthReqById', 'retract']}

const main = async ({
  Err: {InvalidParams},
  db: {retract, getAuthReqById},
  params: {authReqId, res},
}) => {
  const authReq = getAuthReqById(authReqId)
  if (!authReq) throw InvalidParams(`Invalid auth request id ${authReqId}`)
  if (authReq.c) authReq.c.write(res)
  retract(authReqId)

  return
}


/***/ }),

/***/ 99866:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_userRejectedAuthRequest'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    {closed: true},
    ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['error', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.anyp],
  ],
}

const permissions = {
  db: ['getAuthReqById', 'retract'],
  external: ['popup'],
}

const main = async ({
  Err: {InvalidParams, UserRejected},
  db: {retract, getAuthReqById},
  params: {authReqId, error},
}) => {
  const authReq = getAuthReqById(authReqId)
  if (!authReq) throw InvalidParams(`Invalid auth request id ${authReqId}`)

  if (authReq.c) {
    error = error || UserRejected()
    error.rpcData = authReq.req
    authReq.c.write(error)
  }

  retract(authReqId)

  return
}


/***/ }),

/***/ 7796:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var _fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2723);
/* harmony import */ var _fluent_wallet_contract_abis_777_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58934);




const NAME = 'wallet_validate20Token'

const schemas = {
  input: [
    _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
    ['tokenAddress', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ['name', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp],
    ['symbol', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.tokenSymbol],
    ['decimals', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.integer],
    ['userAddress', {optional: true}, [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32UserAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
    ['addressId', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
    ['selectedAccountAddress', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.truep],
  ],
}

const permissions = {
  locked: true,
  external: ['popup', 'inpage'],
  methods: ['cfx_call', 'eth_call'],
  db: ['getCurrentAddr', 'getAddressById'],
}

const main = async ({
  Err: {InvalidParams},
  db: {getCurrentAddr, getAddressById},
  rpcs: {cfx_call, eth_call},
  params: {
    name,
    symbol,
    decimals,
    tokenAddress,
    userAddress,
    addressId,
    selectedAccountAddress,
  },
  network: {type},
}) => {
  if (
    (addressId && userAddress) ||
    (addressId && selectedAccountAddress) ||
    (userAddress && selectedAccountAddress)
  )
    throw InvalidParams(
      `don't support providing userAddress addressId selectedAccountAddress at the same time`,
    )

  let uaddr
  if (addressId) {
    const addr = getAddressById(addressId)
    if (!addr) throw InvalidParams(`Invalid addressId ${addressId}`)
    uaddr = addr.hex
  }
  if (userAddress && type === 'cfx') uaddr = (0,_fluent_wallet_base32_address__WEBPACK_IMPORTED_MODULE_1__/* .decode */ .Jx)(userAddress).hexAddress
  if (userAddress && type === 'eth') uaddr = userAddress
  if (selectedAccountAddress) uaddr = getCurrentAddr().hex

  const call = type === 'cfx' ? cfx_call : eth_call
  const rst = await (0,_fluent_wallet_contract_abis_777_js__WEBPACK_IMPORTED_MODULE_2__/* .validateTokenInfo */ .FU)(
    d => call({errorFallThrough: true}, [d]),
    {name, decimals, symbol, address: tokenAddress, userAddress: uaddr},
  )

  return rst
}


/***/ }),

/***/ 29438:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_validateAppPermissions'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['permissions', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.mapp]],
}

const permissions = {
  locked: true,
  external: [],
}

const main = ({Err: {Unauthorized}, params: perms, app}) => {
  if (!app) throw Unauthorized()
  if (!app) false
  // TODO: validte more detailed permissions once we need more detailed permissions other than {cfx_accounts:{}}
  return Object.keys(perms).reduce((acc, p) => acc || app.perms?.[p], false)
}


/***/ }),

/***/ 68153:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var bip39__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36832);



const NAME = 'wallet_validateMnemonic'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['mnemonic', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.stringp, {min: 1}]]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

function filterWordlistsByWord(wordlists, word) {
  if (typeof wordlists === 'string') return wordlists
  wordlists = wordlists.filter(([, list]) => list.includes(word))
  if (!wordlists.length) return word
  return wordlists
}

const main = ({params: {mnemonic}}) => {
  const words = mnemonic
    .split(' ')
    .map(w => w?.trim())
    .filter(w => Boolean(w))

  const validWordlistsOrInvalidWord = words.reduce(
    filterWordlistsByWord,
    Object.entries(bip39__WEBPACK_IMPORTED_MODULE_1__/* .wordlists */ .ET),
  )

  if (typeof validWordlistsOrInvalidWord === 'string')
    return {valid: false, invalidWord: validWordlistsOrInvalidWord}

  const invalids = validWordlistsOrInvalidWord.reduce((acc, [lang, list]) => {
    if (!(0,bip39__WEBPACK_IMPORTED_MODULE_1__/* .validateMnemonic */ ._I)(mnemonic, list)) return acc.concat([lang])
    return acc.concat([false])
  }, [])

  if (invalids.every(x => !!x))
    return {valid: false, invalidWordlists: invalids}

  return {valid: true}
}


/***/ }),

/***/ 46426:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);
/* harmony import */ var browser_passworder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89620);



const NAME = 'wallet_validatePassword'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['password', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.password]],
  output: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.boolean,
}

const permissions = {
  locked: true,
  db: ['getVault', 'getPassword', 'getLocked'],
}

async function main({
  db: {getVault, getLocked, getPassword},
  params: {password},
}) {
  // validate with in-mem password if not locked
  if (!getLocked()) return password === getPassword()

  // validate with vault if locked
  const vaults = getVault()

  // return true if zero vault
  if (!vaults.length) return true

  // validate
  let valid = false
  try {
    await (0,browser_passworder__WEBPACK_IMPORTED_MODULE_1__.decrypt)(password, vaults[0].data)
    valid = true
  } catch (err) {
    valid = false
  }

  return valid
}


/***/ }),

/***/ 64725:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11239);
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27797);



const NAME = 'wallet_validatePrivateKey'

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.map, {closed: true}, ['privateKey', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_1__.stringp, {min: 1}]]],
}

const permissions = {
  external: ['popup', 'inpage'],
  locked: true,
}

const main = ({params: {privateKey}}) => {
  return {valid: (0,_fluent_wallet_account__WEBPACK_IMPORTED_MODULE_0__/* .validatePrivateKey */ .QS)(privateKey)}
}


/***/ }),

/***/ 90874:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_watchAsset'

const publicSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['type', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.enums, 'ERC20', 'CRC20']],
  [
    'options',
    [
      _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
      ['address', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.base32ContractAddress, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.ethHexAddress]],
      ['symbol', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.tokenSymbol],
      ['decimals', [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.posInt, {max: 255}]],
      ['image', {optional: true}, _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.url],
    ],
  ],
]

const internalSchema = [
  _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map,
  {closed: true},
  ['authReqId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid],
  ['asset', publicSchema],
]

const tokenIdSchema = [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.map, {closed: true}, ['tokenId', _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.dbid]]

const schemas = {
  input: [_fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.or, publicSchema, internalSchema, tokenIdSchema],
}

const permissions = {
  external: ['popup', 'inpage'],
  methods: [
    'wallet_addPendingUserAuthRequest',
    'wallet_userApprovedAuthRequest',
    'wallet_validate20Token',
  ],
  db: [
    'getAuthReqById',
    'getCurrentAddr',
    'addTokenToAddr',
    'findAddress',
    'findToken',
  ],
}

const main = async ({
  Err: {InvalidParams},
  db: {getAuthReqById, addTokenToAddr, getCurrentAddr, findAddress, findToken},
  rpcs: {
    wallet_addPendingUserAuthRequest,
    wallet_userApprovedAuthRequest,
    wallet_validate20Token,
  },
  app,
  params,
  _popup,
  network,
}) => {
  if (params?.tokenId && _popup) {
    const token = findToken({
      tokenId: params.tokenId,
      g: {
        name: 1,
        symbol: 1,
        address: 1,
        decimals: 1,
        logoURI: 1,
        network: {eid: 1},
      },
    })

    if (!token || token.network.eid !== network.eid)
      throw InvalidParams(`Invalid token id ${params.tokenId}`)

    const curAddr = getCurrentAddr()
    addTokenToAddr({
      name: token.name,
      symbol: token.symbol,
      address: token.address,
      decimals: token.decimals,
      image: token.logoURI,
      network: network.eid,
      targetAddressId: curAddr.eid,
      fromUser: true,
    })
    return true
  }
  if (params?.type) {
    const {address} = params.options
    const {name, symbol, decimals, valid} = await wallet_validate20Token({
      ...params.options,
      tokenAddress: address,
    })
    if (!valid) throw InvalidParams('Invalid token')

    if (_popup) {
      const curAddr = getCurrentAddr()
      addTokenToAddr({
        ...params.options,
        name,
        symbol,
        address,
        decimals,
        network: network.eid,
        targetAddressId: curAddr.eid,
        fromUser: true,
      })

      return true
    }

    // from dapp
    const curAddr = findAddress({appId: app.eid})
    const {alreadyInAddr} = addTokenToAddr({
      ...params.options,
      network: app.currentNetwork.eid,
      targetAddressId: curAddr,
      checkOnly: true,
    })
    if (alreadyInAddr) return true

    return await wallet_addPendingUserAuthRequest({
      appId: app.eid,
      req: {
        method: NAME,
        params: {
          ...params,
          options: {...params.options, name, symbol, decimals},
        },
      },
    })
  }

  if (params.authReqId) {
    const authReq = getAuthReqById(params.authReqId)
    if (!authReq) throw InvalidParams(`Invalid auth req id ${params.authReqId}`)
    if (authReq.processed)
      throw InvalidParams(`Already processing auth req ${params.authReqId}`)
    const authedApp = authReq.app
    const addr = findAddress({appId: authedApp.eid})
    addTokenToAddr({
      ...authReq.req.params.options,
      network: authedApp.currentNetwork.eid,
      targetAddressId: addr,
      fromApp: true,
    })

    return await wallet_userApprovedAuthRequest({
      authReqId: params.authReqId,
      res: true,
    })
  }
}


/***/ }),

/***/ 76022:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NAME": () => (/* binding */ NAME),
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "permissions": () => (/* binding */ permissions),
/* harmony export */   "main": () => (/* binding */ main)
/* harmony export */ });
/* harmony import */ var _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27797);


const NAME = 'wallet_zeroAccountGroup'

const schemas = {
  input: _fluent_wallet_spec__WEBPACK_IMPORTED_MODULE_0__.optParam,
}

const permissions = {
  external: ['popup'],
  locked: true,
  db: ['findAddress'],
}

const main = ({db: {findAddress}}) => {
  const selectedAddr = findAddress({selected: true})
  if (Number.isInteger(selectedAddr)) return false
  else return true
}


/***/ }),

/***/ 87580:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "TF": () => (/* reexport */ esm_namespaceObject),
  "IE": () => (/* binding */ capture),
  "uT": () => (/* binding */ sentry_captureMessage),
  "O5": () => (/* binding */ updateUserId)
});

// UNUSED EXPORTS: addBreadcrumb, init

// NAMESPACE OBJECT: ../../node_modules/@sentry/core/esm/integrations/index.js
var integrations_namespaceObject = {};
__webpack_require__.r(integrations_namespaceObject);
__webpack_require__.d(integrations_namespaceObject, {
  "FunctionToString": () => (FunctionToString),
  "InboundFilters": () => (InboundFilters)
});

// NAMESPACE OBJECT: ../../node_modules/@sentry/browser/esm/integrations/index.js
var esm_integrations_namespaceObject = {};
__webpack_require__.r(esm_integrations_namespaceObject);
__webpack_require__.d(esm_integrations_namespaceObject, {
  "Breadcrumbs": () => (Breadcrumbs),
  "Dedupe": () => (Dedupe),
  "GlobalHandlers": () => (GlobalHandlers),
  "HttpContext": () => (HttpContext),
  "LinkedErrors": () => (LinkedErrors),
  "TryCatch": () => (TryCatch)
});

// NAMESPACE OBJECT: ../../node_modules/@sentry/browser/esm/index.js
var esm_namespaceObject = {};
__webpack_require__.r(esm_namespaceObject);
__webpack_require__.d(esm_namespaceObject, {
  "Breadcrumbs": () => (Breadcrumbs),
  "BrowserClient": () => (BrowserClient),
  "Dedupe": () => (Dedupe),
  "FunctionToString": () => (FunctionToString),
  "GlobalHandlers": () => (GlobalHandlers),
  "HttpContext": () => (HttpContext),
  "Hub": () => (esm_hub/* Hub */.Xb),
  "InboundFilters": () => (InboundFilters),
  "Integrations": () => (INTEGRATIONS),
  "LinkedErrors": () => (LinkedErrors),
  "SDK_VERSION": () => (SDK_VERSION),
  "Scope": () => (esm_scope/* Scope */.s),
  "TryCatch": () => (TryCatch),
  "addBreadcrumb": () => (addBreadcrumb),
  "addGlobalEventProcessor": () => (esm_scope/* addGlobalEventProcessor */.c),
  "captureEvent": () => (captureEvent),
  "captureException": () => (captureException),
  "captureMessage": () => (captureMessage),
  "chromeStackLineParser": () => (chromeStackLineParser),
  "close": () => (sdk_close),
  "configureScope": () => (configureScope),
  "createTransport": () => (createTransport),
  "defaultIntegrations": () => (defaultIntegrations),
  "defaultStackLineParsers": () => (defaultStackLineParsers),
  "defaultStackParser": () => (defaultStackParser),
  "flush": () => (flush),
  "forceLoad": () => (forceLoad),
  "geckoStackLineParser": () => (geckoStackLineParser),
  "getCurrentHub": () => (esm_hub/* getCurrentHub */.Gd),
  "getHubFromCarrier": () => (esm_hub/* getHubFromCarrier */.vi),
  "init": () => (init),
  "lastEventId": () => (lastEventId),
  "makeFetchTransport": () => (makeFetchTransport),
  "makeMain": () => (esm_hub/* makeMain */.pj),
  "makeXHRTransport": () => (makeXHRTransport),
  "onLoad": () => (onLoad),
  "opera10StackLineParser": () => (opera10StackLineParser),
  "opera11StackLineParser": () => (opera11StackLineParser),
  "setContext": () => (setContext),
  "setExtra": () => (setExtra),
  "setExtras": () => (setExtras),
  "setTag": () => (setTag),
  "setTags": () => (setTags),
  "setUser": () => (setUser),
  "showReportDialog": () => (showReportDialog),
  "startTransaction": () => (startTransaction),
  "winjsStackLineParser": () => (winjsStackLineParser),
  "withScope": () => (withScope),
  "wrap": () => (sdk_wrap)
});

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/object.js
var object = __webpack_require__(21995);
;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/integrations/functiontostring.js


let originalFunctionToString;

/** Patch toString calls to return proper name for wrapped functions */
class FunctionToString  {constructor() { FunctionToString.prototype.__init.call(this); }
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'FunctionToString';}

  /**
   * @inheritDoc
   */
   __init() {this.name = FunctionToString.id;}

  /**
   * @inheritDoc
   */
   setupOnce() {
        originalFunctionToString = Function.prototype.toString;

        Function.prototype.toString = function ( ...args) {
      var context = (0,object/* getOriginalFunction */.HK)(this) || this;
      return originalFunctionToString.apply(context, args);
    };
  }
} FunctionToString.__initStatic();


//# sourceMappingURL=functiontostring.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/logger.js
var logger = __webpack_require__(58536);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/misc.js
var misc = __webpack_require__(63699);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/string.js
var string = __webpack_require__(39660);
;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/integrations/inboundfilters.js


// "Script error." is hard coded into browsers for errors that it can't read.
// this is the result of a script being pulled in from an external domain and CORS.
var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];

/** Options for the InboundFilters integration */

/** Inbound filters configurable by the user */
class InboundFilters  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'InboundFilters';}

  /**
   * @inheritDoc
   */
   __init() {this.name = InboundFilters.id;}

   constructor(  _options = {}) {;this._options = _options;InboundFilters.prototype.__init.call(this);}

  /**
   * @inheritDoc
   */
   setupOnce(addGlobalEventProcessor, getCurrentHub) {
    var eventProcess = (event) => {
      var hub = getCurrentHub();
      if (hub) {
        var self = hub.getIntegration(InboundFilters);
        if (self) {
          var client = hub.getClient();
          var clientOptions = client ? client.getOptions() : {};
          var options = _mergeOptions(self._options, clientOptions);
          return _shouldDropEvent(event, options) ? null : event;
        }
      }
      return event;
    };

    eventProcess.id = this.name;
    addGlobalEventProcessor(eventProcess);
  }
} InboundFilters.__initStatic();

/** JSDoc */
function _mergeOptions(
  internalOptions = {},
  clientOptions = {},
) {
  return {
    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],
    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],
    ignoreErrors: [
      ...(internalOptions.ignoreErrors || []),
      ...(clientOptions.ignoreErrors || []),
      ...DEFAULT_IGNORE_ERRORS,
    ],
    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,
  };
}

/** JSDoc */
function _shouldDropEvent(event, options) {
  if (options.ignoreInternal && _isSentryError(event)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${(0,misc/* getEventDescription */.jH)(event)}`);
    return true;
  }
  if (_isIgnoredError(event, options.ignoreErrors)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${(0,misc/* getEventDescription */.jH)(event)}`,
      );
    return true;
  }
  if (_isDeniedUrl(event, options.denyUrls)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn(
        `Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${(0,misc/* getEventDescription */.jH)(
          event,
        )}.\nUrl: ${_getEventFilterUrl(event)}`,
      );
    return true;
  }
  if (!_isAllowedUrl(event, options.allowUrls)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${(0,misc/* getEventDescription */.jH)(
          event,
        )}.\nUrl: ${_getEventFilterUrl(event)}`,
      );
    return true;
  }
  return false;
}

function _isIgnoredError(event, ignoreErrors) {
  if (!ignoreErrors || !ignoreErrors.length) {
    return false;
  }

  return _getPossibleEventMessages(event).some(message =>
    ignoreErrors.some(pattern => (0,string/* isMatchingPattern */.zC)(message, pattern)),
  );
}

function _isDeniedUrl(event, denyUrls) {
  // TODO: Use Glob instead?
  if (!denyUrls || !denyUrls.length) {
    return false;
  }
  var url = _getEventFilterUrl(event);
  return !url ? false : denyUrls.some(pattern => (0,string/* isMatchingPattern */.zC)(url, pattern));
}

function _isAllowedUrl(event, allowUrls) {
  // TODO: Use Glob instead?
  if (!allowUrls || !allowUrls.length) {
    return true;
  }
  var url = _getEventFilterUrl(event);
  return !url ? true : allowUrls.some(pattern => (0,string/* isMatchingPattern */.zC)(url, pattern));
}

function _getPossibleEventMessages(event) {
  if (event.message) {
    return [event.message];
  }
  if (event.exception) {
    try {
      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};
      return [`${value}`, `${type}: ${value}`];
    } catch (oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error(`Cannot extract message for event ${(0,misc/* getEventDescription */.jH)(event)}`);
      return [];
    }
  }
  return [];
}

function _isSentryError(event) {
  try {
    // @ts-ignore can't be a sentry error if undefined
        return event.exception.values[0].type === 'SentryError';
  } catch (e) {
    // ignore
  }
  return false;
}

function _getLastValidUrl(frames = []) {
  for (let i = frames.length - 1; i >= 0; i--) {
    var frame = frames[i];

    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
      return frame.filename || null;
    }
  }

  return null;
}

function _getEventFilterUrl(event) {
  try {
    let frames;
    try {
      // @ts-ignore we only care about frames if the whole thing here is defined
      frames = event.exception.values[0].stacktrace.frames;
    } catch (e) {
      // ignore
    }
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error(`Cannot extract url for event ${(0,misc/* getEventDescription */.jH)(event)}`);
    return null;
  }
}


//# sourceMappingURL=inboundfilters.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/integrations/index.js


//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/hub/esm/hub.js
var esm_hub = __webpack_require__(8585);
;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/version.js
var SDK_VERSION = '7.4.1';


//# sourceMappingURL=version.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/hub/esm/scope.js
var esm_scope = __webpack_require__(51684);
;// CONCATENATED MODULE: ../../node_modules/@sentry/hub/esm/exports.js


// Note: All functions in this file are typed with a return value of `ReturnType<Hub[HUB_FUNCTION]>`,
// where HUB_FUNCTION is some method on the Hub class.
//
// This is done to make sure the top level SDK methods stay in sync with the hub methods.
// Although every method here has an explicit return type, some of them (that map to void returns) do not
// contain `return` keywords. This is done to save on bundle size, as `return` is not minifiable.

/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @param captureContext Additional scope data to apply to exception event.
 * @returns The generated eventId.
 */
function captureException(exception, captureContext) {
  return (0,esm_hub/* getCurrentHub */.Gd)().captureException(exception, { captureContext });
}

/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
function captureMessage(
  message,
    captureContext,
) {
  // This is necessary to provide explicit scopes upgrade, without changing the original
  // arity of the `captureMessage(message, level)` method.
  var level = typeof captureContext === 'string' ? captureContext : undefined;
  var context = typeof captureContext !== 'string' ? { captureContext } : undefined;
  return (0,esm_hub/* getCurrentHub */.Gd)().captureMessage(message, level, context);
}

/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
function captureEvent(event, hint) {
  return (0,esm_hub/* getCurrentHub */.Gd)().captureEvent(event, hint);
}

/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
function configureScope(callback) {
  (0,esm_hub/* getCurrentHub */.Gd)().configureScope(callback);
}

/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
function addBreadcrumb(breadcrumb) {
  (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(breadcrumb);
}

/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
function setContext(name, context) {
  (0,esm_hub/* getCurrentHub */.Gd)().setContext(name, context);
}

/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
function setExtras(extras) {
  (0,esm_hub/* getCurrentHub */.Gd)().setExtras(extras);
}

/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
function setExtra(key, extra) {
  (0,esm_hub/* getCurrentHub */.Gd)().setExtra(key, extra);
}

/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
function setTags(tags) {
  (0,esm_hub/* getCurrentHub */.Gd)().setTags(tags);
}

/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
function setTag(key, value) {
  (0,esm_hub/* getCurrentHub */.Gd)().setTag(key, value);
}

/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
function setUser(user) {
  (0,esm_hub/* getCurrentHub */.Gd)().setUser(user);
}

/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
function withScope(callback) {
  (0,esm_hub/* getCurrentHub */.Gd)().withScope(callback);
}

/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
function startTransaction(
  context,
  customSamplingContext,
) {
  return (0,esm_hub/* getCurrentHub */.Gd)().startTransaction({ ...context }, customSamplingContext);
}


//# sourceMappingURL=exports.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/error.js
/** An error emitted by Sentry SDKs and related utilities. */
class SentryError extends Error {
  /** Display name of this error instance. */
  

   constructor( message) {
    super(message);this.message = message;;

    this.name = new.target.prototype.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
}


//# sourceMappingURL=error.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/syncpromise.js
var syncpromise = __webpack_require__(97946);
;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/promisebuffer.js



/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
function makePromiseBuffer(limit) {
  var buffer = [];

  function isReady() {
    return limit === undefined || buffer.length < limit;
  }

  /**
   * Remove a promise from the queue.
   *
   * @param task Can be any PromiseLike<T>
   * @returns Removed promise.
   */
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0];
  }

  /**
   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
   *
   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
   *        limit check.
   * @returns The original promise.
   */
  function add(taskProducer) {
    if (!isReady()) {
      return (0,syncpromise/* rejectedSyncPromise */.$2)(new SentryError('Not adding Promise due to buffer limit reached.'));
    }

    // start the task and add its promise to the queue
    var task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task
      .then(() => remove(task))
      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
      // have promises, so TS has to polyfill when down-compiling.)
      .then(null, () =>
        remove(task).then(null, () => {
          // We have to add another catch here because `remove()` starts a new promise chain.
        }),
      );
    return task;
  }

  /**
   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
   * `false` otherwise
   */
  function drain(timeout) {
    return new syncpromise/* SyncPromise */.cW((resolve, reject) => {
      let counter = buffer.length;

      if (!counter) {
        return resolve(true);
      }

      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
      var capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);

      // if all promises resolve in time, cancel the timer and resolve to `true`
      buffer.forEach(item => {
        void (0,syncpromise/* resolvedSyncPromise */.WD)(item).then(() => {
                    if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }

  return {
    $: buffer,
    add,
    drain,
  };
}


//# sourceMappingURL=promisebuffer.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/envelope.js


/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function createEnvelope(headers, items = []) {
  return [headers, items] ;
}

/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]] ;
}

/**
 * Convenience function to loop through the items and item types of an envelope.
 * (This function was mostly created because working with envelope types is painful at the moment)
 */
function forEachEnvelopeItem(
  envelope,
  callback,
) {
  var envelopeItems = envelope[1];
  envelopeItems.forEach((envelopeItem) => {
    var envelopeItemType = envelopeItem[0].type;
    callback(envelopeItem, envelopeItemType);
  });
}

function encodeUTF8(input, textEncoder) {
  var utf8 = textEncoder || new TextEncoder();
  return utf8.encode(input);
}

/**
 * Serializes an envelope.
 */
function serializeEnvelope(envelope, textEncoder) {
  const [envHeaders, items] = envelope;

  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data
  let parts = JSON.stringify(envHeaders);

  function append(next) {
    if (typeof parts === 'string') {
      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];
    } else {
      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);
    }
  }

  for (var item of items) {
    const [itemHeaders, payload] = item ;
    append(`\n${JSON.stringify(itemHeaders)}\n`);
    append(typeof payload === 'string' || payload instanceof Uint8Array ? payload : JSON.stringify(payload));
  }

  return typeof parts === 'string' ? parts : concatBuffers(parts);
}

function concatBuffers(buffers) {
  var totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);

  var merged = new Uint8Array(totalLength);
  let offset = 0;
  for (var buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }

  return merged;
}

/**
 * Creates attachment envelope items
 */
function createAttachmentEnvelopeItem(
  attachment,
  textEncoder,
) {
  var buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;

  return [
    (0,object/* dropUndefinedKeys */.Jr)({
      type: 'attachment',
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType,
    }),
    buffer,
  ];
}

var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: 'session',
  sessions: 'session',
  attachment: 'attachment',
  transaction: 'transaction',
  event: 'error',
  client_report: 'internal',
  user_report: 'default',
};

/**
 * Maps the type of an envelope item to a data category.
 */
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}


//# sourceMappingURL=envelope.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/ratelimit.js
// Intentionally keeping the key broad, as we don't know for sure what rate limit headers get returned from backend

var DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds

/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
function parseRetryAfterHeader(header, now = Date.now()) {
  var headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1000;
  }

  var headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }

  return DEFAULT_RETRY_AFTER;
}

/**
 * Gets the time that given category is disabled until for rate limiting
 */
function disabledUntil(limits, category) {
  return limits[category] || limits.all || 0;
}

/**
 * Checks if a category is rate limited
 */
function isRateLimited(limits, category, now = Date.now()) {
  return disabledUntil(limits, category) > now;
}

/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
function updateRateLimits(
  limits,
  { statusCode, headers },
  now = Date.now(),
) {
  var updatedRateLimits = {
    ...limits,
  };

  // "The name is case-insensitive."
  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
  var rateLimitHeader = headers && headers['x-sentry-rate-limits'];
  var retryAfterHeader = headers && headers['retry-after'];

  if (rateLimitHeader) {
    /**
     * rate limit headers are of the form
     *     <header>,<header>,..
     * where each <header> is of the form
     *     <retry_after>: <categories>: <scope>: <reason_code>
     * where
     *     <retry_after> is a delay in seconds
     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
     *         <category>;<category>;...
     *     <scope> is what's being limited (org, project, or key) - ignored by SDK
     *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
     */
    for (var limit of rateLimitHeader.trim().split(',')) {
      const [retryAfter, categories] = limit.split(':', 2);
      var headerDelay = parseInt(retryAfter, 10);
      var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (var category of categories.split(';')) {
          updatedRateLimits[category] = now + delay;
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1000;
  }

  return updatedRateLimits;
}


//# sourceMappingURL=ratelimit.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/transports/base.js


var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;

/**
 * Creates an instance of a Sentry `Transport`
 *
 * @param options
 * @param makeRequest
 */
function createTransport(
  options,
  makeRequest,
  buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),
) {
  let rateLimits = {};

  var flush = (timeout) => buffer.drain(timeout);

  function send(envelope) {
    var filteredEnvelopeItems = [];

    // Drop rate limited items from envelope
    forEachEnvelopeItem(envelope, (item, type) => {
      var envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {
        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });

    // Skip sending if envelope is empty after filtering out rate limited events
    if (filteredEnvelopeItems.length === 0) {
      return (0,syncpromise/* resolvedSyncPromise */.WD)();
    }

        var filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems );

    // Creates client report for each item in an envelope
    var recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (_, type) => {
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));
      });
    };

    var requestTask = () =>
      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
        response => {
          // We don't want to throw on NOK responses, but we want to at least log them
          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {
            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
          }

          rateLimits = updateRateLimits(rateLimits, response);
        },
        error => {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('Failed while sending event:', error);
          recordEnvelopeLoss('network_error');
        },
      );

    return buffer.add(requestTask).then(
      result => result,
      error => {
        if (error instanceof SentryError) {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('Skipped sending event due to full buffer');
          recordEnvelopeLoss('queue_overflow');
          return (0,syncpromise/* resolvedSyncPromise */.WD)();
        } else {
          throw error;
        }
      },
    );
  }

  return {
    send,
    flush,
  };
}


//# sourceMappingURL=base.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/global.js
var esm_global = __webpack_require__(65907);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/instrument.js
var instrument = __webpack_require__(64005);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/is.js
var is = __webpack_require__(81757);
// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/browser.js
var browser = __webpack_require__(54194);
;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/memo.js
/**
 * Helper to decycle json objects
 */
function memoBuilder() {
  var hasWeakSet = typeof WeakSet === 'function';
  var inner = hasWeakSet ? new WeakSet() : [];
  function memoize(obj) {
    if (hasWeakSet) {
      if (inner.has(obj)) {
        return true;
      }
      inner.add(obj);
      return false;
    }
        for (let i = 0; i < inner.length; i++) {
      var value = inner[i];
      if (value === obj) {
        return true;
      }
    }
    inner.push(obj);
    return false;
  }

  function unmemoize(obj) {
    if (hasWeakSet) {
      inner.delete(obj);
    } else {
      for (let i = 0; i < inner.length; i++) {
        if (inner[i] === obj) {
          inner.splice(i, 1);
          break;
        }
      }
    }
  }
  return [memoize, unmemoize];
}


//# sourceMappingURL=memo.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/stacktrace.js
var stacktrace = __webpack_require__(69038);
;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/normalize.js





/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
function normalize(input, depth = +Infinity, maxProperties = +Infinity) {
  try {
    // since we're at the outermost level, we don't provide a key
    return visit('', input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}

/** JSDoc */
function normalizeToSize(
    object,
  // Default Node.js REPL depth
  depth = 3,
  // 100kB, as 200kB is max payload size, so half sounds reasonable
  maxSize = 100 * 1024,
) {
  var normalized = normalize(object, depth);

  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }

  return normalized ;
}

/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
function visit(
  key,
  value,
  depth = +Infinity,
  maxProperties = +Infinity,
  memo = memoBuilder(),
) {
  const [memoize, unmemoize] = memo;

  // Get the simple cases out of the way first
  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !(0,is/* isNaN */.i2)(value))) {
    return value ;
  }

  var stringified = stringifyValue(key, value);

  // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
  // Everything else will have already been serialized, so if we don't see that pattern, we're done.
  if (!stringified.startsWith('[object ')) {
    return stringified;
  }

  // From here on, we can assert that `value` is either an object or an array.

  // Do not normalize objects that we know have already been normalized. As a general rule, the
  // "__sentry_skip_normalization__" property should only be used sparingly and only should only be set on objects that
  // have already been normalized.
  if ((value )['__sentry_skip_normalization__']) {
    return value ;
  }

  // We're also done if we've reached the max depth
  if (depth === 0) {
    // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
    return stringified.replace('object ', '');
  }

  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
  if (memoize(value)) {
    return '[Circular ~]';
  }

  // If the value has a `toJSON` method, we call it to extract more information
  var valueWithToJSON = value ;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
    try {
      var jsonValue = valueWithToJSON.toJSON();
      // We need to normalize the return value of `.toJSON()` in case it has circular references
      return visit('', jsonValue, depth - 1, maxProperties, memo);
    } catch (err) {
      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
    }
  }

  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
  // property/entry, and keep track of the number of items we add to it.
  var normalized = (Array.isArray(value) ? [] : {}) ;
  let numAdded = 0;

  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
  // properties are non-enumerable and otherwise would get missed.
  var visitable = (0,object/* convertToPlainObject */.Sh)(value );

  for (var visitKey in visitable) {
    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }

    if (numAdded >= maxProperties) {
      normalized[visitKey] = '[MaxProperties ~]';
      break;
    }

    // Recursively visit all the child nodes
    var visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);

    numAdded += 1;
  }

  // Once we've visited all the branches, remove the parent from memo storage
  unmemoize(value);

  // Return accumulated values
  return normalized;
}

/**
 * Stringify the given value. Handles various known special values and types.
 *
 * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
 * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
 *
 * @param value The value to stringify
 * @returns A stringified representation of the given value
 */
function stringifyValue(
  key,
  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
  // our internal use, it'll do
  value,
) {
  try {
    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {
      return '[Domain]';
    }

    if (key === 'domainEmitter') {
      return '[DomainEmitter]';
    }

    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
    // which won't throw if they are not present.

    if (typeof global !== 'undefined' && value === global) {
      return '[Global]';
    }

        if (typeof window !== 'undefined' && value === window) {
      return '[Window]';
    }

        if (typeof document !== 'undefined' && value === document) {
      return '[Document]';
    }

    // React's SyntheticEvent thingy
    if ((0,is/* isSyntheticEvent */.Cy)(value)) {
      return '[SyntheticEvent]';
    }

    if (typeof value === 'number' && value !== value) {
      return '[NaN]';
    }

    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)
    if (value === void 0) {
      return '[undefined]';
    }

    if (typeof value === 'function') {
      return `[Function: ${(0,stacktrace/* getFunctionName */.$P)(value)}]`;
    }

    if (typeof value === 'symbol') {
      return `[${String(value)}]`;
    }

    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
    if (typeof value === 'bigint') {
      return `[BigInt: ${String(value)}]`;
    }

    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
    // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
    // we can make sure that only plain objects come out that way.
    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}

/** Calculates bytes size of input string */
function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
}

/** Calculates bytes size of input object */
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}


//# sourceMappingURL=normalize.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/eventbuilder.js


/**
 * This function creates an exception from a JavaScript Error
 */
function exceptionFromError(stackParser, ex) {
  // Get the frames first since Opera can lose the stack if we touch anything else first
  var frames = parseStackFrames(stackParser, ex);

  var exception = {
    type: ex && ex.name,
    value: extractMessage(ex),
  };

  if (frames.length) {
    exception.stacktrace = { frames };
  }

  if (exception.type === undefined && exception.value === '') {
    exception.value = 'Unrecoverable error caught';
  }

  return exception;
}

/**
 * @hidden
 */
function eventFromPlainObject(
  stackParser,
  exception,
  syntheticException,
  isUnhandledRejection,
) {
  var event = {
    exception: {
      values: [
        {
          type: (0,is/* isEvent */.cO)(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',
          value: `Non-Error ${
            isUnhandledRejection ? 'promise rejection' : 'exception'
          } captured with keys: ${(0,object/* extractExceptionKeysForMessage */.zf)(exception)}`,
        },
      ],
    },
    extra: {
      __serialized__: normalizeToSize(exception),
    },
  };

  if (syntheticException) {
    var frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      // event.exception.values[0] has been set above
      (event.exception ).values[0].stacktrace = { frames };
    }
  }

  return event;
}

/**
 * @hidden
 */
function eventFromError(stackParser, ex) {
  return {
    exception: {
      values: [exceptionFromError(stackParser, ex)],
    },
  };
}

/** Parses stack frames from an error */
function parseStackFrames(
  stackParser,
  ex,
) {
  // Access and store the stacktrace property before doing ANYTHING
  // else to it because Opera is not very good at providing it
  // reliably in other circumstances.
  var stacktrace = ex.stacktrace || ex.stack || '';

  var popSize = getPopSize(ex);

  try {
    return stackParser(stacktrace, popSize);
  } catch (e) {
    // no-empty
  }

  return [];
}

// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108
var reactMinifiedRegexp = /Minified React error #\d+;/i;

function getPopSize(ex) {
  if (ex) {
    if (typeof ex.framesToPop === 'number') {
      return ex.framesToPop;
    }

    if (reactMinifiedRegexp.test(ex.message)) {
      return 1;
    }
  }

  return 0;
}

/**
 * There are cases where stacktrace.message is an Event object
 * https://github.com/getsentry/sentry-javascript/issues/1949
 * In this specific case we try to extract stacktrace.message.error.message
 */
function extractMessage(ex) {
  var message = ex && ex.message;
  if (!message) {
    return 'No error message';
  }
  if (message.error && typeof message.error.message === 'string') {
    return message.error.message;
  }
  return message;
}

/**
 * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
 * @hidden
 */
function eventFromException(
  stackParser,
  exception,
  hint,
  attachStacktrace,
) {
  var syntheticException = (hint && hint.syntheticException) || undefined;
  var event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
  (0,misc/* addExceptionMechanism */.EG)(event); // defaults to { type: 'generic', handled: true }
  event.level = 'error';
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return (0,syncpromise/* resolvedSyncPromise */.WD)(event);
}

/**
 * Builds and Event from a Message
 * @hidden
 */
function eventFromMessage(
  stackParser,
  message,
    level = 'info',
  hint,
  attachStacktrace,
) {
  var syntheticException = (hint && hint.syntheticException) || undefined;
  var event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return (0,syncpromise/* resolvedSyncPromise */.WD)(event);
}

/**
 * @hidden
 */
function eventFromUnknownInput(
  stackParser,
  exception,
  syntheticException,
  attachStacktrace,
  isUnhandledRejection,
) {
  let event;

  if ((0,is/* isErrorEvent */.VW)(exception ) && (exception ).error) {
    // If it is an ErrorEvent with `error` property, extract it to get actual Error
    var errorEvent = exception ;
    return eventFromError(stackParser, errorEvent.error );
  }

  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name
  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be
  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.
  //
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
  // https://webidl.spec.whatwg.org/#es-DOMException-specialness
  if ((0,is/* isDOMError */.TX)(exception ) || (0,is/* isDOMException */.fm)(exception )) {
    var domException = exception ;

    if ('stack' in (exception )) {
      event = eventFromError(stackParser, exception );
    } else {
      var name = domException.name || ((0,is/* isDOMError */.TX)(domException) ? 'DOMError' : 'DOMException');
      var message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      (0,misc/* addExceptionTypeValue */.Db)(event, message);
    }
    if ('code' in domException) {
      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };
    }

    return event;
  }
  if ((0,is/* isError */.VZ)(exception)) {
    // we have a real Error object, do nothing
    return eventFromError(stackParser, exception);
  }
  if ((0,is/* isPlainObject */.PO)(exception) || (0,is/* isEvent */.cO)(exception)) {
    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize
    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new
    // group on any key/value change.
    var objectException = exception ;
    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
    (0,misc/* addExceptionMechanism */.EG)(event, {
      synthetic: true,
    });
    return event;
  }

  // If none of previous checks were valid, then it means that it's not:
  // - an instance of DOMError
  // - an instance of DOMException
  // - an instance of Event
  // - an instance of Error
  // - a valid ErrorEvent (one with an error property)
  // - a plain Object
  //
  // So bail out and capture it as a simple message:
  event = eventFromString(stackParser, exception , syntheticException, attachStacktrace);
  (0,misc/* addExceptionTypeValue */.Db)(event, `${exception}`, undefined);
  (0,misc/* addExceptionMechanism */.EG)(event, {
    synthetic: true,
  });

  return event;
}

/**
 * @hidden
 */
function eventFromString(
  stackParser,
  input,
  syntheticException,
  attachStacktrace,
) {
  var event = {
    message: input,
  };

  if (attachStacktrace && syntheticException) {
    var frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception = {
        values: [{ value: input, stacktrace: { frames } }],
      };
    }
  }

  return event;
}


//# sourceMappingURL=eventbuilder.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/helpers.js



let ignoreOnError = 0;

/**
 * @hidden
 */
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}

/**
 * @hidden
 */
function ignoreNextOnError() {
  // onerror should trigger before setTimeout
  ignoreOnError += 1;
  setTimeout(() => {
    ignoreOnError -= 1;
  });
}

/**
 * Instruments the given function and sends an event to Sentry every time the
 * function throws an exception.
 *
 * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always
 * has a correct `this` context.
 * @returns The wrapped function.
 * @hidden
 */
function wrap(
  fn,
  options

 = {},
  before,
  ) {
  // for future readers what this does is wrap a function and then create
  // a bi-directional wrapping between them.
  //
  // example: wrapped = wrap(original);
  //  original.__sentry_wrapped__ -> wrapped
  //  wrapped.__sentry_original__ -> original

  if (typeof fn !== 'function') {
    return fn;
  }

  try {
    // if we're dealing with a function that was previously wrapped, return
    // the original wrapper.
    var wrapper = fn.__sentry_wrapped__;
    if (wrapper) {
      return wrapper;
    }

    // We don't wanna wrap it twice
    if ((0,object/* getOriginalFunction */.HK)(fn)) {
      return fn;
    }
  } catch (e) {
    // Just accessing custom props in some Selenium environments
    // can cause a "Permission denied" exception (see raven-js#495).
    // Bail on wrapping and return the function as-is (defers to window.onerror).
    return fn;
  }

    // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`
  var sentryWrapped = function () {
    var args = Array.prototype.slice.call(arguments);

    try {
      if (before && typeof before === 'function') {
        before.apply(this, arguments);
      }

            var wrappedArguments = args.map((arg) => wrap(arg, options));

      // Attempt to invoke user-land function
      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
      //       means the sentry.javascript SDK caught an error invoking your application code. This
      //       is expected behavior and NOT indicative of a bug with sentry.javascript.
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();

      withScope((scope) => {
        scope.addEventProcessor((event) => {
          if (options.mechanism) {
            (0,misc/* addExceptionTypeValue */.Db)(event, undefined, undefined);
            (0,misc/* addExceptionMechanism */.EG)(event, options.mechanism);
          }

          event.extra = {
            ...event.extra,
            arguments: args,
          };

          return event;
        });

        captureException(ex);
      });

      throw ex;
    }
  };
  
  // Accessing some objects may throw
  // ref: https://github.com/getsentry/sentry-javascript/issues/1168
  try {
    for (var property in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property)) {
        sentryWrapped[property] = fn[property];
      }
    }
  } catch (_oO) {} 
  // Signal that this function has been wrapped/filled already
  // for both debugging and to prevent it to being wrapped/filled twice
  (0,object/* markFunctionWrapped */.$Q)(sentryWrapped, fn);

  (0,object/* addNonEnumerableProperty */.xp)(fn, '__sentry_wrapped__', sentryWrapped);

  // Restore original function name (not all browsers allow that)
  try {
    var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') ;
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, 'name', {
        get() {
          return fn.name;
        },
      });
    }
      } catch (_oO) {}

  return sentryWrapped;
}

/**
 * All properties the report dialog supports
 */


//# sourceMappingURL=helpers.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/globalhandlers.js





/** Global handlers */
class GlobalHandlers  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'GlobalHandlers';}

  /**
   * @inheritDoc
   */
   __init() {this.name = GlobalHandlers.id;}

  /** JSDoc */
  

  /**
   * Stores references functions to installing handlers. Will set to undefined
   * after they have been run so that they are not used twice.
   */
   __init2() {this._installFunc = {
    onerror: _installGlobalOnErrorHandler,
    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,
  };}

  /** JSDoc */
   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);
    this._options = {
      onerror: true,
      onunhandledrejection: true,
      ...options,
    };
  }
  /**
   * @inheritDoc
   */
   setupOnce() {
    Error.stackTraceLimit = 50;
    var options = this._options;

    // We can disable guard-for-in as we construct the options object above + do checks against
    // `this._installFunc` for the property.
        for (var key in options) {
      var installFunc = this._installFunc[key ];
      if (installFunc && options[key ]) {
        globalHandlerLog(key);
        installFunc();
        this._installFunc[key ] = undefined;
      }
    }
  }
} GlobalHandlers.__initStatic();

/** JSDoc */
function _installGlobalOnErrorHandler() {
  (0,instrument/* addInstrumentationHandler */.o)(
    'error',
        (data) => {
      const [hub, stackParser, attachStacktrace] = getHubAndOptions();
      if (!hub.getIntegration(GlobalHandlers)) {
        return;
      }
      const { msg, url, line, column, error } = data;
      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {
        return;
      }

      var event =
        error === undefined && (0,is/* isString */.HD)(msg)
          ? _eventFromIncompleteOnError(msg, url, line, column)
          : _enhanceEventWithInitialFrame(
              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),
              url,
              line,
              column,
            );

      event.level = 'error';

      addMechanismAndCapture(hub, error, event, 'onerror');
    },
  );
}

/** JSDoc */
function _installGlobalOnUnhandledRejectionHandler() {
  (0,instrument/* addInstrumentationHandler */.o)(
    'unhandledrejection',
        (e) => {
      const [hub, stackParser, attachStacktrace] = getHubAndOptions();
      if (!hub.getIntegration(GlobalHandlers)) {
        return;
      }
      let error = e;

      // dig the object of the rejection out of known event types
      try {
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in e) {
          error = e.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in e && 'reason' in e.detail) {
          error = e.detail.reason;
        }
      } catch (_oO) {
        // no-empty
      }

      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {
        return true;
      }

      var event = (0,is/* isPrimitive */.pt)(error)
        ? _eventFromRejectionWithPrimitive(error)
        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);

      event.level = 'error';

      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');
      return;
    },
  );
}

/**
 * Create an event from a promise rejection where the `reason` is a primitive.
 *
 * @param reason: The `reason` property of the promise rejection
 * @returns An Event object with an appropriate `exception` value
 */
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: 'UnhandledRejection',
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(reason)}`,
        },
      ],
    },
  };
}

/**
 * This function creates a stack from an old, error-less onerror handler.
 */
function _eventFromIncompleteOnError(msg, url, line, column) {
  var ERROR_TYPES_RE =
    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;

  // If 'message' is ErrorEvent, get real message from inside
  let message = (0,is/* isErrorEvent */.VW)(msg) ? msg.message : msg;
  let name = 'Error';

  var groups = message.match(ERROR_TYPES_RE);
  if (groups) {
    name = groups[1];
    message = groups[2];
  }

  var event = {
    exception: {
      values: [
        {
          type: name,
          value: message,
        },
      ],
    },
  };

  return _enhanceEventWithInitialFrame(event, url, line, column);
}

/** JSDoc */
function _enhanceEventWithInitialFrame(event, url, line, column) {
  // event.exception
  var e = (event.exception = event.exception || {});
  // event.exception.values
  var ev = (e.values = e.values || []);
  // event.exception.values[0]
  var ev0 = (ev[0] = ev[0] || {});
  // event.exception.values[0].stacktrace
  var ev0s = (ev0.stacktrace = ev0.stacktrace || {});
  // event.exception.values[0].stacktrace.frames
  var ev0sf = (ev0s.frames = ev0s.frames || []);

  var colno = isNaN(parseInt(column, 10)) ? undefined : column;
  var lineno = isNaN(parseInt(line, 10)) ? undefined : line;
  var filename = (0,is/* isString */.HD)(url) && url.length > 0 ? url : (0,browser/* getLocationHref */.l)();

  // event.exception.values[0].stacktrace.frames
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: '?',
      in_app: true,
      lineno,
    });
  }

  return event;
}

function globalHandlerLog(type) {
  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`Global Handler attached: ${type}`);
}

function addMechanismAndCapture(hub, error, event, type) {
  (0,misc/* addExceptionMechanism */.EG)(event, {
    handled: false,
    type,
  });
  hub.captureEvent(event, {
    originalException: error,
  });
}

function getHubAndOptions() {
  var hub = (0,esm_hub/* getCurrentHub */.Gd)();
  var client = hub.getClient();
  var options = (client && client.getOptions()) || {
    stackParser: () => [],
    attachStacktrace: false,
  };
  return [hub, options.stackParser, options.attachStacktrace];
}


//# sourceMappingURL=globalhandlers.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/trycatch.js



var DEFAULT_EVENT_TARGET = [
  'EventTarget',
  'Window',
  'Node',
  'ApplicationCache',
  'AudioTrackList',
  'ChannelMergerNode',
  'CryptoOperation',
  'EventSource',
  'FileReader',
  'HTMLUnknownElement',
  'IDBDatabase',
  'IDBRequest',
  'IDBTransaction',
  'KeyOperation',
  'MediaController',
  'MessagePort',
  'ModalWindow',
  'Notification',
  'SVGElementInstance',
  'Screen',
  'TextTrack',
  'TextTrackCue',
  'TextTrackList',
  'WebSocket',
  'WebSocketWorker',
  'Worker',
  'XMLHttpRequest',
  'XMLHttpRequestEventTarget',
  'XMLHttpRequestUpload',
];

/** Wrap timer functions and event targets to catch errors and provide better meta data */
class TryCatch  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'TryCatch';}

  /**
   * @inheritDoc
   */
   __init() {this.name = TryCatch.id;}

  /** JSDoc */
  

  /**
   * @inheritDoc
   */
   constructor(options) {;TryCatch.prototype.__init.call(this);
    this._options = {
      XMLHttpRequest: true,
      eventTarget: true,
      requestAnimationFrame: true,
      setInterval: true,
      setTimeout: true,
      ...options,
    };
  }

  /**
   * Wrap timer functions and event targets to catch errors
   * and provide better metadata.
   */
   setupOnce() {
    var global = (0,esm_global/* getGlobalObject */.R)();

    if (this._options.setTimeout) {
      (0,object/* fill */.hl)(global, 'setTimeout', _wrapTimeFunction);
    }

    if (this._options.setInterval) {
      (0,object/* fill */.hl)(global, 'setInterval', _wrapTimeFunction);
    }

    if (this._options.requestAnimationFrame) {
      (0,object/* fill */.hl)(global, 'requestAnimationFrame', _wrapRAF);
    }

    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {
      (0,object/* fill */.hl)(XMLHttpRequest.prototype, 'send', _wrapXHR);
    }

    var eventTargetOption = this._options.eventTarget;
    if (eventTargetOption) {
      var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
      eventTarget.forEach(_wrapEventTarget);
    }
  }
} TryCatch.__initStatic();

/** JSDoc */
function _wrapTimeFunction(original) {
    return function ( ...args) {
    var originalCallback = args[0];
    args[0] = wrap(originalCallback, {
      mechanism: {
        data: { function: (0,stacktrace/* getFunctionName */.$P)(original) },
        handled: true,
        type: 'instrument',
      },
    });
    return original.apply(this, args);
  };
}

/** JSDoc */
function _wrapRAF(original) {
    return function ( callback) {
        return original.apply(this, [
      wrap(callback, {
        mechanism: {
          data: {
            function: 'requestAnimationFrame',
            handler: (0,stacktrace/* getFunctionName */.$P)(original),
          },
          handled: true,
          type: 'instrument',
        },
      }),
    ]);
  };
}

/** JSDoc */
function _wrapXHR(originalSend) {
    return function ( ...args) {
        var xhr = this;
    var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];

    xmlHttpRequestProps.forEach(prop => {
      if (prop in xhr && typeof xhr[prop] === 'function') {
                (0,object/* fill */.hl)(xhr, prop, function (original) {
          var wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: (0,stacktrace/* getFunctionName */.$P)(original),
              },
              handled: true,
              type: 'instrument',
            },
          };

          // If Instrument integration has been called before TryCatch, get the name of original function
          var originalFunction = (0,object/* getOriginalFunction */.HK)(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = (0,stacktrace/* getFunctionName */.$P)(originalFunction);
          }

          // Otherwise wrap directly
          return wrap(original, wrapOptions);
        });
      }
    });

    return originalSend.apply(this, args);
  };
}

/** JSDoc */
function _wrapEventTarget(target) {
    var global = (0,esm_global/* getGlobalObject */.R)() ;
    var proto = global[target] && global[target].prototype;

    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
    return;
  }

  (0,object/* fill */.hl)(proto, 'addEventListener', function (original)

 {
    return function (
            
      eventName,
      fn,
      options,
    ) {
      try {
        if (typeof fn.handleEvent === 'function') {
          // ESlint disable explanation:
          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would
          //  introduce a bug here, because bind returns a new function that doesn't have our
          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.
          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.
                    fn.handleEvent = wrap(fn.handleEvent, {
            mechanism: {
              data: {
                function: 'handleEvent',
                handler: (0,stacktrace/* getFunctionName */.$P)(fn),
                target,
              },
              handled: true,
              type: 'instrument',
            },
          });
        }
      } catch (err) {
        // can sometimes get 'Permission denied to access property "handle Event'
      }

      return original.apply(this, [
        eventName,
                wrap(fn , {
          mechanism: {
            data: {
              function: 'addEventListener',
              handler: (0,stacktrace/* getFunctionName */.$P)(fn),
              target,
            },
            handled: true,
            type: 'instrument',
          },
        }),
        options,
      ]);
    };
  });

  (0,object/* fill */.hl)(
    proto,
    'removeEventListener',
    function (
      originalRemoveEventListener,
          ) {
      return function (
                
        eventName,
        fn,
        options,
      ) {
        /**
         * There are 2 possible scenarios here:
         *
         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified
         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function
         * as a pass-through, and call original `removeEventListener` with it.
         *
         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using
         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.
         * This helper "wraps" whole callback inside a try/catch statement, and attached appropriate metadata to it,
         * in order for us to make a distinction between wrapped/non-wrapped functions possible.
         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.
         *
         * When someone adds a handler prior to initialization, and then do it again, but after,
         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible
         * to get rid of the initial handler and it'd stick there forever.
         */
        var wrappedEventHandler = fn ;
        try {
          var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
          if (originalEventHandler) {
            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
          }
        } catch (e) {
          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
        }
        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
      };
    },
  );
}


//# sourceMappingURL=trycatch.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/severity.js
// Note: Ideally the `SeverityLevel` type would be derived from `validSeverityLevels`, but that would mean either
//
// a) moving `validSeverityLevels` to `@sentry/types`,
// b) moving the`SeverityLevel` type here, or
// c) importing `validSeverityLevels` from here into `@sentry/types`.
//
// Option A would make `@sentry/types` a runtime dependency of `@sentry/utils` (not good), and options B and C would
// create a circular dependency between `@sentry/types` and `@sentry/utils` (also not good). So a TODO accompanying the
// type, reminding anyone who changes it to change this list also, will have to do.

var validSeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug'];

/**
 * Converts a string-based level into a member of the deprecated {@link Severity} enum.
 *
 * @deprecated `severityFromString` is deprecated. Please use `severityLevelFromString` instead.
 *
 * @param level String representation of Severity
 * @returns Severity
 */
function severityFromString(level) {
  return severityLevelFromString(level) ;
}

/**
 * Converts a string-based level into a `SeverityLevel`, normalizing it along the way.
 *
 * @param level String representation of desired `SeverityLevel`.
 * @returns The `SeverityLevel` corresponding to the given string, or 'log' if the string isn't a valid level.
 */
function severityLevelFromString(level) {
  return (level === 'warn' ? 'warning' : validSeverityLevels.includes(level) ? level : 'log') ;
}


//# sourceMappingURL=severity.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/breadcrumbs.js



/** JSDoc */

var BREADCRUMB_INTEGRATION_ID = 'Breadcrumbs';

/**
 * Default Breadcrumbs instrumentations
 * TODO: Deprecated - with v6, this will be renamed to `Instrument`
 */
class Breadcrumbs  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = BREADCRUMB_INTEGRATION_ID;}

  /**
   * @inheritDoc
   */
   __init() {this.name = Breadcrumbs.id;}

  /**
   * Options of the breadcrumbs integration.
   */
  // This field is public, because we use it in the browser client to check if the `sentry` option is enabled.
  

  /**
   * @inheritDoc
   */
   constructor(options) {;Breadcrumbs.prototype.__init.call(this);
    this.options = {
      console: true,
      dom: true,
      fetch: true,
      history: true,
      sentry: true,
      xhr: true,
      ...options,
    };
  }

  /**
   * Instrument browser built-ins w/ breadcrumb capturing
   *  - Console API
   *  - DOM API (click/typing)
   *  - XMLHttpRequest API
   *  - Fetch API
   *  - History API
   */
   setupOnce() {
    if (this.options.console) {
      (0,instrument/* addInstrumentationHandler */.o)('console', _consoleBreadcrumb);
    }
    if (this.options.dom) {
      (0,instrument/* addInstrumentationHandler */.o)('dom', _domBreadcrumb(this.options.dom));
    }
    if (this.options.xhr) {
      (0,instrument/* addInstrumentationHandler */.o)('xhr', _xhrBreadcrumb);
    }
    if (this.options.fetch) {
      (0,instrument/* addInstrumentationHandler */.o)('fetch', _fetchBreadcrumb);
    }
    if (this.options.history) {
      (0,instrument/* addInstrumentationHandler */.o)('history', _historyBreadcrumb);
    }
  }
} Breadcrumbs.__initStatic();

/**
 * A HOC that creaes a function that creates breadcrumbs from DOM API calls.
 * This is a HOC so that we get access to dom options in the closure.
 */
function _domBreadcrumb(dom) {
    function _innerDomBreadcrumb(handlerData) {
    let target;
    let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;

    if (typeof keyAttrs === 'string') {
      keyAttrs = [keyAttrs];
    }

    // Accessing event.target can throw (see getsentry/raven-js#838, #768)
    try {
      target = handlerData.event.target
        ? (0,browser/* htmlTreeAsString */.R)(handlerData.event.target , keyAttrs)
        : (0,browser/* htmlTreeAsString */.R)(handlerData.event , keyAttrs);
    } catch (e) {
      target = '<unknown>';
    }

    if (target.length === 0) {
      return;
    }

    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(
      {
        category: `ui.${handlerData.name}`,
        message: target,
      },
      {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global,
      },
    );
  }

  return _innerDomBreadcrumb;
}

/**
 * Creates breadcrumbs from console API calls
 */
function _consoleBreadcrumb(handlerData) {
  var breadcrumb = {
    category: 'console',
    data: {
      arguments: handlerData.args,
      logger: 'console',
    },
    level: severityLevelFromString(handlerData.level),
    message: (0,string/* safeJoin */.nK)(handlerData.args, ' '),
  };

  if (handlerData.level === 'assert') {
    if (handlerData.args[0] === false) {
      breadcrumb.message = `Assertion failed: ${(0,string/* safeJoin */.nK)(handlerData.args.slice(1), ' ') || 'console.assert'}`;
      breadcrumb.data.arguments = handlerData.args.slice(1);
    } else {
      // Don't capture a breadcrumb for passed assertions
      return;
    }
  }

  (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(breadcrumb, {
    input: handlerData.args,
    level: handlerData.level,
  });
}

/**
 * Creates breadcrumbs from XHR API calls
 */
function _xhrBreadcrumb(handlerData) {
  if (handlerData.endTimestamp) {
    // We only capture complete, non-sentry requests
    if (handlerData.xhr.__sentry_own_request__) {
      return;
    }

    const { method, url, status_code, body } = handlerData.xhr.__sentry_xhr__ || {};

    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(
      {
        category: 'xhr',
        data: {
          method,
          url,
          status_code,
        },
        type: 'http',
      },
      {
        xhr: handlerData.xhr,
        input: body,
      },
    );

    return;
  }
}

/**
 * Creates breadcrumbs from fetch API calls
 */
function _fetchBreadcrumb(handlerData) {
  // We only capture complete fetch requests
  if (!handlerData.endTimestamp) {
    return;
  }

  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {
    // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)
    return;
  }

  if (handlerData.error) {
    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(
      {
        category: 'fetch',
        data: handlerData.fetchData,
        level: 'error',
        type: 'http',
      },
      {
        data: handlerData.error,
        input: handlerData.args,
      },
    );
  } else {
    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(
      {
        category: 'fetch',
        data: {
          ...handlerData.fetchData,
          status_code: handlerData.response.status,
        },
        type: 'http',
      },
      {
        input: handlerData.args,
        response: handlerData.response,
      },
    );
  }
}

/**
 * Creates breadcrumbs from history API calls
 */
function _historyBreadcrumb(handlerData) {
  var global = (0,esm_global/* getGlobalObject */.R)();
  let from = handlerData.from;
  let to = handlerData.to;
  var parsedLoc = (0,misc/* parseUrl */.en)(global.location.href);
  let parsedFrom = (0,misc/* parseUrl */.en)(from);
  var parsedTo = (0,misc/* parseUrl */.en)(to);

  // Initial pushState doesn't provide `from` information
  if (!parsedFrom.path) {
    parsedFrom = parsedLoc;
  }

  // Use only the path component of the URL if the URL matches the current
  // document (almost all the time when using pushState)
  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
    to = parsedTo.relative;
  }
  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
    from = parsedFrom.relative;
  }

  (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb({
    category: 'navigation',
    data: {
      from,
      to,
    },
  });
}


//# sourceMappingURL=breadcrumbs.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/linkederrors.js




var DEFAULT_KEY = 'cause';
var DEFAULT_LIMIT = 5;

/** Adds SDK info to an event. */
class LinkedErrors  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'LinkedErrors';}

  /**
   * @inheritDoc
   */
    __init() {this.name = LinkedErrors.id;}

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
   constructor(options = {}) {;LinkedErrors.prototype.__init.call(this);
    this._key = options.key || DEFAULT_KEY;
    this._limit = options.limit || DEFAULT_LIMIT;
  }

  /**
   * @inheritDoc
   */
   setupOnce() {
    var client = (0,esm_hub/* getCurrentHub */.Gd)().getClient();
    if (!client) {
      return;
    }
    (0,esm_scope/* addGlobalEventProcessor */.c)((event, hint) => {
      var self = (0,esm_hub/* getCurrentHub */.Gd)().getIntegration(LinkedErrors);
      return self ? _handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;
    });
  }
} LinkedErrors.__initStatic();

/**
 * @inheritDoc
 */
function _handler(
  parser,
  key,
  limit,
  event,
  hint,
) {
  if (!event.exception || !event.exception.values || !hint || !(0,is/* isInstanceOf */.V9)(hint.originalException, Error)) {
    return event;
  }
  var linkedErrors = _walkErrorTree(parser, limit, hint.originalException , key);
  event.exception.values = [...linkedErrors, ...event.exception.values];
  return event;
}

/**
 * JSDOC
 */
function _walkErrorTree(
  parser,
  limit,
  error,
  key,
  stack = [],
) {
  if (!(0,is/* isInstanceOf */.V9)(error[key], Error) || stack.length + 1 >= limit) {
    return stack;
  }
  var exception = exceptionFromError(parser, error[key]);
  return _walkErrorTree(parser, limit, error[key], key, [exception, ...stack]);
}


//# sourceMappingURL=linkederrors.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/httpcontext.js



var httpcontext_global = (0,esm_global/* getGlobalObject */.R)();

/** HttpContext integration collects information about HTTP request headers */
class HttpContext  {constructor() { HttpContext.prototype.__init.call(this); }
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'HttpContext';}

  /**
   * @inheritDoc
   */
   __init() {this.name = HttpContext.id;}

  /**
   * @inheritDoc
   */
   setupOnce() {
    (0,esm_scope/* addGlobalEventProcessor */.c)((event) => {
      if ((0,esm_hub/* getCurrentHub */.Gd)().getIntegration(HttpContext)) {
        // if none of the information we want exists, don't bother
        if (!httpcontext_global.navigator && !httpcontext_global.location && !httpcontext_global.document) {
          return event;
        }

        // grab as much info as exists and add it to the event
        var url = (event.request && event.request.url) || (httpcontext_global.location && httpcontext_global.location.href);
        const { referrer } = httpcontext_global.document || {};
        const { userAgent } = httpcontext_global.navigator || {};

        var headers = {
          ...(event.request && event.request.headers),
          ...(referrer && { Referer: referrer }),
          ...(userAgent && { 'User-Agent': userAgent }),
        };
        var request = { ...(url && { url }), headers };

        return { ...event, request };
      }
      return event;
    });
  }
} HttpContext.__initStatic();


//# sourceMappingURL=httpcontext.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/dedupe.js


/** Deduplication filter */
class Dedupe  {constructor() { Dedupe.prototype.__init.call(this); }
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'Dedupe';}

  /**
   * @inheritDoc
   */
   __init() {this.name = Dedupe.id;}

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
   setupOnce(addGlobalEventProcessor, getCurrentHub) {
    var eventProcessor = currentEvent => {
      var self = getCurrentHub().getIntegration(Dedupe);
      if (self) {
        // Juuust in case something goes wrong
        try {
          if (dedupe_shouldDropEvent(currentEvent, self._previousEvent)) {
            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('Event dropped due to being a duplicate of previously captured event.');
            return null;
          }
        } catch (_oO) {
          return (self._previousEvent = currentEvent);
        }

        return (self._previousEvent = currentEvent);
      }
      return currentEvent;
    };

    eventProcessor.id = this.name;
    addGlobalEventProcessor(eventProcessor);
  }
} Dedupe.__initStatic();

/** JSDoc */
function dedupe_shouldDropEvent(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }

  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }

  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }

  return false;
}

/** JSDoc */
function _isSameMessageEvent(currentEvent, previousEvent) {
  var currentMessage = currentEvent.message;
  var previousMessage = previousEvent.message;

  // If neither event has a message property, they were both exceptions, so bail out
  if (!currentMessage && !previousMessage) {
    return false;
  }

  // If only one event has a stacktrace, but not the other one, they are not the same
  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {
    return false;
  }

  if (currentMessage !== previousMessage) {
    return false;
  }

  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }

  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }

  return true;
}

/** JSDoc */
function _isSameExceptionEvent(currentEvent, previousEvent) {
  var previousException = _getExceptionFromEvent(previousEvent);
  var currentException = _getExceptionFromEvent(currentEvent);

  if (!previousException || !currentException) {
    return false;
  }

  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }

  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }

  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }

  return true;
}

/** JSDoc */
function _isSameStacktrace(currentEvent, previousEvent) {
  let currentFrames = _getFramesFromEvent(currentEvent);
  let previousFrames = _getFramesFromEvent(previousEvent);

  // If neither event has a stacktrace, they are assumed to be the same
  if (!currentFrames && !previousFrames) {
    return true;
  }

  // If only one event has a stacktrace, but not the other one, they are not the same
  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {
    return false;
  }

  currentFrames = currentFrames ;
  previousFrames = previousFrames ;

  // If number of frames differ, they are not the same
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }

  // Otherwise, compare the two
  for (let i = 0; i < previousFrames.length; i++) {
    var frameA = previousFrames[i];
    var frameB = currentFrames[i];

    if (
      frameA.filename !== frameB.filename ||
      frameA.lineno !== frameB.lineno ||
      frameA.colno !== frameB.colno ||
      frameA.function !== frameB.function
    ) {
      return false;
    }
  }

  return true;
}

/** JSDoc */
function _isSameFingerprint(currentEvent, previousEvent) {
  let currentFingerprint = currentEvent.fingerprint;
  let previousFingerprint = previousEvent.fingerprint;

  // If neither event has a fingerprint, they are assumed to be the same
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }

  // If only one event has a fingerprint, but not the other one, they are not the same
  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {
    return false;
  }

  currentFingerprint = currentFingerprint ;
  previousFingerprint = previousFingerprint ;

  // Otherwise, compare the two
  try {
    return !!(currentFingerprint.join('') === previousFingerprint.join(''));
  } catch (_oO) {
    return false;
  }
}

/** JSDoc */
function _getExceptionFromEvent(event) {
  return event.exception && event.exception.values && event.exception.values[0];
}

/** JSDoc */
function _getFramesFromEvent(event) {
  var exception = event.exception;

  if (exception) {
    try {
      // @ts-ignore Object could be undefined
      return exception.values[0].stacktrace.frames;
    } catch (_oO) {
      return undefined;
    }
  }
  return undefined;
}


//# sourceMappingURL=dedupe.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/integrations/index.js






//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/hub/esm/session.js
var esm_session = __webpack_require__(92430);
;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/dsn.js


/** Regular expression used to parse a Dsn. */
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function isValidProtocol(protocol) {
  return protocol === 'http' || protocol === 'https';
}

/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
function dsnToString(dsn, withPassword = false) {
  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
  return (
    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +
    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`
  );
}

/**
 * Parses a Dsn from a given string.
 *
 * @param str A Dsn as string
 * @returns Dsn as DsnComponents
 */
function dsnFromString(str) {
  var match = DSN_REGEX.exec(str);

  if (!match) {
    throw new SentryError(`Invalid Sentry Dsn: ${str}`);
  }

  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);
  let path = '';
  let projectId = lastPath;

  var split = projectId.split('/');
  if (split.length > 1) {
    path = split.slice(0, -1).join('/');
    projectId = split.pop() ;
  }

  if (projectId) {
    var projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }

  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });
}

function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || '',
    pass: components.pass || '',
    host: components.host,
    port: components.port || '',
    path: components.path || '',
    projectId: components.projectId,
  };
}

function validateDsn(dsn) {
  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
    return;
  }

  const { port, projectId, protocol } = dsn;

  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
  requiredComponents.forEach(component => {
    if (!dsn[component]) {
      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);
    }
  });

  if (!projectId.match(/^\d+$/)) {
    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
  }

  if (!isValidProtocol(protocol)) {
    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
  }

  if (port && isNaN(parseInt(port, 10))) {
    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);
  }

  return true;
}

/** The Sentry Dsn, identifying a Sentry instance and project. */
function makeDsn(from) {
  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
  validateDsn(components);
  return components;
}

/**
 * Changes a Dsn to point to the `relay` server running in the Lambda Extension.
 *
 * This is only used by the serverless integration for AWS Lambda.
 *
 * @param originalDsn The original Dsn of the customer.
 * @returns Dsn pointing to Lambda extension.
 */
function extensionRelayDSN(originalDsn) {
  if (originalDsn === undefined) {
    return undefined;
  }

  var dsn = dsnFromString(originalDsn);
  dsn.host = 'localhost';
  dsn.port = '3000';
  dsn.protocol = 'http';

  return dsnToString(dsn);
}


//# sourceMappingURL=dsn.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/time.js
var time = __webpack_require__(7790);
;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/api.js


var SENTRY_API_VERSION = '7';

/** Returns the prefix to construct Sentry ingestion API endpoints. */
function getBaseApiEndpoint(dsn) {
  var protocol = dsn.protocol ? `${dsn.protocol}:` : '';
  var port = dsn.port ? `:${dsn.port}` : '';
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;
}

/** Returns the ingest API endpoint for target. */
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}

/** Returns a URL-encoded string with auth config suitable for a query string. */
function _encodedAuth(dsn) {
  return (0,object/* urlEncode */._j)({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: dsn.publicKey,
    sentry_version: SENTRY_API_VERSION,
  });
}

/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn)}`;
}

/** Returns the url to the report dialog endpoint. */
function getReportDialogEndpoint(
  dsnLike,
  dialogOptions

,
) {
  var dsn = makeDsn(dsnLike);
  var endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;

  let encodedOptions = `dsn=${dsnToString(dsn)}`;
  for (var key in dialogOptions) {
    if (key === 'dsn') {
      continue;
    }

    if (key === 'user') {
      var user = dialogOptions.user;
      if (!user) {
        continue;
      }
      if (user.name) {
        encodedOptions += `&name=${encodeURIComponent(user.name)}`;
      }
      if (user.email) {
        encodedOptions += `&email=${encodeURIComponent(user.email)}`;
      }
    } else {
      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] )}`;
    }
  }

  return `${endpoint}?${encodedOptions}`;
}


//# sourceMappingURL=api.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/baggage.js
var esm_baggage = __webpack_require__(46990);
;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/envelope.js


/** Extract sdk info from from the API metadata */
function getSdkMetadataForEnvelopeHeader(metadata) {
  if (!metadata || !metadata.sdk) {
    return;
  }
  const { name, version } = metadata.sdk;
  return { name, version };
}

/**
 * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
 * Merge with existing data if any.
 **/
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];
  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];
  return event;
}

/** Creates an envelope from a Session */
function createSessionEnvelope(
  session,
  dsn,
  metadata,
  tunnel,
) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  var envelopeHeaders = {
    sent_at: new Date().toISOString(),
    ...(sdkInfo && { sdk: sdkInfo }),
    ...(!!tunnel && { dsn: dsnToString(dsn) }),
  };

  var envelopeItem =
    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session];

  return createEnvelope(envelopeHeaders, [envelopeItem]);
}

/**
 * Create an Envelope from an event.
 */
function createEventEnvelope(
  event,
  dsn,
  metadata,
  tunnel,
) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  var eventType = event.type || 'event';

  const { transactionSampling } = event.sdkProcessingMetadata || {};
  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};

  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);

  var envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);

  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to
  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may
  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid
  // of this `delete`, lest we miss putting it back in the next time the property is in use.)
  delete event.sdkProcessingMetadata;

  var eventItem = [
    {
      type: eventType,
      sample_rates: [{ id: samplingMethod, rate: sampleRate }],
    },
    event,
  ];
  return createEnvelope(envelopeHeaders, [eventItem]);
}

function createEventEnvelopeHeaders(
  event,
  sdkInfo,
  tunnel,
  dsn,
) {
  var baggage = event.sdkProcessingMetadata && event.sdkProcessingMetadata.baggage;
  var dynamicSamplingContext = baggage && (0,esm_baggage/* getSentryBaggageItems */.Hk)(baggage);

  return {
    event_id: event.event_id ,
    sent_at: new Date().toISOString(),
    ...(sdkInfo && { sdk: sdkInfo }),
    ...(!!tunnel && { dsn: dsnToString(dsn) }),
    ...(event.type === 'transaction' &&
      dynamicSamplingContext && {
        trace: (0,object/* dropUndefinedKeys */.Jr)({ ...dynamicSamplingContext }) ,
      }),
  };
}


//# sourceMappingURL=envelope.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/integration.js



var installedIntegrations = [];

/** Map of integrations assigned to a client */

/**
 * @private
 */
function filterDuplicates(integrations) {
  return integrations.reduce((acc, integrations) => {
    if (acc.every(accIntegration => integrations.name !== accIntegration.name)) {
      acc.push(integrations);
    }
    return acc;
  }, [] );
}

/** Gets integration to install */
function getIntegrationsToSetup(options) {
  var defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];
  var userIntegrations = options.integrations;

  let integrations = [...filterDuplicates(defaultIntegrations)];

  if (Array.isArray(userIntegrations)) {
    // Filter out integrations that are also included in user options
    integrations = [
      ...integrations.filter(integrations =>
        userIntegrations.every(userIntegration => userIntegration.name !== integrations.name),
      ),
      // And filter out duplicated user options integrations
      ...filterDuplicates(userIntegrations),
    ];
  } else if (typeof userIntegrations === 'function') {
    integrations = userIntegrations(integrations);
    integrations = Array.isArray(integrations) ? integrations : [integrations];
  }

  // Make sure that if present, `Debug` integration will always run last
  var integrationsNames = integrations.map(i => i.name);
  var alwaysLastToRun = 'Debug';
  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
    integrations.push(...integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1));
  }

  return integrations;
}

/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
function setupIntegrations(integrations) {
  var integrationIndex = {};

  integrations.forEach(integration => {
    integrationIndex[integration.name] = integration;

    if (installedIntegrations.indexOf(integration.name) === -1) {
      integration.setupOnce(esm_scope/* addGlobalEventProcessor */.c, esm_hub/* getCurrentHub */.Gd);
      installedIntegrations.push(integration.name);
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`Integration installed: ${integration.name}`);
    }
  });

  return integrationIndex;
}


//# sourceMappingURL=integration.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/baseclient.js






var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";

/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(options);
 *   }
 *
 *   // ...
 * }
 */
class BaseClient {
  /** Options passed to the SDK. */
  

  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  

  /** Array of set up integrations. */
   __init() {this._integrations = {};}

  /** Indicates whether this client's integrations have been set up. */
   __init2() {this._integrationsInitialized = false;}

  /** Number of calls being processed */
   __init3() {this._numProcessing = 0;}

  /** Holds flushable  */
   __init4() {this._outcomes = {};}

  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
   constructor(options) {;BaseClient.prototype.__init.call(this);BaseClient.prototype.__init2.call(this);BaseClient.prototype.__init3.call(this);BaseClient.prototype.__init4.call(this);
    this._options = options;
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options.tunnel);
      this._transport = options.transport({
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url,
      });
    } else {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('No DSN provided, client will not do anything.');
    }
  }

  /**
   * @inheritDoc
   */
     captureException(exception, hint, scope) {
    // ensure we haven't captured this very object before
    if ((0,misc/* checkOrSetAlreadyCaught */.YO)(exception)) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(ALREADY_SEEN_ERROR);
      return;
    }

    let eventId = hint && hint.event_id;

    this._process(
      this.eventFromException(exception, hint)
        .then(event => this._captureEvent(event, hint, scope))
        .then(result => {
          eventId = result;
        }),
    );

    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureMessage(
    message,
        level,
    hint,
    scope,
  ) {
    let eventId = hint && hint.event_id;

    var promisedEvent = (0,is/* isPrimitive */.pt)(message)
      ? this.eventFromMessage(String(message), level, hint)
      : this.eventFromException(message, hint);

    this._process(
      promisedEvent
        .then(event => this._captureEvent(event, hint, scope))
        .then(result => {
          eventId = result;
        }),
    );

    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureEvent(event, hint, scope) {
    // ensure we haven't captured this very object before
    if (hint && hint.originalException && (0,misc/* checkOrSetAlreadyCaught */.YO)(hint.originalException)) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(ALREADY_SEEN_ERROR);
      return;
    }

    let eventId = hint && hint.event_id;

    this._process(
      this._captureEvent(event, hint, scope).then(result => {
        eventId = result;
      }),
    );

    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureSession(session) {
    if (!this._isEnabled()) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('SDK not enabled, will not capture session.');
      return;
    }

    if (!(typeof session.release === 'string')) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('Discarded session because of missing or non-string release');
    } else {
      this.sendSession(session);
      // After sending, we set init false to indicate it's not the first occurrence
      (0,esm_session/* updateSession */.CT)(session, { init: false });
    }
  }

  /**
   * @inheritDoc
   */
   getDsn() {
    return this._dsn;
  }

  /**
   * @inheritDoc
   */
   getOptions() {
    return this._options;
  }

  /**
   * @inheritDoc
   */
   getTransport() {
    return this._transport;
  }

  /**
   * @inheritDoc
   */
   flush(timeout) {
    var transport = this._transport;
    if (transport) {
      return this._isClientDoneProcessing(timeout).then(clientFinished => {
        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);
      });
    } else {
      return (0,syncpromise/* resolvedSyncPromise */.WD)(true);
    }
  }

  /**
   * @inheritDoc
   */
   close(timeout) {
    return this.flush(timeout).then(result => {
      this.getOptions().enabled = false;
      return result;
    });
  }

  /**
   * Sets up the integrations
   */
   setupIntegrations() {
    if (this._isEnabled() && !this._integrationsInitialized) {
      this._integrations = setupIntegrations(this._options.integrations);
      this._integrationsInitialized = true;
    }
  }

  /**
   * Gets an installed integration by its `id`.
   *
   * @returns The installed integration or `undefined` if no integration with that `id` was installed.
   */
   getIntegrationById(integrationId) {
    return this._integrations[integrationId];
  }

  /**
   * @inheritDoc
   */
   getIntegration(integration) {
    try {
      return (this._integrations[integration.id] ) || null;
    } catch (_oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
      return null;
    }
  }

  /**
   * @inheritDoc
   */
   sendEvent(event, hint = {}) {
    if (this._dsn) {
      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);

      for (var attachment of hint.attachments || []) {
        env = addItemToEnvelope(
          env,
          createAttachmentEnvelopeItem(
            attachment,
            this._options.transportOptions && this._options.transportOptions.textEncoder,
          ),
        );
      }

      this._sendEnvelope(env);
    }
  }

  /**
   * @inheritDoc
   */
   sendSession(session) {
    if (this._dsn) {
      var env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(env);
    }
  }

  /**
   * @inheritDoc
   */
   recordDroppedEvent(reason, category) {
    if (this._options.sendClientReports) {
      // We want to track each category (error, transaction, session) separately
      // but still keep the distinction between different type of outcomes.
      // We could use nested maps, but it's much easier to read and type this way.
      // A correct type for map-based implementation if we want to go that route
      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`
      // With typescript 4.1 we could even use template literal types
      var key = `${reason}:${category}`;
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`Adding outcome: "${key}"`);

      // The following works because undefined + 1 === NaN and NaN is falsy
      this._outcomes[key] = this._outcomes[key] + 1 || 1;
    }
  }

  /** Updates existing session based on the provided event */
   _updateSessionFromEvent(session, event) {
    let crashed = false;
    let errored = false;
    var exceptions = event.exception && event.exception.values;

    if (exceptions) {
      errored = true;

      for (var ex of exceptions) {
        var mechanism = ex.mechanism;
        if (mechanism && mechanism.handled === false) {
          crashed = true;
          break;
        }
      }
    }

    // A session is updated and that session update is sent in only one of the two following scenarios:
    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update
    var sessionNonTerminal = session.status === 'ok';
    var shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);

    if (shouldUpdateAndSend) {
      (0,esm_session/* updateSession */.CT)(session, {
        ...(crashed && { status: 'crashed' }),
        errors: session.errors || Number(errored || crashed),
      });
      this.captureSession(session);
    }
  }

  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
   _isClientDoneProcessing(timeout) {
    return new syncpromise/* SyncPromise */.cW(resolve => {
      let ticked = 0;
      var tick = 1;

      var interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  }

  /** Determines whether this SDK is enabled and a valid Dsn is present. */
   _isEnabled() {
    return this.getOptions().enabled !== false && this._dsn !== undefined;
  }

  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A new event with more information.
   */
   _prepareEvent(event, hint, scope) {
    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = this.getOptions();
    var prepared = {
      ...event,
      event_id: event.event_id || hint.event_id || (0,misc/* uuid4 */.DM)(),
      timestamp: event.timestamp || (0,time/* dateTimestampInSeconds */.yW)(),
    };

    this._applyClientOptions(prepared);
    this._applyIntegrationsMetadata(prepared);

    // If we have scope given to us, use it as the base for further modifications.
    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
    let finalScope = scope;
    if (hint.captureContext) {
      finalScope = esm_scope/* Scope.clone */.s.clone(finalScope).update(hint.captureContext);
    }

    // We prepare the result here with a resolved Event.
    let result = (0,syncpromise/* resolvedSyncPromise */.WD)(prepared);

    // This should be the last thing called, since we want that
    // {@link Hub.addEventProcessor} gets the finished prepared event.
    if (finalScope) {
      // Collect attachments from the hint and scope
      var attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];

      if (attachments.length) {
        hint.attachments = attachments;
      }

      // In case we have a hub we reassign it.
      result = finalScope.applyToEvent(prepared, hint);
    }

    return result.then(evt => {
      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  }

  /**
   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
   * Normalized keys:
   * - `breadcrumbs.data`
   * - `user`
   * - `contexts`
   * - `extra`
   * @param event Event
   * @returns Normalized event
   */
   _normalizeEvent(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }

    var normalized = {
      ...event,
      ...(event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map(b => ({
          ...b,
          ...(b.data && {
            data: normalize(b.data, depth, maxBreadth),
          }),
        })),
      }),
      ...(event.user && {
        user: normalize(event.user, depth, maxBreadth),
      }),
      ...(event.contexts && {
        contexts: normalize(event.contexts, depth, maxBreadth),
      }),
      ...(event.extra && {
        extra: normalize(event.extra, depth, maxBreadth),
      }),
    };

    // event.contexts.trace stores information about a Transaction. Similarly,
    // event.spans[] stores information about child Spans. Given that a
    // Transaction is conceptually a Span, normalization should apply to both
    // Transactions and Spans consistently.
    // For now the decision is to skip normalization of Transactions and Spans,
    // so this block overwrites the normalized event to add back the original
    // Transaction information prior to normalization.
    if (event.contexts && event.contexts.trace && normalized.contexts) {
      normalized.contexts.trace = event.contexts.trace;

      // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it
      if (event.contexts.trace.data) {
        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
      }
    }

    // event.spans[].data may contain circular/dangerous data so we need to normalize it
    if (event.spans) {
      normalized.spans = event.spans.map(span => {
        // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable
        if (span.data) {
          span.data = normalize(span.data, depth, maxBreadth);
        }
        return span;
      });
    }

    return normalized;
  }

  /**
   *  Enhances event using the client configuration.
   *  It takes care of all "static" values like environment, release and `dist`,
   *  as well as truncating overly long values.
   * @param event event instance to be enhanced
   */
   _applyClientOptions(event) {
    var options = this.getOptions();
    const { environment, release, dist, maxValueLength = 250 } = options;

    if (!('environment' in event)) {
      event.environment = 'environment' in options ? environment : 'production';
    }

    if (event.release === undefined && release !== undefined) {
      event.release = release;
    }

    if (event.dist === undefined && dist !== undefined) {
      event.dist = dist;
    }

    if (event.message) {
      event.message = (0,string/* truncate */.$G)(event.message, maxValueLength);
    }

    var exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = (0,string/* truncate */.$G)(exception.value, maxValueLength);
    }

    var request = event.request;
    if (request && request.url) {
      request.url = (0,string/* truncate */.$G)(request.url, maxValueLength);
    }
  }

  /**
   * This function adds all used integrations to the SDK info in the event.
   * @param event The event that will be filled with all integrations.
   */
   _applyIntegrationsMetadata(event) {
    var integrationsArray = Object.keys(this._integrations);
    if (integrationsArray.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];
    }
  }

  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
   _captureEvent(event, hint = {}, scope) {
    return this._processEvent(event, hint, scope).then(
      finalEvent => {
        return finalEvent.event_id;
      },
      reason => {
        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn(reason);
        return undefined;
      },
    );
  }

  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
   _processEvent(event, hint, scope) {
    const { beforeSend, sampleRate } = this.getOptions();

    if (!this._isEnabled()) {
      return (0,syncpromise/* rejectedSyncPromise */.$2)(new SentryError('SDK not enabled, will not capture event.'));
    }

    var isTransaction = event.type === 'transaction';
    // 1.0 === 100% events are sent
    // 0.0 === 0% events are sent
    // Sampling for transaction happens somewhere else
    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
      this.recordDroppedEvent('sample_rate', 'error');
      return (0,syncpromise/* rejectedSyncPromise */.$2)(
        new SentryError(
          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
        ),
      );
    }

    return this._prepareEvent(event, hint, scope)
      .then(prepared => {
        if (prepared === null) {
          this.recordDroppedEvent('event_processor', event.type || 'error');
          throw new SentryError('An event processor returned null, will not send event.');
        }

        var isInternalException = hint.data && (hint.data ).__sentry__ === true;
        if (isInternalException || isTransaction || !beforeSend) {
          return prepared;
        }

        var beforeSendResult = beforeSend(prepared, hint);
        return _ensureBeforeSendRv(beforeSendResult);
      })
      .then(processedEvent => {
        if (processedEvent === null) {
          this.recordDroppedEvent('before_send', event.type || 'error');
          throw new SentryError('`beforeSend` returned `null`, will not send event.');
        }

        var session = scope && scope.getSession();
        if (!isTransaction && session) {
          this._updateSessionFromEvent(session, processedEvent);
        }

        this.sendEvent(processedEvent, hint);
        return processedEvent;
      })
      .then(null, reason => {
        if (reason instanceof SentryError) {
          throw reason;
        }

        this.captureException(reason, {
          data: {
            __sentry__: true,
          },
          originalException: reason ,
        });
        throw new SentryError(
          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`,
        );
      });
  }

  /**
   * Occupies the client with processing and event
   */
   _process(promise) {
    this._numProcessing += 1;
    void promise.then(
      value => {
        this._numProcessing -= 1;
        return value;
      },
      reason => {
        this._numProcessing -= 1;
        return reason;
      },
    );
  }

  /**
   * @inheritdoc
   */
   _sendEnvelope(envelope) {
    if (this._transport && this._dsn) {
      this._transport.send(envelope).then(null, reason => {
        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('Error while sending event:', reason);
      });
    } else {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('Transport disabled');
    }
  }

  /**
   * Clears outcomes on this client and returns them.
   */
   _clearOutcomes() {
    var outcomes = this._outcomes;
    this._outcomes = {};
    return Object.keys(outcomes).map(key => {
      const [reason, category] = key.split(':') ;
      return {
        reason,
        category,
        quantity: outcomes[key],
      };
    });
  }

  /**
   * @inheritDoc
   */
    

}

/**
 * Verifies that return value of configured `beforeSend` is of expected type.
 */
function _ensureBeforeSendRv(rv) {
  var nullErr = '`beforeSend` method has to return `null` or a valid event.';
  if ((0,is/* isThenable */.J8)(rv)) {
    return rv.then(
      event => {
        if (!((0,is/* isPlainObject */.PO)(event) || event === null)) {
          throw new SentryError(nullErr);
        }
        return event;
      },
      e => {
        throw new SentryError(`beforeSend rejected with ${e}`);
      },
    );
  } else if (!((0,is/* isPlainObject */.PO)(rv) || rv === null)) {
    throw new SentryError(nullErr);
  }
  return rv;
}


//# sourceMappingURL=baseclient.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/clientreport.js



/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
function createClientReportEnvelope(
  discarded_events,
  dsn,
  timestamp,
) {
  var clientReportItem = [
    { type: 'client_report' },
    {
      timestamp: timestamp || (0,time/* dateTimestampInSeconds */.yW)(),
      discarded_events,
    },
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}


//# sourceMappingURL=clientreport.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/supports.js
var supports = __webpack_require__(49798);
;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/transports/utils.js


var utils_global = (0,esm_global/* getGlobalObject */.R)();
let cachedFetchImpl;

/**
 * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.
 * Whenever someone wraps the Fetch API and returns the wrong promise chain,
 * this chain becomes orphaned and there is no possible way to capture it's rejections
 * other than allowing it bubble up to this very handler. eg.
 *
 * var f = window.fetch;
 * window.fetch = function () {
 *   var p = f.apply(this, arguments);
 *
 *   p.then(function() {
 *     console.log('hi.');
 *   });
 *
 *   return p;
 * }
 *
 * `p.then(function () { ... })` is producing a completely separate promise chain,
 * however, what's returned is `p` - the result of original `fetch` call.
 *
 * This mean, that whenever we use the Fetch API to send our own requests, _and_
 * some ad-blocker blocks it, this orphaned chain will _always_ reject,
 * effectively causing another event to be captured.
 * This makes a whole process become an infinite loop, which we need to somehow
 * deal with, and break it in one way or another.
 *
 * To deal with this issue, we are making sure that we _always_ use the real
 * browser Fetch API, instead of relying on what `window.fetch` exposes.
 * The only downside to this would be missing our own requests as breadcrumbs,
 * but because we are already not doing this, it should be just fine.
 *
 * Possible failed fetch error messages per-browser:
 *
 * Chrome:  Failed to fetch
 * Edge:    Failed to Fetch
 * Firefox: NetworkError when attempting to fetch resource
 * Safari:  resource blocked by content blocker
 */
function getNativeFetchImplementation() {
  if (cachedFetchImpl) {
    return cachedFetchImpl;
  }

  // Fast path to avoid DOM I/O
  if ((0,supports/* isNativeFetch */.Du)(utils_global.fetch)) {
    return (cachedFetchImpl = utils_global.fetch.bind(utils_global));
  }

  var document = utils_global.document;
  let fetchImpl = utils_global.fetch;
    if (document && typeof document.createElement === 'function') {
    try {
      var sandbox = document.createElement('iframe');
      sandbox.hidden = true;
      document.head.appendChild(sandbox);
      var contentWindow = sandbox.contentWindow;
      if (contentWindow && contentWindow.fetch) {
        fetchImpl = contentWindow.fetch;
      }
      document.head.removeChild(sandbox);
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger/* logger.warn */.kg.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);
    }
  }

  return (cachedFetchImpl = fetchImpl.bind(utils_global));
  }

/**
 * Sends sdk client report using sendBeacon or fetch as a fallback if available
 *
 * @param url report endpoint
 * @param body report payload
 */
function sendReport(url, body) {
  var isRealNavigator = Object.prototype.toString.call(utils_global && utils_global.navigator) === '[object Navigator]';
  var hasSendBeacon = isRealNavigator && typeof utils_global.navigator.sendBeacon === 'function';

  if (hasSendBeacon) {
    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch
    var sendBeacon = utils_global.navigator.sendBeacon.bind(utils_global.navigator);
    sendBeacon(url, body);
  } else if ((0,supports/* supportsFetch */.Ak)()) {
    var fetch = getNativeFetchImplementation();
    fetch(url, {
      body,
      method: 'POST',
      credentials: 'omit',
      keepalive: true,
    }).then(null, error => {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error(error);
    });
  }
}


//# sourceMappingURL=utils.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/client.js






var globalObject = (0,esm_global/* getGlobalObject */.R)();

/**
 * The Sentry Browser SDK Client.
 *
 * @see BrowserOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
class BrowserClient extends BaseClient {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
   constructor(options) {
    options._metadata = options._metadata || {};
    options._metadata.sdk = options._metadata.sdk || {
      name: 'sentry.javascript.browser',
      packages: [
        {
          name: 'npm:@sentry/browser',
          version: SDK_VERSION,
        },
      ],
      version: SDK_VERSION,
    };

    super(options);

    if (options.sendClientReports && globalObject.document) {
      globalObject.document.addEventListener('visibilitychange', () => {
        if (globalObject.document.visibilityState === 'hidden') {
          this._flushOutcomes();
        }
      });
    }
  }

  /**
   * @inheritDoc
   */
   eventFromException(exception, hint) {
    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
  }

  /**
   * @inheritDoc
   */
   eventFromMessage(
    message,
        level = 'info',
    hint,
  ) {
    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
  }

  /**
   * @inheritDoc
   */
   sendEvent(event, hint) {
    // We only want to add the sentry event breadcrumb when the user has the breadcrumb integration installed and
    // activated its `sentry` option.
    // We also do not want to use the `Breadcrumbs` class here directly, because we do not want it to be included in
    // bundles, if it is not used by the SDK.
    // This all sadly is a bit ugly, but we currently don't have a "pre-send" hook on the integrations so we do it this
    // way for now.
    var breadcrumbIntegration = this.getIntegrationById(BREADCRUMB_INTEGRATION_ID) ;
    if (
      breadcrumbIntegration &&
      // We check for definedness of `options`, even though it is not strictly necessary, because that access to
      // `.sentry` below does not throw, in case users provided their own integration with id "Breadcrumbs" that does
      // not have an`options` field
      breadcrumbIntegration.options &&
      breadcrumbIntegration.options.sentry
    ) {
      (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(
        {
          category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,
          event_id: event.event_id,
          level: event.level,
          message: (0,misc/* getEventDescription */.jH)(event),
        },
        {
          event,
        },
      );
    }

    super.sendEvent(event, hint);
  }

  /**
   * @inheritDoc
   */
   _prepareEvent(event, hint, scope) {
    event.platform = event.platform || 'javascript';
    return super._prepareEvent(event, hint, scope);
  }

  /**
   * Sends client reports as an envelope.
   */
   _flushOutcomes() {
    var outcomes = this._clearOutcomes();

    if (outcomes.length === 0) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('No outcomes to send');
      return;
    }

    if (!this._dsn) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('No dsn provided, will not send outcomes');
      return;
    }

    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('Sending outcomes:', outcomes);

    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, this._options.tunnel);
    var envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));

    try {
      sendReport(url, serializeEnvelope(envelope));
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error(e);
    }
  }
}


//# sourceMappingURL=client.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/transports/fetch.js



/**
 * Creates a Transport that uses the Fetch API to send events to Sentry.
 */
function makeFetchTransport(
  options,
  nativeFetch = getNativeFetchImplementation(),
) {
  function makeRequest(request) {
    var requestOptions = {
      body: request.body,
      method: 'POST',
      referrerPolicy: 'origin',
      headers: options.headers,
      ...options.fetchOptions,
    };

    return nativeFetch(options.url, requestOptions).then(response => ({
      statusCode: response.status,
      headers: {
        'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
        'retry-after': response.headers.get('Retry-After'),
      },
    }));
  }

  return createTransport(options, makeRequest);
}


//# sourceMappingURL=fetch.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/transports/xhr.js



/**
 * The DONE ready state for XmlHttpRequest
 *
 * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined
 * (e.g. during testing, it is `undefined`)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}
 */
var XHR_READYSTATE_DONE = 4;

/**
 * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.
 */
function makeXHRTransport(options) {
  function makeRequest(request) {
    return new syncpromise/* SyncPromise */.cW((resolve, reject) => {
      var xhr = new XMLHttpRequest();

      xhr.onerror = reject;

      xhr.onreadystatechange = () => {
        if (xhr.readyState === XHR_READYSTATE_DONE) {
          resolve({
            statusCode: xhr.status,
            headers: {
              'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),
              'retry-after': xhr.getResponseHeader('Retry-After'),
            },
          });
        }
      };

      xhr.open('POST', options.url);

      for (var header in options.headers) {
        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
          xhr.setRequestHeader(header, options.headers[header]);
        }
      }

      xhr.send(request.body);
    });
  }

  return createTransport(options, makeRequest);
}


//# sourceMappingURL=xhr.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/stack-parsers.js


// global reference to slice
var UNKNOWN_FUNCTION = '?';

var OPERA10_PRIORITY = 10;
var OPERA11_PRIORITY = 20;
var CHROME_PRIORITY = 30;
var WINJS_PRIORITY = 40;
var GECKO_PRIORITY = 50;

function createFrame(filename, func, lineno, colno) {
  var frame = {
    filename,
    function: func,
    // All browser frames are considered in_app
    in_app: true,
  };

  if (lineno !== undefined) {
    frame.lineno = lineno;
  }

  if (colno !== undefined) {
    frame.colno = colno;
  }

  return frame;
}

// Chromium based browsers: Chrome, Brave, new Opera, new Edge
var chromeRegex =
  /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;

var chrome = line => {
  var parts = chromeRegex.exec(line);

  if (parts) {
    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    if (isEval) {
      var subMatch = chromeEvalRegex.exec(parts[2]);

      if (subMatch) {
        // throw out eval line/column and use top-most line/column number
        parts[2] = subMatch[1]; // url
        parts[3] = subMatch[2]; // line
        parts[4] = subMatch[3]; // column
      }
    }

    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now
    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)
    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);

    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);
  }

  return;
};

var chromeStackLineParser = [CHROME_PRIORITY, chrome];

// gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
// We need this specific case for now because we want no other regex to match.
var geckoREgex =
  /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

var gecko = line => {
  var parts = geckoREgex.exec(line);

  if (parts) {
    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    if (isEval) {
      var subMatch = geckoEvalRegex.exec(parts[3]);

      if (subMatch) {
        // throw out eval line/column and use top-most line number
        parts[1] = parts[1] || 'eval';
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = ''; // no column when eval
      }
    }

    let filename = parts[3];
    let func = parts[1] || UNKNOWN_FUNCTION;
    [func, filename] = extractSafariExtensionDetails(func, filename);

    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);
  }

  return;
};

var geckoStackLineParser = [GECKO_PRIORITY, gecko];

var winjsRegex =
  /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

var winjs = line => {
  var parts = winjsRegex.exec(line);

  return parts
    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)
    : undefined;
};

var winjsStackLineParser = [WINJS_PRIORITY, winjs];

var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;

var opera10 = line => {
  var parts = opera10Regex.exec(line);
  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;
};

var opera10StackLineParser = [OPERA10_PRIORITY, opera10];

var opera11Regex =
  / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;

var opera11 = line => {
  var parts = opera11Regex.exec(line);
  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;
};

var opera11StackLineParser = [OPERA11_PRIORITY, opera11];

var defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];

var defaultStackParser = (0,stacktrace/* createStackParser */.pE)(...defaultStackLineParsers);

/**
 * Safari web extensions, starting version unknown, can produce "frames-only" stacktraces.
 * What it means, is that instead of format like:
 *
 * Error: wat
 *   at function@url:row:col
 *   at function@url:row:col
 *   at function@url:row:col
 *
 * it produces something like:
 *
 *   function@url:row:col
 *   function@url:row:col
 *   function@url:row:col
 *
 * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.
 * This function is extracted so that we can use it in both places without duplicating the logic.
 * Unfortunately "just" changing RegExp is too complicated now and making it pass all tests
 * and fix this case seems like an impossible, or at least way too time-consuming task.
 */
var extractSafariExtensionDetails = (func, filename) => {
  var isSafariExtension = func.indexOf('safari-extension') !== -1;
  var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;

  return isSafariExtension || isSafariWebExtension
    ? [
        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,
        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,
      ]
    : [func, filename];
};


//# sourceMappingURL=stack-parsers.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/core/esm/sdk.js



/** A class object that can instantiate Client objects. */

/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
function initAndBind(
  clientClass,
  options,
) {
  if (options.debug === true) {
    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
      logger/* logger.enable */.kg.enable();
    } else {
      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
            console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
    }
  }
  var hub = (0,esm_hub/* getCurrentHub */.Gd)();
  var scope = hub.getScope();
  if (scope) {
    scope.update(options.initialScope);
  }

  var client = new clientClass(options);
  hub.bindClient(client);
}


//# sourceMappingURL=sdk.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/sdk.js
















var defaultIntegrations = [
  new InboundFilters(),
  new FunctionToString(),
  new TryCatch(),
  new Breadcrumbs(),
  new GlobalHandlers(),
  new LinkedErrors(),
  new Dedupe(),
  new HttpContext(),
];

/**
 * The Sentry Browser SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible when
 * loading the web page. To set context information or send manual events, use
 * the provided methods.
 *
 * @example
 *
 * ```
 *
 * import { init } from '@sentry/browser';
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * import { configureScope } from '@sentry/browser';
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * import { addBreadcrumb } from '@sentry/browser';
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 *
 * ```
 *
 * import * as Sentry from '@sentry/browser';
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link BrowserOptions} for documentation on configuration options.
 */
function init(options = {}) {
  if (options.defaultIntegrations === undefined) {
    options.defaultIntegrations = defaultIntegrations;
  }
  if (options.release === undefined) {
    var window = (0,esm_global/* getGlobalObject */.R)();
    // This supports the variable that sentry-webpack-plugin injects
    if (window.SENTRY_RELEASE && window.SENTRY_RELEASE.id) {
      options.release = window.SENTRY_RELEASE.id;
    }
  }
  if (options.autoSessionTracking === undefined) {
    options.autoSessionTracking = true;
  }
  if (options.sendClientReports === undefined) {
    options.sendClientReports = true;
  }

  var clientOptions = {
    ...options,
    stackParser: (0,stacktrace/* stackParserFromStackParserOptions */.Sq)(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || ((0,supports/* supportsFetch */.Ak)() ? makeFetchTransport : makeXHRTransport),
  };

  initAndBind(BrowserClient, clientOptions);

  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}

/**
 * Present the user with a report dialog.
 *
 * @param options Everything is optional, we try to fetch all info need from the global scope.
 */
function showReportDialog(options = {}, hub = (0,esm_hub/* getCurrentHub */.Gd)()) {
  // doesn't work without a document (React Native)
  var global = (0,esm_global/* getGlobalObject */.R)();
  if (!global.document) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('Global document not defined in showReportDialog call');
    return;
  }

  const { client, scope } = hub.getStackTop();
  var dsn = options.dsn || (client && client.getDsn());
  if (!dsn) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('DSN not configured for showReportDialog call');
    return;
  }

  if (scope) {
    options.user = {
      ...scope.getUser(),
      ...options.user,
    };
  }

  if (!options.eventId) {
    options.eventId = hub.lastEventId();
  }

  var script = global.document.createElement('script');
  script.async = true;
  script.src = getReportDialogEndpoint(dsn, options);

  if (options.onLoad) {
        script.onload = options.onLoad;
  }

  var injectionPoint = global.document.head || global.document.body;
  if (injectionPoint) {
    injectionPoint.appendChild(script);
  } else {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.error */.kg.error('Not injecting report dialog. No injection point found in HTML');
  }
}

/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
function lastEventId() {
  return (0,esm_hub/* getCurrentHub */.Gd)().lastEventId();
}

/**
 * This function is here to be API compatible with the loader.
 * @hidden
 */
function forceLoad() {
  // Noop
}

/**
 * This function is here to be API compatible with the loader.
 * @hidden
 */
function onLoad(callback) {
  callback();
}

/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
function flush(timeout) {
  var client = (0,esm_hub/* getCurrentHub */.Gd)().getClient();
  if (client) {
    return client.flush(timeout);
  }
  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('Cannot flush events. No client defined.');
  return (0,syncpromise/* resolvedSyncPromise */.WD)(false);
}

/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
function sdk_close(timeout) {
  var client = (0,esm_hub/* getCurrentHub */.Gd)().getClient();
  if (client) {
    return client.close(timeout);
  }
  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('Cannot flush events and disable SDK. No client defined.');
  return (0,syncpromise/* resolvedSyncPromise */.WD)(false);
}

/**
 * Wrap code within a try/catch block so the SDK is able to capture errors.
 *
 * @param fn A function to wrap.
 *
 * @returns The result of wrapped function call.
 */
function sdk_wrap(fn) {
  return wrap(fn)();
}

function startSessionOnHub(hub) {
  hub.startSession({ ignoreDuration: true });
  hub.captureSession();
}

/**
 * Enable automatic Session Tracking for the initial page load.
 */
function startSessionTracking() {
  var window = (0,esm_global/* getGlobalObject */.R)();
  var document = window.document;

  if (typeof document === 'undefined') {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');
    return;
  }

  var hub = (0,esm_hub/* getCurrentHub */.Gd)();

  // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and
  // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are
  // pinned at the same version in package.json, but there are edge cases where it's possible. See
  // https://github.com/getsentry/sentry-javascript/issues/3207 and
  // https://github.com/getsentry/sentry-javascript/issues/3234 and
  // https://github.com/getsentry/sentry-javascript/issues/3278.
  if (!hub.captureSession) {
    return;
  }

  // The session duration for browser sessions does not track a meaningful
  // concept that can be used as a metric.
  // Automatically captured sessions are akin to page views, and thus we
  // discard their duration.
  startSessionOnHub(hub);

  // We want to create a session for every navigation as well
  (0,instrument/* addInstrumentationHandler */.o)('history', ({ from, to }) => {
    // Don't create an additional session for the initial route or if the location did not change
    if (!(from === undefined || from === to)) {
      startSessionOnHub((0,esm_hub/* getCurrentHub */.Gd)());
    }
  });
}


//# sourceMappingURL=sdk.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/browser/esm/index.js

















let windowIntegrations = {};

// This block is needed to add compatibility with the integrations packages when used with a CDN
var _window = (0,esm_global/* getGlobalObject */.R)();
if (_window.Sentry && _window.Sentry.Integrations) {
  windowIntegrations = _window.Sentry.Integrations;
}

var INTEGRATIONS = {
  ...windowIntegrations,
  ...integrations_namespaceObject,
  ...esm_integrations_namespaceObject,
};


//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/tracing/esm/hubextensions.js + 1 modules
var hubextensions = __webpack_require__(78900);
;// CONCATENATED MODULE: ../../node_modules/@sentry/utils/esm/tracing.js
var TRACEPARENT_REGEXP = new RegExp(
  '^[ \\t]*' + // whitespace
    '([0-9a-f]{32})?' + // trace_id
    '-?([0-9a-f]{16})?' + // span_id
    '-?([01])?' + // sampled
    '[ \\t]*$', // whitespace
);

/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
function extractTraceparentData(traceparent) {
  var matches = traceparent.match(TRACEPARENT_REGEXP);
  if (matches) {
    let parentSampled;
    if (matches[3] === '1') {
      parentSampled = true;
    } else if (matches[3] === '0') {
      parentSampled = false;
    }
    return {
      traceId: matches[1],
      parentSampled,
      parentSpanId: matches[2],
    };
  }
  return undefined;
}


//# sourceMappingURL=tracing.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/tracing/esm/idletransaction.js
var idletransaction = __webpack_require__(40564);
// EXTERNAL MODULE: ../../node_modules/@sentry/tracing/esm/utils.js
var utils = __webpack_require__(92517);
;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/backgroundtab.js



var backgroundtab_global = (0,esm_global/* getGlobalObject */.R)();

/**
 * Add a listener that cancels and finishes a transaction when the global
 * document is hidden.
 */
function registerBackgroundTabDetection() {
  if (backgroundtab_global && backgroundtab_global.document) {
    backgroundtab_global.document.addEventListener('visibilitychange', () => {
      var activeTransaction = (0,utils/* getActiveTransaction */.x1)() ;
      if (backgroundtab_global.document.hidden && activeTransaction) {
        var statusType = 'cancelled';

        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
          logger/* logger.log */.kg.log(
            `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`,
          );
        // We should not set status if it is already set, this prevent important statuses like
        // error or data loss from being overwritten on transaction.
        if (!activeTransaction.status) {
          activeTransaction.setStatus(statusType);
        }
        activeTransaction.setTag('visibilitychange', 'document.hidden');
        activeTransaction.finish();
      }
    });
  } else {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger/* logger.warn */.kg.warn('[Tracing] Could not set up background tab detection due to lack of global document');
  }
}


//# sourceMappingURL=backgroundtab.js.map

// EXTERNAL MODULE: ../../node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.js
var _nullishCoalesce = __webpack_require__(12885);
;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js
var bindReporter = (
  callback,
  metric,
  reportAllChanges,
) => {
  let prevValue;
  return (forceReport) => {
    if (metric.value >= 0) {
      if (forceReport || reportAllChanges) {
        metric.delta = metric.value - (prevValue || 0);

        // Report the metric if there's a non-zero delta or if no previous
        // value exists (which can happen in the case of the document becoming
        // hidden when the metric value is 0).
        // See: https://github.com/GoogleChrome/web-vitals/issues/14
        if (metric.delta || prevValue === undefined) {
          prevValue = metric.value;
          callback(metric);
        }
      }
    }
  };
};


//# sourceMappingURL=bindReporter.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Performantly generate a unique, 30-char string by combining a version
 * number, the current timestamp with a 13-digit number integer.
 * @return {string}
 */
var generateUniqueID = () => {
  return `v2-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;
};


//# sourceMappingURL=generateUniqueID.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js



var initMetric = (name, value) => {
  return {
    name,
    value: (0,_nullishCoalesce/* _nullishCoalesce */.h)(value, () => ( -1)),
    delta: 0,
    entries: [],
    id: generateUniqueID(),
  };
};


//# sourceMappingURL=initMetric.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Takes a performance entry type and a callback function, and creates a
 * `PerformanceObserver` instance that will observe the specified entry type
 * with buffering enabled and call the callback _for each entry_.
 *
 * This function also feature-detects entry support and wraps the logic in a
 * try/catch to avoid errors in unsupporting browsers.
 */
var observe = (type, callback) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(type)) {
      // More extensive feature detect needed for Firefox due to:
      // https://github.com/GoogleChrome/web-vitals/issues/142
      if (type === 'first-input' && !('PerformanceEventTiming' in self)) {
        return;
      }

      var po = new PerformanceObserver(l => l.getEntries().map(callback));

      po.observe({ type, buffered: true });
      return po;
    }
  } catch (e) {
    // Do nothing.
  }
  return;
};


//# sourceMappingURL=observe.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js


/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var onHidden = (cb, once) => {
  var onHiddenOrPageHide = (event) => {
    if (event.type === 'pagehide' || (0,esm_global/* getGlobalObject */.R)().document.visibilityState === 'hidden') {
      cb(event);
      if (once) {
        removeEventListener('visibilitychange', onHiddenOrPageHide, true);
        removeEventListener('pagehide', onHiddenOrPageHide, true);
      }
    }
  };
  addEventListener('visibilitychange', onHiddenOrPageHide, true);
  // Some browsers have buggy implementations of visibilitychange,
  // so we use pagehide in addition, just to be safe.
  addEventListener('pagehide', onHiddenOrPageHide, true);
};


//# sourceMappingURL=onHidden.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js





/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://wicg.github.io/layout-instability/#sec-layout-shift

var getCLS = (onReport, reportAllChanges) => {
  var metric = initMetric('CLS', 0);
  let report;

  let sessionValue = 0;
  let sessionEntries = [];

  var entryHandler = (entry) => {
    // Only count layout shifts without recent user input.
    // TODO: Figure out why entry can be undefined
    if (entry && !entry.hadRecentInput) {
      var firstSessionEntry = sessionEntries[0];
      var lastSessionEntry = sessionEntries[sessionEntries.length - 1];

      // If the entry occurred less than 1 second after the previous entry and
      // less than 5 seconds after the first entry in the session, include the
      // entry in the current session. Otherwise, start a new session.
      if (
        sessionValue &&
        sessionEntries.length !== 0 &&
        entry.startTime - lastSessionEntry.startTime < 1000 &&
        entry.startTime - firstSessionEntry.startTime < 5000
      ) {
        sessionValue += entry.value;
        sessionEntries.push(entry);
      } else {
        sessionValue = entry.value;
        sessionEntries = [entry];
      }

      // If the current session value is larger than the current CLS value,
      // update CLS and the entries contributing to it.
      if (sessionValue > metric.value) {
        metric.value = sessionValue;
        metric.entries = sessionEntries;
        if (report) {
          report();
        }
      }
    }
  };

  var po = observe('layout-shift', entryHandler );
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);

    onHidden(() => {
      po.takeRecords().map(entryHandler );
      report(true);
    });
  }
};


//# sourceMappingURL=getCLS.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js



/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let firstHiddenTime = -1;

var initHiddenTime = () => {
  return (0,esm_global/* getGlobalObject */.R)().document.visibilityState === 'hidden' ? 0 : Infinity;
};

var trackChanges = () => {
  // Update the time if/when the document becomes hidden.
  onHidden(({ timeStamp }) => {
    firstHiddenTime = timeStamp;
  }, true);
};

var getVisibilityWatcher = (

) => {
  if (firstHiddenTime < 0) {
    // If the document is hidden when this code runs, assume it was hidden
    // since navigation start. This isn't a perfect heuristic, but it's the
    // best we can do until an API is available to support querying past
    // visibilityState.
    firstHiddenTime = initHiddenTime();
    trackChanges();
  }
  return {
    get firstHiddenTime() {
      return firstHiddenTime;
    },
  };
};


//# sourceMappingURL=getVisibilityWatcher.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js






/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var getFID = (onReport, reportAllChanges) => {
  var visibilityWatcher = getVisibilityWatcher();
  var metric = initMetric('FID');
  let report;

  var entryHandler = (entry) => {
    // Only report if the page wasn't hidden prior to the first input.
    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
      metric.value = entry.processingStart - entry.startTime;
      metric.entries.push(entry);
      report(true);
    }
  };

  var po = observe('first-input', entryHandler );
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    onHidden(() => {
      po.takeRecords().map(entryHandler );
      po.disconnect();
    }, true);
  }
};


//# sourceMappingURL=getFID.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js






/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://wicg.github.io/largest-contentful-paint/#sec-largest-contentful-paint-interface

var reportedMetricIDs = {};

var getLCP = (onReport, reportAllChanges) => {
  var visibilityWatcher = getVisibilityWatcher();
  var metric = initMetric('LCP');
  let report;

  var entryHandler = (entry) => {
    // The startTime attribute returns the value of the renderTime if it is not 0,
    // and the value of the loadTime otherwise.
    var value = entry.startTime;

    // If the page was hidden prior to paint time of the entry,
    // ignore it and mark the metric as final, otherwise add the entry.
    if (value < visibilityWatcher.firstHiddenTime) {
      metric.value = value;
      metric.entries.push(entry);
    }

    if (report) {
      report();
    }
  };

  var po = observe('largest-contentful-paint', entryHandler);

  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);

    var stopListening = () => {
      if (!reportedMetricIDs[metric.id]) {
        po.takeRecords().map(entryHandler );
        po.disconnect();
        reportedMetricIDs[metric.id] = true;
        report(true);
      }
    };

    // Stop listening after input. Note: while scrolling is an input that
    // stop LCP observation, it's unreliable since it can be programmatically
    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75
    ['keydown', 'click'].forEach(type => {
      addEventListener(type, stopListening, { once: true, capture: true });
    });

    onHidden(stopListening, true);
  }
};


//# sourceMappingURL=getLCP.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/metrics/utils.js
/**
 * Checks if a given value is a valid measurement value.
 */
function isMeasurementValue(value) {
  return typeof value === 'number' && isFinite(value);
}

/**
 * Helper function to start child on transactions. This function will make sure that the transaction will
 * use the start timestamp of the created child span if it is earlier than the transactions actual
 * start timestamp.
 */
function _startChild(transaction, { startTimestamp, ...ctx }) {
  if (startTimestamp && transaction.startTimestamp > startTimestamp) {
    transaction.startTimestamp = startTimestamp;
  }

  return transaction.startChild({
    startTimestamp,
    ...ctx,
  });
}


//# sourceMappingURL=utils.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/metrics/index.js









var metrics_global = (0,esm_global/* getGlobalObject */.R)();

function getBrowserPerformanceAPI() {
  return metrics_global && metrics_global.addEventListener && metrics_global.performance;
}

let _performanceCursor = 0;

let _measurements = {};
let _lcpEntry;
let _clsEntry;

/**
 * Start tracking web vitals
 */
function startTrackingWebVitals(reportAllChanges = false) {
  var performance = getBrowserPerformanceAPI();
  if (performance && time/* browserPerformanceTimeOrigin */.Z1) {
    if (performance.mark) {
      metrics_global.performance.mark('sentry-tracing-init');
    }
    _trackCLS();
    _trackLCP(reportAllChanges);
    _trackFID();
  }
}

/** Starts tracking the Cumulative Layout Shift on the current page. */
function _trackCLS() {
  // See:
  // https://web.dev/evolving-cls/
  // https://web.dev/cls-web-tooling/
  getCLS(metric => {
    var entry = metric.entries.pop();
    if (!entry) {
      return;
    }

    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding CLS');
    _measurements['cls'] = { value: metric.value, unit: '' };
    _clsEntry = entry ;
  });
}

/** Starts tracking the Largest Contentful Paint on the current page. */
function _trackLCP(reportAllChanges) {
  getLCP(metric => {
    var entry = metric.entries.pop();
    if (!entry) {
      return;
    }

    var timeOrigin = (0,utils/* msToSec */.XL)(time/* browserPerformanceTimeOrigin */.Z1 );
    var startTime = (0,utils/* msToSec */.XL)(entry.startTime);
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding LCP');
    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };
    _measurements['mark.lcp'] = { value: timeOrigin + startTime, unit: 'second' };
    _lcpEntry = entry ;
  }, reportAllChanges);
}

/** Starts tracking the First Input Delay on the current page. */
function _trackFID() {
  getFID(metric => {
    var entry = metric.entries.pop();
    if (!entry) {
      return;
    }

    var timeOrigin = (0,utils/* msToSec */.XL)(time/* browserPerformanceTimeOrigin */.Z1 );
    var startTime = (0,utils/* msToSec */.XL)(entry.startTime);
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding FID');
    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };
    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };
  });
}

/** Add performance related spans to a transaction */
function addPerformanceEntries(transaction) {
  var performance = getBrowserPerformanceAPI();
  if (!performance || !metrics_global.performance.getEntries || !time/* browserPerformanceTimeOrigin */.Z1) {
    // Gatekeeper if performance API not available
    return;
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Tracing] Adding & adjusting spans using Performance API');
  var timeOrigin = (0,utils/* msToSec */.XL)(time/* browserPerformanceTimeOrigin */.Z1);

  var performanceEntries = performance.getEntries();

  let responseStartTimestamp;
  let requestStartTimestamp;

    performanceEntries.slice(_performanceCursor).forEach((entry) => {
    var startTime = (0,utils/* msToSec */.XL)(entry.startTime);
    var duration = (0,utils/* msToSec */.XL)(entry.duration);

    if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
      return;
    }

    switch (entry.entryType) {
      case 'navigation': {
        _addNavigationSpans(transaction, entry, timeOrigin);
        responseStartTimestamp = timeOrigin + (0,utils/* msToSec */.XL)(entry.responseStart);
        requestStartTimestamp = timeOrigin + (0,utils/* msToSec */.XL)(entry.requestStart);
        break;
      }
      case 'mark':
      case 'paint':
      case 'measure': {
        var startTimestamp = _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);

        // capture web vitals
        var firstHidden = getVisibilityWatcher();
        // Only report if the page wasn't hidden prior to the web vital.
        var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;

        if (entry.name === 'first-paint' && shouldRecord) {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding FP');
          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };
          _measurements['mark.fp'] = { value: startTimestamp, unit: 'second' };
        }
        if (entry.name === 'first-contentful-paint' && shouldRecord) {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding FCP');
          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };
          _measurements['mark.fcp'] = { value: startTimestamp, unit: 'second' };
        }
        break;
      }
      case 'resource': {
        var resourceName = (entry.name ).replace(metrics_global.location.origin, '');
        _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
        break;
      }
      default:
      // Ignore other entry types.
    }
  });

  _performanceCursor = Math.max(performanceEntries.length - 1, 0);

  _trackNavigator(transaction);

  // Measurements are only available for pageload transactions
  if (transaction.op === 'pageload') {
    // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the
    // start of the response in milliseconds
    if (typeof responseStartTimestamp === 'number') {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding TTFB');
      _measurements['ttfb'] = {
        value: (responseStartTimestamp - transaction.startTimestamp) * 1000,
        unit: 'millisecond',
      };

      if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {
        // Capture the time spent making the request and receiving the first byte of the response.
        // This is the time between the start of the request and the start of the response in milliseconds.
        _measurements['ttfb.requestTime'] = {
          value: (responseStartTimestamp - requestStartTimestamp) * 1000,
          unit: 'millisecond',
        };
      }
    }

    ['fcp', 'fp', 'lcp'].forEach(name => {
      if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {
        return;
      }
      // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.
      // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need
      // to be adjusted to be relative to transaction.startTimestamp.
      var oldValue = _measurements[name].value;
      var measurementTimestamp = timeOrigin + (0,utils/* msToSec */.XL)(oldValue);

      // normalizedValue should be in milliseconds
      var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);
      var delta = normalizedValue - oldValue;

      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger/* logger.log */.kg.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);
      _measurements[name].value = normalizedValue;
    });

    if (_measurements['mark.fid'] && _measurements['fid']) {
      // create span for FID
      _startChild(transaction, {
        description: 'first input delay',
        endTimestamp: _measurements['mark.fid'].value + (0,utils/* msToSec */.XL)(_measurements['fid'].value),
        op: 'web.vitals',
        startTimestamp: _measurements['mark.fid'].value,
      });
    }

    // If FCP is not recorded we should not record the cls value
    // according to the new definition of CLS.
    if (!('fcp' in _measurements)) {
      delete _measurements.cls;
    }

    Object.keys(_measurements).forEach(measurementName => {
      transaction.setMeasurement(
        measurementName,
        _measurements[measurementName].value,
        _measurements[measurementName].unit,
      );
    });

    _tagMetricInfo(transaction);
  }

  _lcpEntry = undefined;
  _clsEntry = undefined;
  _measurements = {};
}

/** Create measure related spans */
function _addMeasureSpans(
  transaction,
    entry,
  startTime,
  duration,
  timeOrigin,
) {
  var measureStartTimestamp = timeOrigin + startTime;
  var measureEndTimestamp = measureStartTimestamp + duration;

  _startChild(transaction, {
    description: entry.name ,
    endTimestamp: measureEndTimestamp,
    op: entry.entryType ,
    startTimestamp: measureStartTimestamp,
  });

  return measureStartTimestamp;
}

/** Instrument navigation entries */
function _addNavigationSpans(transaction, entry, timeOrigin) {
  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {
    _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
  });
  _addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');
  _addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');
  _addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');
  _addRequest(transaction, entry, timeOrigin);
}

/** Create performance navigation related spans */
function _addPerformanceNavigationTiming(
  transaction,
    entry,
  event,
  timeOrigin,
  description,
  eventEnd,
) {
  var end = eventEnd ? (entry[eventEnd] ) : (entry[`${event}End`] );
  var start = entry[`${event}Start`] ;
  if (!start || !end) {
    return;
  }
  _startChild(transaction, {
    op: 'browser',
    description: (0,_nullishCoalesce/* _nullishCoalesce */.h)(description, () => ( event)),
    startTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(start),
    endTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(end),
  });
}

/** Create request and response related spans */
function _addRequest(transaction, entry, timeOrigin) {
  _startChild(transaction, {
    op: 'browser',
    description: 'request',
    startTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.requestStart ),
    endTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.responseEnd ),
  });

  _startChild(transaction, {
    op: 'browser',
    description: 'response',
    startTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.responseStart ),
    endTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.responseEnd ),
  });
}

/** Create resource-related spans */
function _addResourceSpans(
  transaction,
  entry,
  resourceName,
  startTime,
  duration,
  timeOrigin,
) {
  // we already instrument based on fetch and xhr, so we don't need to
  // duplicate spans here.
  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
    return;
  }

    var data = {};
  if ('transferSize' in entry) {
    data['Transfer Size'] = entry.transferSize;
  }
  if ('encodedBodySize' in entry) {
    data['Encoded Body Size'] = entry.encodedBodySize;
  }
  if ('decodedBodySize' in entry) {
    data['Decoded Body Size'] = entry.decodedBodySize;
  }

  var startTimestamp = timeOrigin + startTime;
  var endTimestamp = startTimestamp + duration;

  _startChild(transaction, {
    description: resourceName,
    endTimestamp,
    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',
    startTimestamp,
    data,
  });
}

/**
 * Capture the information of the user agent.
 */
function _trackNavigator(transaction) {
  var navigator = metrics_global.navigator ;
  if (!navigator) {
    return;
  }

  // track network connectivity
  var connection = navigator.connection;
  if (connection) {
    if (connection.effectiveType) {
      transaction.setTag('effectiveConnectionType', connection.effectiveType);
    }

    if (connection.type) {
      transaction.setTag('connectionType', connection.type);
    }

    if (isMeasurementValue(connection.rtt)) {
      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };
    }

    if (isMeasurementValue(connection.downlink)) {
      _measurements['connection.downlink'] = { value: connection.downlink, unit: '' }; // unit is empty string for now, while relay doesn't support download speed units
    }
  }

  if (isMeasurementValue(navigator.deviceMemory)) {
    transaction.setTag('deviceMemory', `${navigator.deviceMemory} GB`);
  }

  if (isMeasurementValue(navigator.hardwareConcurrency)) {
    transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));
  }
}

/** Add LCP / CLS data to transaction to allow debugging */
function _tagMetricInfo(transaction) {
  if (_lcpEntry) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding LCP Data');

    // Capture Properties of the LCP element that contributes to the LCP.

    if (_lcpEntry.element) {
      transaction.setTag('lcp.element', (0,browser/* htmlTreeAsString */.R)(_lcpEntry.element));
    }

    if (_lcpEntry.id) {
      transaction.setTag('lcp.id', _lcpEntry.id);
    }

    if (_lcpEntry.url) {
      // Trim URL to the first 200 characters.
      transaction.setTag('lcp.url', _lcpEntry.url.trim().slice(0, 200));
    }

    transaction.setTag('lcp.size', _lcpEntry.size);
  }

  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift
  if (_clsEntry && _clsEntry.sources) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log('[Measurements] Adding CLS Data');
    _clsEntry.sources.forEach((source, index) =>
      transaction.setTag(`cls.source.${index + 1}`, (0,browser/* htmlTreeAsString */.R)(source.node)),
    );
  }
}


//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/request.js



var DEFAULT_TRACING_ORIGINS = ['localhost', /^\//];

/** Options for Request Instrumentation */

var defaultRequestInstrumentationOptions = {
  traceFetch: true,
  traceXHR: true,
  tracingOrigins: DEFAULT_TRACING_ORIGINS,
};

/** Registers span creators for xhr and fetch requests  */
function instrumentOutgoingRequests(_options) {
    const { traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest } = {
    ...defaultRequestInstrumentationOptions,
    ..._options,
  };

  // We should cache url -> decision so that we don't have to compute
  // regexp everytime we create a request.
  var urlMap = {};

  var defaultShouldCreateSpan = (url) => {
    if (urlMap[url]) {
      return urlMap[url];
    }
    var origins = tracingOrigins;
    urlMap[url] =
      origins.some((origin) => (0,string/* isMatchingPattern */.zC)(url, origin)) &&
      !(0,string/* isMatchingPattern */.zC)(url, 'sentry_key');
    return urlMap[url];
  };

  // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves
  // That's why we filter out already unwanted Spans from tracingOrigins
  let shouldCreateSpan = defaultShouldCreateSpan;
  if (typeof shouldCreateSpanForRequest === 'function') {
    shouldCreateSpan = (url) => {
      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
    };
  }

  var spans = {};

  if (traceFetch) {
    (0,instrument/* addInstrumentationHandler */.o)('fetch', (handlerData) => {
      fetchCallback(handlerData, shouldCreateSpan, spans);
    });
  }

  if (traceXHR) {
    (0,instrument/* addInstrumentationHandler */.o)('xhr', (handlerData) => {
      xhrCallback(handlerData, shouldCreateSpan, spans);
    });
  }
}

/**
 * Create and track fetch request spans
 */
function fetchCallback(
  handlerData,
  shouldCreateSpan,
  spans,
) {
  if (!(0,utils/* hasTracingEnabled */.zu)() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
    return;
  }

  if (handlerData.endTimestamp) {
    var spanId = handlerData.fetchData.__span;
    if (!spanId) return;

    var span = spans[spanId];
    if (span) {
      if (handlerData.response) {
        // TODO (kmclb) remove this once types PR goes through
                span.setHttpStatus(handlerData.response.status);
      } else if (handlerData.error) {
        span.setStatus('internal_error');
      }
      span.finish();

            delete spans[spanId];
    }
    return;
  }

  var activeTransaction = (0,utils/* getActiveTransaction */.x1)();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: {
        ...handlerData.fetchData,
        type: 'fetch',
      },
      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,
      op: 'http.client',
    });

    handlerData.fetchData.__span = span.spanId;
    spans[span.spanId] = span;

    var request = (handlerData.args[0] = handlerData.args[0] );
        var options = (handlerData.args[1] = (handlerData.args[1] ) || {});
    options.headers = addTracingHeaders(request, activeTransaction.getBaggage(), span, options);
  }
}

function addTracingHeaders(
  request,
  incomingBaggage,
  span,
  options,
) {
  let headers = options.headers;

  if ((0,is/* isInstanceOf */.V9)(request, Request)) {
    headers = (request ).headers;
  }

  if (headers) {
        if (typeof headers.append === 'function') {
            headers.append('sentry-trace', span.toTraceparent());
            headers.append(esm_baggage/* BAGGAGE_HEADER_NAME */.bU, (0,esm_baggage/* mergeAndSerializeBaggage */.J8)(incomingBaggage, headers.get(esm_baggage/* BAGGAGE_HEADER_NAME */.bU)));
    } else if (Array.isArray(headers)) {
      const [, headerBaggageString] = headers.find(([key, _]) => key === esm_baggage/* BAGGAGE_HEADER_NAME */.bU);
      headers = [
        ...headers,
        ['sentry-trace', span.toTraceparent()],
        [esm_baggage/* BAGGAGE_HEADER_NAME */.bU, (0,esm_baggage/* mergeAndSerializeBaggage */.J8)(incomingBaggage, headerBaggageString)],
      ];
    } else {
      headers = {
        ...headers,
        'sentry-trace': span.toTraceparent(),
                baggage: (0,esm_baggage/* mergeAndSerializeBaggage */.J8)(incomingBaggage, headers.baggage),
      };
    }
  } else {
    headers = { 'sentry-trace': span.toTraceparent(), baggage: (0,esm_baggage/* mergeAndSerializeBaggage */.J8)(incomingBaggage) };
  }
  return headers;
}

/**
 * Create and track xhr request spans
 */
function xhrCallback(
  handlerData,
  shouldCreateSpan,
  spans,
) {
  if (
    !(0,utils/* hasTracingEnabled */.zu)() ||
    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||
    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))
  ) {
    return;
  }

  var xhr = handlerData.xhr.__sentry_xhr__;

  // check first if the request has finished and is tracked by an existing span which should now end
  if (handlerData.endTimestamp) {
    var spanId = handlerData.xhr.__sentry_xhr_span_id__;
    if (!spanId) return;

    var span = spans[spanId];
    if (span) {
      span.setHttpStatus(xhr.status_code);
      span.finish();

            delete spans[spanId];
    }
    return;
  }

  // if not, create a new span to track it
  var activeTransaction = (0,utils/* getActiveTransaction */.x1)();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: {
        ...xhr.data,
        type: 'xhr',
        method: xhr.method,
        url: xhr.url,
      },
      description: `${xhr.method} ${xhr.url}`,
      op: 'http.client',
    });

    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;

    if (handlerData.xhr.setRequestHeader) {
      try {
        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());

        var headerBaggageString =
          handlerData.xhr.getRequestHeader && handlerData.xhr.getRequestHeader(esm_baggage/* BAGGAGE_HEADER_NAME */.bU);

        handlerData.xhr.setRequestHeader(
          esm_baggage/* BAGGAGE_HEADER_NAME */.bU,
          (0,esm_baggage/* mergeAndSerializeBaggage */.J8)(activeTransaction.getBaggage(), headerBaggageString),
        );
      } catch (_) {
        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.
      }
    }
  }
}


//# sourceMappingURL=request.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/router.js


var router_global = (0,esm_global/* getGlobalObject */.R)();

/**
 * Default function implementing pageload and navigation transactions
 */
function instrumentRoutingWithDefaults(
  customStartTransaction,
  startTransactionOnPageLoad = true,
  startTransactionOnLocationChange = true,
) {
  if (!router_global || !router_global.location) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('Could not initialize routing instrumentation due to invalid location');
    return;
  }

  let startingUrl = router_global.location.href;

  let activeTransaction;
  if (startTransactionOnPageLoad) {
    activeTransaction = customStartTransaction({ name: router_global.location.pathname, op: 'pageload' });
  }

  if (startTransactionOnLocationChange) {
    (0,instrument/* addInstrumentationHandler */.o)('history', ({ to, from }) => {
      /**
       * This early return is there to account for some cases where a navigation transaction starts right after
       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't
       * create an uneccessary navigation transaction.
       *
       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also
       * only be caused in certain development environments where the usage of a hot module reloader is causing
       * errors.
       */
      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
        startingUrl = undefined;
        return;
      }

      if (from !== to) {
        startingUrl = undefined;
        if (activeTransaction) {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);
          // If there's an open transaction on the scope, we need to finish it before creating an new one.
          activeTransaction.finish();
        }
        activeTransaction = customStartTransaction({ name: router_global.location.pathname, op: 'navigation' });
      }
    });
  }
}


//# sourceMappingURL=router.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/browser/browsertracing.js









var BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';

/** Options for Browser Tracing integration */

var DEFAULT_BROWSER_TRACING_OPTIONS = {
  idleTimeout: idletransaction/* DEFAULT_IDLE_TIMEOUT */.nT,
  finalTimeout: idletransaction/* DEFAULT_FINAL_TIMEOUT */.mg,
  markBackgroundTransactions: true,
  routingInstrumentation: instrumentRoutingWithDefaults,
  startTransactionOnLocationChange: true,
  startTransactionOnPageLoad: true,
  ...defaultRequestInstrumentationOptions,
};

/**
 * The Browser Tracing integration automatically instruments browser pageload/navigation
 * actions as transactions, and captures requests, metrics and errors as spans.
 *
 * The integration can be configured with a variety of options, and can be extended to use
 * any routing library. This integration uses {@see IdleTransaction} to create transactions.
 */
class BrowserTracing  {
  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented
  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.
  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all
  // integrations.

  /** Browser Tracing integration options */
  

  /**
   * @inheritDoc
   */
   __init() {this.name = BROWSER_TRACING_INTEGRATION_ID;}

   constructor(_options) {;BrowserTracing.prototype.__init.call(this);
    let tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
    // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances
    if (_options) {
      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
        tracingOrigins = _options.tracingOrigins;
      } else {
        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && (this._emitOptionsWarning = true);
      }
    }

    this.options = {
      ...DEFAULT_BROWSER_TRACING_OPTIONS,
      ..._options,
      tracingOrigins,
    };

    const { _metricOptions } = this.options;
    startTrackingWebVitals(_metricOptions && _metricOptions._reportAllChanges);
  }

  /**
   * @inheritDoc
   */
   setupOnce(_, getCurrentHub) {
    this._getCurrentHub = getCurrentHub;

    if (this._emitOptionsWarning) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger/* logger.warn */.kg.warn(
          '[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.',
        );
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger/* logger.warn */.kg.warn(
          `[Tracing] We added a reasonable default for you: ${defaultRequestInstrumentationOptions.tracingOrigins}`,
        );
    }

        const {
      routingInstrumentation: instrumentRouting,
      startTransactionOnLocationChange,
      startTransactionOnPageLoad,
      markBackgroundTransactions,
      traceFetch,
      traceXHR,
      tracingOrigins,
      shouldCreateSpanForRequest,
    } = this.options;

    instrumentRouting(
      (context) => this._createRouteTransaction(context),
      startTransactionOnPageLoad,
      startTransactionOnLocationChange,
    );

    if (markBackgroundTransactions) {
      registerBackgroundTabDetection();
    }

    instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
  }

  /** Create routing idle transaction. */
   _createRouteTransaction(context) {
    if (!this._getCurrentHub) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger/* logger.warn */.kg.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);
      return undefined;
    }

        const { beforeNavigate, idleTimeout, finalTimeout } = this.options;

    var parentContextFromHeader = context.op === 'pageload' ? extractTraceDataFromMetaTags() : undefined;

    var expandedContext = {
      ...context,
      ...parentContextFromHeader,
      trimEnd: true,
    };
    var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;

    // For backwards compatibility reasons, beforeNavigate can return undefined to "drop" the transaction (prevent it
    // from being sent to Sentry).
    var finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;

    if (finalContext.sampled === false) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger/* logger.log */.kg.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
    }

    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);

    var hub = this._getCurrentHub();
    const { location } = (0,esm_global/* getGlobalObject */.R)() ;

    var idleTransaction = (0,hubextensions/* startIdleTransaction */.lb)(
      hub,
      finalContext,
      idleTimeout,
      finalTimeout,
      true,
      { location }, // for use in the tracesSampler
    );
    idleTransaction.registerBeforeFinishCallback(transaction => {
      addPerformanceEntries(transaction);
      transaction.setTag(
        'sentry_reportAllChanges',
        Boolean(this.options._metricOptions && this.options._metricOptions._reportAllChanges),
      );
    });

    return idleTransaction ;
  }
}

/**
 * Gets transaction context data from `sentry-trace` and `baggage` <meta> tags.
 * @returns Transaction context data or undefined neither tag exists or has valid data
 */
function extractTraceDataFromMetaTags() {
  var sentrytraceValue = getMetaContent('sentry-trace');
  var baggageValue = getMetaContent('baggage');

  var sentrytraceData = sentrytraceValue ? extractTraceparentData(sentrytraceValue) : undefined;
  var baggage = (0,esm_baggage/* parseBaggageSetMutability */.rg)(baggageValue, sentrytraceValue);

  // TODO more extensive checks for baggage validity/emptyness?
  if (sentrytraceData || baggage) {
    return {
      ...(sentrytraceData && sentrytraceData),
      ...(baggage && { metadata: { baggage } }),
    };
  }

  return undefined;
}

/** Returns the value of a meta tag */
function getMetaContent(metaName) {
  var globalObject = (0,esm_global/* getGlobalObject */.R)();

  // DOM/querySelector is not available in all environments
  if (globalObject.document && globalObject.document.querySelector) {
    var el = globalObject.document.querySelector(`meta[name=${metaName}]`);
    return el ? el.getAttribute('content') : null;
  } else {
    return null;
  }
}


//# sourceMappingURL=browsertracing.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/integrations/index.js









//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/@sentry/tracing/esm/index.js














;
;

// Treeshakable guard to remove all code related to tracing

// Guard for tree
if (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {
  // We are patching the global object with our hub extension methods
  (0,hubextensions/* addExtensionMethods */.ro)();
}
//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ../../node_modules/@ethersproject/keccak256/lib.esm/index.js
var lib_esm = __webpack_require__(59256);
;// CONCATENATED MODULE: ../../packages/sentry/index.js
const defaultOpts={integrations:[new BrowserTracing()],environment:'unknown',release:'unknown',// Set tracesSampleRate to 1.0 to capture 100%
// of transactions for performance monitoring.
// We recommend adjusting this value in production
tracesSampleRate:1.0,attachStacktrace:false,autoSessionTracking:true};function sentry_init(opts={}){Sentry.init(Object.assign(defaultOpts,opts));}function capture(err,cpatureContext){captureException(err,cpatureContext);}function sentry_captureMessage(message){if(!message||typeof message!=='string')return;captureMessage(message);}function updateUserId(id){if(typeof id!=='string')return;configureScope(scope=>{scope.setUser({id:(0,lib_esm/* keccak256 */.w)(id)});});}function sentry_addBreadcrumb(opts={}){Sentry.addBreadcrumb(opts);}

/***/ }),

/***/ 52206:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "To": () => (/* binding */ cfxEncodeTx),
  "s": () => (/* binding */ cfxJoinTransactionAndSignature),
  "c0": () => (/* binding */ cfxRecoverTransactionToAddress),
  "sA": () => (/* binding */ cfxSignTransaction),
  "e6": () => (/* binding */ ethEncodeTx),
  "qf": () => (/* binding */ ethJoinTransactionAndSignature),
  "fP": () => (/* binding */ ethRecoverTransactionToAddress),
  "jb": () => (/* binding */ ethSignTransaction),
  "PV": () => (/* binding */ getTxHashFromRawTx),
  "Jv": () => (/* binding */ hashTypedData),
  "W0": () => (/* binding */ personalSign),
  "Qi": () => (/* binding */ signTypedData_v4)
});

// UNUSED EXPORTS: cfxEcdsaRecover, cfxEcdsaSign, ecdsaRecover, ecdsaSign, ethEcdsaRecover, ethEcdsaSign, hashPersonalMessage, recoverPersonalSignature, recoverTypedSignature_v4

// EXTERNAL MODULE: ../../node_modules/@docusaurus/core/node_modules/@babel/runtime/helpers/esm/interopRequireWildcard.js
var interopRequireWildcard = __webpack_require__(65370);
// EXTERNAL MODULE: ../../packages/utils/index.js
var utils = __webpack_require__(11818);
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/signing-key/lib.esm/index.js + 2 modules
var lib_esm = __webpack_require__(3378);
// EXTERNAL MODULE: ../../node_modules/js-conflux-sdk/src/index.js
var src = __webpack_require__(11293);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/bytes/lib.esm/index.js + 1 modules
var bytes_lib_esm = __webpack_require__(75398);
// EXTERNAL MODULE: ../../node_modules/@ethersproject/transactions/lib.esm/index.js + 3 modules
var transactions_lib_esm = __webpack_require__(11482);
;// CONCATENATED MODULE: ../../node_modules/superstruct/lib/index.es.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Convert a validation result to an iterable of failures.
 */
function* toFailures(result, context) {
  if (result === true) ; else if (result === false) {
    yield context.fail();
  } else {
    yield* result;
  }
}
/**
 * Shifts (removes and returns) the first value from the `input` iterator.
 * Like `Array.prototype.shift()` but for an `Iterator`.
 */

function iteratorShift(input) {
  const {
    done,
    value
  } = input.next();
  return done ? undefined : value;
}

/**
 * `Struct` objects encapsulate the schema for a specific data type (with
 * optional coercion). You can then use the `assert`, `is` or `validate` helpers
 * to validate unknown data against a struct.
 */

class Struct {
  constructor(props) {
    const {
      type,
      schema,
      coercer = value => value,
      validator = () => [],
      refiner = () => []
    } = props;
    this.type = type;
    this.schema = schema;
    this.coercer = coercer;
    this.validator = validator;
    this.refiner = refiner;
  }

}
/**
 * `StructError` objects are thrown (or returned) by Superstruct when its
 * validation fails. The error represents the first error encountered during
 * validation. But they also have an `error.failures` property that holds
 * information for all of the failures encountered.
 */

class StructError extends TypeError {
  constructor(failure, moreFailures) {
    const {
      path,
      value,
      type,
      branch
    } = failure,
          rest = _objectWithoutProperties(failure, ["path", "value", "type", "branch"]);

    const message = `Expected a value of type \`${type}\`${path.length ? ` for \`${path.join('.')}\`` : ''} but received \`${JSON.stringify(value)}\`.`;
    let failuresResult;

    function failures() {
      if (!failuresResult) {
        failuresResult = [failure, ...moreFailures];
      }

      return failuresResult;
    }

    super(message);
    this.value = value;
    Object.assign(this, rest);
    this.type = type;
    this.path = path;
    this.branch = branch;
    this.failures = failures;
    this.stack = new Error().stack;
    this.__proto__ = StructError.prototype;
  }

}
/**
 * Assert that a value passes a `Struct`, throwing if it doesn't.
 */

function assert(value, struct) {
  const result = validate(value, struct);

  if (result[0]) {
    throw result[0];
  }
}
/**
 * Coerce a value with the coercion logic of `Struct` and validate it.
 */

function coerce(value, struct) {
  const ret = struct.coercer(value);
  assert(ret, struct);
  return ret;
}
/**
 * Check if a value passes a `Struct`.
 */

function is(value, struct) {
  const result = validate(value, struct);
  return !result[0];
}
/**
 * Validate a value against a `Struct`, returning an error if invalid.
 */

function validate(value, struct, coercing = false) {
  if (coercing) {
    value = struct.coercer(value);
  }

  const failures = check(value, struct);
  const failure = iteratorShift(failures);

  if (failure) {
    const error = new StructError(failure, failures);
    return [error, undefined];
  } else {
    return [undefined, value];
  }
}
/**
 * Check a value against a `Struct`, returning an iterable of failures.
 */

function* check(value, struct, path = [], branch = []) {
  const {
    type
  } = struct;
  const ctx = {
    value,
    type,
    branch,
    path,

    fail(props = {}) {
      return _objectSpread2({
        value,
        type,
        path,
        branch: [...branch, value]
      }, props);
    },

    check(v, s, parent, key) {
      const p = parent !== undefined ? [...path, key] : path;
      const b = parent !== undefined ? [...branch, parent] : branch;
      return check(v, s, p, b);
    }

  };
  const failures = toFailures(struct.validator(value, ctx), ctx);
  const failure = iteratorShift(failures);

  if (failure) {
    yield failure;
    yield* failures;
  } else {
    yield* toFailures(struct.refiner(value, ctx), ctx);
  }
}

/**
 * Augment a `Struct` to add an additional coercion step to its input.
 */

function coercion(struct, coercer) {
  const fn = struct.coercer;
  return new Struct(_objectSpread2(_objectSpread2({}, struct), {}, {
    coercer: value => {
      return fn(coercer(value));
    }
  }));
}
/**
 * Augment a struct to coerce a default value for missing values.
 *
 * Note: You must use `coerce(value, Struct)` on the value before validating it
 * to have the value defaulted!
 */

function defaulted(S, fallback, strict) {
  return coercion(S, x => {
    const f = typeof fallback === 'function' ? fallback() : fallback;

    if (x === undefined) {
      return f;
    }

    if (strict !== true && isPlainObject(x) && isPlainObject(f)) {
      const ret = _objectSpread2({}, x);

      let changed = false;

      for (const key in f) {
        if (ret[key] === undefined) {
          ret[key] = f[key];
          changed = true;
        }
      }

      if (changed) {
        return ret;
      }
    }

    return x;
  });
}
/**
 * Coerce a value to mask its properties to only that defined in the struct.
 */

function masked(S) {
  return coercion(S, x => {
    if (!isPlainObject(x)) {
      return x;
    }

    const ret = {};

    for (const key in S.schema) {
      ret[key] = x[key];
    }

    return ret;
  });
}
/**
 * Check if a value is a plain object.
 */

function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Augment a string or array struct to constrain its length to zero.
 */

function empty(S) {
  return refinement(S, `${S.type} & Empty`, value => {
    return value.length === 0;
  });
}
/**
 * Augment a string or array struct to constrain its length to being between a
 * minimum and maximum size.
 */

function index_es_length(S, min, max) {
  return refinement(S, `${S.type} & Length<${min},${max}>`, value => {
    return min < value.length && value.length < max;
  });
}
/**
 * Refine a string struct to match a specific regexp pattern.
 */

function pattern(S, regexp) {
  return refinement(S, `${S.type} & Pattern<${regexp.source}>`, value => {
    return regexp.test(value);
  });
}
/**
 * Augment a `Struct` to add an additional refinement to the validation.
 */

function refinement(struct, type, refiner) {
  const fn = struct.refiner;
  return new Struct(_objectSpread2(_objectSpread2({}, struct), {}, {
    type,

    *refiner(value, fail) {
      yield* toFailures(fn(value, fail), fail);
      yield* toFailures(refiner(value, fail), fail);
    }

  }));
}

/**
 * Validate any value.
 */

function any() {
  return struct('any', () => true);
}
function array(Element) {
  return new Struct({
    type: `Array<${Element ? Element.type : 'unknown'}>`,
    schema: Element,
    coercer: value => {
      return Element && Array.isArray(value) ? value.map(v => coerce(v, Element)) : value;
    },

    *validator(value, ctx) {
      if (!Array.isArray(value)) {
        yield ctx.fail();
        return;
      }

      if (Element) {
        for (const [i, v] of value.entries()) {
          yield* ctx.check(v, Element, value, i);
        }
      }
    }

  });
}
/**
 * Validate that boolean values.
 */

function index_es_boolean() {
  return struct('boolean', value => {
    return typeof value === 'boolean';
  });
}
/**
 * Validate that `Date` values.
 *
 * Note: this also ensures that the value is *not* an invalid `Date` object,
 * which can occur when parsing a date fails but still returns a `Date`.
 */

function date() {
  return struct('Date', value => {
    return value instanceof Date && !isNaN(value.getTime());
  });
}
/**
 * Validate that a value dynamically, determing which struct to use at runtime.
 */

function dynamic(fn) {
  return struct('Dynamic<...>', (value, ctx) => {
    return ctx.check(value, fn(value, ctx));
  });
}
function enums(values) {
  return struct(`Enum<${values.map(toLiteralString)}>`, value => {
    return values.includes(value);
  });
}
/**
 * Validate that a value is a function.
 */

function func() {
  return struct('Function', value => {
    return typeof value === 'function';
  });
}
/**
 * Validate that a value is an instance of a class.
 */

function instance(Class) {
  return struct(`InstanceOf<${Class.name}>`, value => {
    return value instanceof Class;
  });
}
function intersection(Structs) {
  return struct(Structs.map(s => s.type).join(' & '), function* (value, ctx) {
    for (const S of Structs) {
      yield* ctx.check(value, S);
    }
  });
}
/**
 * Validate a value lazily, by constructing the struct right before the first
 * validation. This is useful for cases where you want to have self-referential
 * structs for nested data structures.
 */

function lazy(fn) {
  let S;
  return struct('Lazy<...>', (value, ctx) => {
    if (!S) {
      S = fn();
    }

    return ctx.check(value, S);
  });
}
function literal(constant) {
  return struct(`Literal<${toLiteralString(constant)}>`, value => {
    return value === constant;
  });
}
/**
 * Validate that a value is a map with specific key and value entries.
 */

function map(Key, Value) {
  return struct(`Map<${Key.type},${Value.type}>`, function* (value, ctx) {
    if (!(value instanceof Map)) {
      yield ctx.fail();
      return;
    }

    for (const [k, v] of value.entries()) {
      yield* ctx.check(k, Key, value, k);
      yield* ctx.check(v, Value, value, k);
    }
  });
}
/**
 * Validate that a value always fails.
 */

function never() {
  return struct('never', () => false);
}
/**
 * Augment a struct to make it accept `null` values.
 */

function nullable(S) {
  return new Struct({
    type: `${S.type} | null`,
    schema: S.schema,
    validator: (value, ctx) => {
      return value === null || ctx.check(value, S);
    }
  });
}
/**
 * Validate that a value is a number.
 */

function number() {
  return struct(`number`, value => {
    return typeof value === 'number' && !isNaN(value);
  });
}
function object(Structs) {
  const knowns = Structs ? Object.keys(Structs) : [];
  const Never = never();
  return new Struct({
    type: Structs ? `Object<{${knowns.join(',')}}>` : 'Object',
    schema: Structs ? Structs : null,
    coercer: Structs ? createObjectCoercer(Structs) : x => x,

    *validator(value, ctx) {
      if (typeof value !== 'object' || value == null) {
        yield ctx.fail();
        return;
      }

      if (Structs) {
        const unknowns = new Set(Object.keys(value));

        for (const key of knowns) {
          unknowns.delete(key);
          const Value = Structs[key];
          const v = value[key];
          yield* ctx.check(v, Value, value, key);
        }

        for (const key of unknowns) {
          const v = value[key];
          yield* ctx.check(v, Never, value, key);
        }
      }
    }

  });
}
/**
 * Augment a struct to make it optionally accept `undefined` values.
 */

function optional(S) {
  return new Struct({
    type: `${S.type}?`,
    schema: S.schema,
    validator: (value, ctx) => {
      return value === undefined || ctx.check(value, S);
    }
  });
}
/**
 * Validate that a partial object with specific entry values.
 */

function partial(Structs) {
  if (Structs instanceof Struct) {
    Structs = Structs.schema;
  }

  const knowns = Object.keys(Structs);
  const Never = never();
  return new Struct({
    type: `Partial<{${knowns.join(',')}}>`,
    schema: Structs,
    coercer: createObjectCoercer(Structs),

    *validator(value, ctx) {
      if (typeof value !== 'object' || value == null) {
        yield ctx.fail();
        return;
      }

      const unknowns = new Set(Object.keys(value));

      for (const key of knowns) {
        unknowns.delete(key);

        if (!(key in value)) {
          continue;
        }

        const Value = Structs[key];
        const v = value[key];
        yield* ctx.check(v, Value, value, key);
      }

      for (const key of unknowns) {
        const v = value[key];
        yield* ctx.check(v, Never, value, key);
      }
    }

  });
}
/**
 * Validate that a value is a record with specific key and
 * value entries.
 */

function record(Key, Value) {
  return struct(`Record<${Key.type},${Value.type}>`, function* (value, ctx) {
    if (typeof value !== 'object' || value == null) {
      yield ctx.fail();
      return;
    }

    for (const k in value) {
      const v = value[k];
      yield* ctx.check(k, Key, value, k);
      yield* ctx.check(v, Value, value, k);
    }
  });
}
/**
 * Validate that a set of values matches a specific type.
 */

function set(Element) {
  return struct(`Set<${Element.type}>`, (value, ctx) => {
    if (!(value instanceof Set)) {
      return false;
    }

    for (const val of value) {
      const [failure] = ctx.check(val, Element);

      if (failure) {
        return false;
      }
    }

    return true;
  });
}
/**
 * Validate that a value is a string.
 */

function string() {
  return struct('string', value => {
    return typeof value === 'string';
  });
}
/**
 * Define a `Struct` instance with a type and validation function.
 */

function struct(name, validator) {
  return new Struct({
    type: name,
    validator,
    schema: null
  });
}
function tuple(Elements) {
  const Never = never();
  return struct(`[${Elements.map(s => s.type).join(',')}]`, function* (value, ctx) {
    if (!Array.isArray(value)) {
      yield ctx.fail();
      return;
    }

    for (const [index, Element] of Elements.entries()) {
      const v = value[index];
      yield* ctx.check(v, Element, value, index);
    }

    if (value.length > Elements.length) {
      const index = Elements.length;
      const v = value[index];
      yield* ctx.check(v, Never, value, index);
    }
  });
}
/**
 * Validate that a value matches a specific strutural interface, like the
 * structural typing that TypeScript uses.
 */

function type(Structs) {
  const keys = Object.keys(Structs);
  return struct(`Type<{${keys.join(',')}}>`, function* (value, ctx) {
    if (typeof value !== 'object' || value == null) {
      yield ctx.fail();
      return;
    }

    for (const key of keys) {
      const Value = Structs[key];
      const v = value[key];
      yield* ctx.check(v, Value, value, key);
    }
  });
}
function union(Structs) {
  return struct(`${Structs.map(s => s.type).join(' | ')}`, function* (value, ctx) {
    for (const S of Structs) {
      const [...failures] = ctx.check(value, S);

      if (failures.length === 0) {
        return;
      }
    }

    yield ctx.fail();
  });
}
/**
 * Convert a value to a literal string.
 */

function toLiteralString(value) {
  return typeof value === 'string' ? `"${value.replace(/"/g, '"')}"` : `${value}`;
}
/**
 * Coerce the values of an object-like struct.
 */


function createObjectCoercer(Structs) {
  const knowns = Object.keys(Structs);
  return value => {
    if (typeof value !== 'object' || value == null) {
      return value;
    }

    const ret = {};
    const unknowns = new Set(Object.keys(value));

    for (const key of knowns) {
      unknowns.delete(key);
      const Value = Structs[key];
      const v = value[key];
      ret[key] = coerce(v, Value);
    }

    for (const key of unknowns) {
      ret[key] = value[key];
    }

    return ret;
  };
}


//# sourceMappingURL=index.es.js.map

;// CONCATENATED MODULE: ../../node_modules/cip-23/lib/es/types.js

const TYPE_REGEX = /^\w+/;
const ARRAY_REGEX = /^(.*)\[([0-9]*?)]$/;
const BYTES_REGEX = /^bytes([0-9]{1,2})$/;
const NUMBER_REGEX = /^u?int([0-9]{0,3})$/;
const STATIC_TYPES = ['address', 'bool', 'bytes', 'string'];
const TYPE = refinement(string(), 'Type', (type, context) => {
  return isValidType(context.branch[0].types, type);
});
const CIP_23_TYPE = object({
  name: string(),
  type: TYPE
});
const CIP_23_DOMAIN_TYPE = object({
  name: optional(string()),
  version: optional(string()),
  chainId: optional(union([string(), number()])),
  verifyingContract: optional(pattern(string(), /^0x[0-9a-z]{40}$/i)),
  salt: optional(union([array(number()), pattern(string(), /^0x[0-9a-z]{64}$/i)]))
});
const CIP_23_TYPED_DATA_TYPE = object({
  types: intersection([type({
    CIP23Domain: array(CIP_23_TYPE)
  }), record(string(), array(CIP_23_TYPE))]),
  primaryType: string(),
  domain: CIP_23_DOMAIN_TYPE,
  message: object()
});
const EIP_712_TYPED_DATA_TYPE = object({
  types: intersection([type({
    EIP712Domain: array(CIP_23_TYPE)
  }), record(string(), array(CIP_23_TYPE))]),
  primaryType: string(),
  domain: CIP_23_DOMAIN_TYPE,
  message: object()
});
const isValidType = (types, type) => {
  if (STATIC_TYPES.includes(type)) {
    return true;
  }

  if (types[type]) {
    return true;
  }

  if (type.match(ARRAY_REGEX)) {
    const match = type.match(TYPE_REGEX);

    if (match) {
      const innerType = match[0];
      return isValidType(types, innerType);
    }
  }

  const bytesMatch = type.match(BYTES_REGEX);

  if (bytesMatch) {
    const length = Number(bytesMatch[1]);

    if (length >= 1 && length <= 32) {
      return true;
    }
  }

  const numberMatch = type.match(NUMBER_REGEX);

  if (numberMatch) {
    const length = Number(numberMatch[1]);

    if (length >= 8 && length <= 256 && length % 8 === 0) {
      return true;
    }
  }

  return false;
};
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ../../node_modules/cip-23/lib/es/utils/json.js


const json_validateTypedData = data => {
  return is(data, CIP_23_TYPED_DATA_TYPE) || is(data, EIP_712_TYPED_DATA_TYPE);
};
//# sourceMappingURL=json.js.map
// EXTERNAL MODULE: ../../node_modules/keccak/index.js
var keccak = __webpack_require__(37029);
var keccak_default = /*#__PURE__*/__webpack_require__.n(keccak);
;// CONCATENATED MODULE: ../../node_modules/cip-23/lib/es/utils/buffer.js
/* provided dependency */ var Buffer = __webpack_require__(14300)["Buffer"];

const buffer_keccak256 = (data, encoding) => {
  return keccak_default()('keccak256').update(data, encoding).digest();
};
const buffer_toBuffer = (data, encoding) => {
  if (!encoding) {
    if (data.startsWith('0x')) {
      return Buffer.from(data.substring(2), 'hex');
    }

    return Buffer.from(data, 'hex');
  }

  return Buffer.from(data, encoding);
};
//# sourceMappingURL=buffer.js.map
// EXTERNAL MODULE: ../../node_modules/@conflux-dev/conflux-address-js/lib/index.js
var lib = __webpack_require__(40376);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/utils/buffer.js
/* provided dependency */ var buffer_Buffer = __webpack_require__(14300)["Buffer"];
const BUFFER_WIDTH = 32;
const buffer_concat = (target, value, position) => {
  return new Uint8Array([...target.subarray(0, position !== null && position !== void 0 ? position : target.length), ...value, ...target.subarray(position !== null && position !== void 0 ? position : target.length)]);
};
const concatMultiple = buffers => {
  return buffers.reduce((target, buffer) => {
    const array = new Uint8Array(target.length + buffer.length);
    array.set(target, 0);
    array.set(buffer, target.length);
    return array;
  }, new Uint8Array(0));
};
const addPadding = (buffer, length = 32) => {
  const padding = buffer_Buffer.alloc(Math.max(length - buffer.length, 0), 0);
  return buffer_concat(buffer, padding);
};
const utils_buffer_toBuffer = value => {
  if (buffer_Buffer.isBuffer(value) || value instanceof Uint8Array) {
    return value;
  }

  if (typeof value === 'string') {
    const stringValue = value.startsWith('0x') ? value.substring(2) : value;
    return buffer_Buffer.from(stringValue, 'hex');
  }

  const hex = value.toString(16);
  return buffer_Buffer.from(hex.padStart(BUFFER_WIDTH * 2, '0').slice(0, BUFFER_WIDTH * 2), 'hex');
};
const buffer_toString = value => {
  if (typeof window !== 'undefined' && window.TextDecoder) {
    return new TextDecoder('utf-8').decode(value);
  }

  return new ((__webpack_require__(73837).TextDecoder))('utf-8').decode(value);
};
const toNumber = buffer => {
  const hex = toHex(buffer);

  if (hex.length === 0) {
    return BigInt(0);
  }

  return BigInt(`0x${hex}`);
};

const numberToHex = value => {
  return ('0' + value.toString(16)).slice(-2);
};

const toHex = buffer => {
  return Array.from(buffer).map(numberToHex).join('');
};
//# sourceMappingURL=buffer.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/parsers/address.js
/* provided dependency */ var address_Buffer = __webpack_require__(14300)["Buffer"];

const encodeAddress = (buffer, value) => {
  if (value.length !== 42) {
    throw new Error('Invalid address length');
  }

  const addressBuffer = address_Buffer.alloc(32);
  addressBuffer.write(value.substring(2), 12, 'hex');
  return buffer_concat(buffer, addressBuffer);
};
const decodeAddress = value => {
  const addressBuffer = value.subarray(-20);
  return `0x${toHex(addressBuffer)}`;
};
//# sourceMappingURL=address.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/parsers/bytes.js
/* provided dependency */ var bytes_Buffer = __webpack_require__(14300)["Buffer"];

const encodeBytes = (buffer, value) => {
  const bufferValue = utils_buffer_toBuffer(value);
  const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;
  return buffer_concat(buffer, bytes_Buffer.concat([utils_buffer_toBuffer(bufferValue.byteLength), addPadding(bufferValue, paddedSize)]));
};
const decodeBytes = (value, buffer) => {
  const pointer = Number(toNumber(value.subarray(0, 32)));
  const length = toNumber(value.subarray(pointer, pointer + 32));
  return buffer.subarray(32, 32 + Number(length));
};
//# sourceMappingURL=bytes.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/parsers/fixed-bytes.js

const fixed_bytes_BYTES_REGEX = /^bytes([0-9]{1,2})$/;
const isFixedBytes = type => {
  return fixed_bytes_BYTES_REGEX.test(type);
};
const getByteLength = type => {
  var _type$match;

  const bytes = (_type$match = type.match(fixed_bytes_BYTES_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1];

  if (bytes) {
    const length = Number(bytes);

    if (length <= 0 || length > 32) {
      throw new Error('Invalid type: length is out of range');
    }

    return length;
  }

  throw new Error('Invalid type: no length');
};
const encodeFixedBytes = (buffer, value, type) => {
  const length = getByteLength(type);
  const bufferValue = utils_buffer_toBuffer(value);

  if (bufferValue.length > length) {
    throw new Error(`Buffer is too long, expected ${length}, got ${bufferValue.length}`);
  }

  return buffer_concat(buffer, addPadding(bufferValue));
};
const decodeFixedBytes = (value, _, type) => {
  const length = getByteLength(type);
  return value.subarray(0, length);
};
//# sourceMappingURL=fixed-bytes.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/utils/twos-complement.js

const fromTwosComplement = buffer => {
  const bufferValue = utils_buffer_toBuffer(buffer);
  let value = 0n;

  for (const byte of bufferValue) {
    value = (value << 8n) + BigInt(byte);
  }

  return BigInt.asIntN(bufferValue.length * 8, value);
};
const toTwosComplement = (value, length) => {
  const buffer = new Uint8Array(length);

  for (let i = 0; i < buffer.length; i++) {
    buffer[i] = Number(BigInt.asUintN(8, value));
    value = value >> 8n;
  }

  return buffer.reverse();
};
//# sourceMappingURL=twos-complement.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/parsers/number.js


const number_NUMBER_REGEX = /^u?int([0-9]*)?$/;

const isSigned = type => {
  return type.startsWith('i');
};

const isNumber = type => {
  return number_NUMBER_REGEX.test(type);
};
const getBitLength = type => {
  var _type$match$, _type$match;

  const rawBits = (_type$match$ = (_type$match = type.match(number_NUMBER_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1]) !== null && _type$match$ !== void 0 ? _type$match$ : '256';
  return Number(rawBits);
};
const inRange = (value, type) => {
  const bits = BigInt(getBitLength(type));

  if (isSigned(type)) {
    const maxSignedValue = 2n ** (bits - 1n) - 1n;
    return value >= -maxSignedValue - 1n && value <= maxSignedValue;
  }

  const maxValue = 2n ** bits - 1n;
  return value >= 0n && value <= maxValue;
};

const asNumber = value => {
  if (typeof value === 'bigint') {
    return value;
  }

  return BigInt(value);
};

const encodeNumber = (buffer, value, type) => {
  const numberValue = asNumber(value);

  if (!inRange(numberValue, type)) {
    throw new Error(`Cannot encode number: value is out of range for type ${type}`);
  }

  if (isSigned(type)) {
    return buffer_concat(buffer, toTwosComplement(numberValue, 32));
  }

  return buffer_concat(buffer, utils_buffer_toBuffer(numberValue));
};
const decodeNumber = (value, _, type) => {
  if (isSigned(type)) {
    return fromTwosComplement(value);
  }

  return toNumber(value);
};
//# sourceMappingURL=number.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/parsers/string.js
/* provided dependency */ var string_Buffer = __webpack_require__(14300)["Buffer"];


const encodeString = (buffer, value) => {
  const bufferValue = string_Buffer.from(value, 'utf8');
  return encodeBytes(buffer, bufferValue, 'bytes');
};
const decodeString = (value, buffer) => {
  return buffer_toString(decodeBytes(value, buffer, 'string'));
};
//# sourceMappingURL=string.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/parsers/array.js
/* provided dependency */ var array_Buffer = __webpack_require__(14300)["Buffer"];






const array_ARRAY_REGEX = /^(.*)\[]$/;
const isArray = type => {
  return array_ARRAY_REGEX.test(type);
};
const getType = type => {
  return type.match(array_ARRAY_REGEX)[1];
};
const encodeArray = (buffer, values, type) => {
  if (!isArray(type)) {
    throw new Error('Invalid type: type is not array');
  }

  const actualType = getType(type);
  const length = utils_buffer_toBuffer(values.length);
  const arrayBuffer = buffer_concat(buffer, length);
  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));
};
const decodeArray = (value, buffer, type) => {
  if (!isArray(type)) {
    throw new Error('Invalid type: type is not array');
  }

  const actualType = getType(type);
  const pointer = Number(toNumber(value));
  const length = Number(toNumber(buffer.subarray(pointer, pointer + 32)));
  const arrayPointer = pointer + 32;
  const arrayBuffer = buffer.subarray(arrayPointer);
  return array_unpack(arrayBuffer, new Array(length).fill(actualType));
};
const parsers = {
  address: {
    encode: encodeAddress,
    decode: decodeAddress
  },
  array: {
    dynamic: true,
    encode: encodeArray,
    decode: decodeArray
  },
  bytes: {
    dynamic: true,
    encode: encodeBytes,
    decode: decodeBytes
  },
  fixedBytes: {
    encode: encodeFixedBytes,
    decode: decodeFixedBytes
  },
  number: {
    encode: encodeNumber,
    decode: decodeNumber
  },
  string: {
    dynamic: true,
    encode: encodeString,
    decode: decodeString
  }
};
const getParser = type => {
  if (parsers[type]) {
    return parsers[type];
  }

  if (isFixedBytes(type)) {
    return parsers.fixedBytes;
  }

  if (isNumber(type) || type === 'bool') {
    return parsers.number;
  }

  if (isArray(type)) {
    return parsers.array;
  }

  throw new Error(`type "${type}" is not supported`);
};
const pack = (buffer, values, types) => {
  const {
    staticBuffer: packedStaticBuffer,
    dynamicBuffer: packedDynamicBuffer,
    updateFunctions: packedUpdateFunctions
  } = types.reduce(({
    staticBuffer,
    dynamicBuffer,
    updateFunctions
  }, type, index) => {
    const parser = getParser(type);
    const value = values[index];

    if (parser.dynamic) {
      const offset = dynamicBuffer.length;
      const staticOffset = staticBuffer.length;
      const newStaticBuffer = buffer_concat(staticBuffer, array_Buffer.alloc(32, 0));
      const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);

      const update = oldBuffer => {
        return concatMultiple([oldBuffer.subarray(0, staticOffset), utils_buffer_toBuffer(oldBuffer.length + offset), oldBuffer.subarray(staticOffset + 32)]);
      };

      return {
        staticBuffer: newStaticBuffer,
        dynamicBuffer: newDynamicBuffer,
        updateFunctions: [...updateFunctions, update]
      };
    }

    const newBuffer = parser.encode(staticBuffer, value, type);
    return {
      staticBuffer: newBuffer,
      dynamicBuffer,
      updateFunctions
    };
  }, {
    staticBuffer: new Uint8Array(0),
    dynamicBuffer: new Uint8Array(0),
    updateFunctions: []
  });
  const updatedStaticBuffer = packedUpdateFunctions.reduce((target, update) => update(target), packedStaticBuffer);
  return concatMultiple([buffer, updatedStaticBuffer, packedDynamicBuffer]);
};
function* iterate(buffer, chunkSize) {
  for (let i = 0; i < buffer.length; i += chunkSize) {
    yield buffer.slice(i, i + chunkSize);
  }

  return buffer;
}
const array_unpack = (buffer, types) => {
  const iterator = iterate(buffer, 32);
  return types.map(type => {
    const {
      value,
      done
    } = iterator.next();

    if (done) {
      throw new Error('input data has an invalid length');
    }

    const parser = getParser(type);
    return parser.decode(value, buffer, type);
  });
};
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ../../node_modules/@findeth/abi/lib/es/abi.js
/* provided dependency */ var abi_Buffer = __webpack_require__(14300)["Buffer"];



const encode = (input, values) => {
  const types = input.map(type => {
    if (typeof type === 'string') {
      return type;
    }

    return type.type;
  });
  return pack(abi_Buffer.alloc(0), values, types);
};
const encodeWithIdentifier = (contractFunction, values) => {
  const identifier = abi_Buffer.from(getIdentifier(contractFunction), 'hex');
  const encoded = encode(contractFunction.inputs, values);
  return concat(identifier, encoded);
};
const decode = (input, buffer) => {
  const types = input.map(type => {
    if (typeof type === 'string') {
      return type;
    }

    return type.type;
  });
  return unpack(buffer, types);
};
//# sourceMappingURL=abi.js.map
;// CONCATENATED MODULE: ../../node_modules/cip-23/lib/es/utils/abi.js
/* provided dependency */ var utils_abi_Buffer = __webpack_require__(14300)["Buffer"];


const ADDRESS = 'address';
const abi_encode = (types, values) => {
  values.map(function (v, i, origin) {
    if (types[i] === ADDRESS) {
      origin[i] = normalizeAddress(v);
    }
  });
  return utils_abi_Buffer.from(encode(types, values));
};

function normalizeAddress(address) {
  if (!lib_default().hasNetworkPrefix(address)) {
    return address;
  }

  return '0x' + lib_default().decode(address).hexAddress.toString('hex');
}
//# sourceMappingURL=abi.js.map
;// CONCATENATED MODULE: ../../node_modules/cip-23/lib/es/cip-23.js
/* provided dependency */ var cip_23_Buffer = __webpack_require__(14300)["Buffer"];


const EIP_191_PREFIX = cip_23_Buffer.from('1901', 'hex');
const getDependencies = (typedData, type, dependencies = []) => {
  if (!json_validateTypedData(typedData)) {
    throw new Error('Typed data does not match JSON schema');
  }

  const match = type.match(TYPE_REGEX);
  const actualType = match[0];

  if (dependencies.includes(actualType)) {
    return dependencies;
  }

  if (!typedData.types[actualType]) {
    return dependencies;
  }

  return [actualType, ...typedData.types[actualType].reduce((previous, type) => {
    const newDependencies = actualType === type.type ? [] : getDependencies(typedData, type.type, previous).filter(dependency => !previous.includes(dependency));
    return [...previous, ...newDependencies];
  }, [])];
};
const encodeType = (typedData, type) => {
  const [primary, ...dependencies] = getDependencies(typedData, type);
  const types = [primary, ...dependencies.sort()];
  return types.map(dependency => {
    return `${dependency}(${typedData.types[dependency].map(type => `${type.type} ${type.name}`)})`;
  }).join('');
};
const getTypeHash = (typedData, type) => {
  return buffer_keccak256(encodeType(typedData, type), 'utf8');
};

const encodeValue = (typedData, type, data) => {
  const match = type.match(ARRAY_REGEX);

  if (match) {
    const arrayType = match[1];
    const length = Number(match[2]) || undefined;

    if (!Array.isArray(data)) {
      throw new Error('Cannot encode data: value is not of array type');
    }

    if (length && data.length !== length) {
      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);
    }

    const encodedData = data.map(item => encodeValue(typedData, arrayType, item));
    const types = encodedData.map(item => item[0]);
    const values = encodedData.map(item => item[1]);
    return ['bytes32', buffer_keccak256(abi_encode(types, values))];
  }

  if (typedData.types[type]) {
    return ['bytes32', getStructHash(typedData, type, data)];
  }

  if (type === 'string') {
    return ['bytes32', buffer_keccak256(data, 'utf8')];
  }

  if (type === 'bytes') {
    return ['bytes32', buffer_keccak256(cip_23_Buffer.isBuffer(data) ? data : buffer_toBuffer(data), 'hex')];
  }

  return [type, data];
};

const encodeData = (typedData, type, data) => {
  const [types, values] = typedData.types[type].reduce(([types, values], field) => {
    if (data[field.name] === undefined || data[field.name] === null) {
      return [[...types, 'bytes32'], [...values, '0x0000000000000000000000000000000000000000000000000000000000000000']];
    }

    const value = data[field.name];
    const [type, encodedValue] = encodeValue(typedData, field.type, value);
    return [[...types, type], [...values, encodedValue]];
  }, [['bytes32'], [getTypeHash(typedData, type)]]);
  return abi_encode(types, values);
};
const getStructHash = (typedData, type, data) => {
  return buffer_keccak256(encodeData(typedData, type, data));
};
const getMessage = (typedData, hash, domainName = 'CIP23Domain') => {
  const message = cip_23_Buffer.concat([EIP_191_PREFIX, getStructHash(typedData, domainName, typedData.domain), getStructHash(typedData, typedData.primaryType, typedData.message)]);

  if (hash) {
    return buffer_keccak256(message);
  }

  return message;
};
const asArray = (typedData, type = typedData.primaryType, data = typedData.message) => {
  if (!validateTypedData(typedData)) {
    throw new Error('Typed data does not match JSON schema');
  }

  if (!typedData.types[type]) {
    throw new Error('Cannot get data as array: type does not exist');
  }

  return typedData.types[type].reduce((array, {
    name,
    type
  }) => {
    if (typedData.types[type]) {
      if (!data[name]) {
        throw new Error(`Cannot get data as array: missing data for '${name}'`);
      }

      return [...array, asArray(typedData, type, data[name])];
    }

    const value = data[name];
    return [...array, value];
  }, []);
};
//# sourceMappingURL=cip-23.js.map
// EXTERNAL MODULE: ../../node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(59256);
;// CONCATENATED MODULE: ../../packages/signature/index.js
const hashPersonalMessage=(type,message)=>type==='cfx'?CfxPersonalMessage.personalHash(message):ethHashPersonalMessage(message);async function personalSign(type,privateKey,message){return type==='cfx'?src.PersonalMessage.sign((0,utils/* addHexPrefix */.L_)(privateKey),message):(await Promise.resolve().then(()=>(0,interopRequireWildcard/* default */.Z)(require('eth-sig-util')))).default.personalSign((0,utils/* toBuffer */.Qi)((0,utils/* addHexPrefix */.L_)(privateKey)),{data:message});}function recoverPersonalSignature(type,signature,message,netId){if(type==='cfx'){const pub=CfxPersonalMessage.recover(signature,message);const addr=cfxSDKSign.publicKeyToAddress(toBuffer(pub));return encodeCfxAddress(addr,netId);}return verifyEthPersonalSign(message,signature);}function hashTypedData(type,typedData){return (0,keccak256_lib_esm/* keccak256 */.w)(getMessage(typedData,false,type==='cfx'?'CIP23Domain':'EIP712Domain'));}// v4
async function signTypedData_v4(type,privateKey,typedData){if(type==='cfx'){const hashedMessage=(0,keccak256_lib_esm/* keccak256 */.w)(getMessage(typedData,false,type==='cfx'?'CIP23Domain':'EIP712Domain'));const signature=src.Message.sign((0,utils/* toBuffer */.Qi)((0,utils/* addHexPrefix */.L_)(privateKey)),(0,utils/* toBuffer */.Qi)(hashedMessage));return signature;}const{TypedDataUtils}=(await Promise.resolve().then(()=>(0,interopRequireWildcard/* default */.Z)(require('eth-sig-util')))).default;const digest=TypedDataUtils.sign(typedData,true);const signature=new lib_esm/* SigningKey */.Et((0,utils/* addHexPrefix */.L_)(privateKey)).signDigest(digest);return (0,bytes_lib_esm/* joinSignature */.gV)(signature);}async function recoverTypedSignature_v4(type,signature,typedData,netId){if(type==='cfx'){const hashedMessage=keccak256(cip23GetMessage(typedData,false,type==='cfx'?'CIP23Domain':'EIP712Domain'));return encodeCfxAddress(cfxSDKSign.publicKeyToAddress(toBuffer(CfxMessage.recover(signature,hashedMessage))),netId);}const{TypedDataUtils}=(await Promise.resolve().then(()=>_interopRequireWildcard(require('eth-sig-util')))).default;const digest=TypedDataUtils.sign(typedData,true);const pub=ethRecoverPublicKey(digest,signature);return ethComputeAddress(pub);}const ethEcdsaSign=(hash,pk)=>new SigningKey(addHexPrefix(pk)).sign(addHexPrefix(hash));const cfxEcdsaSign=(hash,pk)=>CfxMessage.sign(toBuffer(addHexPrefix(pk)),toBuffer(hash));const ecdsaSign=(type,hash,privateKey)=>type==='cfx'?cfxEcdsaSign(hash,privateKey):ethEcdsaSign(hash,privateKey);const ethEcdsaRecover=(hash,signature)=>ethRecoverPublicKey(addHexPrefix(hash),signature);const cfxEcdsaRecover=(hash,signature,netId)=>encodeCfxAddress(cfxSDKSign.publicKeyToAddress(toBuffer(CfxMessage.recover(hash,signature))),netId);const ecdsaRecover=(type,hash,sig,netId)=>type==='cfx'?cfxEcdsaRecover(hash,sig,netId):ethEcdsaRecover(hash,sig);const cfxSignTransaction=(tx,pk,netId)=>{const transaction=new src.Transaction(tx);return transaction.sign(pk,netId).serialize();};const ethSignTransaction=(tx,pk)=>{pk=(0,utils/* addHexPrefix */.L_)(pk);const signature=new lib_esm/* SigningKey */.Et(pk).signDigest((0,keccak256_lib_esm/* keccak256 */.w)((0,transactions_lib_esm/* serialize */.qC)(tx)));return (0,transactions_lib_esm/* serialize */.qC)(tx,signature);};const cfxRecoverTransactionToAddress=(tx,{r,s,v},netId)=>{const transaction=new src.Transaction({...tx,r:(0,utils/* addHexPrefix */.L_)(r),s:(0,utils/* addHexPrefix */.L_)(s),v:(0,utils/* addHexPrefix */.L_)(v)});let pub=transaction.recover();return (0,base32_address/* encode */.cv)('0x'+src.sign.publicKeyToAddress((0,utils/* toBuffer */.Qi)(pub)).toString('hex'),netId);};const ethRecoverTransactionToAddress=(tx,{r,s,v})=>{const addr=(0,transactions_lib_esm/* recoverAddress */.RJ)((0,keccak256_lib_esm/* keccak256 */.w)((0,transactions_lib_esm/* serialize */.qC)(tx)),{r:(0,utils/* addHexPrefix */.L_)(r),s:(0,utils/* addHexPrefix */.L_)(s),v:(0,utils/* addHexPrefix */.L_)(v)});return addr;};const cfxEncodeTx=(tx,shouldStripHexPrefix=false)=>{const transaction=new src.Transaction(tx);const encoded=transaction.encode(false).toString('hex');if(shouldStripHexPrefix)return encoded;return`0x${encoded}`;};const ethEncodeTx=(tx,shouldStripHexPrefix=false)=>{tx=(0,transactions_lib_esm/* serialize */.qC)(tx);if(shouldStripHexPrefix)return (0,utils/* stripHexPrefix */.MT)(tx);return tx;};const cfxJoinTransactionAndSignature=({tx,signature:[r,s,v]})=>{const transaction=new src.Transaction({...tx,r:(0,utils/* addHexPrefix */.L_)(r),s:(0,utils/* addHexPrefix */.L_)(s),v:(0,utils/* addHexPrefix */.L_)(v)});return transaction.serialize();};const ethJoinTransactionAndSignature=({tx,signature:[r,s,v]})=>{return (0,transactions_lib_esm/* serialize */.qC)(tx,(0,bytes_lib_esm/* joinSignature */.gV)({r:(0,utils/* addHexPrefix */.L_)(r),s:(0,utils/* addHexPrefix */.L_)(s),v:(0,utils/* addHexPrefix */.L_)(v)}));};const getTxHashFromRawTx=txhash=>{return (0,keccak256_lib_esm/* keccak256 */.w)(txhash);};

/***/ }),

/***/ 27797:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Byte": () => (/* reexport */ Byte),
  "Bytes": () => (/* reexport */ Bytes),
  "Bytes256": () => (/* reexport */ Bytes256),
  "Bytes32": () => (/* reexport */ Bytes32),
  "Bytes65": () => (/* reexport */ Bytes65),
  "Hash32": () => (/* reexport */ Hash32),
  "Uint": () => (/* reexport */ Uint),
  "Uint256": () => (/* reexport */ Uint256),
  "addressType": () => (/* reexport */ addressType),
  "alt": () => (/* reexport */ alt),
  "altn": () => (/* reexport */ altn),
  "and": () => (/* reexport */ and),
  "any": () => (/* reexport */ any),
  "anyp": () => (/* reexport */ anyp),
  "arr": () => (/* reexport */ arr),
  "arrp": () => (/* reexport */ arrp),
  "associative": () => (/* reexport */ associative),
  "asterisk": () => (/* reexport */ asterisk),
  "atLeastOneHttpUrl": () => (/* reexport */ atLeastOneHttpUrl),
  "base32Address": () => (/* binding */ base32Address),
  "base32BuiltinAddress": () => (/* binding */ base32BuiltinAddress),
  "base32ContractAddress": () => (/* binding */ base32ContractAddress),
  "base32NullAddress": () => (/* binding */ base32NullAddress),
  "base32UserAddress": () => (/* binding */ base32UserAddress),
  "blockRef": () => (/* reexport */ blockRef),
  "blockTag": () => (/* reexport */ blockTag),
  "boolean": () => (/* reexport */ spec_boolean),
  "booleanp": () => (/* reexport */ booleanp),
  "cat": () => (/* reexport */ cat),
  "catn": () => (/* reexport */ catn),
  "cfxHexAddress": () => (/* binding */ cfxHexAddress),
  "chainId": () => (/* reexport */ chainId),
  "char": () => (/* reexport */ spec_char),
  "coll": () => (/* reexport */ coll),
  "dbid": () => (/* reexport */ dbid),
  "defBase32AddressSchemaFactory": () => (/* reexport */ defBase32AddressSchemaFactory),
  "defRestSchemas": () => (/* reexport */ defRestSchemas),
  "double": () => (/* reexport */ spec_double),
  "doublep": () => (/* reexport */ doublep),
  "empty": () => (/* reexport */ empty),
  "enums": () => (/* reexport */ enums),
  "epochRef": () => (/* reexport */ epochRef),
  "epochRefNoMined": () => (/* reexport */ epochRefNoMined),
  "epochTag": () => (/* reexport */ epochTag),
  "epochTagNoMined": () => (/* reexport */ epochTagNoMined),
  "eq": () => (/* reexport */ eq),
  "ethHexAddress": () => (/* binding */ ethHexAddress),
  "explain": () => (/* reexport */ explain),
  "f": () => (/* reexport */ f),
  "falsep": () => (/* reexport */ falsep),
  "float": () => (/* reexport */ spec_float),
  "fn": () => (/* reexport */ fn),
  "gt": () => (/* reexport */ gt),
  "gte": () => (/* reexport */ gte),
  "hdPath": () => (/* binding */ hdPath),
  "hex": () => (/* reexport */ hex),
  "hexBuiltInAddress": () => (/* binding */ hexBuiltInAddress),
  "hexContractAddress": () => (/* binding */ hexContractAddress),
  "hexNullAddress": () => (/* binding */ hexNullAddress),
  "hexUserAddress": () => (/* binding */ hexUserAddress),
  "ident": () => (/* reexport */ ident),
  "indexed": () => (/* reexport */ indexed),
  "inst": () => (/* reexport */ inst),
  "int": () => (/* reexport */ spec_int),
  "integer": () => (/* reexport */ integer),
  "intp": () => (/* reexport */ intp),
  "jsinst": () => (/* reexport */ jsinst),
  "jssetp": () => (/* reexport */ jssetp),
  "k": () => (/* reexport */ k),
  "keyword": () => (/* reexport */ keyword),
  "keywordp": () => (/* reexport */ keywordp),
  "list": () => (/* reexport */ list),
  "lt": () => (/* reexport */ lt),
  "lte": () => (/* reexport */ lte),
  "map": () => (/* reexport */ map),
  "mapOf": () => (/* reexport */ mapOf),
  "mapp": () => (/* reexport */ mapp),
  "maybe": () => (/* reexport */ maybe),
  "mnemonic": () => (/* binding */ mnemonic),
  "multi": () => (/* reexport */ multi),
  "natInt": () => (/* reexport */ natInt),
  "neg": () => (/* reexport */ neg),
  "negInt": () => (/* reexport */ negInt),
  "neq": () => (/* reexport */ neq),
  "networkId": () => (/* reexport */ networkId),
  "nickname": () => (/* binding */ nickname),
  "not": () => (/* reexport */ not),
  "nul": () => (/* reexport */ nul),
  "number": () => (/* reexport */ number),
  "obj": () => (/* reexport */ obj),
  "objOf": () => (/* reexport */ objOf),
  "objp": () => (/* reexport */ objp),
  "oneOrMore": () => (/* reexport */ oneOrMore),
  "optParam": () => (/* reexport */ optParam),
  "optionalMapKey": () => (/* binding */ optionalMapKey),
  "or": () => (/* reexport */ or),
  "orn": () => (/* reexport */ orn),
  "password": () => (/* reexport */ spec_password),
  "plus": () => (/* reexport */ plus),
  "pos": () => (/* reexport */ pos),
  "posInt": () => (/* reexport */ posInt),
  "privateKey": () => (/* binding */ privateKey),
  "qualifiedIdent": () => (/* reexport */ qualifiedIdent),
  "qualifiedKeyword": () => (/* reexport */ qualifiedKeyword),
  "qualifiedSymbol": () => (/* reexport */ qualifiedSymbol),
  "questionMark": () => (/* reexport */ questionMark),
  "rawSchema": () => (/* reexport */ rawSchema),
  "re": () => (/* reexport */ re),
  "ref": () => (/* reexport */ ref),
  "regexp": () => (/* reexport */ regexp),
  "repeat": () => (/* reexport */ repeat),
  "richUrl": () => (/* reexport */ richUrl),
  "schema": () => (/* reexport */ schema),
  "seq": () => (/* reexport */ seq),
  "seqable": () => (/* reexport */ seqable),
  "sequential": () => (/* reexport */ sequential),
  "sequentialp": () => (/* reexport */ sequentialp),
  "set": () => (/* reexport */ set),
  "setp": () => (/* reexport */ setp),
  "simpleIdent": () => (/* reexport */ simpleIdent),
  "some": () => (/* reexport */ some),
  "string": () => (/* reexport */ string),
  "stringp": () => (/* reexport */ stringp),
  "symbol": () => (/* reexport */ symbol),
  "symbolp": () => (/* reexport */ symbolp),
  "tokenSymbol": () => (/* reexport */ tokenSymbol),
  "truep": () => (/* reexport */ truep),
  "tuple": () => (/* reexport */ tuple),
  "undefine": () => (/* reexport */ undefine),
  "uri": () => (/* reexport */ uri),
  "url": () => (/* reexport */ url),
  "uuid": () => (/* reexport */ uuid),
  "uuidp": () => (/* reexport */ uuidp),
  "validate": () => (/* reexport */ validate),
  "vector": () => (/* reexport */ vector),
  "vectorp": () => (/* reexport */ vectorp),
  "zero": () => (/* reexport */ zero),
  "zeroOrMore": () => (/* reexport */ zeroOrMore),
  "zeroOrOne": () => (/* reexport */ zeroOrOne)
});

// EXTERNAL MODULE: ../../packages/spec/src/shared.js
var shared = __webpack_require__(46615);
;// CONCATENATED MODULE: ../../packages/spec/src/spec.js


var Bt=function(a,b,c){if(shared/* $APP.Oe */.EY.Oe(c)){var d=shared/* $APP.wf */.EY.wf(shared/* $APP.Ko */.EY.Ko,shared/* $APP.ig.h */.EY.ig.h(a,c));return b.g?b.g(d):b.call(null,d)}return shared/* $APP.zg */.EY.zg(c)?(d=new shared/* $APP.oe */.EY.oe(function(){var e=shared/* $APP.Sb */.EY.Sb(c);return a.g?a.g(e):a.call(null,e)}(),function(){var e=shared/* $APP.Ub */.EY.Ub(c);return a.g?a.g(e):a.call(null,e)}()),b.g?b.g(d):b.call(null,d)):shared/* $APP.ae */.EY.ae(c)?(d=shared/* $APP.ci */.EY.ci(shared/* $APP.ig.h */.EY.ig.h(a,c)),b.g?b.g(d):b.call(null,d)):shared/* $APP.Ud */.EY.Ud(c)?(d=shared/* $APP.tb */.EY.tb(function(e,Df){return shared/* $APP.Qe.h */.EY.Qe.h(e,a.g?a.g(Df):a.call(null,Df))},c,c),b.g?b.g(d):b.call(null,d)):shared/* $APP.Pd */.EY.Pd(c)?(d=shared/* $APP.hg.h */.EY.hg.h(shared/* $APP.Fd */.EY.Fd(c),
shared/* $APP.ig.h */.EY.ig.h(a,c)),b.g?b.g(d):b.call(null,d)):b.g?b.g(c):b.call(null,c)},Ct=function(a){return function d(c){return new shared/* $APP.ef */.EY.ef(null,function(){if(shared/* $APP.z */.EY.z(shared/* $APP.Sd.g */.EY.Sd.g?shared/* $APP.Sd.g */.EY.Sd.g(c):shared/* $APP.Sd.call */.EY.Sd.call(null,c))){var e=shared/* $APP.Bd */.EY.Bd([shared/* $APP.J.g */.EY.J.g?shared/* $APP.J.g */.EY.J.g(c):shared/* $APP.J.call */.EY.J.call(null,c)]);e=shared/* $APP.wf */.EY.wf(shared/* $APP.Lo */.EY.Lo,shared/* $APP.xf */.EY.xf(shared/* $APP.ig */.EY.ig,d,e))}else e=null;return shared/* $APP.Te */.EY.Te(c,e)},null)}(a)},Dt=function(a){return shared/* $APP.dg */.EY.dg(function(b){return!shared/* $APP.Sd */.EY.Sd(b)},shared/* $APP.bd */.EY.bd(Ct(a)))},Et=function(a,b,c){return new shared/* $APP.ef */.EY.ef(null,function(){var d=shared/* $APP.J */.EY.J(c);if(d){var e=shared/* $APP.Wh.h */.EY.Wh.h(a,
d);return a===shared/* $APP.ud */.EY.ud(e)?shared/* $APP.Te */.EY.Te(e,Et(a,b,shared/* $APP.ag */.EY.ag(b,d))):null}return null},null)},Ft=function(a,b){var c=shared/* $APP.Ef */.EY.Ef(b);c=shared/* $APP.R.h */.EY.R.h(c,shared/* $APP.Bi */.EY.Bi);var d=shared/* $APP.z */.EY.z(c)?shared/* $APP.mi */.EY.mi:shared/* $APP.G */.EY.G;return function g(Df){return(null!=Df?shared/* $APP.Qc */.EY.Qc===Df.Ze||(Df.jb?0:shared/* $APP.ob */.EY.ob(shared/* $APP.zi */.EY.zi,Df)):shared/* $APP.ob */.EY.ob(shared/* $APP.zi */.EY.zi,Df))?shared/* $APP.Ai */.EY.Ai(Df,shared/* $APP.wf */.EY.wf(shared/* $APP.Ci */.EY.Ci,b)):shared/* $APP.ae */.EY.ae(Df)?shared/* $APP.ci */.EY.ci(shared/* $APP.ig.h */.EY.ig.h(g,Df)):shared/* $APP.zg */.EY.zg(Df)?new shared/* $APP.oe */.EY.oe(g(shared/* $APP.Sb */.EY.Sb(Df)),g(shared/* $APP.Ub */.EY.Ub(Df))):shared/* $APP.Pd */.EY.Pd(Df)?shared/* $APP.hg.i */.EY.hg.i(shared/* $APP.Fd */.EY.Fd(Df),shared/* $APP.ig.g */.EY.ig.g(g),Df):shared/* $APP.gb */.EY.gb(Df)?shared/* $APP.uc */.EY.uc(shared/* $APP.tb */.EY.tb(function(h,Wm){return shared/* $APP.Ma */.EY.Ma(h,
g(Wm))},shared/* $APP.sc */.EY.sc(shared/* $APP.fg */.EY.fg),Df)):shared/* $APP.pb */.EY.pb(Df)===Object?shared/* $APP.uc */.EY.uc(shared/* $APP.tb */.EY.tb(function(h,Wm){var m=shared/* $APP.Da */.EY.Da(Df,Wm);return null==m?h:shared/* $APP.pf */.EY.pf(h,d.g?d.g(Wm):d.call(null,Wm),g(m))},shared/* $APP.sc */.EY.sc(shared/* $APP.Jf */.EY.Jf),shared/* $APP.Ba */.EY.Ba(Df))):Df}(a)},Gt=function(a){return Ft(a,shared/* $APP.Bd */.EY.Bd([shared/* $APP.Bi */.EY.Bi,!0]))},It=function(a,b){return shared/* $APP.z */.EY.z(shared/* $APP.Of */.EY.Of(shared/* $APP.Ph */.EY.Ph([b]),Ht))?new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[b,new shared/* $APP.n */.EY.n(null,1,[dC,a],null)],null):b},Jt=function(a,b){return shared/* $APP.mi.g */.EY.mi.g(["base32",shared/* $APP.z */.EY.z(a)?["-",shared/* $APP.z */.EY.z(b)?[shared/* $APP.G.g */.EY.G.g(a),"-",shared/* $APP.G.g */.EY.G.g(b)].join(""):shared/* $APP.G.g */.EY.G.g(a)].join(""):
shared/* $APP.z */.EY.z(b)?["-",shared/* $APP.G.g */.EY.G.g(b)].join(""):"","-address"].join(""))},Kt=function Kt(a,b){return Bt(shared/* $APP.Rf */.EY.Rf(Kt,a),a,b)},Lt=new shared/* $APP.u */.EY.u(null,"privateKey","privateKey",1845961641),eC=new shared/* $APP.u */.EY.u(null,"hexContractAddress","hexContractAddress",-893096304),aC=new shared/* $APP.u */.EY.u(null,"ethHexAddress","ethHexAddress",-582045032),Mt=new shared/* $APP.u */.EY.u(null,"epoch-tag-no-mined","epoch-tag-no-mined",82003433),Rt=new shared/* $APP.u */.EY.u(null,"randomPrivateKey","randomPrivateKey",1183021577),fC=new shared/* $APP.u */.EY.u(null,"epoch-ref","epoch-ref",-48908512),Tt=
new shared/* $APP.u */.EY.u(null,"randomHexAddress","randomHexAddress",1570574414),cC=new shared/* $APP.H */.EY.H(null,"lower","lower",-1534114948,null),Ut=new shared/* $APP.u */.EY.u(null,"uint","uint",521409576),Vt=new shared/* $APP.u */.EY.u(null,"hexBuiltInAddress","hexBuiltInAddress",1280085039),gC=new shared/* $APP.u */.EY.u(null,"undefined","undefined",-1970511116),hC=new shared/* $APP.u */.EY.u(null,"validateHDPath","validateHDPath",-1924266109),vD=new shared/* $APP.u */.EY.u(null,"at-least-one-http-or-https-url","at-least-one-http-or-https-url",-1305343988),iC=new shared/* $APP.u */.EY.u(null,"bytes-256","bytes-256",-339812064),
bu=new shared/* $APP.u */.EY.u(null,"js-set","js-set",855005610),jC=new shared/* $APP.u */.EY.u(null,"generateMnemonic","generateMnemonic",-1133348254),du=new shared/* $APP.u */.EY.u(null,"address-type","address-type",921859604),uC=new shared/* $APP.H */.EY.H(null,"upper","upper",1886775433,null),dC=new shared/* $APP.u */.EY.u(null,"netId","netId",-280816369),Nt=new shared/* $APP.u */.EY.u(null,"bytes-32","bytes-32",953912278),Ot=new shared/* $APP.u */.EY.u(null,"uint-256","uint-256",582839198),Pt=new shared/* $APP.u */.EY.u(null,"hexUserAddress","hexUserAddress",1842704561),Qt=new shared/* $APP.u */.EY.u(null,"bytes-65","bytes-65",469917002),St=
new shared/* $APP.u */.EY.u(null,"INTERNAL_CONTRACTS_HEX_ADDRESS","INTERNAL_CONTRACTS_HEX_ADDRESS",1890509993),kC=new shared/* $APP.u */.EY.u(null,"abc","abc",-1232035677),lC=new shared/* $APP.u */.EY.u(null,"randomHDPath","randomHDPath",-672829199),mC=new shared/* $APP.u */.EY.u(null,"js-date","js-date",-66554654),JC=new shared/* $APP.u */.EY.u(null,"isChecksummed","isChecksummed",2103096499),Wt=new shared/* $APP.u */.EY.u(null,"optional-param","optional-param",745881564),nC=new shared/* $APP.u */.EY.u("cfxjs.spec.core","schema","cfxjs.spec.core/schema",-2104791549),oC=new shared/* $APP.u */.EY.u(null,"hexNullAddress","hexNullAddress",
-1249531275),Xt=new shared/* $APP.u */.EY.u(null,"url","url",276297046),pC=new shared/* $APP.u */.EY.u(null,"epoch-tag","epoch-tag",-1905188154),qC=new shared/* $APP.u */.EY.u(null,"hd-path","hd-path",-1739234499),Yt=new shared/* $APP.u */.EY.u(null,"hash-32","hash-32",1821363454),rC=new shared/* $APP.u */.EY.u(null,"validateMnemonic","validateMnemonic",-1802951577),sC=new shared/* $APP.u */.EY.u(null,"dbid","dbid",-196647356),Zt=new shared/* $APP.u */.EY.u(null,"hexString","hexString",608989661),$t=new shared/* $APP.u */.EY.u(null,"validatePrivateKey","validatePrivateKey",2114592353),au=new shared/* $APP.u */.EY.u(null,"epoch-ref-no-mined","epoch-ref-no-mined",
1348888713),cu=new shared/* $APP.u */.EY.u(null,"byte","byte",683775220),tC=new shared/* $APP.u */.EY.u(null,"network-id","network-id",-1769267262),eu=new shared/* $APP.u */.EY.u(null,"bytes","bytes",1175866680);/*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
var Ht,fu,gu,hu,iu,ju,ku=function ku(a){switch(arguments.length){case 1:return ku.g(arguments[0]);case 2:return ku.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",shared/* $APP.G.g */.EY.G.g(arguments.length)].join(""));}};ku.g=function(a){return ku.h(a,shared/* $APP.Jf */.EY.Jf)};ku.h=function(a,b){a=Gt(a);b=shared/* $APP.R.h */.EY.R.h(b,dC);return shared/* $APP.z */.EY.z(b)?Kt(shared/* $APP.Rf */.EY.Rf(It,b),a):a};ku.B=2;
var lu=function lu(a){switch(arguments.length){case 1:return lu.g(arguments[0]);case 2:return lu.h(arguments[0],arguments[1]);case 3:return lu.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",shared/* $APP.G.g */.EY.G.g(arguments.length)].join(""));}};lu.g=function(a){return lu.i(a,void 0,shared/* $APP.Jf */.EY.Jf)};lu.h=function(a,b){return lu.i(a,b,shared/* $APP.Jf */.EY.Jf)};lu.i=function(a,b,c){c=Gt(c);a=shared/* $APP.Fi */.EY.Fi(ku)(a,c);b=Ft(b,shared/* $APP.Bd */.EY.Bd([shared/* $APP.Bi */.EY.Bi,!1]));return shared/* $APP.Ul */.EY.Ul(a,b,c)};lu.B=3;
var mu=function mu(a){switch(arguments.length){case 2:return mu.h(arguments[0],arguments[1]);case 3:return mu.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",shared/* $APP.G.g */.EY.G.g(arguments.length)].join(""));}};mu.h=function(a,b){return mu.i(a,b,shared/* $APP.Jf */.EY.Jf)};mu.i=function(a,b,c){c=Gt(c);a=shared/* $APP.Fi */.EY.Fi(ku)(a,c);b=Ft(b,shared/* $APP.Bd */.EY.Bd([shared/* $APP.Bi */.EY.Bi,!1]));b=shared/* $APP.Wl */.EY.Wl(a,c)(b,shared/* $APP.fg */.EY.fg,shared/* $APP.fg */.EY.fg);b=shared/* $APP.ym */.EY.ym(b);return shared/* $APP.Xo */.EY.Xo(b)};mu.B=3;
var nu=function nu(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return nu.j(arguments[0],1<c.length?new shared/* $APP.Yc */.EY.Yc(c.slice(1),0,null):null)};
nu.j=function(a,b){b=Et(2,2,b);var c=shared/* $APP.O */.EY.O(b),d=shared/* $APP.Q */.EY.Q(c,0,null);c=shared/* $APP.Q */.EY.Q(c,1,null);d=shared/* $APP.Bd */.EY.Bd([shared/* $APP.Vd */.EY.Vd(d)?d:new shared/* $APP.X */.EY.X(null,1,5,shared/* $APP.Z */.EY.Z,[d],null),c]);a=shared/* $APP.Sk */.EY.Sk(a,null);d=shared/* $APP.Ff */.EY.Ff(shared/* $APP.xf */.EY.xf(shared/* $APP.Po */.EY.Po,shared/* $APP.ok */.EY.ok(a),d));c=shared/* $APP.ok */.EY.ok(a);if(d!==c&&!shared/* $APP.vd.h */.EY.vd.h(d,c)){c=shared/* $APP.kk */.EY.kk;var e=shared/* $APP.rk */.EY.rk(a);var Df=(Df=null!=a?shared/* $APP.Qc */.EY.Qc===a.Bd?!0:!1:!1)?shared/* $APP.gk */.EY.gk(a):Df;Df=shared/* $APP.z */.EY.z(Df)?Df:shared/* $APP.qk */.EY.qk(a);a=c(e,d,Df,shared/* $APP.pk */.EY.pk(a))}b=Dt(shared/* $APP.bd */.EY.bd(b));return shared/* $APP.Od */.EY.Od(b)?a:shared/* $APP.xf */.EY.xf(nu,a,b)};nu.B=1;
nu.F=function(a){var b=shared/* $APP.O */.EY.O(a);a=shared/* $APP.P */.EY.P(a);return this.j(b,a)};
var ou=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.wt */.EY.wt,new shared/* $APP.n */.EY.n(null,2,[shared/* $APP.Ck */.EY.Ck,8,shared/* $APP.Dk */.EY.Dk,128],null)],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.tq */.EY.tq,"String between 8 to 128 character",shared/* $APP.Gk */.EY.Gk,shared/* $APP.$o */.EY.$o])),pu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.$z */.EY.$z,new shared/* $APP.n */.EY.n(null,2,[shared/* $APP.Ck */.EY.Ck,0,shared/* $APP.Dk */.EY.Dk,4294967295],null)],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,tC,shared/* $APP.tq */.EY.tq,"1029 for mainnet, 1 for testnet, 0 \x3c\x3d networkId \x3c\x3d 4294967295"])),qu=nu.j(new shared/* $APP.X */.EY.X(null,5,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.dr */.EY.dr,"user","contract","builtin","null"],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,du,shared/* $APP.tq */.EY.tq,
"Is string, one of user contract builtin null"])),ru=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0(x|X)?[a-fA-F0-9]+$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Zt,shared/* $APP.ez */.EY.ez,function(){return["0x",shared/* $APP.G.g */.EY.G.g(Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))].join("")},shared/* $APP.Pr */.EY.Pr,"invalid hex string, should match regex ^0(x|X)?[a-fA-F0-9]+$",shared/* $APP.tq */.EY.tq,"hexadecimal string"])),su=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x([0-9a-fA-F]?){1,2}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,cu,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x([0-9a-fA-F]?){1,2}$",
shared/* $APP.tq */.EY.tq,"hex encoded byte"])),tu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x[0-9a-f]*$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,eu,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x[0-9a-f]*$",shared/* $APP.tq */.EY.tq,"hex encoded bytes"])),uu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x[0-9a-f]{64}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Nt,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x[0-9a-f]{64}$",shared/* $APP.tq */.EY.tq,"32 hex encoded bytes"])),vu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x[0-9a-f]{512}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,iC,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x[0-9a-f]{512}$",shared/* $APP.tq */.EY.tq,
"256 hex encoded bytes"])),wu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x[0-9a-f]{512}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Qt,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x[0-9a-f]{512}$",shared/* $APP.tq */.EY.tq,"65 hex encoded bytes"])),xu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x([1-9a-f]+[0-9a-f]*|0)$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Ut,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x([1-9a-f]+[0-9a-f]*|0)$",shared/* $APP.tq */.EY.tq,"hex encoded unsigned integer"])),yu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x[0-9a-f]{64}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Ot,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x[0-9a-f]{64}$",
shared/* $APP.tq */.EY.tq,"hex encoded unsigned integer"])),zu=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x[0-9a-f]{64}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Yt,shared/* $APP.Pr */.EY.Pr,"should match regex ^0x[0-9a-f]{64}$",shared/* $APP.tq */.EY.tq,"32 byte hex value"])),Au=nu.j(xu,shared/* $APP.Bd */.EY.Bd([new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.tq */.EY.tq,"chainid, 0x-prefixed hexadecimal string"],null)])),Bu=shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,mC,shared/* $APP.mm */.EY.mm,function(a){try{return shared/* $APP.id */.EY.id(a)||shared/* $APP.id */.EY.id(new Date(a))}catch(b){if(b instanceof Error)return!1;throw b;}},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,
"should be a valid date string",shared/* $APP.tq */.EY.tq,"valid js date string",shared/* $APP.ez */.EY.ez,function(){function a(c){var d=null;if(0<arguments.length){d=0;for(var e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new shared/* $APP.Yc */.EY.Yc(e,0,null)}return b.call(this,d)}function b(){return(new Date).toISOString()}a.B=0;a.F=function(c){c=shared/* $APP.J */.EY.J(c);return b(c)};a.j=b;return a}()],null)],null)),Cu=shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,bu,shared/* $APP.mm */.EY.mm,function(a){return shared/* $APP.Vd */.EY.Vd(a)&&shared/* $APP.vd.h */.EY.vd.h(shared/* $APP.ud */.EY.ud(shared/* $APP.hg.h */.EY.hg.h(shared/* $APP.Oh */.EY.Oh,a)),shared/* $APP.ud */.EY.ud(a))},
shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,"should be a array without duplicate item",shared/* $APP.tq */.EY.tq,"array without duplicate item",shared/* $APP.ez */.EY.ez,function(){function a(c){var d=null;if(0<arguments.length){d=0;for(var e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new shared/* $APP.Yc */.EY.Yc(e,0,null)}return b.call(this,d)}function b(){return new shared/* $APP.Nh */.EY.Nh(null,new shared/* $APP.n */.EY.n(null,4,[kC,null,"a",null,3,null,!1,null],null),null)}a.B=0;a.F=function(c){c=shared/* $APP.J */.EY.J(c);return b(c)};a.j=b;return a}()],null)],null)),Du=shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,
3,[shared/* $APP.Gk */.EY.Gk,shared/* $APP.Xq */.EY.Xq,shared/* $APP.mm */.EY.mm,shared/* $APP.fb */.EY.fb,shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,"should be null or cljs nil",shared/* $APP.tq */.EY.tq,"javascript null or cljs nil",shared/* $APP.ez */.EY.ez,function(){function a(b){if(0<arguments.length)for(var c=0,d=Array(arguments.length-0);c<d.length;)d[c]=arguments[c+0],++c;return null}a.B=0;a.F=function(b){shared/* $APP.J */.EY.J(b);return null};a.j=function(){return null};return a}()],null)],null)),Eu=RegExp,fv=shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,gC,shared/* $APP.mm */.EY.mm,function(a){return shared/* $APP.vd.h */.EY.vd.h(void 0,a)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,
3,[shared/* $APP.Pr */.EY.Pr,"should be undefined",shared/* $APP.tq */.EY.tq,"javascript undefined",shared/* $APP.ez */.EY.ez,function(){function a(b){if(0<arguments.length)for(var c=0,d=Array(arguments.length-0);c<d.length;)d[c]=arguments[c+0],++c}a.B=0;a.F=function(b){shared/* $APP.J */.EY.J(b)};a.j=function(){};return a}()],null)],null)),gv=nu.j(new shared/* $APP.X */.EY.X(null,8,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.dr */.EY.dr,"latest_mined","latest_finalized","latest_confirmed","latest_state","latest_checkpoint","earliest",null],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,pC,shared/* $APP.Pr */.EY.Pr,"must be one of latest_mined, latest_finalized, latest_confirmed, latest_state, latest_checkpoint, earliest or null",
shared/* $APP.tq */.EY.tq,"one of latest_mined, latest_finalized, latest_confirmed, latest_state, latest_checkpoint, earliest or null, default to latest_state"])),hv=nu.j(new shared/* $APP.X */.EY.X(null,7,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.dr */.EY.dr,"latest_finalized","latest_confirmed","latest_state","latest_checkpoint","earliest",null],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Mt,shared/* $APP.Pr */.EY.Pr,"must be one of latest_finalized, latest_confirmed, latest_state, latest_checkpoint, earliest or null",shared/* $APP.tq */.EY.tq,"one of latest_finalized, latest_confirmed, latest_state, latest_checkpoint, earliest or null, default to latest_state"])),
iv=nu.j(new shared/* $APP.X */.EY.X(null,3,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Fp */.EY.Fp,gv,xu],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,fC,shared/* $APP.Pr */.EY.Pr,"invalid epoch ref, check the doc at https://developer.conflux-chain.org/conflux-doc/docs/json_rpc#the-epoch-number-parameter",shared/* $APP.tq */.EY.tq,"epoch number tag, check the doc at https://developer.conflux-chain.org/conflux-doc/docs/json_rpc#the-epoch-number-parameter"])),jv=nu.j(new shared/* $APP.X */.EY.X(null,3,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Fp */.EY.Fp,hv,xu],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,au,shared/* $APP.Pr */.EY.Pr,"invalid epoch ref, check the doc at https://developer.conflux-chain.org/conflux-doc/docs/json_rpc#the-epoch-number-parameter",
shared/* $APP.tq */.EY.tq,"epoch number tag, check the doc at https://developer.conflux-chain.org/conflux-doc/docs/json_rpc#the-epoch-number-parameter"])),kv=nu.j(new shared/* $APP.X */.EY.X(null,5,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.dr */.EY.dr,"latest","earliest","pending",null],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,pC,shared/* $APP.Pr */.EY.Pr,"invalid block tag, must be one of latest pending or earliest",shared/* $APP.tq */.EY.tq,"one of latest pending or earliest, default to latest"])),lv=nu.j(new shared/* $APP.X */.EY.X(null,3,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Fp */.EY.Fp,kv,xu],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,fC,shared/* $APP.Pr */.EY.Pr,"invalid block ref, must be one of latest, pending, earliest, block number or null",
shared/* $APP.tq */.EY.tq,"one of latest, pending, earliest, block number or null"]));nu.j(new shared/* $APP.X */.EY.X(null,4,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.dr */.EY.dr,"builtin","user","contract"],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,du,shared/* $APP.Pr */.EY.Pr,"invalid conflux user type, must be one of builtin user contract",shared/* $APP.tq */.EY.tq,"one of builtin user contract"]));
var mv=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^(?:(?:https?):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))?\.?)(?::\d{2,5})?(?:[\/?#]\S*)?$/i],null),
shared/* $APP.Bd */.EY.Bd([shared/* $APP.ez */.EY.ez,function(){return"https://example.com/"},shared/* $APP.Gk */.EY.Gk,Xt,shared/* $APP.Pr */.EY.Pr,"invalid http/https url",shared/* $APP.tq */.EY.tq,"http/https url"])),wD=nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^(?:(?:((http|ws)s?|ipfs)):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))?\.?)(?::\d{2,5})?(?:[\/?#]\S*)?$/i],
null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.ez */.EY.ez,function(){return"https://example.com/"},shared/* $APP.Gk */.EY.Gk,Xt,shared/* $APP.Pr */.EY.Pr,"Invalid http/https/wss/ws/ipfs url",shared/* $APP.tq */.EY.tq,"http/https/ws/wss/ipfs url"])),xD=nu.j(new shared/* $APP.X */.EY.X(null,3,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Yy */.EY.Yy,function(a,b,c){return shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,["at-least-one-",shared/* $APP.G.g */.EY.G.g(a)].join(""),shared/* $APP.mm */.EY.mm,function(d){return shared/* $APP.Of */.EY.Of(b,d)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,["At least one fullfill ",shared/* $APP.G.g */.EY.G.g(a)].join(""),shared/* $APP.tq */.EY.tq,["At least one fullfill ",shared/* $APP.G.g */.EY.G.g(a)].join(""),shared/* $APP.ez */.EY.ez,c],null)],null))}("starts-with-http",
function(a){var b="string"===typeof a;return b?a.startsWith("http"):b},function(){return"https://example.com"}),new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Jp */.EY.Jp,wD],null)],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,vD,shared/* $APP.Pr */.EY.Pr,"should has at least one http/https url",shared/* $APP.tq */.EY.tq,"array with at least one http/https url",shared/* $APP.ez */.EY.ez,function(){return new shared/* $APP.X */.EY.X(null,1,5,shared/* $APP.Z */.EY.Z,["https://example.com"],null)}])),nv=nu.j(new shared/* $APP.X */.EY.X(null,4,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Fp */.EY.Fp,fv,Du,new shared/* $APP.X */.EY.X(null,3,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Yy */.EY.Yy,shared/* $APP.Vd */.EY.Vd,shared/* $APP.Od */.EY.Od],null)],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,
Wt,shared/* $APP.tq */.EY.tq,"undefined, null or empty array"])),ov=nu.j(shared/* $APP.he */.EY.he,shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,sC,shared/* $APP.Pr */.EY.Pr,"invalid dbid, must be a positive integer",shared/* $APP.tq */.EY.tq,"database id, positive integer"])),pv=nu.j(new shared/* $APP.X */.EY.X(null,3,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Yy */.EY.Yy,new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^[a-zA-Z0-9+\-%\/$]+$/],null),new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.wt */.EY.wt,new shared/* $APP.n */.EY.n(null,2,[shared/* $APP.Ck */.EY.Ck,1,shared/* $APP.Dk */.EY.Dk,20],null)],null)],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Pr */.EY.Pr,"invalid token symbol, 1. should match regex ^[a-zA-Z0-9+\\-%/$]+$ 2. length should between 1 to 20",
shared/* $APP.tq */.EY.tq,"token symbol"]));let uri=shared/* $APP.aj */.EY.aj;let uuid=shared/* $APP.Lz */.EY.Lz;let seq=shared/* $APP.ae */.EY.ae;let keywordp=shared/* $APP.Ve */.EY.Ve;let arrp=shared/* $APP.Vd */.EY.Vd;let set=shared/* $APP.Tp */.EY.Tp;let obj=shared/* $APP.xq */.EY.xq;let mapOf=shared/* $APP.$q */.EY.$q;let Bytes65=wu;let lt=shared/* $APP.Xu */.EY.Xu;let enums=shared/* $APP.dr */.EY.dr;let spec_boolean=shared/* $APP.Ku */.EY.Ku;let booleanp=shared/* $APP.$d */.EY.$d;let map=shared/* $APP.xq */.EY.xq;let spec_char=shared/* $APP.lb */.EY.lb;let addressType=qu;let networkId=pu;let blockRef=lv;let any=shared/* $APP.Tq */.EY.Tq;let neg=shared/* $APP.Le */.EY.Le;let objp=shared/* $APP.Td */.EY.Td;
let indexed=shared/* $APP.td */.EY.td;let zero=shared/* $APP.Ke */.EY.Ke;let objOf=shared/* $APP.$q */.EY.$q;let qualifiedIdent=shared/* $APP.$e */.EY.$e;let richUrl=wD;
let defBase32AddressSchemaFactory=function(a,b){fu=shared/* $APP.ms */.EY.ms(function(c){c=shared/* $APP.Ef */.EY.Ef(c);var d=shared/* $APP.R.h */.EY.R.h(c,dC);return new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,Jt(null,d),shared/* $APP.mm */.EY.mm,function(e){return a.h?a.h(e,d):a.call(null,e,d)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,["Invalid base32 address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.tq */.EY.tq,["Base32 address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.ez */.EY.ez,function(){return b.call(null,d)}],null)],null)});gu=shared/* $APP.ms */.EY.ms(function(c){c=
shared/* $APP.Ef */.EY.Ef(c);var d=shared/* $APP.R.h */.EY.R.h(c,dC);return new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,Jt("user",d),shared/* $APP.mm */.EY.mm,function(e){return a.i?a.i(e,"user",d):a.call(null,e,"user",d)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,["Invalid base32 user address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.tq */.EY.tq,["Base32 user address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.ez */.EY.ez,function(){return b.call(null,d)}],null)],null)});hu=shared/* $APP.ms */.EY.ms(function(c){c=shared/* $APP.Ef */.EY.Ef(c);var d=shared/* $APP.R.h */.EY.R.h(c,dC);return new shared/* $APP.n */.EY.n(null,
3,[shared/* $APP.Gk */.EY.Gk,Jt("contract",d),shared/* $APP.mm */.EY.mm,function(e){return a.i?a.i(e,"contract",d):a.call(null,e,"contract",d)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,["Invalid base32 contract address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.tq */.EY.tq,["Base32 contract address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.ez */.EY.ez,function(){return b.call(null,d)}],null)],null)});iu=shared/* $APP.ms */.EY.ms(function(c){c=shared/* $APP.Ef */.EY.Ef(c);var d=shared/* $APP.R.h */.EY.R.h(c,dC);return new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,Jt("builtin",
d),shared/* $APP.mm */.EY.mm,function(e){return a.i?a.i(e,"builtin",d):a.call(null,e,"builtin",d)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,["Invalid base32 builtin address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.tq */.EY.tq,["Base32 builtin address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.ez */.EY.ez,function(){return b.call(null,d)}],null)],null)});ju=shared/* $APP.ms */.EY.ms(function(c){c=shared/* $APP.Ef */.EY.Ef(c);var d=shared/* $APP.R.h */.EY.R.h(c,dC);return new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,Jt("null",d),shared/* $APP.mm */.EY.mm,function(e){return a.i?
a.i(e,"null",d):a.call(null,e,"null",d)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,["Invalid base32 null address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.tq */.EY.tq,["Base32 null address",shared/* $APP.z */.EY.z(d)?[", with network id ",shared/* $APP.G.g */.EY.G.g(d)].join(""):""].join(""),shared/* $APP.ez */.EY.ez,function(){return b.call(null,d)}],null)],null)});return Ht=new shared/* $APP.X */.EY.X(null,5,5,shared/* $APP.Z */.EY.Z,[fu,gu,hu,iu,ju],null)};let cat=shared/* $APP.Uz */.EY.Uz;let schema=shared/* $APP.Cm */.EY.Cm;let explain=mu;let oneOrMore=shared/* $APP.Jp */.EY.Jp;
let asterisk=shared/* $APP.kz */.EY.kz;let zeroOrOne=shared/* $APP.iA */.EY.iA;let epochTag=gv;let Uint256=yu;let spec_double=shared/* $APP.Wp */.EY.Wp;let dbid=ov;let questionMark=shared/* $APP.iA */.EY.iA;let jssetp=Cu;let zeroOrMore=shared/* $APP.kz */.EY.kz;let fn=shared/* $APP.OA */.EY.OA;let stringp=shared/* $APP.kb */.EY.kb;let orn=shared/* $APP.vr */.EY.vr;let intp=shared/* $APP.ge */.EY.ge;let jsinst=Bu;let inst=shared/* $APP.id */.EY.id;let eq=shared/* $APP.wp */.EY.wp;let validate=lu;let spec_int=shared/* $APP.$z */.EY.$z;let undefine=fv;let number=shared/* $APP.hb */.EY.hb;
let rawSchema=nC;let alt=shared/* $APP.Uy */.EY.Uy;let seqable=shared/* $APP.be */.EY.be;let vectorp=shared/* $APP.Vd */.EY.Vd;let spec_password=ou;let qualifiedSymbol=shared/* $APP.Dz */.EY.Dz;let ref=shared/* $APP.Uk */.EY.Uk;let falsep=shared/* $APP.Yd */.EY.Yd;let sequential=shared/* $APP.PA */.EY.PA;let spec_float=shared/* $APP.ke */.EY.ke;let arr=shared/* $APP.cq */.EY.cq;let setp=shared/* $APP.Qd */.EY.Qd;let symbol=shared/* $APP.mA */.EY.mA;let maybe=shared/* $APP.mz */.EY.mz;let associative=shared/* $APP.Rd */.EY.Rd;let natInt=shared/* $APP.je */.EY.je;let or=shared/* $APP.Fp */.EY.Fp;let nul=Du;let re=shared/* $APP.Al */.EY.Al;let negInt=shared/* $APP.ie */.EY.ie;
let some=shared/* $APP.jb */.EY.jb;let coll=shared/* $APP.Pd */.EY.Pd;let tuple=shared/* $APP.dB */.EY.dB;let pos=shared/* $APP.Je */.EY.Je;let not=shared/* $APP.Az */.EY.Az;let Bytes32=uu;let gte=shared/* $APP.pt */.EY.pt;let tokenSymbol=pv;let empty=shared/* $APP.Od */.EY.Od;
let defRestSchemas=function(a){a=Gt(a);a=shared/* $APP.Ef */.EY.Ef(a);var b=shared/* $APP.R.h */.EY.R.h(a,$t),c=shared/* $APP.R.h */.EY.R.h(a,jC),d=shared/* $APP.R.h */.EY.R.h(a,hC),e=shared/* $APP.R.h */.EY.R.h(a,rC),Df=shared/* $APP.R.h */.EY.R.h(a,Rt),g=shared/* $APP.R.h */.EY.R.h(a,St),h=shared/* $APP.R.h */.EY.R.h(a,Tt),Wm=shared/* $APP.R.h */.EY.R.h(a,lC),m=shared/* $APP.R.h */.EY.R.h(a,JC);a=Ft(g,shared/* $APP.Bd */.EY.Bd([shared/* $APP.Bi */.EY.Bi,!1]));return{hdPath:shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,qC,shared/* $APP.mm */.EY.mm,function(p){var r="string"===typeof p;return r?d.g?d.g(p):d.call(null,p):r},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,"should be a valid hdPath without the last address index",shared/* $APP.tq */.EY.tq,"hd wallet derivation path without the last address_index, check https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#abstract for detail",
shared/* $APP.ez */.EY.ez,function(){return Wm.call()}],null)],null)),mnemonic:shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,shared/* $APP.az */.EY.az,shared/* $APP.mm */.EY.mm,function(p){var r="string"===typeof p;return r?e.g?e.g(p):e.call(null,p):r},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,"should be a valid mnemonic",shared/* $APP.tq */.EY.tq,"Mnemonic phrase",shared/* $APP.ez */.EY.ez,function(){return c.call()}],null)],null)),privateKey:shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,Lt,shared/* $APP.mm */.EY.mm,function(p){return b.g?b.g(p):b.call(null,p)},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,"invalid private key",shared/* $APP.tq */.EY.tq,"0x-prefixed private key",
shared/* $APP.ez */.EY.ez,function(){return Df.call()}],null)],null)),ethHexAddress:shared/* $APP.ms */.EY.ms(new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Gk */.EY.Gk,aC,shared/* $APP.mm */.EY.mm,function(p){return"string"===typeof p?shared/* $APP.vd.h */.EY.vd.h(cC,p)?!0:shared/* $APP.vd.h */.EY.vd.h(uC,p)?!0:m.g?m.g(p):m.call(null,p):null},shared/* $APP.Um */.EY.Um,new shared/* $APP.n */.EY.n(null,3,[shared/* $APP.Pr */.EY.Pr,"invalid hex address, should match regex ^0x[0-9a-fA-F]{40}$ and should be valid checksum address if is mixed case",shared/* $APP.tq */.EY.tq,"0x-prefixed address, checksummed or single case address",shared/* $APP.ez */.EY.ez,function(){return h.h?h.h(null,!0):h.call(null,null,!0)}],
null)],null)),hexUserAddress:nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x1[0-9a-fA-F]{39}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Pt,shared/* $APP.ez */.EY.ez,function(){return h.g?h.g("user"):h.call(null,"user")},shared/* $APP.Pr */.EY.Pr,"invalid hex user address, should match regex #^0x1[0-9a-fA-F]{39}$",shared/* $APP.tq */.EY.tq,"Conflux hex user address"])),hexContractAddress:nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.Al */.EY.Al,/^0x8[0-9a-fA-F]{39}$/],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,eC,shared/* $APP.Pr */.EY.Pr,"invalid hex contract address, should match regex #^0x8[0-9a-fA-F]{39}$",shared/* $APP.tq */.EY.tq,"Conflux hex user address",
shared/* $APP.ez */.EY.ez,function(){return h.g?h.g("contract"):h.call(null,"contract")}])),hexBuiltInAddress:nu.j(shared/* $APP.hg.h */.EY.hg.h(new shared/* $APP.X */.EY.X(null,1,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.dr */.EY.dr],null),a),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,Vt,shared/* $APP.Pr */.EY.Pr,["invalid hex builtin address, can only be one of ",shared/* $APP.G.g */.EY.G.g(a)].join(""),shared/* $APP.tq */.EY.tq,"Hex address of conflux internal contract, can be found at https://confluxscan.io/contracts",shared/* $APP.hp */.EY.hp,a])),hexNullAddress:nu.j(new shared/* $APP.X */.EY.X(null,2,5,shared/* $APP.Z */.EY.Z,[shared/* $APP.wp */.EY.wp,"0x0000000000000000000000000000000000000000"],null),shared/* $APP.Bd */.EY.Bd([shared/* $APP.Gk */.EY.Gk,oC,shared/* $APP.tq */.EY.tq,
"Null address: 0x0000000000000000000000000000000000000000",shared/* $APP.Pr */.EY.Pr,"invalid hex null address, should be 0x0000000000000000000000000000000000000000"]))}};let string=shared/* $APP.wt */.EY.wt;let vector=shared/* $APP.cq */.EY.cq;let k=shared/* $APP.mi */.EY.mi;let qualifiedKeyword=shared/* $APP.Kq */.EY.Kq;let epochRef=iv;let mapp=shared/* $APP.Td */.EY.Td;let symbolp=shared/* $APP.Tc */.EY.Tc;let posInt=shared/* $APP.he */.EY.he;let altn=shared/* $APP.ap */.EY.ap;let integer=shared/* $APP.fe */.EY.fe;let regexp=Eu;let Bytes=tu;let doublep=shared/* $APP.le */.EY.le;let hex=ru;
let Hash32=zu;let list=shared/* $APP.Oe */.EY.Oe;let catn=shared/* $APP.nA */.EY.nA;let keyword=shared/* $APP.yr */.EY.yr;let multi=shared/* $APP.bz */.EY.bz;let chainId=Au;let neq=shared/* $APP.RA */.EY.RA;let gt=shared/* $APP.Oz */.EY.Oz;let truep=shared/* $APP.Zd */.EY.Zd;let anyp=shared/* $APP.nb */.EY.nb;let atLeastOneHttpUrl=xD;let sequentialp=shared/* $APP.Sd */.EY.Sd;let plus=shared/* $APP.Jp */.EY.Jp;let epochTagNoMined=hv;let ident=shared/* $APP.Ye */.EY.Ye;let url=mv;let repeat=shared/* $APP.gp */.EY.gp;let Uint=xu;let lte=shared/* $APP.Nu */.EY.Nu;let and=shared/* $APP.Yy */.EY.Yy;
let blockTag=kv;let uuidp=shared/* $APP.Vi */.EY.Vi;let epochRefNoMined=jv;let simpleIdent=shared/* $APP.Ze */.EY.Ze;let Byte=su;let Bytes256=vu;let f=shared/* $APP.nl */.EY.nl;let optParam=nv;
// EXTERNAL MODULE: ../../packages/consts/index.js
var consts = __webpack_require__(9414);
// EXTERNAL MODULE: ../../packages/account/index.js + 16 modules
var account = __webpack_require__(11239);
// EXTERNAL MODULE: ../../node_modules/bip39/src/index.js
var src = __webpack_require__(36832);
// EXTERNAL MODULE: ../../packages/base32-address/index.js + 3 modules
var base32_address = __webpack_require__(2723);
// EXTERNAL MODULE: ../../packages/hdkey/index.js
var hdkey = __webpack_require__(32299);
;// CONCATENATED MODULE: ../../packages/spec/index.js

 // eslint-disable-line import/export
;








const {
  ethHexAddress,
  hexUserAddress,
  hexContractAddress,
  hexBuiltInAddress,
  hexNullAddress,
  mnemonic,
  privateKey,
  hdPath,
} = defRestSchemas({
  INTERNAL_CONTRACTS_HEX_ADDRESS: consts/* INTERNAL_CONTRACTS_HEX_ADDRESS */.kg,
  NULL_HEX_ADDRESS: consts/* NULL_HEX_ADDRESS */.JV,
  validatePrivateKey: account/* validatePrivateKey */.QS,
  isChecksummed: account/* isChecksummed */.KS,
  randomHexAddress: account/* randomHexAddress */.MG,
  randomCfxHexAddress: account/* randomCfxHexAddress */.fS,
  randomPrivateKey: account/* randomPrivateKey */.UB,
  validateMnemonic: src/* validateMnemonic */._I,
  generateMnemonic: src/* generateMnemonic */.OF,
  validateHDPath: hdkey/* validateHDPath */.BQ,
  randomHDPath: hdkey/* randomHDPath */.mu,
})

const cfxHexAddress = [
  or,
  hexUserAddress,
  hexContractAddress,
  hexBuiltInAddress,
  hexNullAddress,
]

const [
  base32Address,
  base32UserAddress,
  base32ContractAddress,
  base32BuiltinAddress,
  base32NullAddress,
] = defBase32AddressSchemaFactory(base32_address/* validateBase32Address */.pd, base32_address/* randomBase32Address */.TW)

const nickname = [
  stringp,
  {
    min: 1,
    max: 20,
    doc: 'Nickname of this account, a string with 1 to 20 characters',
  },
]

const optionalMapKey = s => {
  if (s.length === 3) {
    const [k, opt, v] = s
    return [k, {...opt, optional: true}, v]
  }
  if (s.length === 2) {
    const [k, v] = s
    return [k, {optional: true}, v]
  }

  throw new Error('unsupported spec')
}


/***/ }),

/***/ 46615:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EY": () => (/* binding */ $APP)
/* harmony export */ });
/* unused harmony exports shadow$provide, $jscomp */

const $APP = {};
const shadow$provide = {};
const $jscomp = {};
/*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
var da,ja,ya,ua,va,Aa,Fa,Ga,Ea,Ha,Ia,Ja,Ka,La,Na,Pa,Qa,Oa,Sa,Ua,Wa,Ta,Xa,Za,Ya,$a,eb,rb,sb,vb,wb,xb,yb,zb,Ab,Bb,Cb,Eb,Fb,Gb,Hb,Ib,Jb,Kb,Lb,Mb,Nb,Ob,Pb,Qb,Rb,Vb,Wb,Xb,Yb,Zb,ac,bc,dc,ec,fc,gc,hc,ic,jc,kc,lc,mc,nc,oc,pc,qc,rc,vc,wc,xc,yc,Bc,Cc,Dc,Ec,Fc,Hc,Kc,Lc,Mc,Pc,Rc,Sc,Uc,Vc,Wc,Xc,cd,dd,ed,$c,fd,hd,jd,kd,md,nd,od,pd,qd,rd,sd,yd,zd,Ad,Cd,Hd,xd,Id,Jd,Kd,Ld,Md,Nd,Xd,ee,pe,qe,qn,se,ve,ye,we,xe,ze,Ae,ub,Be,De,Fe,Ie,Me,Pe,Re,Se,Ue,Xe,af,cf,ff,gf,jf,kf,mf,ue,nf,of,qf,rf,tf,sf,uf,vf,Bf,yf,zf,Af,Mf,Qf,Uf,
Xf,Zf,$f,Tf,bg,mg,ng,og,pg,qg,rg,sg,tg,ug,vg,xg,wg,yg,Dg,Gg,Eg,Fg,Hg,Jg,Kg,Lg,Mg,Ng,Og,Qg,Sg,Tg,Ug,Vg,Wg,bh,Ih,Sh,Xg,Ll,Yg,$g,ah,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,oh,mh,nh,qh,th,rh,sh,uh,yh,wh,xh,zh,Ah,Ch,Dh,Eh,Ag,Gh,Hh,Bg,Lh,Mh,Qh,Th,Vh,Xh,Yh,Zh,bi,di,ei,hi,ji,ki,oi,qi,si,ti,ui,ni,wi,xi,yi,Ji,Ki,Li,Ni,Oi,Si,Ui,Zi,$i,ej,gg,jg,mb,hj,Tb,de,vh,ij,jj,kj,lj,mj,nj,oj,pj,qj,rj,sj,uj,vj,wj,xj,yj,Aj,Cj,Dj,Ej,Gj,Ij,Jj,Kj,Lj,Mj,Nj,Oj,Pj,Qj,Rj,Sj,Tj,Uj,Vj,Wj,Xj,bk,ck,ek,bj,ik,jk,mk,nk,sk,cj,fj,gj,ak,fk,uk,hk,yk,
zk,Ak,Bk,tk,Lk,Mk,Nk,Ok,im,km,bl,el,kl,fl,gl,jl,Jk,Gl,Hl,Qk,Am,Mm,Sm,Ym,dn,ws,zs,Ds,Fs,Hs,Is,rl,sl,Js,Wy,gB,jB,mB,Yk,Xk,tl,rB,uB,xB,AB,Cl,FB,IB,LB,Wk,Vk,Kk,SB,YB,Nl,Ql,hl,Tk,rp,xs,Oo,BB,$l,cD,fD,gD,hD,lm,nm,om,pm,um,vm,zm,Bm,Dm,Fm,Hm,Jm,Nm,Pm,Rm,Tm,Vm,Xm,Zm,an,cn,en,gn,jn,ln,nn,pn,rn,sn,tn,un,wn,xn,yn,zn,Bn,Cn,En,Fn,Hn,In,Kn,Nn,On,Mn,Tn,Un,Vn,Xn,Yn,bo,co,ho,io,no,qo,ro,fa,ha;$APP.aa=function(a){var b=typeof a;return"object"!=b?b:a?Array.isArray(a)?"array":b:"null"};
da=function(a){var b=$APP.aa(a);return"array"==b||"object"==b&&"number"==typeof a.length};ja=function(a){return Object.prototype.hasOwnProperty.call(a,fa)&&a[fa]||(a[fa]=++ha)};$APP.ma=function(a,b){return new $APP.ka(a,b)};$APP.sa=function(a){return 0<a?0x7fffffffffffffff<=a?na:new $APP.ka(a,a/4294967296):0>a?-0x7fffffffffffffff>=a?oa:$APP.pa(new $APP.ka(-a,-a/4294967296)):$APP.qa};$APP.pa=function(a){var b=~a.da+1|0;return $APP.ma(b,~a.V+!b|0)};
$APP.ta=function(a){return 4294967296*a.V+(a.da>>>0)};
ya=function(a,b){if(ua(b))throw Error("division by zero");if(0>a.V){if(va(a,oa)){if(va(b,$APP.wa)||va(b,xa))return oa;if(va(b,oa))return $APP.wa;var c=ya($APP.za(a,1),b).shiftLeft(1);if(va(c,$APP.qa))return 0>b.V?$APP.wa:xa;var d=b.multiply(c);a=a.add($APP.pa(d));return c.add(ya(a,b))}return 0>b.V?ya($APP.pa(a),$APP.pa(b)):$APP.pa(ya($APP.pa(a),b))}if(ua(a))return $APP.qa;if(0>b.V)return va(b,oa)?$APP.qa:$APP.pa(ya(a,$APP.pa(b)));for(d=$APP.qa;0<=a.compare(b);){c=Math.max(1,Math.floor($APP.ta(a)/
$APP.ta(b)));var e=Math.ceil(Math.log(c)/Math.LN2);e=48>=e?1:Math.pow(2,e-48);for(var Df=$APP.sa(c),g=Df.multiply(b);0>g.V||0<g.compare(a);)c-=e,Df=$APP.sa(c),g=Df.multiply(b);ua(Df)&&(Df=$APP.wa);d=d.add(Df);a=a.add($APP.pa(g))}return d};ua=function(a){return 0==a.da&&0==a.V};va=function(a,b){return a.da==b.da&&a.V==b.V};$APP.za=function(a,b){b&=63;if(0==b)return a;var c=a.V;return 32>b?$APP.ma(a.da>>>b|c<<32-b,c>>b):$APP.ma(c>>b-32,0<=c?0:-1)};Aa=function(a){return/^[\s\xa0]*$/.test(a)};
$APP.Ba=function(a){const b=[];let c=0;for(const d in a)b[c++]=d;return b};$APP.Da=function(a,b){return null!==a&&b in a?a[b]:void 0};Fa=function(a,b){a.sort(b||Ea)};Ga=function(a,b){const c=Array(a.length);for(let e=0;e<a.length;e++)c[e]={index:e,value:a[e]};const d=b||Ea;Fa(c,function(e,Df){return d(e.value,Df.value)||e.index-Df.index});for(b=0;b<a.length;b++)a[b]=c[b].value};Ea=function(a,b){return a>b?1:a<b?-1:0};
Ha=function(a){if(a.qc&&"function"==typeof a.qc)return a.qc();if("undefined"!==typeof Map&&a instanceof Map||"undefined"!==typeof Set&&a instanceof Set)return Array.from(a.values());if("string"===typeof a)return a.split("");if(da(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}b=[];c=0;for(d in a)b[c++]=a[d];return b};
Ia=function(a){if(a.je&&"function"==typeof a.je)return a.je();if(!a.qc||"function"!=typeof a.qc){if("undefined"!==typeof Map&&a instanceof Map)return Array.from(a.keys());if(!("undefined"!==typeof Set&&a instanceof Set)){if(da(a)||"string"===typeof a){var b=[];a=a.length;for(var c=0;c<a;c++)b.push(c);return b}return $APP.Ba(a)}}};
Ja=function(a,b,c){if(a.forEach&&"function"==typeof a.forEach)a.forEach(b,c);else if(da(a)||"string"===typeof a)Array.prototype.forEach.call(a,b,c);else for(var d=Ia(a),e=Ha(a),Df=e.length,g=0;g<Df;g++)b.call(c,e[g],d&&d[g],a)};Ka=function(a,b){if(a){a=a.split("\x26");for(var c=0;c<a.length;c++){var d=a[c].indexOf("\x3d"),e=null;if(0<=d){var Df=a[c].substring(0,d);e=a[c].substring(d+1)}else Df=a[c];b(Df,e?decodeURIComponent(e.replace(/\+/g," ")):"")}}};
La=function(a){this.Rb=this.vc=this.ec="";this.Mc=null;this.pc=this.Gb="";this.yb=this.xf=!1;if(a instanceof La){this.yb=a.yb;Na(this,a.ec);var b=a.vc;Oa(this);this.vc=b;b=a.Rb;Oa(this);this.Rb=b;Pa(this,a.Mc);b=a.Gb;Oa(this);this.Gb=b;Qa(this,a.Fb.clone());a=a.pc;Oa(this);this.pc=a}else a&&(b=String(a).match(Ra))?(this.yb=!1,Na(this,b[1]||"",!0),a=b[2]||"",Oa(this),this.vc=Sa(a),a=b[3]||"",Oa(this),this.Rb=Sa(a,!0),Pa(this,b[4]),a=b[5]||"",Oa(this),this.Gb=Sa(a,!0),Qa(this,b[6]||"",!0),a=b[7]||"",
Oa(this),this.pc=Sa(a)):(this.yb=!1,this.Fb=new Ta(null,this.yb))};Na=function(a,b,c){Oa(a);a.ec=c?Sa(b,!0):b;a.ec&&(a.ec=a.ec.replace(/:$/,""))};Pa=function(a,b){Oa(a);if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.Mc=b}else a.Mc=null};Qa=function(a,b,c){Oa(a);b instanceof Ta?(a.Fb=b,a.Fb.Ef(a.yb)):(c||(b=Ua(b,Va)),a.Fb=new Ta(b,a.yb))};Oa=function(a){if(a.xf)throw Error("Tried to modify a read-only Uri");};
Sa=function(a,b){return a?b?decodeURI(a.replace(/%25/g,"%2525")):decodeURIComponent(a):""};Ua=function(a,b,c){return"string"===typeof a?(a=encodeURI(a).replace(b,Wa),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null};Wa=function(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)};Ta=function(a,b){this.pb=this.Ja=null;this.ub=a||null;this.yb=!!b};Xa=function(a){a.Ja||(a.Ja=new Map,a.pb=0,a.ub&&Ka(a.ub,function(b,c){a.add(decodeURIComponent(b.replace(/\+/g," ")),c)}))};
Za=function(a,b){Xa(a);b=Ya(a,b);return a.Ja.has(b)};Ya=function(a,b){b=String(b);a.yb&&(b=b.toLowerCase());return b};$a=function(a,b){null!=a&&this.append.apply(this,arguments)};eb=function(){return new $APP.n(null,5,[If,!0,ab,!0,bb,!1,cb,!1,db,null],null)};$APP.z=function(a){return null!=a&&!1!==a};$APP.fb=function(a){return null==a};$APP.gb=function(a){return a instanceof Array};$APP.hb=function(a){return"number"===typeof a};$APP.ib=function(a){return null==a?!0:!1===a?!0:!1};
$APP.jb=function(a){return null!=a};$APP.kb=function(a){return"string"===$APP.aa(a)};$APP.lb=function(a){return"string"===typeof a&&1===a.length};$APP.nb=function(){return!0};$APP.ob=function(a,b){return a[$APP.aa(null==b?null:b)]?!0:a._?!0:!1};$APP.pb=function(a){return null==a?null:a.constructor};$APP.qb=function(a,b){var c=$APP.pb(b);return Error(["No protocol method ",a," defined for type ",$APP.z($APP.z(c)?c.R:c)?c.P:$APP.aa(b),": ",b].join(""))};rb=function(a){var b=a.P;return $APP.z(b)?b:$APP.G.g(a)};
sb=function(a){for(var b=a.length,c=Array(b),d=0;;)if(d<b)c[d]=a[d],d+=1;else break;return c};vb=function(a){function b(d,e){d.push(e);return d}var c=[];return $APP.tb?$APP.tb(b,c,a):ub.call(null,b,c,a)};wb=function(){};xb=function(){};yb=function(){};zb=function(a){if(null!=a&&null!=a.ja)a=a.ja(a);else{var b=zb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=zb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("ICounted.-count",a);}return a};Ab=function(){};
Bb=function(a){if(null!=a&&null!=a.Ba)a=a.Ba(a);else{var b=Bb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Bb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IEmptyableCollection.-empty",a);}return a};Cb=function(){};
$APP.Db=function(a,b){if(null!=a&&null!=a.Aa)a=a.Aa(a,b);else{var c=$APP.Db[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=$APP.Db._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("ICollection.-conj",a);}return a};Eb=function(){};Fb=function(){};
Gb=function(a){if(null!=a&&null!=a.Da)a=a.Da(a);else{var b=Gb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Gb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("ISeq.-first",a);}return a};Hb=function(a){if(null!=a&&null!=a.Ha)a=a.Ha(a);else{var b=Hb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Hb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("ISeq.-rest",a);}return a};Ib=function(){};
Jb=function(a){if(null!=a&&null!=a.Ca)a=a.Ca(a);else{var b=Jb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Jb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("INext.-next",a);}return a};Kb=function(){};Lb=function(){};Mb=function(a,b){if(null!=a&&null!=a.Lb)a=a.Lb(a,b);else{var c=Mb[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=Mb._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IAssociative.-contains-key?",a);}return a};
Nb=function(a,b,c){if(null!=a&&null!=a.tb)a=a.tb(a,b,c);else{var d=Nb[$APP.aa(null==a?null:a)];if(null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else if(d=Nb._,null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else throw $APP.qb("IAssociative.-assoc",a);}return a};Ob=function(){};Pb=function(a,b){if(null!=a&&null!=a.Ac)a=a.Ac(a,b);else{var c=Pb[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=Pb._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IFind.-find",a);}return a};
Qb=function(){};Rb=function(a,b){if(null!=a&&null!=a.Sc)a=a.Sc(a,b);else{var c=Rb[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=Rb._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IMap.-dissoc",a);}return a};$APP.Sb=function(a){if(null!=a&&null!=a.df)a=a.key;else{var b=$APP.Sb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.Sb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IMapEntry.-key",a);}return a};
$APP.Ub=function(a){if(null!=a&&null!=a.ef)a=a.o;else{var b=$APP.Ub[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.Ub._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IMapEntry.-val",a);}return a};Vb=function(){};Wb=function(a){if(null!=a&&null!=a.Cc)a=a.Cc(a);else{var b=Wb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Wb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IStack.-peek",a);}return a};
Xb=function(a){if(null!=a&&null!=a.Dc)a=a.Dc(a);else{var b=Xb[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Xb._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IStack.-pop",a);}return a};Yb=function(){};Zb=function(a,b,c){if(null!=a&&null!=a.lc)a=a.lc(a,b,c);else{var d=Zb[$APP.aa(null==a?null:a)];if(null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else if(d=Zb._,null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else throw $APP.qb("IVector.-assoc-n",a);}return a};
$APP.$b=function(a){if(null!=a&&null!=a.Mb)a=a.Mb(a);else{var b=$APP.$b[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.$b._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IDeref.-deref",a);}return a};ac=function(){};bc=function(a){if(null!=a&&null!=a.I)a=a.I(a);else{var b=bc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=bc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IMeta.-meta",a);}return a};
$APP.cc=function(a,b){if(null!=a&&null!=a.J)a=a.J(a,b);else{var c=$APP.cc[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=$APP.cc._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IWithMeta.-with-meta",a);}return a};dc=function(){};ec=function(){};
fc=function(a,b,c){if(null!=a&&null!=a.kc)a=a.kc(a,b,c);else{var d=fc[$APP.aa(null==a?null:a)];if(null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else if(d=fc._,null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else throw $APP.qb("IKVReduce.-kv-reduce",a);}return a};gc=function(a,b){if(null!=a&&null!=a.fa)a=a.fa(a,b);else{var c=gc[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=gc._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IEquiv.-equiv",a);}return a};
hc=function(a){if(null!=a&&null!=a.ga)a=a.ga(a);else{var b=hc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=hc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IHash.-hash",a);}return a};ic=function(){};jc=function(a){if(null!=a&&null!=a.ia)a=a.ia(a);else{var b=jc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=jc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("ISeqable.-seq",a);}return a};kc=function(){};lc=function(){};
mc=function(){};nc=function(){};oc=function(a){if(null!=a&&null!=a.Wc)a=a.Wc(a);else{var b=oc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=oc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IReversible.-rseq",a);}return a};pc=function(a,b){if(null!=a&&null!=a.Ae)a=a.Ae(a,b);else{var c=pc[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=pc._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IWriter.-write",a);}return a};
qc=function(){};rc=function(a,b,c){if(null!=a&&null!=a.Z)a=a.Z(a,b,c);else{var d=rc[$APP.aa(null==a?null:a)];if(null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else if(d=rc._,null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else throw $APP.qb("IPrintWithWriter.-pr-writer",a);}return a};
$APP.sc=function(a){if(null!=a&&null!=a.zc)a=a.zc(a);else{var b=$APP.sc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.sc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IEditableCollection.-as-transient",a);}return a};
$APP.tc=function(a,b){if(null!=a&&null!=a.Fc)a=a.Fc(a,b);else{var c=$APP.tc[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=$APP.tc._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("ITransientCollection.-conj!",a);}return a};
$APP.uc=function(a){if(null!=a&&null!=a.Xc)a=a.Xc(a);else{var b=$APP.uc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.uc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("ITransientCollection.-persistent!",a);}return a};
vc=function(a,b,c){if(null!=a&&null!=a.Ec)a=a.Ec(a,b,c);else{var d=vc[$APP.aa(null==a?null:a)];if(null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else if(d=vc._,null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else throw $APP.qb("ITransientAssociative.-assoc!",a);}return a};wc=function(){};
xc=function(a,b){if(null!=a&&null!=a.Zb)a=a.Zb(a,b);else{var c=xc[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=xc._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IComparable.-compare",a);}return a};yc=function(a){if(null!=a&&null!=a.ce)a=a.ce(a);else{var b=yc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=yc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IChunk.-drop-first",a);}return a};
$APP.zc=function(a){if(null!=a&&null!=a.Qc)a=a.Qc(a);else{var b=$APP.zc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.zc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IChunkedSeq.-chunked-first",a);}return a};$APP.Ac=function(a){if(null!=a&&null!=a.Yb)a=a.Yb(a);else{var b=$APP.Ac[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.Ac._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IChunkedSeq.-chunked-rest",a);}return a};
Bc=function(a){if(null!=a&&null!=a.Tc)a=a.Tc(a);else{var b=Bc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Bc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("INamed.-name",a);}return a};Cc=function(a){if(null!=a&&null!=a.Uc)a=a.Uc(a);else{var b=Cc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Cc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("INamed.-namespace",a);}return a};
Dc=function(a,b){if(null!=a&&null!=a.hf)a=a.hf(a,b);else{var c=Dc[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=Dc._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IReset.-reset!",a);}return a};Ec=function(a,b){if(null!=a&&null!=a.ee)a=a.ee(a,b);else{var c=Ec[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=Ec._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IVolatile.-vreset!",a);}return a};Fc=function(){};
$APP.Gc=function(a){if(null!=a&&null!=a.gb)a=a.gb(a);else{var b=$APP.Gc[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.Gc._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IIterable.-iterator",a);}return a};Hc=function(a){this.Hg=a;this.s=1073741824;this.A=0};$APP.Ic=function(a){var b=new $a;a.Z(null,new Hc(b),eb());return $APP.G.g(b)};Kc=function(a){a=Jc(a|0,-862048943);return Jc(a<<15|a>>>-15,461845907)};
Lc=function(a,b){a=(a|0)^(b|0);return Jc(a<<13|a>>>-13,5)+-430675100|0};Mc=function(a,b){a=(a|0)^b;a=Jc(a^a>>>16,-2048144789);a=Jc(a^a>>>13,-1028477387);return a^a>>>16};Pc=function(a){255<Nc&&(Oc={},Nc=0);if(null==a)return 0;var b=Oc[a];if("number"===typeof b)a=b;else{a:if(null!=a)if(b=a.length,0<b)for(var c=0,d=0;;)if(c<b)d=Jc(31,d)+a.charCodeAt(c),c+=1;else{b=d;break a}else b=0;else b=0;Oc[a]=b;Nc+=1;a=b}return a};
Rc=function(a){if(null!=a&&(a.s&4194304||$APP.Qc===a.Ug))return a.ga(null)^0;if("number"===typeof a){if(isFinite(a))return Math.floor(a)%2147483647;switch(a){case Infinity:return 2146435072;case -Infinity:return-1048576;default:return 2146959360}}else return!0===a?a=1231:!1===a?a=1237:"string"===typeof a?(a=Pc(a),a=0===a?a:Mc(Lc(0,Kc(a)),4)):a=a instanceof Date?a.valueOf()^0:null==a?0:hc(a)^0,a};Sc=function(a,b){return a^b+2654435769+(a<<6)+(a>>2)};$APP.Tc=function(a){return a instanceof $APP.H};
Uc=function(a){var b=a.name;a:{var c=1;for(var d=0;;)if(c<b.length)d=Lc(d,Kc(b.charCodeAt(c-1)|b.charCodeAt(c)<<16)),c+=2;else{c=d;break a}}return Sc(Mc(1===(b.length&1)?c^Kc(b.charCodeAt(b.length-1)):c,Jc(2,b.length)),Pc(a.eb))};Vc=function(a,b){if(a.Ib===b.Ib)return 0;var c=$APP.ib(a.eb);if($APP.z(c?b.eb:c))return-1;if($APP.z(a.eb)){if($APP.ib(b.eb))return 1;c=Ea(a.eb,b.eb);return 0===c?Ea(a.name,b.name):c}return Ea(a.name,b.name)};
$APP.H=function(a,b,c,d,e){this.eb=a;this.name=b;this.Ib=c;this.xc=d;this.xb=e;this.s=2154168321;this.A=4096};Wc=function(a,b,c){this.o=a;this.uc=b;this.xb=c;this.s=6717441;this.A=0};Xc=function(a){return null!=a?a.A&131072||$APP.Qc===a.Vg?!0:a.A?!1:$APP.ob(Fc,a):$APP.ob(Fc,a)};
$APP.J=function(a){if(null==a)return null;if(null!=a&&(a.s&8388608||$APP.Qc===a.ye))return a.ia(null);if($APP.gb(a)||"string"===typeof a)return 0===a.length?null:new $APP.Yc(a,0,null);if(null!=a&&null!=a[Zc])return a=$APP.Da(a,Zc).call(a),$c.g?$c.g(a):$c.call(null,a);if($APP.ob(ic,a))return jc(a);throw Error([$APP.G.g(a)," is not ISeqable"].join(""));};$APP.O=function(a){if(null==a)return null;if(null!=a&&(a.s&64||$APP.Qc===a.Bc))return a.Da(null);a=$APP.J(a);return null==a?null:Gb(a)};
$APP.bd=function(a){return null!=a?null!=a&&(a.s&64||$APP.Qc===a.Bc)?a.Ha(null):(a=$APP.J(a))?a.Ha(null):$APP.ad:$APP.ad};$APP.P=function(a){return null==a?null:null!=a&&(a.s&128||$APP.Qc===a.Vc)?a.Ca(null):$APP.J($APP.bd(a))};cd=function(a){this.W=a};dd=function(a){return new cd($APP.J(a))};ed=function(a,b){this.value=a;this.Kc=b;this.Zd=null;this.s=8388672;this.A=0};$c=function(a){var b=a.next();return $APP.z(b.done)?null:new ed(b.value,a)};
fd=function(a){var b=0,c=1;for(a=$APP.J(a);;)if(null!=a)b+=1,c=Jc(31,c)+Rc($APP.O(a))|0,a=$APP.P(a);else return Mc(Lc(0,Kc(c)),b)};$APP.gd=function(a){var b=0,c=0;for(a=$APP.J(a);;)if(null!=a)b+=1,c=c+Rc($APP.O(a))|0,a=$APP.P(a);else return Mc(Lc(0,Kc(c)),b)};hd=function(){};$APP.id=function(a){return null!=a?$APP.Qc===a.pf?!0:a.jb?!1:$APP.ob(hd,a):$APP.ob(hd,a)};jd=function(a){this.o=a;this.s=32768;this.A=0};kd=function(a){return new jd(a)};$APP.ld=function(a){return a instanceof jd};md=function(a){return $APP.$b(a)};
nd=function(a,b){var c=a.ja(null);if(0===c)return b.l?b.l():b.call(null);for(var d=a.ha(null,0),e=1;;)if(e<c){var Df=a.ha(null,e);d=b.h?b.h(d,Df):b.call(null,d,Df);if($APP.ld(d))return $APP.$b(d);e+=1}else return d};od=function(a,b,c){var d=a.ja(null),e=c;for(c=0;;)if(c<d){var Df=a.ha(null,c);e=b.h?b.h(e,Df):b.call(null,e,Df);if($APP.ld(e))return $APP.$b(e);c+=1}else return e};
pd=function(a,b){var c=a.length;if(0===a.length)return b.l?b.l():b.call(null);for(var d=a[0],e=1;;)if(e<c){var Df=a[e];d=b.h?b.h(d,Df):b.call(null,d,Df);if($APP.ld(d))return $APP.$b(d);e+=1}else return d};qd=function(a,b,c){var d=a.length,e=c;for(c=0;;)if(c<d){var Df=a[c];e=b.h?b.h(e,Df):b.call(null,e,Df);if($APP.ld(e))return $APP.$b(e);c+=1}else return e};rd=function(a,b,c,d){for(var e=a.length;;)if(d<e){var Df=a[d];c=b.h?b.h(c,Df):b.call(null,c,Df);if($APP.ld(c))return $APP.$b(c);d+=1}else return c};
sd=function(a){return null!=a?a.s&2||$APP.Qc===a.We?!0:a.s?!1:$APP.ob(yb,a):$APP.ob(yb,a)};$APP.td=function(a){return null!=a?a.s&16||$APP.Qc===a.xe?!0:a.s?!1:$APP.ob(Eb,a):$APP.ob(Eb,a)};yd=function(a,b,c){var d=$APP.ud.g?$APP.ud.g(a):$APP.ud.call(null,a);if(c>=d)return-1;!(0<c)&&0>c&&(c+=d,c=0>c?0:c);for(;;)if(c<d){if($APP.vd.h($APP.wd?$APP.wd(a,c):xd.call(null,a,c),b))return c;c+=1}else return-1};
zd=function(a,b,c){var d=$APP.ud.g?$APP.ud.g(a):$APP.ud.call(null,a);if(0===d)return-1;0<c?(--d,c=d<c?d:c):c=0>c?d+c:c;for(;;)if(0<=c){if($APP.vd.h($APP.wd?$APP.wd(a,c):xd.call(null,a,c),b))return c;--c}else return-1};Ad=function(a,b){this.arr=a;this.D=b};$APP.Yc=function(a,b,c){this.arr=a;this.D=b;this.H=c;this.s=166592766;this.A=139264};$APP.Bd=function(a){return 0<a.length?new $APP.Yc(a,0,null):null};Cd=function(a,b,c){this.od=a;this.D=b;this.H=c;this.s=32374990;this.A=8192};$APP.Dd=function(a){return $APP.O($APP.P(a))};
$APP.Ed=function(a){for(;;){var b=$APP.P(a);if(null!=b)a=b;else return $APP.O(a)}};$APP.Fd=function(a){return null==a?null:null!=a&&(a.s&4||$APP.Qc===a.Ye)?a.Ba(null):(null!=a?a.s&4||$APP.Qc===a.Ye||(a.s?0:$APP.ob(Ab,a)):$APP.ob(Ab,a))?Bb(a):null};
$APP.ud=function(a){if(null!=a)if(null!=a&&(a.s&2||$APP.Qc===a.We))a=a.ja(null);else if($APP.gb(a))a=a.length;else if("string"===typeof a)a=a.length;else if(null!=a&&(a.s&8388608||$APP.Qc===a.ye))a:{a=$APP.J(a);for(var b=0;;){if(sd(a)){a=b+zb(a);break a}a=$APP.P(a);b+=1}}else a=zb(a);else a=0;return a};Hd=function(a,b,c){for(;;){if(null==a)return c;if(0===b)return $APP.J(a)?$APP.O(a):c;if($APP.td(a))return $APP.Gd(a,b,c);if($APP.J(a))a=$APP.P(a),--b;else return c}};
xd=function(a){switch(arguments.length){case 2:return $APP.wd(arguments[0],arguments[1]);case 3:return $APP.Q(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
$APP.wd=function(a,b){if("number"!==typeof b)throw Error("Index argument to nth must be a number");if(null==a)return a;if(null!=a&&(a.s&16||$APP.Qc===a.xe))return a.ha(null,b);if($APP.gb(a)){if(-1<b&&b<a.length)return a[b|0];throw Error("Index out of bounds");}if("string"===typeof a){if(-1<b&&b<a.length)return a.charAt(b|0);throw Error("Index out of bounds");}if(null!=a&&(a.s&64||$APP.Qc===a.Bc)||null!=a&&(a.s&16777216||$APP.Qc===a.ze)){if(0>b)throw Error("Index out of bounds");a:for(;;){if(null==
a)throw Error("Index out of bounds");if(0===b){if($APP.J(a)){a=$APP.O(a);break a}throw Error("Index out of bounds");}if($APP.td(a)){a=$APP.Gd(a,b);break a}if($APP.J(a))a=$APP.P(a),--b;else throw Error("Index out of bounds");}return a}if($APP.ob(Eb,a))return $APP.Gd(a,b);throw Error(["nth not supported on this type ",$APP.G.g(rb($APP.pb(a)))].join(""));};
$APP.Q=function(a,b,c){if("number"!==typeof b)throw Error("Index argument to nth must be a number.");if(null==a)return c;if(null!=a&&(a.s&16||$APP.Qc===a.xe))return a.La(null,b,c);if($APP.gb(a))return-1<b&&b<a.length?a[b|0]:c;if("string"===typeof a)return-1<b&&b<a.length?a.charAt(b|0):c;if(null!=a&&(a.s&64||$APP.Qc===a.Bc)||null!=a&&(a.s&16777216||$APP.Qc===a.ze))return 0>b?c:Hd(a,b,c);if($APP.ob(Eb,a))return $APP.Gd(a,b,c);throw Error(["nth not supported on this type ",$APP.G.g(rb($APP.pb(a)))].join(""));
};Id=function(a){var b="function"===typeof a;return b?b:null!=a?$APP.Qc===a.ve?!0:a.jb?!1:$APP.ob(wb,a):$APP.ob(wb,a)};Jd=function(a,b){this.u=a;this.H=b;this.s=393217;this.A=0};Kd=function(a,b){return"function"===typeof a?new Jd(a,b):null==a?null:$APP.cc(a,b)};Ld=function(a){var b=null!=a;return(b?null!=a?a.s&131072||$APP.Qc===a.de||(a.s?0:$APP.ob(ac,a)):$APP.ob(ac,a):b)?bc(a):null};Md=function(a){return null==a?null:Wb(a)};Nd=function(a){return null==a?null:Xb(a)};
$APP.Od=function(a){return null==a||$APP.ib($APP.J(a))};$APP.Pd=function(a){return null==a?!1:null!=a?a.s&8||$APP.Qc===a.Sg?!0:a.s?!1:$APP.ob(Cb,a):$APP.ob(Cb,a)};$APP.Qd=function(a){return null==a?!1:null!=a?a.s&4096||$APP.Qc===a.bh?!0:a.s?!1:$APP.ob(Vb,a):$APP.ob(Vb,a)};$APP.Rd=function(a){return null!=a?a.s&512||$APP.Qc===a.we?!0:a.s?!1:$APP.ob(Lb,a):$APP.ob(Lb,a)};$APP.Sd=function(a){return null!=a?a.s&16777216||$APP.Qc===a.ze?!0:a.s?!1:$APP.ob(kc,a):$APP.ob(kc,a)};
$APP.Td=function(a){return null==a?!1:null!=a?a.s&1024||$APP.Qc===a.Yg?!0:a.s?!1:$APP.ob(Qb,a):$APP.ob(Qb,a)};$APP.Ud=function(a){return null!=a?a.s&67108864||$APP.Qc===a.$g?!0:a.s?!1:$APP.ob(mc,a):$APP.ob(mc,a)};$APP.Vd=function(a){return null!=a?a.s&16384||$APP.Qc===a.dh?!0:a.s?!1:$APP.ob(Yb,a):$APP.ob(Yb,a)};$APP.Wd=function(a){return null!=a?a.A&512||$APP.Qc===a.Rg?!0:!1:!1};Xd=function(a,b,c,d,e){for(;;){if(0===e)return c;c[d]=a[b];d+=1;--e;b+=1}};$APP.Yd=function(a){return!1===a};
$APP.Zd=function(a){return!0===a};$APP.$d=function(a){return!0===a||!1===a};$APP.ae=function(a){return null==a?!1:null!=a?a.s&64||$APP.Qc===a.Bc?!0:a.s?!1:$APP.ob(Fb,a):$APP.ob(Fb,a)};$APP.be=function(a){var b=null==a;return b?b:(b=null!=a?a.s&8388608||$APP.Qc===a.ye?!0:a.s?!1:$APP.ob(ic,a):$APP.ob(ic,a))?b:$APP.gb(a)||"string"===typeof a};$APP.ce=function(a){return null==a?!1:!1===a?!1:!0};ee=function(a){var b=Id(a);return b?b:null!=a?a.s&1||$APP.Qc===a.Tg?!0:a.s?!1:$APP.ob(xb,a):$APP.ob(xb,a)};
$APP.fe=function(a){return"number"===typeof a&&!isNaN(a)&&Infinity!==a&&parseFloat(a)===parseInt(a,10)};$APP.ge=function(a){return $APP.fe(a)||a instanceof $APP.ka};$APP.he=function(a){return $APP.fe(a)?0<a:a instanceof $APP.ka?$APP.ib(0>a.V)&&$APP.ib(ua(a)):!1};$APP.ie=function(a){return $APP.fe(a)?0>a:a instanceof $APP.ka?0>a.V:!1};$APP.je=function(a){return $APP.fe(a)?!(0>a):a instanceof $APP.ka?$APP.ib(0>a.V):!1};$APP.ke=function(a){return"number"===typeof a};
$APP.le=function(a){return"number"===typeof a};$APP.ne=function(a,b){return null!=a&&(a.s&512||$APP.Qc===a.we)?a.Lb(null,b):$APP.ob(Lb,a)?Mb(a,b):$APP.R.i(a,b,me)===me?!1:!0};pe=function(a,b){return(null!=a?$APP.Qc===a.Rc||(a.jb?0:$APP.ob(Ob,a)):$APP.ob(Ob,a))?Pb(a,b):null!=a&&$APP.Rd(a)&&$APP.ne(a,b)?new $APP.oe(b,$APP.R.h(a,b)):null};
qe=function(a,b){if(a===b)return 0;if(null==a)return-1;if(null==b)return 1;if("number"===typeof a){if("number"===typeof b)return Ea(a,b);throw Error(["Cannot compare ",$APP.G.g(a)," to ",$APP.G.g(b)].join(""));}if(null!=a?a.A&2048||$APP.Qc===a.yc||(a.A?0:$APP.ob(wc,a)):$APP.ob(wc,a))return xc(a,b);if("string"!==typeof a&&!$APP.gb(a)&&!0!==a&&!1!==a||$APP.pb(a)!==$APP.pb(b))throw Error(["Cannot compare ",$APP.G.g(a)," to ",$APP.G.g(b)].join(""));return Ea(a,b)};
qn=function(a,b){var c=$APP.ud(a),d=$APP.ud(b);if(c<d)a=-1;else if(c>d)a=1;else if(0===c)a=0;else a:for(d=0;;){var e=qe($APP.wd(a,d),$APP.wd(b,d));if(0===e&&d+1<c)d+=1;else{a=e;break a}}return a};se=function(a){return $APP.vd.h(a,qe)?qe:function(b,c){var d=a.h?a.h(b,c):a.call(null,b,c);return"number"===typeof d?d:$APP.z(d)?-1:$APP.z(a.h?a.h(c,b):a.call(null,c,b))?1:0}};ve=function(a){var b=$APP.Ba(te);if($APP.J(b)){var c=ue.g?ue.g(b):ue.call(null,b);Ga(c,se(a));return Kd($APP.J(c),Ld(b))}return $APP.ad};
ye=function(a){switch(arguments.length){case 2:return we(arguments[0],arguments[1]);case 3:return xe(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};we=function(a,b){var c=$APP.J(b);return c?(b=$APP.O(c),c=$APP.P(c),$APP.tb?$APP.tb(a,b,c):ub.call(null,a,b,c)):a.l?a.l():a.call(null)};xe=function(a,b,c){for(c=$APP.J(c);;)if(c){var d=$APP.O(c);b=a.h?a.h(b,d):a.call(null,b,d);if($APP.ld(b))return $APP.$b(b);c=$APP.P(c)}else return b};
ze=function(a,b){a=$APP.Gc(a);if($APP.z(a.Ia()))for(var c=a.next();;)if(a.Ia()){var d=a.next();c=b.h?b.h(c,d):b.call(null,c,d);if($APP.ld(c))return $APP.$b(c)}else return c;else return b.l?b.l():b.call(null)};Ae=function(a,b,c){for(a=$APP.Gc(a);;)if(a.Ia()){var d=a.next();c=b.h?b.h(c,d):b.call(null,c,d);if($APP.ld(c))return $APP.$b(c)}else return c};
ub=function(a){switch(arguments.length){case 2:return Be(arguments[0],arguments[1]);case 3:return $APP.tb(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};Be=function(a,b){return null!=b&&(b.s&524288||$APP.Qc===b.gf)?b.Fa(null,a):$APP.gb(b)?pd(b,a):"string"===typeof b?pd(b,a):$APP.ob(dc,b)?Ce(b,a):Xc(b)?ze(b,a):we(a,b)};
$APP.tb=function(a,b,c){return null!=c&&(c.s&524288||$APP.Qc===c.gf)?c.Ga(null,a,b):$APP.gb(c)?qd(c,a,b):"string"===typeof c?qd(c,a,b):$APP.ob(dc,c)?Ce(c,a,b):Xc(c)?Ae(c,a,b):xe(a,b,c)};De=function(a,b,c){return null!=c?fc(c,a,b):b};$APP.Ee=function(a){return a};Fe=function(a,b,c,d){a=a.g?a.g(b):a.call(null,b);c=$APP.tb(a,c,d);return a.g?a.g(c):a.call(null,c)};$APP.Ge=function(a){return 0<=a?Math.floor(a):Math.ceil(a)};$APP.He=function(a,b){return $APP.Ge((a-a%b)/b)};
Ie=function(a){a-=a>>1&1431655765;a=(a&858993459)+(a>>2&858993459);return 16843009*(a+(a>>4)&252645135)>>24};$APP.Je=function(a){return 0<a};$APP.Ke=function(a){return 0===a};$APP.Le=function(a){return 0>a};Me=function(a,b){if($APP.Sd(b))if(sd(a)&&sd(b)&&$APP.ud(a)!==$APP.ud(b))a=!1;else a:for(a=$APP.J(a),b=$APP.J(b);;){if(null==a){a=null==b;break a}if(null!=b&&$APP.vd.h($APP.O(a),$APP.O(b)))a=$APP.P(a),b=$APP.P(b);else{a=!1;break a}}else a=null;return $APP.ce(a)};
$APP.Ne=function(a,b,c,d,e){this.H=a;this.first=b;this.Wb=c;this.count=d;this.M=e;this.s=65937646;this.A=8192};$APP.Oe=function(a){return null!=a?a.s&33554432||$APP.Qc===a.Xg?!0:a.s?!1:$APP.ob(lc,a):$APP.ob(lc,a)};Pe=function(a){this.H=a;this.s=65937614;this.A=8192};Re=function(a){return(null!=a?a.s&134217728||$APP.Qc===a.ah||(a.s?0:$APP.ob(nc,a)):$APP.ob(nc,a))?(a=oc(a))?a:$APP.ad:$APP.tb($APP.Qe,$APP.ad,a)};Se=function(a,b,c,d){this.H=a;this.first=b;this.Wb=c;this.M=d;this.s=65929452;this.A=8192};
$APP.Te=function(a,b){return null==b?new $APP.Ne(null,a,null,1,null):null!=b&&(b.s&64||$APP.Qc===b.Bc)?new Se(null,a,b,null):new Se(null,a,$APP.J(b),null)};Ue=function(a,b){if(a.cb===b.cb)return 0;var c=$APP.ib(a.eb);if($APP.z(c?b.eb:c))return-1;if($APP.z(a.eb)){if($APP.ib(b.eb))return 1;c=Ea(a.eb,b.eb);return 0===c?Ea(a.name,b.name):c}return Ea(a.name,b.name)};$APP.u=function(a,b,c,d){this.eb=a;this.name=b;this.cb=c;this.xc=d;this.s=2153775105;this.A=4096};
$APP.Ve=function(a){return a instanceof $APP.u};$APP.We=function(a,b){return a===b?!0:a instanceof $APP.u&&b instanceof $APP.u?a.cb===b.cb:!1};Xe=function(a){if(null!=a&&(a.A&4096||$APP.Qc===a.ff))return a.Uc(null);throw Error(["Doesn't support namespace: ",$APP.G.g(a)].join(""));};$APP.Ye=function(a){return a instanceof $APP.u||a instanceof $APP.H};$APP.Ze=function(a){return $APP.Ye(a)&&null==Xe(a)};$APP.$e=function(a){var b=$APP.Ye(a);b?(a=Xe(a),a=$APP.z(a)?!0:a):a=b;return $APP.ce(a)};
af=function(a){return a instanceof $APP.H&&null==Xe(a)};$APP.bf=function(a){var b=a instanceof $APP.H;b?(a=Xe(a),a=$APP.z(a)?!0:a):a=b;return $APP.ce(a)};cf=function(a){return a instanceof $APP.u&&null==Xe(a)};$APP.df=function(a){var b=a instanceof $APP.u;b?(a=Xe(a),a=$APP.z(a)?!0:a):a=b;return $APP.ce(a)};$APP.ef=function(a,b,c){this.H=a;this.fn=b;this.W=null;this.M=c;this.s=32374988;this.A=1};ff=function(a){null!=a.fn&&(a.W=a.fn.l?a.fn.l():a.fn.call(null),a.fn=null);return a.W};
gf=function(a){this.ae=a;this.end=0;this.s=2;this.A=0};$APP.hf=function(a){return new gf(Array(a))};jf=function(a,b,c){this.arr=a;this.Za=b;this.end=c;this.s=524306;this.A=0};kf=function(a,b,c,d){this.ba=a;this.Cb=b;this.H=c;this.M=d;this.s=31850732;this.A=1536};$APP.lf=function(a,b){return 0===zb(a)?b:new kf(a,b,null,null)};mf=function(a,b){a.add(b)};ue=function(a){var b=[];for(a=$APP.J(a);;)if(null!=a)b.push($APP.O(a)),a=$APP.P(a);else return b};
nf=function(a){if("number"===typeof a)a:{var b=Array(a);if($APP.ae(null))for(var c=0,d=$APP.J(null);;)if(d&&c<a)b[c]=$APP.O(d),c+=1,d=$APP.P(d);else{a=b;break a}else{for(c=0;;)if(c<a)b[c]=null,c+=1;else break;a=b}}else a=vb(a);return a};of=function(a,b){if(sd(b))return $APP.ud(b);var c=0;for(b=$APP.J(b);;)if(null!=b&&c<a)c+=1,b=$APP.P(b);else return c};$APP.Ma=function(a,b){return $APP.tc(a,b)};$APP.pf=function(a,b,c){return vc(a,b,c)};
qf=function(a,b,c){var d=$APP.J(c);if(0===b)return a.l?a.l():a.call(null);c=Gb(d);var e=Hb(d);if(1===b)return a.g?a.g(c):a.call(null,c);d=Gb(e);var Df=Hb(e);if(2===b)return a.h?a.h(c,d):a.call(null,c,d);e=Gb(Df);var g=Hb(Df);if(3===b)return a.i?a.i(c,d,e):a.call(null,c,d,e);Df=Gb(g);var h=Hb(g);if(4===b)return a.K?a.K(c,d,e,Df):a.call(null,c,d,e,Df);g=Gb(h);var Wm=Hb(h);if(5===b)return a.G?a.G(c,d,e,Df,g):a.call(null,c,d,e,Df,g);h=Gb(Wm);var m=Hb(Wm);if(6===b)return a.O?a.O(c,d,e,Df,g,h):a.call(null,
c,d,e,Df,g,h);Wm=Gb(m);var p=Hb(m);if(7===b)return a.X?a.X(c,d,e,Df,g,h,Wm):a.call(null,c,d,e,Df,g,h,Wm);m=Gb(p);var r=Hb(p);if(8===b)return a.ca?a.ca(c,d,e,Df,g,h,Wm,m):a.call(null,c,d,e,Df,g,h,Wm,m);p=Gb(r);var t=Hb(r);if(9===b)return a.va?a.va(c,d,e,Df,g,h,Wm,m,p):a.call(null,c,d,e,Df,g,h,Wm,m,p);r=Gb(t);var v=Hb(t);if(10===b)return a.ka?a.ka(c,d,e,Df,g,h,Wm,m,p,r):a.call(null,c,d,e,Df,g,h,Wm,m,p,r);t=Gb(v);var x=Hb(v);if(11===b)return a.la?a.la(c,d,e,Df,g,h,Wm,m,p,r,t):a.call(null,c,d,e,Df,g,
h,Wm,m,p,r,t);v=Gb(x);var A=Hb(x);if(12===b)return a.ma?a.ma(c,d,e,Df,g,h,Wm,m,p,r,t,v):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v);x=Gb(A);var E=Hb(A);if(13===b)return a.na?a.na(c,d,e,Df,g,h,Wm,m,p,r,t,v,x):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x);A=Gb(E);var M=Hb(E);if(14===b)return a.oa?a.oa(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A);E=Gb(M);var U=Hb(M);if(15===b)return a.pa?a.pa(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E);M=Gb(U);var W=
Hb(U);if(16===b)return a.qa?a.qa(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M);U=Gb(W);var ba=Hb(W);if(17===b)return a.ra?a.ra(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U);W=Gb(ba);var T=Hb(ba);if(18===b)return a.sa?a.sa(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W);ba=Gb(T);T=Hb(T);if(19===b)return a.ta?a.ta(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba):a.call(null,c,d,e,Df,g,h,Wm,
m,p,r,t,v,x,A,E,M,U,W,ba);var q=Gb(T);Hb(T);if(20===b)return a.ua?a.ua(c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba,q):a.call(null,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba,q);throw Error("Only up to 20 arguments supported on functions");};rf=function(a){return null!=a&&(a.s&128||$APP.Qc===a.Vc)?a.Ca(null):$APP.J($APP.bd(a))};tf=function(a,b,c){return null==c?a.g?a.g(b):a.call(a,b):sf(a,b,Gb(c),rf(c))};sf=function(a,b,c,d){return null==d?a.h?a.h(b,c):a.call(a,b,c):uf(a,b,c,Gb(d),rf(d))};
uf=function(a,b,c,d,e){return null==e?a.i?a.i(b,c,d):a.call(a,b,c,d):vf(a,b,c,d,Gb(e),rf(e))};
vf=function(a,b,c,d,e,Df){if(null==Df)return a.K?a.K(b,c,d,e):a.call(a,b,c,d,e);var g=Gb(Df),h=$APP.P(Df);if(null==h)return a.G?a.G(b,c,d,e,g):a.call(a,b,c,d,e,g);Df=Gb(h);var Wm=$APP.P(h);if(null==Wm)return a.O?a.O(b,c,d,e,g,Df):a.call(a,b,c,d,e,g,Df);h=Gb(Wm);var m=$APP.P(Wm);if(null==m)return a.X?a.X(b,c,d,e,g,Df,h):a.call(a,b,c,d,e,g,Df,h);Wm=Gb(m);var p=$APP.P(m);if(null==p)return a.ca?a.ca(b,c,d,e,g,Df,h,Wm):a.call(a,b,c,d,e,g,Df,h,Wm);m=Gb(p);var r=$APP.P(p);if(null==r)return a.va?a.va(b,c,
d,e,g,Df,h,Wm,m):a.call(a,b,c,d,e,g,Df,h,Wm,m);p=Gb(r);var t=$APP.P(r);if(null==t)return a.ka?a.ka(b,c,d,e,g,Df,h,Wm,m,p):a.call(a,b,c,d,e,g,Df,h,Wm,m,p);r=Gb(t);var v=$APP.P(t);if(null==v)return a.la?a.la(b,c,d,e,g,Df,h,Wm,m,p,r):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r);t=Gb(v);var x=$APP.P(v);if(null==x)return a.ma?a.ma(b,c,d,e,g,Df,h,Wm,m,p,r,t):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t);v=Gb(x);var A=$APP.P(x);if(null==A)return a.na?a.na(b,c,d,e,g,Df,h,Wm,m,p,r,t,v):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v);x=
Gb(A);var E=$APP.P(A);if(null==E)return a.oa?a.oa(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x);A=Gb(E);var M=$APP.P(E);if(null==M)return a.pa?a.pa(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A);E=Gb(M);var U=$APP.P(M);if(null==U)return a.qa?a.qa(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E);M=Gb(U);var W=$APP.P(U);if(null==W)return a.ra?a.ra(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,
t,v,x,A,E,M);U=Gb(W);var ba=$APP.P(W);if(null==ba)return a.sa?a.sa(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U);W=Gb(ba);var T=$APP.P(ba);if(null==T)return a.ta?a.ta(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U,W):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U,W);ba=Gb(T);T=$APP.P(T);if(null==T)return a.ua?a.ua(b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba):a.call(a,b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba);b=[b,c,d,e,g,Df,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba];for(c=T;;)if(c)b.push(Gb(c)),
c=$APP.P(c);else break;return a.apply(a,b)};
Bf=function(a){switch(arguments.length){case 2:return $APP.wf(arguments[0],arguments[1]);case 3:return $APP.xf(arguments[0],arguments[1],arguments[2]);case 4:return yf(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return zf(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return Af(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],new $APP.Yc(b.slice(5),0,null))}};
$APP.wf=function(a,b){if(a.F){var c=a.B,d=of(c+1,b);return d<=c?qf(a,d,b):a.F(b)}b=$APP.J(b);return null==b?a.l?a.l():a.call(a):tf(a,Gb(b),rf(b))};$APP.xf=function(a,b,c){if(a.F){b=$APP.Te(b,c);var d=a.B;c=of(d,c)+1;return c<=d?qf(a,c,b):a.F(b)}return tf(a,b,$APP.J(c))};yf=function(a,b,c,d){return a.F?(b=$APP.Te(b,$APP.Te(c,d)),c=a.B,d=2+of(c-1,d),d<=c?qf(a,d,b):a.F(b)):sf(a,b,c,$APP.J(d))};
zf=function(a,b,c,d,e){return a.F?(b=$APP.Te(b,$APP.Te(c,$APP.Te(d,e))),c=a.B,e=3+of(c-2,e),e<=c?qf(a,e,b):a.F(b)):uf(a,b,c,d,$APP.J(e))};Af=function(a,b,c,d,e,Df){return a.F?(Df=Cf(Df),b=$APP.Te(b,$APP.Te(c,$APP.Te(d,$APP.Te(e,Df)))),c=a.B,Df=4+of(c-3,Df),Df<=c?qf(a,Df,b):a.F(b)):vf(a,b,c,d,e,Cf(Df))};$APP.Ef=function(a){return null!=a&&(a.s&64||$APP.Qc===a.Bc)?$APP.P(a)?Xg(ue(a)):$APP.J(a)?$APP.O(a):$APP.Jf:a};$APP.Ff=function(a){return $APP.J(a)?a:null};
$APP.Kf=function(){if("undefined"===typeof Gf||"undefined"===typeof Hf||"undefined"===typeof Rn)Rn=function(a){this.Qf=a;this.s=393216;this.A=0},Rn.prototype.J=function(a,b){return new Rn(b)},Rn.prototype.I=function(){return this.Qf},Rn.prototype.Ia=function(){return!1},Rn.prototype.next=function(){return Error("No such element")},Rn.prototype.remove=function(){return Error("Unsupported operation")},Rn.R=!0,Rn.P="cljs.core/t_cljs$core21906",Rn.S=function(a){return pc(a,"cljs.core/t_cljs$core21906")};
return new Rn($APP.Jf)};Mf=function(a){this.Oc=Lf;this.fc=a};$APP.Nf=function(a,b){for(;;){if(null==$APP.J(b))return!0;var c=$APP.O(b);c=a.g?a.g(c):a.call(null,c);if($APP.z(c))b=$APP.P(b);else return!1}};$APP.Of=function(a,b){for(;;)if(b=$APP.J(b)){var c=$APP.O(b);c=a.g?a.g(c):a.call(null,c);if($APP.z(c))return c;b=$APP.P(b)}else return null};$APP.eg=function(a){if($APP.fe(a))return 0===(a&1);throw Error(["Argument must be an integer: ",$APP.G.g(a)].join(""));};
$APP.Pf=function(a){return function(){function b(g,h){return $APP.ib(a.h?a.h(g,h):a.call(null,g,h))}function c(g){return $APP.ib(a.g?a.g(g):a.call(null,g))}function d(){return $APP.ib(a.l?a.l():a.call(null))}var e=null,Df=function(){function g(Wm,m,p){var r=null;if(2<arguments.length){r=0;for(var t=Array(arguments.length-2);r<t.length;)t[r]=arguments[r+2],++r;r=new $APP.Yc(t,0,null)}return h.call(this,Wm,m,r)}function h(Wm,m,p){return $APP.ib(yf(a,Wm,m,p))}g.B=2;g.F=function(Wm){var m=$APP.O(Wm);
Wm=$APP.P(Wm);var p=$APP.O(Wm);Wm=$APP.bd(Wm);return h(m,p,Wm)};g.j=h;return g}();e=function(g,h,Wm){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,g);case 2:return b.call(this,g,h);default:var m=null;if(2<arguments.length){m=0;for(var p=Array(arguments.length-2);m<p.length;)p[m]=arguments[m+2],++m;m=new $APP.Yc(p,0,null)}return Df.j(g,h,m)}throw Error("Invalid arity: "+arguments.length);};e.B=2;e.F=Df.F;e.l=d;e.g=c;e.h=b;e.j=Df.j;return e}()};
Qf=function(a){return function(){function b(c){if(0<arguments.length)for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;return a}b.B=0;b.F=function(c){$APP.J(c);return a};b.j=function(){return a};return b}()};
$APP.Rf=function(a,b){return function(){function c(Wm,m,p){return a.K?a.K(b,Wm,m,p):a.call(null,b,Wm,m,p)}function d(Wm,m){return a.i?a.i(b,Wm,m):a.call(null,b,Wm,m)}function e(Wm){return a.h?a.h(b,Wm):a.call(null,b,Wm)}function Df(){return a.g?a.g(b):a.call(null,b)}var g=null,h=function(){function Wm(p,r,t,v){var x=null;if(3<arguments.length){x=0;for(var A=Array(arguments.length-3);x<A.length;)A[x]=arguments[x+3],++x;x=new $APP.Yc(A,0,null)}return m.call(this,p,r,t,x)}function m(p,r,t,v){return Af(a,
b,p,r,t,$APP.Bd([v]))}Wm.B=3;Wm.F=function(p){var r=$APP.O(p);p=$APP.P(p);var t=$APP.O(p);p=$APP.P(p);var v=$APP.O(p);p=$APP.bd(p);return m(r,t,v,p)};Wm.j=m;return Wm}();g=function(Wm,m,p,r){switch(arguments.length){case 0:return Df.call(this);case 1:return e.call(this,Wm);case 2:return d.call(this,Wm,m);case 3:return c.call(this,Wm,m,p);default:var t=null;if(3<arguments.length){t=0;for(var v=Array(arguments.length-3);t<v.length;)v[t]=arguments[t+3],++t;t=new $APP.Yc(v,0,null)}return h.j(Wm,m,p,t)}throw Error("Invalid arity: "+
arguments.length);};g.B=3;g.F=h.F;g.l=Df;g.g=e;g.h=d;g.i=c;g.j=h.j;return g}()};
Uf=function(){var a=$APP.Sf;return function(b){var c=Tf.g?Tf.g(-1):Tf.call(null,-1);return function(){function d(h,Wm){var m=Ec(c,$APP.$b(c)+1);Wm=a.h?a.h(m,Wm):a.call(null,m,Wm);return b.h?b.h(h,Wm):b.call(null,h,Wm)}function e(h){return b.g?b.g(h):b.call(null,h)}function Df(){return b.l?b.l():b.call(null)}var g=null;g=function(h,Wm){switch(arguments.length){case 0:return Df.call(this);case 1:return e.call(this,h);case 2:return d.call(this,h,Wm)}throw Error("Invalid arity: "+arguments.length);};
g.l=Df;g.g=e;g.h=d;return g}()}};$APP.Vf=function(a,b){return function Df(d,e){return new $APP.ef(null,function(){var g=$APP.J(e);if(g){if($APP.Wd(g)){for(var h=$APP.zc(g),Wm=$APP.ud(h),m=$APP.hf(Wm),p=0;;)if(p<Wm)mf(m,function(){var r=d+p,t=$APP.Gd(h,p);return a.h?a.h(r,t):a.call(null,r,t)}()),p+=1;else break;return $APP.lf(m.ba(),Df(d+Wm,$APP.Ac(g)))}return $APP.Te(function(){var r=$APP.O(g);return a.h?a.h(d,r):a.call(null,d,r)}(),Df(d+1,$APP.bd(g)))}return null},null)}(0,b)};
$APP.Wf=function(a,b){return new $APP.ef(null,function(){var c=$APP.J(b);if(c){if($APP.Wd(c)){for(var d=$APP.zc(c),e=$APP.ud(d),Df=$APP.hf(e),g=0;;)if(g<e){var h=function(){var Wm=$APP.Gd(d,g);return a.g?a.g(Wm):a.call(null,Wm)}();null!=h&&Df.add(h);g+=1}else break;return $APP.lf(Df.ba(),$APP.Wf(a,$APP.Ac(c)))}e=function(){var Wm=$APP.O(c);return a.g?a.g(Wm):a.call(null,Wm)}();return null==e?$APP.Wf(a,$APP.bd(c)):$APP.Te(e,$APP.Wf(a,$APP.bd(c)))}return null},null)};
Xf=function(a){this.state=a;this.Te=this.wb=this.H=null;this.A=16386;this.s=6455296};$APP.Yf=function(a){return new Xf(a)};
Zf=function(a,b){if(a instanceof Xf){var c=a.wb;if(null!=c&&!$APP.z(c.g?c.g(b):c.call(null,b)))throw Error("Validator rejected reference state");c=a.state;a.state=b;if(null!=a.Te)a:for(var d=$APP.J(a.Te),e=null,Df=0,g=0;;)if(g<Df){var h=e.ha(null,g),Wm=$APP.Q(h,0,null);h=$APP.Q(h,1,null);h.K?h.K(Wm,a,c,b):h.call(null,Wm,a,c,b);g+=1}else if(d=$APP.J(d))$APP.Wd(d)?(e=$APP.zc(d),d=$APP.Ac(d),Wm=e,Df=$APP.ud(e),e=Wm):(e=$APP.O(d),Wm=$APP.Q(e,0,null),h=$APP.Q(e,1,null),h.K?h.K(Wm,a,c,b):h.call(null,Wm,
a,c,b),d=$APP.P(d),e=null,Df=0),g=0;else break a;return b}return Dc(a,b)};$f=function(a){this.state=a;this.s=32768;this.A=0};Tf=function(a){return new $f(a)};$APP.ag=function(a,b){return new $APP.ef(null,function(){a:for(var c=a,d=b;;)if(d=$APP.J(d),0<c&&d)--c,d=$APP.bd(d);else break a;return d},null)};bg=function(a,b,c,d){this.H=a;this.count=b;this.o=c;this.next=d;this.M=null;this.s=32374988;this.A=1};$APP.cg=function(a,b){return 0<a?new bg(null,a,b,null):$APP.ad};
$APP.dg=function(a,b){return new $APP.ef(null,function(){var c=$APP.J(b);if(c){if($APP.Wd(c)){for(var d=$APP.zc(c),e=$APP.ud(d),Df=$APP.hf(e),g=0;;)if(g<e){var h=$APP.Gd(d,g);h=a.g?a.g(h):a.call(null,h);$APP.z(h)&&(h=$APP.Gd(d,g),Df.add(h));g+=1}else break;return $APP.lf(Df.ba(),$APP.dg(a,$APP.Ac(c)))}d=$APP.O(c);c=$APP.bd(c);return $APP.z(a.g?a.g(d):a.call(null,d))?$APP.Te(d,$APP.dg(a,c)):$APP.dg(a,c)}return null},null)};
$APP.lg=function(a,b,c,d){var e=$APP.kg.i,Df=$APP.R.h(a,b);c=$APP.kg.i?$APP.kg.i(Df,c,d):$APP.kg.call(null,Df,c,d);return e.call($APP.kg,a,b,c)};mg=function(a,b){this.wa=a;this.arr=b};ng=function(a){return new mg(a,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null])};og=function(a){return new mg(a.wa,sb(a.arr))};pg=function(a){a=a.C;return 32>a?0:a-1>>>5<<5};
qg=function(a,b,c){for(;;){if(0===b)return c;var d=ng(a);d.arr[0]=c;c=d;b-=5}};rg=function(a,b){throw Error(["No item ",$APP.G.g(a)," in vector of length ",$APP.G.g(b)].join(""));};sg=function(a,b){if(b>=pg(a))return a.bb;var c=a.root;for(a=a.shift;;)if(0<a){var d=a-5;c=c.arr[b>>>a&31];a=d}else return c.arr};tg=function(a,b){return 0<=b&&b<a.C?sg(a,b):rg(b,a.C)};ug=function(a,b,c,d,e,Df){this.D=a;this.$d=b;this.arr=c;this.Ka=d;this.start=e;this.end=Df};
vg=function(a,b,c){return new ug(b,b-b%32,b<$APP.ud(a)?sg(a,b):null,a,b,c)};xg=function(a,b,c,d){return c<d?wg(a,b,$APP.wd(a,c),c+1,d):b.l?b.l():b.call(null)};wg=function(a,b,c,d,e){var Df=c;c=d;for(d=sg(a,d);;)if(c<e){var g=c&31;d=0===g?sg(a,c):d;g=d[g];Df=b.h?b.h(Df,g):b.call(null,Df,g);if($APP.ld(Df))return $APP.$b(Df);c+=1}else return Df};$APP.X=function(a,b,c,d,e,Df){this.H=a;this.C=b;this.shift=c;this.root=d;this.bb=e;this.M=Df;this.s=167666463;this.A=139268};
yg=function(a,b){var c=a.length;a=b?a:sb(a);if(32>c)return new $APP.X(null,c,5,$APP.Z,a,null);b=32;for(var d=(new $APP.X(null,32,5,$APP.Z,a.slice(0,32),null)).zc(null);;)if(b<c){var e=b+1;d=$APP.tc(d,a[b]);b=e}else return $APP.uc(d)};$APP.Cg=function(a){return $APP.z($APP.zg.g?$APP.zg.g(a):$APP.zg.call(null,a))?new $APP.X(null,2,5,$APP.Z,[Ag.g?Ag.g(a):Ag.call(null,a),Bg.g?Bg.g(a):Bg.call(null,a)],null):$APP.Vd(a)?Kd(a,null):$APP.gb(a)?yg(a,!0):$APP.uc($APP.tb($APP.tc,$APP.sc($APP.fg),a))};
Dg=function(a,b,c,d,e){this.qb=a;this.node=b;this.D=c;this.Za=d;this.H=e;this.M=null;this.s=32375020;this.A=1536};Gg=function(a){switch(arguments.length){case 3:var b=arguments[0],c=arguments[1],d=arguments[2];return new Dg(b,tg(b,c),c,d,null);case 4:return Eg(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return Fg(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
Eg=function(a,b,c,d){return new Dg(a,b,c,d,null)};Fg=function(a,b,c,d,e){return new Dg(a,b,c,d,e)};Hg=function(a,b,c,d,e){this.H=a;this.Ka=b;this.start=c;this.end=d;this.M=e;this.s=167666463;this.A=139264};$APP.Ig=function(a,b,c,d,e){for(;;)if(b instanceof Hg)c=b.start+c,d=b.start+d,b=b.Ka;else{if(!$APP.Vd(b))throw Error("v must satisfy IVector");if(0>c||d<c||d>$APP.ud(b))throw Error("Index out of bounds");return new Hg(a,b,c,d,e)}};Jg=function(a,b){return a===b.wa?b:new mg(a,sb(b.arr))};
Kg=function(a){return new mg({},sb(a.arr))};Lg=function(a){var b=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];Xd(a,0,b,0,a.length);return b};Mg=function(a,b,c,d){this.C=a;this.shift=b;this.root=c;this.bb=d;this.A=88;this.s=275};
Ng=function(a,b,c){if(a.root.wa){if(0<=b&&b<a.C){if(pg(a)<=b)a.bb[b&31]=c;else{var d=function h(Df,g){g=Jg(a.root.wa,g);if(0===Df)g.arr[b&31]=c;else{var Wm=b>>>Df&31;Df=h(Df-5,g.arr[Wm]);g.arr[Wm]=Df}return g}(a.shift,a.root);a.root=d}return a}if(b===a.C)return a.Fc(null,c);throw Error(["Index ",$APP.G.g(b)," out of bounds for TransientVector of length",$APP.G.g(a.C)].join(""));}throw Error("assoc! after persistent!");};Og=function(){this.s=2097152;this.A=0};
Qg=function(a,b){return $APP.ce($APP.Td(b)&&!$APP.Ud(b)?$APP.ud(a)===$APP.ud(b)?(null!=a?a.s&1048576||$APP.Qc===a.Wg||(a.s?0:$APP.ob(ec,a)):$APP.ob(ec,a))?De(function(c,d,e){return $APP.vd.h($APP.R.i(b,d,Pg),e)?!0:kd(!1)},!0,a):$APP.Nf(function(c){return $APP.vd.h($APP.R.i(b,$APP.O(c),Pg),$APP.Dd(c))},a):null:null)};Sg=function(a){this.W=a};Tg=function(a){this.W=a};
Ug=function(a,b){if(b instanceof $APP.u)a:{var c=a.length;b=b.cb;for(var d=0;;){if(c<=d){a=-1;break a}if(a[d]instanceof $APP.u&&b===a[d].cb){a=d;break a}d+=2}}else if("string"===typeof b||"number"===typeof b)a:for(c=a.length,d=0;;){if(c<=d){a=-1;break a}if(b===a[d]){a=d;break a}d+=2}else if(b instanceof $APP.H)a:for(c=a.length,b=b.Ib,d=0;;){if(c<=d){a=-1;break a}if(a[d]instanceof $APP.H&&b===a[d].Ib){a=d;break a}d+=2}else if(null==b)a:for(b=a.length,c=0;;){if(b<=c){a=-1;break a}if(null==a[c]){a=c;
break a}c+=2}else a:for(c=a.length,d=0;;){if(c<=d){a=-1;break a}if($APP.vd.h(b,a[d])){a=d;break a}d+=2}return a};$APP.oe=function(a,b){this.key=a;this.o=b;this.M=null;this.s=166619935;this.A=0};$APP.zg=function(a){return null!=a?a.s&2048||$APP.Qc===a.Zg?!0:!1:!1};Vg=function(a,b,c){this.arr=a;this.D=b;this.xb=c;this.s=32374990;this.A=0};Wg=function(a,b){this.arr=a;this.D=0;this.C=b};$APP.n=function(a,b,c,d){this.H=a;this.C=b;this.arr=c;this.M=d;this.s=16647951;this.A=139268};
bh=function(a,b){return a===b?!0:$APP.We(a,b)?!0:$APP.vd.h(a,b)};Ih=function(a){for(var b=0,c=0;;)if(b<a.length){var d;a:for(d=0;;)if(d<b){var e=bh(a[b],a[d]);if(e){d=e;break a}d=2+d}else{d=!1;break a}c=d?c:c+2;b=2+b}else return c};Sh=function(a,b){var c=a.length-1,d=$APP.J(b);b=Array(c+2*$APP.ud(d));a=Xd(a,0,b,0,c);for(b=c;;)if(d){var e=$APP.O(d);a[b]=$APP.Sb(e);a[b+1]=$APP.Ub(e);b=2+c;d=$APP.P(d)}else return a};
Xg=function(a){var b=a.length,c=1===(b&1),d;if(!(d=c))a:for(d=0;;)if(d<a.length){var e;b:for(e=0;;)if(e<d){var Df=bh(a[d],a[e]);if(Df){e=Df;break b}e=2+e}else{e=!1;break b}if(e){d=e;break a}d=2+d}else{d=!1;break a}return d?Ll(a,c):new $APP.n(null,b/2,a,null)};
Ll=function(a,b){var c=b?Sh(a,$APP.hg.h($APP.Jf,a[a.length-1])):a;a=Ih(c);var d=c.length;if(a<d){a=Array(a);for(var e=0,Df=0;;)if(e<d)(function(){for(var g=0;;)if(g<Df){var h=bh(c[e],c[g]);if(h)return h;g=2+g}else return!1})()?(b=Df,e=2+e,Df=b):(b=function(){for(var g=d-2;;)if(g>=e){if(bh(c[e],c[g]))return g;g-=2}else return g}(),a[Df]=c[e],a[Df+1]=c[b+1],b=2+Df,e=2+e,Df=b);else break;return new $APP.n(null,a.length/2,a,null)}return new $APP.n(null,c.length/2,c,null)};
Yg=function(a,b){this.Ic={};this.rc=a;this.arr=b;this.s=259;this.A=56};$g=function(a,b){for(var c=$APP.sc(Zg),d=0;;)if(d<a)c=vc(c,b[d],b[d+1]),d+=2;else return c};ah=function(){this.o=!1};ch=function(a,b,c){a=sb(a);a[b]=c;return a};dh=function(a,b){var c=Array(a.length-2);Xd(a,0,c,0,2*b);Xd(a,2*(b+1),c,2*b,c.length-2*b);return c};eh=function(a,b,c,d){a=a.mc(b);a.arr[c]=d;return a};
fh=function(a,b,c){for(var d=a.length,e=0,Df=c;;)if(e<d){c=a[e];if(null!=c){var g=a[e+1];c=b.i?b.i(Df,c,g):b.call(null,Df,c,g)}else c=a[e+1],c=null!=c?c.dd(b,Df):Df;if($APP.ld(c))return c;e+=2;Df=c}else return Df};gh=function(a){this.arr=a;this.D=0;this.Db=this.kd=null};hh=function(a,b,c){this.wa=a;this.ya=b;this.arr=c;this.A=131072;this.s=0};ih=function(a){this.arr=a;this.D=0;this.Db=null};jh=function(a,b,c){this.wa=a;this.C=b;this.arr=c;this.A=131072;this.s=0};
kh=function(a,b,c){b*=2;for(var d=0;;)if(d<b){if(bh(c,a[d]))return d;d+=2}else return-1};lh=function(a,b,c,d){this.wa=a;this.Pb=b;this.C=c;this.arr=d;this.A=131072;this.s=0};oh=function(a){switch(arguments.length){case 6:return mh(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 7:return nh(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
mh=function(a,b,c,d,e,Df){var g=Rc(b);if(g===d)return new lh(null,g,2,[b,c,e,Df]);var h=new ah;return ph.Ab(a,g,b,c,h).Ab(a,d,e,Df,h)};nh=function(a,b,c,d,e,Df,g){var h=Rc(c);if(h===e)return new lh(null,h,2,[c,d,Df,g]);var Wm=new ah;return ph.Bb(a,b,h,c,d,Wm).Bb(a,b,e,Df,g,Wm)};qh=function(a,b,c,d,e){this.H=a;this.Eb=b;this.D=c;this.W=d;this.M=e;this.s=32374988;this.A=0};
th=function(a){switch(arguments.length){case 1:return rh(arguments[0]);case 3:return sh(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};rh=function(a){return sh(a,0,null)};sh=function(a,b,c){if(null==c)for(c=a.length;;)if(b<c){if(null!=a[b])return new qh(null,a,b,null,null);var d=a[b+1];if($APP.z(d)&&(d=d.bd(),$APP.z(d)))return new qh(null,a,b+2,d,null);b+=2}else return null;else return new qh(null,a,b,c,null)};
uh=function(a,b,c,d,e){this.H=a;this.Eb=b;this.D=c;this.W=d;this.M=e;this.s=32374988;this.A=0};yh=function(a){switch(arguments.length){case 1:return wh(arguments[0]);case 3:return xh(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};wh=function(a){return xh(a,0,null)};
xh=function(a,b,c){if(null==c)for(c=a.length;;)if(b<c){var d=a[b];if($APP.z(d)&&(d=d.bd(),$APP.z(d)))return new uh(null,a,b+1,d,null);b+=1}else return null;else return new uh(null,a,b,c,null)};zh=function(a,b){this.ab=a;this.Qe=b;this.qe=!1};Ah=function(a,b,c,d,e,Df){this.H=a;this.C=b;this.root=c;this.$a=d;this.ab=e;this.M=Df;this.s=16123663;this.A=139268};
$APP.Bh=function(a,b){for(var c=a.length,d=0,e=$APP.sc(Zg);;)if(d<c){if(b.length<=d)throw Error(["No value supplied for key: ",$APP.G.g(a[d])].join(""));var Df=d+1;e=vc(e,a[d],b[d]);d=Df}else return $APP.uc(e)};Ch=function(a,b,c,d){this.wa={};this.root=a;this.count=b;this.$a=c;this.ab=d;this.s=259;this.A=56};
Dh=function(a,b,c){if(a.wa){if(null==b)a.ab!==c&&(a.ab=c),a.$a||(a.count+=1,a.$a=!0);else{var d=new ah;b=(null==a.root?ph:a.root).Bb(a.wa,0,Rc(b),b,c,d);b!==a.root&&(a.root=b);d.o&&(a.count+=1)}return a}throw Error("assoc! after persistent!");};Eh=function(a,b){this.Y=a;this.xb=b;this.s=32374988;this.A=0};$APP.Fh=function(a){return(a=$APP.J(a))?new Eh(a,null):null};Ag=function(a){return $APP.Sb(a)};Gh=function(a,b){this.Y=a;this.xb=b;this.s=32374988;this.A=0};
Hh=function(a){return(a=$APP.J(a))?new Gh(a,null):null};Bg=function(a){return $APP.Ub(a)};Lh=function(a){for(var b=$APP.Jf,c=$APP.J(new $APP.X(null,1,5,$APP.Z,[Jh],null));;)if(c){var d=$APP.O(c),e=$APP.R.i(a,d,dk);b=$APP.Kh.h(e,dk)?$APP.kg.i(b,d,e):b;c=$APP.P(c)}else return $APP.cc(b,Ld(a))};Mh=function(a){this.Kc=a};$APP.Nh=function(a,b,c){this.H=a;this.bc=b;this.M=c;this.s=15077647;this.A=139268};
$APP.Ph=function(a){for(var b=a.length,c=$APP.sc($APP.Oh),d=0;;)if(d<b)$APP.tc(c,a[d]),d+=1;else break;return $APP.uc(c)};Qh=function(a){this.Xb=a;this.A=136;this.s=259};$APP.Rh=function(a){if($APP.Qd(a))return Kd(a,null);a=$APP.J(a);if(null==a)return $APP.Oh;if(a instanceof $APP.Yc&&0===a.D)return $APP.Ph(a.arr);for(var b=$APP.sc($APP.Oh);;)if(null!=a){var c=$APP.P(a);b=$APP.tc(b,Gb(a));a=c}else return $APP.uc(b)};
Th=function(a){for(var b=$APP.fg;;)if($APP.P(a))b=$APP.Qe.h(b,$APP.O(a)),a=$APP.P(a);else return $APP.J(b)};$APP.Uh=function(a){if(null!=a&&(a.A&4096||$APP.Qc===a.ff))return a.Tc(null);if("string"===typeof a)return a;throw Error(["Doesn't support name: ",$APP.G.g(a)].join(""));};Vh=function(a,b){var c=$APP.sc($APP.Jf);a=$APP.J(a);for(b=$APP.J(b);;)if(a&&b)c=$APP.pf(c,$APP.O(a),$APP.O(b)),a=$APP.P(a),b=$APP.P(b);else return $APP.uc(c)};
Xh=function(a,b,c){return new $APP.ef(null,function(){var d=$APP.J(c);return d?$APP.Te($APP.Wh.h(a,d),Xh(a,b,$APP.ag(b,d))):null},null)};Yh=function(a,b,c){this.start=a;this.step=b;this.count=c;this.s=82;this.A=0};Zh=function(a,b,c){this.D=a;this.end=b;this.step=c};$APP.$h=function(a,b,c,d,e,Df,g){this.H=a;this.start=b;this.end=c;this.step=d;this.ba=e;this.Kb=Df;this.M=g;this.s=32375006;this.A=140800};
$APP.ai=function(a,b,c,d,e,Df,g){this.H=a;this.start=b;this.end=c;this.step=d;this.ba=e;this.Kb=Df;this.M=g;this.A=140800;this.s=32374988};
bi=function(){return function(){function a(g,h,Wm){return new $APP.X(null,2,5,$APP.Z,[Th.i?Th.i(g,h,Wm):Th.call(null,g,h,Wm),$APP.Ed.i?$APP.Ed.i(g,h,Wm):$APP.Ed.call(null,g,h,Wm)],null)}function b(g,h){return new $APP.X(null,2,5,$APP.Z,[Th.h?Th.h(g,h):Th.call(null,g,h),$APP.Ed.h?$APP.Ed.h(g,h):$APP.Ed.call(null,g,h)],null)}function c(g){return new $APP.X(null,2,5,$APP.Z,[Th.g?Th.g(g):Th.call(null,g),$APP.Ed.g?$APP.Ed.g(g):$APP.Ed.call(null,g)],null)}function d(){return new $APP.X(null,2,5,$APP.Z,
[Th.l?Th.l():Th.call(null),$APP.Ed.l?$APP.Ed.l():$APP.Ed.call(null)],null)}var e=null,Df=function(){function g(Wm,m,p,r){var t=null;if(3<arguments.length){t=0;for(var v=Array(arguments.length-3);t<v.length;)v[t]=arguments[t+3],++t;t=new $APP.Yc(v,0,null)}return h.call(this,Wm,m,p,t)}function h(Wm,m,p,r){return new $APP.X(null,2,5,$APP.Z,[zf(Th,Wm,m,p,r),zf($APP.Ed,Wm,m,p,r)],null)}g.B=3;g.F=function(Wm){var m=$APP.O(Wm);Wm=$APP.P(Wm);var p=$APP.O(Wm);Wm=$APP.P(Wm);var r=$APP.O(Wm);Wm=$APP.bd(Wm);
return h(m,p,r,Wm)};g.j=h;return g}();e=function(g,h,Wm,m){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,g);case 2:return b.call(this,g,h);case 3:return a.call(this,g,h,Wm);default:var p=null;if(3<arguments.length){p=0;for(var r=Array(arguments.length-3);p<r.length;)r[p]=arguments[p+3],++p;p=new $APP.Yc(r,0,null)}return Df.j(g,h,Wm,p)}throw Error("Invalid arity: "+arguments.length);};e.B=3;e.F=Df.F;e.l=d;e.g=c;e.h=b;e.i=a;e.j=Df.j;return e}()};
$APP.ci=function(a){a:for(var b=a;;)if(b=$APP.J(b))b=$APP.P(b);else break a;return a};di=function(a,b){if("string"===typeof b)return a=a.exec(b),null==a?null:1===a.length?a[0]:$APP.Cg(a);throw new TypeError("re-find must match against a string.");};ei=function(a){if(a instanceof RegExp)return a;var b=di(/^\(\?([idmsux]*)\)/,a),c=$APP.Q(b,0,null);b=$APP.Q(b,1,null);return new RegExp(a.substring(null==c?0:c.length),$APP.z(b)?b:"")};
$APP.gi=function(a,b,c,d,e,Df,g){var h=fi;fi=null==fi?null:fi-1;try{if(null!=fi&&0>fi)return pc(a,"#");pc(a,c);if(0===db.g(Df))$APP.J(g)&&pc(a,function(){var v=vl.g(Df);return $APP.z(v)?v:"..."}());else{if($APP.J(g)){var Wm=$APP.O(g);b.i?b.i(Wm,a,Df):b.call(null,Wm,a,Df)}for(var m=$APP.P(g),p=db.g(Df)-1;;)if(!m||null!=p&&0===p){$APP.J(m)&&0===p&&(pc(a,d),pc(a,function(){var v=vl.g(Df);return $APP.z(v)?v:"..."}()));break}else{pc(a,d);var r=$APP.O(m);c=a;g=Df;b.i?b.i(r,c,g):b.call(null,r,c,g);var t=
$APP.P(m);c=p-1;m=t;p=c}}return pc(a,e)}finally{fi=h}};hi=function(a,b){b=$APP.J(b);for(var c=null,d=0,e=0;;)if(e<d){var Df=c.ha(null,e);pc(a,Df);e+=1}else if(b=$APP.J(b))c=b,$APP.Wd(c)?(b=$APP.zc(c),d=$APP.Ac(c),c=b,Df=$APP.ud(b),b=d,d=Df):(Df=$APP.O(c),pc(a,Df),b=$APP.P(c),c=null,d=0),e=0;else return null};ji=function(a){return['"',$APP.G.g(a.replace(RegExp('[\\\\"\b\f\n\r\t]',"g"),function(b){return ii[b]})),'"'].join("")};
ki=function(a,b){return(a=$APP.ce($APP.R.h(a,bb)))?(a=null!=b?b.s&131072||$APP.Qc===b.de?!0:!1:!1)?null!=Ld(b):a:a};
oi=function(a,b,c){if(null==a)return pc(b,"nil");if(ki(c,a)){pc(b,"^");var d=Ld(a);$APP.li.i?$APP.li.i(d,b,c):$APP.li.call(null,d,b,c);pc(b," ")}if(a.R)return a.S(b);if(null!=a?a.s&2147483648||$APP.Qc===a.za||(a.s?0:$APP.ob(qc,a)):$APP.ob(qc,a))return rc(a,b,c);if(!0===a||!1===a)return pc(b,$APP.G.g(a));if("number"===typeof a)return pc(b,isNaN(a)?"##NaN":a===Number.POSITIVE_INFINITY?"##Inf":a===Number.NEGATIVE_INFINITY?"##-Inf":$APP.G.g(a));if(null!=a&&a.constructor===Object)return pc(b,"#js "),d=
$APP.ig.h(function(Df){var g=/[A-Za-z_\*\+\?!\-'][\w\*\+\?!\-']*/;if("string"===typeof Df)g=g.exec(Df),g=null!=g&&$APP.vd.h(g[0],Df)?1===g.length?g[0]:$APP.Cg(g):null;else throw new TypeError("re-matches must match against a string.");return new $APP.oe(null!=g?$APP.mi.g(Df):Df,a[Df])},$APP.Ba(a)),ni.K?ni.K(d,$APP.li,b,c):ni.call(null,d,$APP.li,b,c);if($APP.gb(a))return $APP.gi(b,$APP.li,"#js ["," ","]",c,a);if("string"===typeof a)return $APP.z(ab.g(c))?pc(b,ji(a)):pc(b,a);if("function"===typeof a){var e=
a.name;c=$APP.z(function(){var Df=null==e;return Df?Df:Aa(e)}())?"Function":e;return hi(b,$APP.Bd(["#object[",c,$APP.z(!1)?[' "',$APP.G.g(a),'"'].join(""):"","]"]))}if(a instanceof Date)return c=function(Df,g){for(Df=$APP.G.g(Df);;)if(Df.length<g)Df=["0",Df].join("");else return Df},hi(b,$APP.Bd(['#inst "',c(a.getUTCFullYear(),4),"-",c(a.getUTCMonth()+1,2),"-",c(a.getUTCDate(),2),"T",c(a.getUTCHours(),2),":",c(a.getUTCMinutes(),2),":",c(a.getUTCSeconds(),2),".",c(a.getUTCMilliseconds(),3),"-",'00:00"']));
if(a instanceof RegExp)return hi(b,$APP.Bd(['#"',a.source,'"']));if("symbol"===$APP.aa(a)||"undefined"!==typeof Symbol&&a instanceof Symbol)return hi(b,$APP.Bd(["#object[",a.toString(),"]"]));if($APP.z(function(){var Df=null==a?null:a.constructor;return null==Df?null:Df.P}()))return hi(b,$APP.Bd(["#object[",a.constructor.P.replace(RegExp("/","g"),"."),"]"]));e=function(){var Df=null==a?null:a.constructor;return null==Df?null:Df.name}();c=$APP.z(function(){var Df=null==e;return Df?Df:Aa(e)}())?"Object":
e;return null==a.constructor?hi(b,$APP.Bd(["#object[",c,"]"])):hi(b,$APP.Bd(["#object[",c," ",$APP.G.g(a),"]"]))};$APP.li=function(a,b,c){var d=pi.g(c);return $APP.z(d)?(c=$APP.kg.i(c,xl,oi),d.i?d.i(a,b,c):d.call(null,a,b,c)):oi(a,b,c)};
qi=function(a){var b=eb();if($APP.Od(a))b="";else{var c=$APP.G,d=c.g,e=new $a,Df=new Hc(e);$APP.li($APP.O(a),Df,b);a=$APP.J($APP.P(a));for(var g=null,h=0,Wm=0;;)if(Wm<h){var m=g.ha(null,Wm);pc(Df," ");$APP.li(m,Df,b);Wm+=1}else if(a=$APP.J(a))g=a,$APP.Wd(g)?(a=$APP.zc(g),h=$APP.Ac(g),g=a,m=$APP.ud(a),a=h,h=m):(m=$APP.O(g),pc(Df," "),$APP.li(m,Df,b),a=$APP.P(g),g=null,h=0),Wm=0;else break;b=d.call(c,e)}return b};si=function(a){return a instanceof $APP.H?$APP.ri.h(null,$APP.Uh(a)):$APP.mi.h(null,$APP.Uh(a))};
ti=function(a){if($APP.z(!1)){var b=$APP.J(a),c=$APP.J(b),d=$APP.O(c);$APP.P(c);$APP.Q(d,0,null);$APP.Q(d,1,null);c=$APP.Fd(a);for(a=null;;){d=a;b=$APP.J(b);a=$APP.O(b);var e=$APP.P(b),Df=a;a=$APP.Q(Df,0,null);b=$APP.Q(Df,1,null);if($APP.z(Df))if(a instanceof $APP.u||a instanceof $APP.H)if($APP.z(d))if($APP.vd.h(d,Xe(a)))c=$APP.kg.i(c,si(a),b),a=d,b=e;else return null;else if(d=Xe(a),$APP.z(d))c=$APP.kg.i(c,si(a),b),a=d,b=e;else return null;else return null;else return new $APP.X(null,2,5,$APP.Z,
[d,c],null)}}else return null};ui=function(a,b,c,d,e){return $APP.gi(d,function(Df,g,h){var Wm=$APP.Sb(Df);c.i?c.i(Wm,g,h):c.call(null,Wm,g,h);pc(g," ");Df=$APP.Ub(Df);return c.i?c.i(Df,g,h):c.call(null,Df,g,h)},[$APP.G.g(a),"{"].join(""),", ","}",e,$APP.J(b))};ni=function(a,b,c,d){var e=$APP.Td(a)?ti(a):null,Df=$APP.Q(e,0,null);e=$APP.Q(e,1,null);return $APP.z(Df)?ui(["#:",$APP.G.g(Df)].join(""),e,b,c,d):ui(null,a,b,c,d)};$APP.vi=function(a){this.f=a;this.value=null;this.s=2147516416;this.A=1};
wi=function(){};xi=function(a){if(null!=a&&null!=a.bf)a=a.bf(a);else{var b=xi[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=xi._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IEncodeJS.-clj-\x3ejs",a);}return a};yi=function(a,b){return(null!=a?$APP.Qc===a.af||(a.jb?0:$APP.ob(wi,a)):$APP.ob(wi,a))?xi(a):"string"===typeof a||"number"===typeof a||a instanceof $APP.u||a instanceof $APP.H?b.g?b.g(a):b.call(null,a):qi($APP.Bd([a]))};$APP.zi=function(){};
$APP.Ai=function(a,b){if(null!=a&&null!=a.$e)a=a.$e(a,b);else{var c=$APP.Ai[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=$APP.Ai._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IEncodeClojure.-js-\x3eclj",a);}return a};
$APP.Di=function(a,b){var c=$APP.Ef(b);c=$APP.R.h(c,$APP.Bi);var d=$APP.z(c)?$APP.mi:$APP.G;return function g(Df){return(null!=Df?$APP.Qc===Df.Ze||(Df.jb?0:$APP.ob($APP.zi,Df)):$APP.ob($APP.zi,Df))?$APP.Ai(Df,$APP.wf($APP.Ci,b)):$APP.ae(Df)?$APP.ci($APP.ig.h(g,Df)):$APP.zg(Df)?new $APP.oe(g($APP.Sb(Df)),g($APP.Ub(Df))):$APP.Pd(Df)?$APP.hg.i($APP.Fd(Df),$APP.ig.g(g),Df):$APP.gb(Df)?$APP.uc($APP.tb(function(h,Wm){return $APP.Ma(h,g(Wm))},$APP.sc($APP.fg),Df)):$APP.pb(Df)===Object?$APP.uc($APP.tb(function(h,
Wm){return $APP.pf(h,d.g?d.g(Wm):d.call(null,Wm),g($APP.Da(Df,Wm)))},$APP.sc($APP.Jf),$APP.Ba(Df))):Df}(a)};
$APP.Fi=function(a){var b=$APP.Yf($APP.Jf);return function(){function c(e){var Df=null;if(0<arguments.length){Df=0;for(var g=Array(arguments.length-0);Df<g.length;)g[Df]=arguments[Df+0],++Df;Df=new $APP.Yc(g,0,null)}return d.call(this,Df)}function d(e){var Df=$APP.R.i($APP.$b(b),e,me);return Df===me?(Df=$APP.wf(a,e),$APP.Ei.K(b,$APP.kg,e,Df),Df):Df}c.B=0;c.F=function(e){e=$APP.J(e);return d(e)};c.j=d;return c}()};
$APP.Ii=function(){null==Gi&&(Gi=$APP.Yf(new $APP.n(null,3,[zl,$APP.Jf,Hi,$APP.Jf,Bl,$APP.Jf],null)));return Gi};Ji=function(a,b,c){var d=$APP.vd.h(b,c);if(d)return d;d=Bl.g(a);d=d.g?d.g(b):d.call(null,b);if(!(d=$APP.ne(d,c))&&(d=$APP.Vd(c)))if(d=$APP.Vd(b))if(d=$APP.ud(c)===$APP.ud(b)){d=!0;for(var e=0;;)if(d&&e!==$APP.ud(c))d=Ji(a,b.g?b.g(e):b.call(null,e),c.g?c.g(e):c.call(null,e)),e+=1;else return d}else return d;else return d;else return d};
Ki=function(a){var b=$APP.$b($APP.Ii());return $APP.Ff($APP.R.h(zl.g(b),a))};Li=function(a,b,c,d){$APP.Ei.h(a,function(){return $APP.$b(b)});$APP.Ei.h(c,function(){return $APP.$b(d)})};Ni=function(a,b,c,d){c=Mi(a,b,c);return $APP.z(c)?c:Ji(d,a,b)};Oi=function(a,b){throw Error(["No method in multimethod '",$APP.G.g(a),"' for dispatch value: ",$APP.G.g(b)].join(""));};
$APP.Pi=function(a,b,c,d,e,Df,g,h){this.name=a;this.v=b;this.qf=c;this.rd=d;this.Td=e;this.Cg=Df;this.Sd=g;this.nd=h;this.s=4194305;this.A=4352};$APP.Qi=function(a,b,c){$APP.Ei.K(a.Td,$APP.kg,b,c);Li(a.Sd,a.Td,a.nd,a.rd)};Si=function(a,b){$APP.vd.h($APP.$b(a.nd),$APP.$b(a.rd))||Li(a.Sd,a.Td,a.nd,a.rd);var c=$APP.$b(a.Sd);c=c.g?c.g(b):c.call(null,b);return $APP.z(c)?c:Ri(a.name,b,a.rd,a.Td,a.Cg,a.Sd,a.nd,a.qf)};$APP.Ti=function(a){this.uuid=a;this.M=null;this.s=2153775104;this.A=2048};
Ui=function(){function a(){return Math.floor(16*Math.random()).toString(16)}var b=(8|3&Math.floor(16*Math.random())).toString(16);return new $APP.Ti([$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),"-",$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),"-4",$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),"-",$APP.G.g(b),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),"-",$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),
$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a()),$APP.G.g(a())].join("").toLowerCase())};$APP.Vi=function(a){return null!=a?$APP.Qc===a.nf?!0:!1:!1};$APP.Wi=function(a,b){var c=Error(a);this.message=a;this.data=b;this.cause=null;this.name=c.name;this.description=c.description;this.number=c.number;this.fileName=c.fileName;this.lineNumber=c.lineNumber;this.columnNumber=c.columnNumber;this.stack=c.stack;return this};$APP.Xi=function(a,b){return new $APP.Wi(a,b)};
Zi=function(){$APP.z(Yi)||(Yi=function(){for(var a=ve(function(e,Df){return Df.length-e.length}),b="";;)if($APP.J(a)){var c=$APP.P(a),d=[function(){var e=b;return""!==b?[e,"|"].join(""):e}(),$APP.G.g($APP.O(a))].join("");a=c;b=d}else return[b,"|\\$"].join("")}());return Yi};
$i=function(a){var b=$APP.G.g(a);if("_DOT__DOT_"===b)var c="..";else a:{c=new RegExp(Zi(),"g");var d=b.length-1;d=0<=d&&b.indexOf("$",d)==d;b=$APP.z(d)?b.substring(0,b.length-1):b;d="";for(var e=0;;){var Df=c.exec(b);if($APP.z(Df))Df=$APP.Q(Df,0,null),d=[d,$APP.G.g(b.substring(e,c.lastIndex-Df.length)),$APP.G.g("$"===Df?"/":$APP.Da(te,Df))].join(""),e=c.lastIndex;else{c=[d,$APP.G.g(b.substring(e,b.length))].join("");break a}}}a=a instanceof $APP.H?$APP.ri:$APP.G;return a.g?a.g(c):a.call(null,c)};
$APP.aj=function(a){return a instanceof La};ej=function(a,b){return $APP.We(b,dj)?b:a.g?a.g(b):a.call(null,b)};gg=function(a){return $APP.We(a,dj)?kd.g?kd.g(a):kd.call(null,a):a};jg=function(a,b){var c=$APP.fg;return De($APP.No.h(function(d){return gg(d)},a),c,b)};mb=function(a,b,c,d){return new $APP.n(null,4,[Zz,a,Tr,b,$APP.Cm,c,$APP.Vl,d],null)};hj=function(a,b,c,d,e){return new $APP.n(null,5,[Zz,a,Tr,b,$APP.Cm,c,$APP.Vl,d,$APP.Gk,e],null)};
Tb=function(a,b){return $APP.hg.i($APP.fg,$APP.ig.g(a),b)};de=function(a){return function(b){return $APP.ce($APP.tb(function(c,d){c=d.g?d.g(b):d.call(null,b);return $APP.z(c)?c:kd(!1)},!0,a))}};vh=function(a){return function(b){return $APP.ce($APP.Of(function(c){return c.g?c.g(b):c.call(null,b)},a))}};
ij=function(a,b,c,d,e,Df){if(null!=a&&null!=a.ne)a=a.ne(a,b,c,d,e,Df);else{var g=ij[$APP.aa(null==a?null:a)];if(null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else if(g=ij._,null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else throw $APP.qb("IValidationDriver.noncaching-park-validator!",a);}return a};
jj=function(a,b,c,d,e,Df){if(null!=a&&null!=a.Me)a=a.Me(a,b,c,d,e,Df);else{var g=jj[$APP.aa(null==a?null:a)];if(null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else if(g=jj._,null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else throw $APP.qb("IValidationDriver.park-validator!",a);}return a};
kj=function(a,b,c,d,e,Df){if(null!=a&&null!=a.me)a=a.me(a,b,c,d,e,Df);else{var g=kj[$APP.aa(null==a?null:a)];if(null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else if(g=kj._,null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else throw $APP.qb("IExplanationDriver.noncaching-park-explainer!",a);}return a};
lj=function(a,b,c,d,e,Df){if(null!=a&&null!=a.Ke)a=a.Ke(a,b,c,d,e,Df);else{var g=lj[$APP.aa(null==a?null:a)];if(null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else if(g=lj._,null!=g)a=g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df);else throw $APP.qb("IExplanationDriver.park-explainer!",a);}return a};
mj=function(a,b){if(null!=a&&null!=a.Le)a=a.Le(a,b);else{var c=mj[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=mj._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("IExplanationDriver.value-path",a);}return a};
nj=function(a,b,c){if(null!=a&&null!=a.Je)a=a.Je(a,b,c);else{var d=nj[$APP.aa(null==a?null:a)];if(null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else if(d=nj._,null!=d)a=d.i?d.i(a,b,c):d.call(null,a,b,c);else throw $APP.qb("IExplanationDriver.fail!",a);}return a};
oj=function(a,b,c,d,e,Df,g){if(null!=a&&null!=a.Cf)a=a.Cf(a,b,c,d,e,Df,g);else{var h=oj[$APP.aa(null==a?null:a)];if(null!=h)a=h.X?h.X(a,b,c,d,e,Df,g):h.call(null,a,b,c,d,e,Df,g);else if(h=oj._,null!=h)a=h.X?h.X(a,b,c,d,e,Df,g):h.call(null,a,b,c,d,e,Df,g);else throw $APP.qb("IParseDriver.noncaching-park-transformer!",a);}return a};
pj=function(a,b,c,d,e,Df,g){if(null!=a&&null!=a.Df)a=a.Df(a,b,c,d,e,Df,g);else{var h=pj[$APP.aa(null==a?null:a)];if(null!=h)a=h.X?h.X(a,b,c,d,e,Df,g):h.call(null,a,b,c,d,e,Df,g);else if(h=pj._,null!=h)a=h.X?h.X(a,b,c,d,e,Df,g):h.call(null,a,b,c,d,e,Df,g);else throw $APP.qb("IParseDriver.park-transformer!",a);}return a};qj=function(a){return function(b,c,d,e,Df){if(b=$APP.J(e))b=$APP.O(e),b=a.g?a.g(b):a.call(null,b);return $APP.z(b)?(d+=1,e=$APP.bd(e),Df.h?Df.h(d,e):Df.call(null,d,e)):null}};
rj=function(a,b,c){return function(d,e,Df,g,h){e=mj(d,Df);if($APP.J(g)){var Wm=$APP.O(g);e=c.i?c.i(Wm,e,$APP.fg):c.call(null,Wm,e,$APP.fg);if($APP.J(e))return nj(d,Df,e);d=Df+1;g=$APP.bd(g);return h.h?h.h(d,g):h.call(null,d,g)}return nj(d,Df,new $APP.X(null,1,5,$APP.Z,[hj(a,e,b,null,Dl)],null))}};sj=function(){return function(a,b,c,d,e){return $APP.Od(d)?e.h?e.h(c,d):e.call(null,c,d):null}};
uj=function(a,b){return function(c,d,e,Df,g){return $APP.Od(Df)?g.h?g.h(e,Df):g.call(null,e,Df):nj(c,e,new $APP.Ne(null,hj(b,mj(c,e),a,$APP.O(Df),tj),null,1,null))}};vj=function(){return function(a,b,c,d,e){return e.i?e.i(null,c,d):e.call(null,null,c,d)}};wj=function(){return $APP.fg};xj=function(a,b){return function(c,d,e,Df,g){function h(Wm,m,p){Wm=a.g?a.g(Wm):a.call(null,Wm);return g.i?g.i(Wm,m,p):g.call(null,Wm,m,p)}return b.G?b.G(c,d,e,Df,h):b.call(null,c,d,e,Df,h)}};
yj=function(a){return $APP.Vd(a)?$APP.R.h(a,1):a};Aj=function(a){var b=zj.l();return function Wm(d,e,Df,g,h){function m(p,r){return jj(d,Wm,e,p,r,h)}jj(d,b,e,Df,g,h);return a.G?a.G(d,e,Df,g,m):a.call(null,d,e,Df,g,m)}};Cj=function(a){var b=Bj.l();return function Wm(d,e,Df,g,h){function m(p,r){return lj(d,Wm,e,p,r,h)}lj(d,b,e,Df,g,h);return a.G?a.G(d,e,Df,g,m):a.call(null,d,e,Df,g,m)}};
Dj=function(a){function b(c,d,e,Df,g,h){return h.i?h.i(e,Df,g):h.call(null,e,Df,g)}return function(){function c(Df,g,h,Wm,m,p){function r(t,v,x){return pj(Df,e,g,$APP.Qe.h(h,t),v,x,p)}pj(Df,b,g,h,Wm,m,p);return a.G?a.G(Df,g,Wm,m,r):a.call(null,Df,g,Wm,m,r)}function d(Df,g,h,Wm,m){return e.O(Df,g,$APP.fg,h,Wm,m)}var e=null;e=function(Df,g,h,Wm,m,p){switch(arguments.length){case 5:return d.call(this,Df,g,h,Wm,m);case 6:return c.call(this,Df,g,h,Wm,m,p)}throw Error("Invalid arity: "+arguments.length);
};e.G=d;e.O=c;return e}()};Ej=function(a){return function(b){return $APP.tb(function(c,d){d=a.g?a.g(d):a.call(null,d);return $APP.We(d,dj)?kd(d):$APP.hg.h(c,d)},$APP.fg,b)}};Gj=function(a){var b=Fj.l();return function m(d,e,Df,g,h,Wm){function p(r,t,v){return pj(d,m,e,r,t,v,Wm)}pj(d,b,e,Df,g,h,Wm);return a.O?a.O(d,e,Df,g,h,p):a.call(null,d,e,Df,g,h,p)}};Ij=function(a){return xj(function(b){var c=$APP.Q(b,0,null);b=$APP.Q(b,1,null);return $APP.hg.h(new $APP.X(null,1,5,$APP.Z,[c],null),b)},Hj.j(a,$APP.Bd([Dj(a)])))};
Jj=function(a){var b=Ej(a);return function(c){return $APP.Vd(c)&&1<=$APP.ud(c)?b(c):dj}};
Kj=function(a,b,c){var d=zj.l(),e=function t(h,Wm,m,p,r){if(Md(Wm)<a){var v=function(x,A){return ij(h,function(E,M,U,W,ba){return t(E,$APP.Qe.h(Nd(M),Md(M)+1),U,W,ba)},Wm,x,A,r)};return c.G?c.G(h,Wm,m,p,v):c.call(null,h,Wm,m,p,v)}return Df(h,Wm,m,p,r)},Df=function v(Wm,m,p,r,t){if(Md(m)<b){jj(Wm,d,m,p,r,t);var x=function(A,E){return ij(Wm,function(M,U,W,ba,T){return v(M,$APP.Qe.h(Nd(U),Md(U)+1),W,ba,T)},m,A,E,t)};return c.G?c.G(Wm,m,p,r,x):c.call(null,Wm,m,p,r,x)}return t.h?t.h(p,r):t.call(null,p,
r)};return function(Wm,m,p,r,t){return e(Wm,$APP.Qe.h(m,0),p,r,t)}};
Lj=function(a,b,c){var d=Bj.l(),e=function t(h,Wm,m,p,r){if(Md(Wm)<a){var v=function(x,A){return kj(h,function(E,M,U,W,ba){return t(E,$APP.Qe.h(Nd(M),Md(M)+1),U,W,ba)},Wm,x,A,r)};return c.G?c.G(h,Wm,m,p,v):c.call(null,h,Wm,m,p,v)}return Df(h,Wm,m,p,r)},Df=function v(Wm,m,p,r,t){if(Md(m)<b){lj(Wm,d,m,p,r,t);var x=function(A,E){return kj(Wm,function(M,U,W,ba,T){return v(M,$APP.Qe.h(Nd(U),Md(U)+1),W,ba,T)},m,A,E,t)};return c.G?c.G(Wm,m,p,r,x):c.call(null,Wm,m,p,r,x)}return t.h?t.h(p,r):t.call(null,p,
r)};return function(Wm,m,p,r,t){return e(Wm,$APP.Qe.h(m,0),p,r,t)}};
Mj=function(a,b,c){function d(g,h,Wm,m,p,r){return r.i?r.i(Wm,m,p):r.call(null,Wm,m,p)}var e=function v(h,Wm,m,p,r,t){if(Md(Wm)<a){var x=function(A,E,M){return oj(h,function(U,W,ba,T,q,w){return v(U,$APP.Qe.h(Nd(W),Md(W)+1),$APP.Qe.h(ba,A),T,q,w)},Wm,m,E,M,t)};return c.G?c.G(h,Wm,p,r,x):c.call(null,h,Wm,p,r,x)}return Df(h,Wm,m,p,r,t)},Df=function x(Wm,m,p,r,t,v){if(Md(m)<b){pj(Wm,d,m,p,r,t,v);var A=function(E,M,U){return oj(Wm,function(W,ba,T,q,w,y){return x(W,$APP.Qe.h(Nd(ba),Md(ba)+1),$APP.Qe.h(T,
E),q,w,y)},m,p,M,U,v)};return c.G?c.G(Wm,m,r,t,A):c.call(null,Wm,m,r,t,A)}return v.i?v.i(p,r,t):v.call(null,p,r,t)};return function(Wm,m,p,r,t){return e(Wm,$APP.Qe.h(m,0),$APP.fg,p,r,t)}};Nj=function(a,b,c){var d=Ej(c);return function(e){return $APP.Vd(e)&&a<=$APP.ud(e)&&$APP.ud(e)<=b?d(e):dj}};
Oj=function(a,b,c){var d=Fj.l(),e=function v(h,Wm,m,p,r,t){if(Md(Wm)<a){var x=function(A,E,M){return oj(h,function(U,W,ba,T,q,w){return v(U,$APP.Qe.h(Nd(W),Md(W)+1),ba,T,q,w)},Wm,A,E,M,t)};return c.O?c.O(h,Wm,m,p,r,x):c.call(null,h,Wm,m,p,r,x)}return Df(h,Wm,m,p,r,t)},Df=function x(Wm,m,p,r,t,v){if(Md(m)<b){pj(Wm,d,m,p,r,t,v);var A=function(E,M,U){return oj(Wm,function(W,ba,T,q,w,y){return x(W,$APP.Qe.h(Nd(ba),Md(ba)+1),T,q,w,y)},m,E,M,U,v)};return c.O?c.O(Wm,m,p,r,t,A):c.call(null,Wm,m,p,r,t,A)}return v.i?
v.i(p,r,t):v.call(null,p,r,t)};return function(Wm,m,p,r,t,v){return e(Wm,$APP.Qe.h(m,0),p,r,t,v)}};Pj=function(a,b,c,d){if(null!=a&&null!=a.Ie)a=a.Ie(a,b,c,d);else{var e=Pj[$APP.aa(null==a?null:a)];if(null!=e)a=e.K?e.K(a,b,c,d):e.call(null,a,b,c,d);else if(e=Pj._,null!=e)a=e.K?e.K(a,b,c,d):e.call(null,a,b,c,d);else throw $APP.qb("ICache.ensure-cached!",a);}return a};Qj=function(a,b,c,d){this.hash=a;this.f=b;this.pos=c;this.Gg=d};Rj=function(){this.values=nf(2);this.size=0};
Sj=function(){var a=new Rj;this.tc=!1;this.stack=[];this.cache=a};Tj=function(a){var b=zj.j(a,$APP.Bd([sj()]));return function(c){var d=$APP.Sd(c);if(d){var e=new Sj;d=function(){return e.tc=$APP.ce(!0)};b.G?b.G(e,$APP.ad,0,c,d):b.call(null,e,$APP.ad,0,c,d);c=e.tc;if($APP.z(c))return c;for(;;){c=0===e.stack.length?null:e.stack.pop();if(null==c)return!1;c.l?c.l():c.call(null);c=e.tc;if($APP.z(c))return c}}else return d}};
Uj=function(a,b){var c=$APP.fg;this.tc=!1;this.stack=[];this.cache=a;this.vb=b;this.he=0;this.errors=c};
Vj=function(a,b,c){var d=Bj.j(c,$APP.Bd([uj(a,b)]));return function(e,Df,g){if($APP.Sd(e)){var h=new Uj(new Rj,Df);Df=function(){return h.tc=$APP.ce(!0)};d.G?d.G(h,$APP.ad,0,e,Df):d.call(null,h,$APP.ad,0,e,Df);if($APP.z(h.tc))return g;for(;;){e=0===h.stack.length?null:h.stack.pop();if(null==e)return $APP.hg.h(g,h.errors);e.l?e.l():e.call(null);if($APP.z(h.tc))return g}}else return $APP.Qe.h(g,hj(b,Df,a,e,El))}};Wj=function(){};
Xj=function(a,b){if(null!=a&&null!=a.oe)a=a.oe(a,b);else{var c=Xj[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=Xj._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("Registry.-schema",a);}return a};
bk=function(a){if("undefined"===typeof Yj||"undefined"===typeof Zj||"undefined"===typeof yo)yo=function(b,c){this.zd=b;this.Xf=c;this.s=393216;this.A=0},yo.prototype.J=function(b,c){return new yo(this.zd,c)},yo.prototype.I=function(){return this.Xf},yo.prototype.Ne=$APP.Qc,yo.prototype.oe=function(b,c){return this.zd.g?this.zd.g(c):this.zd.call(null,c)},yo.R=!0,yo.P="malli.registry/t_malli$registry23715",yo.S=function(b){return pc(b,"malli.registry/t_malli$registry23715")};return new yo(a,$APP.Jf)};
ck=function(a){return null==a?null:null!=a&&$APP.Qc===a.Ne?a:$APP.Td(a)?bk(a):(null!=a?$APP.Qc===a.Ne||(a.jb?0:$APP.ob(Wj,a)):$APP.ob(Wj,a))?a:null};
ek=function(a){var b=$APP.on.h(ck,a);if("undefined"===typeof Yj||"undefined"===typeof Zj||"undefined"===typeof Bo)Bo=function(c,d,e){this.Ue=c;this.Pe=d;this.Zf=e;this.s=393216;this.A=0},Bo.prototype.J=function(c,d){return new Bo(this.Ue,this.Pe,d)},Bo.prototype.I=function(){return this.Zf},Bo.prototype.Ne=$APP.Qc,Bo.prototype.oe=function(c,d){return $APP.Of(function(e){return Xj(e,d)},this.Pe)},Bo.R=!0,Bo.P="malli.registry/t_malli$registry23732",Bo.S=function(c){return pc(c,"malli.registry/t_malli$registry23732")};
return new Bo(a,b,$APP.Jf)};bj=function(a){this.f=a;this.ic=null;this.s=32769;this.A=0};ik=function(a){if(null!=a&&null!=a.Na)a=a.Na(a);else{var b=ik[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=ik._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IntoSchema.-type",a);}return a};
jk=function(a){if(null!=a&&null!=a.Oa)a=a.Oa(a);else{var b=jk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=jk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("IntoSchema.-type-properties",a);}return a};
$APP.kk=function(a,b,c,d){if(null!=a&&null!=a.Ma)a=a.Ma(a,b,c,d);else{var e=$APP.kk[$APP.aa(null==a?null:a)];if(null!=e)a=e.K?e.K(a,b,c,d):e.call(null,a,b,c,d);else if(e=$APP.kk._,null!=e)a=e.K?e.K(a,b,c,d):e.call(null,a,b,c,d);else throw $APP.qb("IntoSchema.-into-schema",a);}return a};
mk=function(a){if(null!=a&&null!=a.Ea)a=a.Ea(a);else{var b=mk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=mk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Schema.-validator",a);}return a};nk=function(a,b){if(null!=a&&null!=a.Qa)a=a.Qa(a,b);else{var c=nk[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=nk._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("Schema.-explainer",a);}return a};
$APP.ok=function(a){if(null!=a&&null!=a.Ya)a=a.N;else{var b=$APP.ok[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.ok._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Schema.-properties",a);}return a};$APP.pk=function(a){if(null!=a&&null!=a.Ra)a=a.Ra(a);else{var b=$APP.pk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.pk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Schema.-options",a);}return a};
$APP.qk=function(a){if(null!=a&&null!=a.Va)a=a.Va(a);else{var b=$APP.qk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.qk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Schema.-children",a);}return a};$APP.rk=function(a){if(null!=a&&null!=a.Xa)a=a.parent;else{var b=$APP.rk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.rk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Schema.-parent",a);}return a};
sk=function(a){if(null!=a&&null!=a.Wa)a=a.Wa(a);else{var b=sk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=sk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Schema.-form",a);}return a};cj=function(a,b){if(null!=a&&null!=a.wd)a=a.wd(a,b);else{var c=cj[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=cj._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("AST.-to-ast",a);}return a};
fj=function(a){if(null!=a&&null!=a.Pf)a=a.Pf(a);else{var b=fj[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=fj._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("EntryParser.-entry-keyset",a);}return a};gj=function(a){if(null!=a&&null!=a.Mf)a=a.Mf(a);else{var b=gj[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=gj._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("EntryParser.-entry-children",a);}return a};
ak=function(a){if(null!=a&&null!=a.Nf)a=a.Nf(a);else{var b=ak[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=ak._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("EntryParser.-entry-entries",a);}return a};fk=function(a){if(null!=a&&null!=a.Of)a=a.Of(a);else{var b=fk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=fk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("EntryParser.-entry-forms",a);}return a};
uk=function(a){if(null!=a&&null!=a.Ad)a=a.Ad(a);else{var b=uk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=uk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("EntrySchema.-entries",a);}return a};$APP.gk=function(a){if(null!=a&&null!=a.Ed)a=a.Jc;else{var b=$APP.gk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.gk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("EntrySchema.-entry-parser",a);}return a};
hk=function(a){if(null!=a&&null!=a.vd)a=a.cache;else{var b=hk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=hk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("Cached.-cache",a);}return a};$APP.wk=function(a){if(null!=a&&null!=a.sd)a=a.sd(a);else{var b=$APP.wk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.wk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("RefSchema.-deref",a);}return a};
$APP.xk=function(a){if(null!=a&&null!=a.hd)a=a.hd(a);else{var b=$APP.xk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=$APP.xk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("RegexSchema.-regex-op?",a);}return a};yk=function(a){if(null!=a&&null!=a.jd)a=a.jd(a);else{var b=yk[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=yk._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("RegexSchema.-regex-validator",a);}return a};
zk=function(a,b){if(null!=a&&null!=a.fd)a=a.fd(a,b);else{var c=zk[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=zk._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("RegexSchema.-regex-explainer",a);}return a};Ak=function(a){if(null!=a&&null!=a.gd)a=a.gd(a);else{var b=Ak[$APP.aa(null==a?null:a)];if(null!=b)a=b.g?b.g(a):b.call(null,a);else if(b=Ak._,null!=b)a=b.g?b.g(a):b.call(null,a);else throw $APP.qb("RegexSchema.-regex-min-max",a);}return a};
$APP.lk=function(a){return null!=a?$APP.Qc===a.Lc?!0:!1:!1};Bk=function(a){return function(b){try{return $APP.ce(a.g?a.g(b):a.call(null,b))}catch(c){if(c instanceof Error)return!1;throw c;}}};tk=function(a,b,c,d,e){var Df=function(){var g=$APP.Sd(c)||null==c;return g?$APP.ud(c):g}();$APP.z(Df)&&$APP.z(function(){var g=$APP.z(d)?Df<d:d;return $APP.z(g)?g:$APP.z(e)?Df>e:e}())&&$APP.Ek.h(Ml,new $APP.n(null,5,[$APP.Gk,a,Hk,b,$APP.Ol,c,$APP.Ck,d,$APP.Dk,e],null))};
Lk=function(a,b,c){a=new $APP.n(null,1,[Pl,a],null);a=Kk.g?Kk.g(a):Kk.call(null,a);return $APP.kk(a,null,new $APP.X(null,1,5,$APP.Z,[b],null),c)};Mk=function(a){return"string"===typeof a||$APP.df(a)};Nk=function(a,b){var c=$APP.kg.i,d=$APP.R.h(a,cl);b=b.g?b.g(d):b.call(null,d);return c.call($APP.kg,a,cl,b)};$APP.vk=function(a,b){return Tb(a,b)};Ok=function(a){var b=$APP.Yf(null);return function(){var c=$APP.$b(b);return $APP.z(c)?c:Zf(b,a.l?a.l():a.call(null))}};
$APP.ql=function(a){if($APP.vd.h($APP.ml.g?$APP.ml.g(a):$APP.ml.call(null,a),$APP.nl)){var b=$APP.qk(a);a=$APP.Q(b,0,null);b=$APP.Q(b,1,null);var c=Ak(a),d=$APP.Ef(c);c=$APP.R.h(d,$APP.Ck);d=$APP.R.h(d,$APP.Dk);a=new $APP.n(null,4,[$APP.Ck,c,$APP.Gm,$APP.vd.h(c,d)?c:$APP.ol,$APP.pl,a,$APP.Im,b],null);return $APP.z(d)?$APP.kg.i(a,$APP.Dk,d):a}return null};
$APP.$k=function(a){var b=$APP.Yf($APP.Oh);return $APP.tb(function(c,d){d=$APP.Ef(d);var e=$APP.R.h(d,$APP.Ck),Df=$APP.R.h(d,$APP.Gm),g=$APP.vd.h($APP.ol,Df),h=$APP.z(function(){if(g){var Wm=$APP.$b(b);return Wm.g?Wm.g(e):Wm.call(null,e)}return g}())?$APP.wf(Ik,$APP.dg($APP.ge,$APP.$b(b)))+1:e;if($APP.z(function(){if(g){var Wm=$APP.$b(b);return Wm.g?Wm.g(Df):Wm.call(null,Df)}return g}()))return $APP.Ek.h(Rk,new $APP.n(null,1,[wA,a],null));if($APP.z(function(){var Wm=$APP.$b(b);return Wm.g?Wm.g(h):
Wm.call(null,h)}()))return $APP.Ek.h(Ou,new $APP.n(null,1,[wA,a],null));$APP.Ei.i(b,$APP.Qe,Df);return $APP.kg.i(c,Df,$APP.kg.i(d,$APP.Ck,h))},$APP.Jf,a)};im=function(a,b,c){b=$APP.Ef(b);var d=$APP.R.h(b,$APP.Ck);b=$APP.R.h(b,$APP.Dk);c=Ak(c);c=$APP.Ef(c);var e=$APP.R.h(c,$APP.Ck);c=$APP.R.h(c,$APP.Dk);d=$APP.z(d)?d:0;d=a.h?a.h(d,e):a.call(null,d,e);d=new $APP.n(null,1,[$APP.Ck,d],null);return $APP.z($APP.z(b)?c:b)?$APP.kg.i(d,$APP.Dk,a.h?a.h(b,c):a.call(null,b,c)):d};
km=function(a,b){a=$APP.Ef(a);var c=$APP.R.h(a,$APP.Ck);a=$APP.R.h(a,$APP.Dk);b=Ak(b);var d=$APP.Ef(b);b=$APP.R.h(d,$APP.Ck);d=$APP.R.h(d,$APP.Dk);c=$APP.z(c)?c:$APP.jm;c=new $APP.n(null,1,[$APP.Ck,c<b?c:b],null);return $APP.z($APP.z(a)?d:a)?$APP.kg.i(c,$APP.Dk,a>d?a:d):c};
bl=function(a,b){var c=$APP.Vd(b)?b:new $APP.X(null,2,5,$APP.Z,[b,$APP.$b(b)],null);b=$APP.Q(c,0,null);var d=$APP.Q(c,1,null);c=Lq.g(Ld(b));d=new $APP.n(null,2,[$APP.Gk,c,$APP.mm,d],null);d=$APP.ms.g?$APP.ms.g(d):$APP.ms.call(null,d);return $APP.kg.i($APP.kg.i(a,c,d),$APP.$b(b),d)};el=function(a){a=$APP.z(a)?ck(a.g?a.g(cl):a.call(null,cl)):null;return $APP.z(a)?a:dl};
kl=function(a,b,c){var d=$APP.kg.i(b,Em,!0);return De(function(e,Df,g){var h=$APP.kg.i;g=$APP.Sk?$APP.Sk(g,d):Tk.call(null,g,d);g=c.g?c.g(g):c.call(null,g);return h.call($APP.kg,e,Df,g)},$APP.Jf,a)};fl=function(a,b){var c=el(b),d=Xj(c,a);if($APP.z(d))return d;c=null==c?null:Xj(c,$APP.pb(a));return null==c?null:$APP.kk(c,null,new $APP.X(null,1,5,$APP.Z,[a],null),b)};
gl=function(a,b,c){$APP.z(b)&&(b=b.g?b.g(a):b.call(null,a),b=$APP.z(b)?a:b);if($APP.z(b))return b;c=fl(a,c);return $APP.z(c)?c:$APP.Ek.h(il,new $APP.n(null,1,[$APP.Cm,a],null))};jl=function(){return $APP.Yf($APP.Jf)};$APP.ll=function(a,b,c){if(null!=a&&$APP.Qc===a.td){var d=hk(a);var e=$APP.$b(d);e=e.g?e.g(b):e.call(null,b);if($APP.z(e))return e;a=$APP.Ei.K(d,$APP.kg,b,c.g?c.g(a):c.call(null,a));return a.g?a.g(b):a.call(null,b)}return c.g?c.g(a):c.call(null,a)};
Jk=function(a,b,c,d){var e=$APP.J(c),Df=$APP.J(b);if(Df){var g=cl.g(b);b=$APP.z(g)?$APP.kg.i(b,cl,kl(g,d,sk)):b}else b=null;return Df&&e?$APP.tb($APP.Qe,new $APP.X(null,2,5,$APP.Z,[a,b],null),c):Df?new $APP.X(null,2,5,$APP.Z,[a,b],null):e?$APP.tb($APP.Qe,new $APP.X(null,1,5,$APP.Z,[a],null),c):a};Gl=function(a,b,c,d,e){return Jk(ik(a),b,Tb(d,c),e)};Hl=function(a,b,c,d){return Jk(ik(a),b,fk(c),d)};
Qk=function(a,b,c){a=$APP.Of($APP.Vd(b)&&$APP.vd.h(Pk,$APP.wd(b,0))?function(d){return $APP.vd.h($APP.wd(d,0),$APP.wd(b,1))?d:null}:function(d){return $APP.vd.h($APP.wd(d,0),b)?$APP.wd(d,2):null},$APP.qk(a));return $APP.z(a)?a:c};
Am=function(a,b,c){var d=$APP.ig.h(function(e){var Df=$APP.Q(e,0,null),g=$APP.Q(e,1,null);e=$APP.Q(e,2,null);g=Xk?Xk(e,g):Yk.call(null,e,g);return new $APP.oe(Df,g)},b);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Yr)Yr=function(e,Df,g,h,Wm){this.le=e;this.children=Df;this.forms=g;this.entries=h;this.$f=Wm;this.s=393216;this.A=0},Yr.prototype.J=function(e,Df){return new Yr(this.le,this.children,this.forms,this.entries,Df)},Yr.prototype.I=function(){return this.$f},Yr.prototype.Tf=
$APP.Qc,Yr.prototype.Pf=function(){return this.le},Yr.prototype.Mf=function(){return this.children},Yr.prototype.Nf=function(){return this.entries},Yr.prototype.Of=function(){return this.forms},Yr.R=!0,Yr.P="malli.core/t_malli$core28512",Yr.S=function(e){return pc(e,"malli.core/t_malli$core28512")};return new Yr(a,b,c,d,$APP.Jf)};
Mm=function(a,b,c,d,e,Df,g,h){function Wm(W,ba,T){T=v(T);var q=sk(T);return x(W,new $APP.X(null,3,5,$APP.Z,[W,ba,T],null),$APP.z(ba)?new $APP.X(null,3,5,$APP.Z,[W,ba,q],null):new $APP.X(null,2,5,$APP.Z,[W,q],null),e)}function m(W,ba){ba=v(ba);var T=new $APP.X(null,2,5,$APP.Z,[W,sk(ba)],null);return x(W,new $APP.X(null,3,5,$APP.Z,[W,null,ba],null),T,e)}function p(W,ba,T){var q=v(ba);return x(ba,new $APP.X(null,3,5,$APP.Z,[ba,T,q],null),W,e)}function r(W,ba){var T=v(ba);return x(ba,new $APP.X(null,
3,5,$APP.Z,[ba,null,T],null),W,e)}function t(W){var ba=v(W);return x(W,new $APP.X(null,3,5,$APP.Z,[W,null,ba],null),W,e)}function v(W){var ba=Mk(W);$APP.z(ba?c:ba)&&(ba=new $APP.n(null,1,[qm,!0],null),ba=Vk?Vk(ba):Wk.call(null,ba),W=$APP.kk(ba,null,new $APP.X(null,1,5,$APP.Z,[W],null),d));return $APP.Sk?$APP.Sk(W,d):Tk.call(null,W,d)}function x(W,ba,T,q){q|=0;h[2*q]=W;h[2*q+1]=new $APP.n(null,1,[Km,q],null);Df[q]=ba;g[q]=T;return q+1}if($APP.Vd(a)){var A=nf(a),E=A.length,M=A[0];if(1===E)return $APP.z(function(){var W=
Mk(M);return W?b:W}())?r(a,M):e;var U=A[1];return 2===E?Mk(M)&&$APP.Td(U)?$APP.z(b)?p(a,M,U):e:m(M,U):Wm(M,U,A[2])}return $APP.z($APP.z(b)?Mk(a):b)?t(a):$APP.Ek.h(bm,new $APP.n(null,1,[$APP.Uk,a],null))};
Sm=function(a,b,c){function d(x){var A=$APP.wf($APP.Ci,x);$APP.vd.h(2*$APP.ud(A),$APP.ud(x))||$APP.Ek.g(Qm);return A}function e(x){return $APP.Cg(x)}var Df=$APP.Ef(b),g=$APP.R.h(Df,Yl),h=$APP.R.h(Df,Jh),Wm=nf(a),m=Wm.length;a=nf(m);for(var p=nf(m),r=nf(2*m),t=0,v=0;;){if(v===m)return b=v===t?e:function(x){return function(A){return $APP.Cg(A.slice(0,x))}}(t,v,b,Df,g,h,Wm,m,a,p,r),Am(d(r),b(a),b(p));t=Mm(Wm[t],g,h,c,t,a,p,r)|0;v+=1}};
Ym=function(a,b,c){var d=new $APP.vi(function(){return Sm(a,b,c)});if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Zr)Zr=function(e,Df,g,h,Wm){this.Uf=e;this.kh=Df;this.options=g;this.Cd=h;this.ag=Wm;this.s=393216;this.A=0},Zr.prototype.J=function(e,Df){return new Zr(this.Uf,this.kh,this.options,this.Cd,Df)},Zr.prototype.I=function(){return this.ag},Zr.prototype.Tf=$APP.Qc,Zr.prototype.Pf=function(){return fj($APP.$b(this.Cd))},Zr.prototype.Mf=function(){return gj($APP.$b(this.Cd))},
Zr.prototype.Nf=function(){return ak($APP.$b(this.Cd))},Zr.prototype.Of=function(){return fk($APP.$b(this.Cd))},Zr.R=!0,Zr.P="malli.core/t_malli$core28534",Zr.S=function(e){return pc(e,"malli.core/t_malli$core28534")};return new Zr(a,b,c,d,$APP.Jf)};dn=function(a,b,c){if(null==a||$APP.Qc!==a.Tf){var d=qm.g(b);d=$APP.z(d)?d:bn.g(c);a=$APP.z(d)?Ym(a,b,c):Sm(a,b,c)}return a};
ws=function(a,b,c){var d=function(){var Df=cl.g(b);return $APP.z(Df)?$APP.hg.i($APP.Jf,$APP.ig.g(function(g){var h=$APP.Q(g,0,null);g=$APP.Q(g,1,null);return new $APP.X(null,2,5,$APP.Z,[h,Oo?Oo(g,c):rp.call(null,g,c)],null)}),Df):null}(),e=$APP.Ff($APP.z(d)?$APP.Ln.h(b,cl):b);a=$APP.z(e)?$APP.kg.i(a,Hk,e):a;return $APP.z(d)?$APP.kg.i(a,cl,d):a};
zs=function(a,b){return ws(new $APP.n(null,2,[$APP.Gk,$APP.ml.g?$APP.ml.g(a):$APP.ml.call(null,a),al,$APP.tb(function(c,d){var e=$APP.Q(d,0,null),Df=$APP.Q(d,1,null),g=$APP.Q(d,2,null);d=$APP.kg.i;g=new $APP.n(null,2,[Km,Km.g($APP.R.h(b,e)),$APP.Vl,xs?xs(g):rp.call(null,g)],null);Df=$APP.z(Df)?$APP.kg.i(g,Hk,Df):g;return d.call($APP.kg,c,e,Df)},$APP.Jf,$APP.qk(a))],null),$APP.ok(a),$APP.pk(a))};
Ds=function(a){var b=$APP.ml.g?$APP.ml.g(a):$APP.ml.call(null,a);var c=$APP.wd($APP.qk(a),0);c=xs?xs(c):rp.call(null,c);return ws(new $APP.n(null,2,[$APP.Gk,b,Cs,c],null),$APP.ok(a),$APP.pk(a))};Fs=function(a,b,c){var d=Hk.g(b);b=$APP.Vl.g(b);return $APP.kk(a,d,$APP.z(b)?new $APP.X(null,1,5,$APP.Z,[b],null):null,c)};Hs=function(a){return ws(new $APP.n(null,2,[$APP.Gk,$APP.ml.g?$APP.ml.g(a):$APP.ml.call(null,a),$APP.Vl,$APP.wd($APP.qk(a),0)],null),$APP.ok(a),$APP.pk(a))};
Is=function(a){return ws(new $APP.n(null,1,[$APP.Gk,$APP.ml.g?$APP.ml.g(a):$APP.ml.call(null,a)],null),$APP.ok(a),$APP.pk(a))};
rl=function(a){return function(b){b=$APP.Ef(b);var c=$APP.R.h(b,$APP.Ck),d=$APP.R.h(b,$APP.Dk);return $APP.ib($APP.z(c)?c:d)?null:$APP.z(function(){var e=$APP.z(c)?d:c;return $APP.z(e)?a:e}())?function(e){e=a.g?a.g(e):a.call(null,e);return c<=e&&e<=d}:$APP.z($APP.z(c)?d:c)?function(e){return c<=e&&e<=d}:$APP.z($APP.z(c)?a:c)?function(e){return c<=(a.g?a.g(e):a.call(null,e))}:$APP.z(c)?function(e){return c<=e}:$APP.z($APP.z(d)?a:d)?function(e){return(a.g?a.g(e):a.call(null,e))<=d}:$APP.z(d)?function(e){return e<=
d}:null}};sl=function(a,b){a=rl($APP.ud)(new $APP.n(null,2,[$APP.Ck,a,$APP.Dk,b],null));return $APP.z(a)?a:Qf(!0)};Js=function(a){var b=function(){var c=null==a?null:$APP.ey.g(a);return null==c?null:$APP.Uh(c)}();return $APP.z(b)?function(c){return $APP.vd.h(Xe(c),b)}:null};
Wy=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof $r)$r=function(a){this.Gd=a;this.s=393216;this.A=0},$r.prototype.J=function(a,b){return new $r(b)},$r.prototype.I=function(){return this.Gd},$r.prototype.Ta=$APP.Qc,$r.prototype.Na=function(){return $APP.Yy},$r.prototype.Oa=function(){return null},$r.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.Yy,b,c,1,null);var Df=$APP.vk(function(g){return $APP.Sk?$APP.Sk(g,d):Tk.call(null,g,d)},c);a=new $APP.vi(function(){return Gl(e,
b,Df,sk,d)});c=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof rD)rD=function(g,h,Wm,m,p,r,t,v,x){this.Gd=g;this.parent=h;this.N=Wm;this.children=m;this.options=p;this.form=r;this.cache=t;this.ib=v;this.Md=x;this.s=393216;this.A=0},rD.prototype.J=function(g,h){return new rD(this.Gd,this.parent,this.N,this.children,this.options,this.form,this.cache,this.ib,h)},rD.prototype.I=function(){return this.Md},rD.prototype.Ua=$APP.Qc,rD.prototype.Ea=function(){var g=Tb(mk,this.children);
return de(g)},rD.prototype.Ra=function(){return this.options},rD.prototype.Ya=function(){return this.N},rD.prototype.Va=function(){return this.children},rD.prototype.Wa=function(){return $APP.$b(this.form)},rD.prototype.Qa=function(g,h){var Wm=$APP.vk(function(m){var p=$APP.Q(m,0,null);m=$APP.Q(m,1,null);return nk(m,$APP.Qe.h(h,p))},$APP.Vf($APP.Sf,this.children));return function(m,p,r){return $APP.tb(function(t,v){return v.i?v.i(m,p,t):v.call(null,m,p,t)},r,Wm)}},rD.prototype.Xa=function(){return this.parent},
rD.prototype.td=$APP.Qc,rD.prototype.vd=function(){return this.cache},rD.prototype.Pa=function(g,h,Wm){return $APP.R.i(this.children,h,Wm)},rD.R=!0,rD.P="malli.core/t_malli$core28599",rD.S=function(g){return pc(g,"malli.core/t_malli$core28599")};return new rD(this.Gd,e,b,Df,d,a,c,function(g,h){var Wm=function(){var m=Tb(g,Df);return h.g?h.g(m):h.call(null,m)}();return function(m){return $APP.tb(function(p,r){return gg(r.g?r.g(p):r.call(null,p))},m,Wm)}},new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},
$r.R=!0,$r.P="malli.core/t_malli$core28595",$r.S=function(a){return pc(a,"malli.core/t_malli$core28595")};return new $r(new $APP.n(null,1,[$APP.Gk,yl],null))};
gB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof as)as=function(a){this.Hd=a;this.s=393216;this.A=0},as.prototype.J=function(a,b){return new as(b)},as.prototype.I=function(){return this.Hd},as.prototype.Ta=$APP.Qc,as.prototype.Na=function(){return $APP.Fp},as.prototype.Oa=function(){return null},as.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.Fp,b,c,1,null);var Df=$APP.vk(function(g){return $APP.Sk?$APP.Sk(g,d):Tk.call(null,g,d)},c);a=new $APP.vi(function(){return Gl(e,
b,Df,sk,d)});c=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Nr)Nr=function(g,h,Wm,m,p,r,t,v,x){this.Hd=g;this.parent=h;this.N=Wm;this.children=m;this.options=p;this.form=r;this.cache=t;this.ib=v;this.gg=x;this.s=393216;this.A=0},Nr.prototype.J=function(g,h){return new Nr(this.Hd,this.parent,this.N,this.children,this.options,this.form,this.cache,this.ib,h)},Nr.prototype.I=function(){return this.gg},Nr.prototype.Ua=$APP.Qc,Nr.prototype.Ea=function(){var g=Tb(mk,this.children);
return vh(g)},Nr.prototype.Ra=function(){return this.options},Nr.prototype.Ya=function(){return this.N},Nr.prototype.Va=function(){return this.children},Nr.prototype.Wa=function(){return $APP.$b(this.form)},Nr.prototype.Qa=function(g,h){var Wm=$APP.vk(function(m){var p=$APP.Q(m,0,null);m=$APP.Q(m,1,null);return nk(m,$APP.Qe.h(h,p))},$APP.Vf($APP.Sf,this.children));return function(m,p,r){return $APP.tb(function(t,v){v=v.i?v.i(m,p,t):v.call(null,m,p,t);return t===v?kd(r):v},r,Wm)}},Nr.prototype.Xa=
function(){return this.parent},Nr.prototype.td=$APP.Qc,Nr.prototype.vd=function(){return this.cache},Nr.prototype.Pa=function(g,h,Wm){return $APP.R.i(this.children,h,Wm)},Nr.R=!0,Nr.P="malli.core/t_malli$core28612",Nr.S=function(g){return pc(g,"malli.core/t_malli$core28612")};return new Nr(this.Hd,e,b,Df,d,a,c,function(g){var h=Tb(g,Df);return function(Wm){return $APP.tb(function(m,p){return ej(kd,p.g?p.g(Wm):p.call(null,Wm))},dj,h)}},new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},as.R=!0,as.P="malli.core/t_malli$core28609",
as.S=function(a){return pc(a,"malli.core/t_malli$core28609")};return new as(new $APP.n(null,1,[$APP.Gk,yl],null))};
jB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Wr)Wr=function(a){this.Od=a;this.s=393216;this.A=0},Wr.prototype.J=function(a,b){return new Wr(b)},Wr.prototype.I=function(){return this.Od},Wr.prototype.zb=$APP.Qc,Wr.prototype.Ta=$APP.Qc,Wr.prototype.Na=function(){return $APP.vr},Wr.prototype.Oa=function(){return null},Wr.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.vr,b,c,1,null);var Df=dn(c,new $APP.n(null,1,[Yl,!0],null),d);a=new $APP.vi(function(){return Hl(e,
b,Df,d)});var g=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Xr)Xr=function(h,Wm,m,p,r,t,v,x,A){this.Od=h;this.parent=Wm;this.N=m;this.children=p;this.options=r;this.Jc=t;this.form=v;this.cache=x;this.hg=A;this.s=393216;this.A=0},Xr.prototype.J=function(h,Wm){return new Xr(this.Od,this.parent,this.N,this.children,this.options,this.Jc,this.form,this.cache,Wm)},Xr.prototype.I=function(){return this.hg},Xr.prototype.zb=$APP.Qc,Xr.prototype.wd=function(){return zs(this,
fj(this.Jc))},Xr.prototype.Ua=$APP.Qc,Xr.prototype.Ea=function(){return vh($APP.vk(function(h){$APP.Q(h,0,null);$APP.Q(h,1,null);h=$APP.Q(h,2,null);return mk(h)},this.Va(null)))},Xr.prototype.Ra=function(){return this.options},Xr.prototype.Ya=function(){return this.N},Xr.prototype.Va=function(){return gj(this.Jc)},Xr.prototype.Wa=function(){return $APP.$b(this.form)},Xr.prototype.Qa=function(h,Wm){var m=$APP.vk(function(p){var r=$APP.Q(p,0,null);$APP.Q(p,1,null);p=$APP.Q(p,2,null);return nk(p,$APP.Qe.h(Wm,
r))},this.Va(null));return function(p,r,t){return $APP.tb(function(v,x){x=x.i?x.i(p,r,v):x.call(null,p,r,v);return v===x?kd(t):x},t,m)}},Xr.prototype.Xa=function(){return this.parent},Xr.prototype.Bd=$APP.Qc,Xr.prototype.Ad=function(){return ak(this.Jc)},Xr.prototype.Ed=function(){return this.Jc},Xr.prototype.td=$APP.Qc,Xr.prototype.vd=function(){return this.cache},Xr.prototype.Pa=function(h,Wm,m){return Qk(this,Wm,m)},Xr.R=!0,Xr.P="malli.core/t_malli$core28625",Xr.S=function(h){return pc(h,"malli.core/t_malli$core28625")};
return new Xr(this.Od,e,b,c,d,Df,a,g,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},Wr.R=!0,Wr.P="malli.core/t_malli$core28622",Wr.S=function(a){return pc(a,"malli.core/t_malli$core28622")};return new Wr(new $APP.n(null,1,[$APP.Gk,yl],null))};
mB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof bs)bs=function(a){this.Id=a;this.s=393216;this.A=0},bs.prototype.J=function(a,b){return new bs(b)},bs.prototype.I=function(){return this.Id},bs.prototype.zb=$APP.Qc,bs.prototype.Ta=$APP.Qc,bs.prototype.Na=function(){return $APP.Az},bs.prototype.Oa=function(){return null},bs.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.Az,b,c,1,1);var Df=$APP.vk(function(h){return $APP.Sk?$APP.Sk(h,d):Tk.call(null,h,d)},c);
a=$APP.Q(Df,0,null);c=new $APP.vi(function(){return Gl(e,b,Df,sk,d)});var g=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof cs)cs=function(h,Wm,m,p,r,t,v,x,A,E){this.form=h;this.options=Wm;this.Id=m;this.N=p;this.schema=r;this.children=t;this.parent=v;this.Og=x;this.cache=A;this.cg=E;this.s=393216;this.A=0},cs.prototype.J=function(h,Wm){return new cs(this.form,this.options,this.Id,this.N,this.schema,this.children,this.parent,this.Og,this.cache,Wm)},cs.prototype.I=function(){return this.cg},
cs.prototype.zb=$APP.Qc,cs.prototype.wd=function(){return Ds(this)},cs.prototype.Ua=$APP.Qc,cs.prototype.Ea=function(){return $APP.Pf(mk(this.schema))},cs.prototype.Ra=function(){return this.options},cs.prototype.Ya=function(){return this.N},cs.prototype.Va=function(){return this.children},cs.prototype.Wa=function(){return $APP.$b(this.form)},cs.prototype.Qa=function(h,Wm){var m=this,p=m.Ea(null);return function(r,t,v){return $APP.ib(p.g?p.g(r):p.call(null,r))?$APP.Qe.h(v,mb($APP.Qe.h(Wm,0),t,m,r)):
v}},cs.prototype.Xa=function(){return this.parent},cs.prototype.td=$APP.Qc,cs.prototype.vd=function(){return this.cache},cs.prototype.Pa=function(h,Wm,m){return $APP.R.i(this.children,Wm,m)},cs.R=!0,cs.P="malli.core/t_malli$core28662",cs.S=function(h){return pc(h,"malli.core/t_malli$core28662")};return new cs(c,d,this.Id,b,a,Df,e,Df,g,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},bs.R=!0,bs.P="malli.core/t_malli$core28656",bs.S=function(a){return pc(a,"malli.core/t_malli$core28656")};return new bs(new $APP.n(null,
1,[$APP.Gk,yl],null))};Yk=function(a){switch(arguments.length){case 2:return Xk(arguments[0],arguments[1]);case 0:return tl();default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};Xk=function(a,b){return $APP.kk(tl(),b,new $APP.Ne(null,a,null,1,null),$APP.pk(a))};
tl=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof ds)ds=function(a){this.Jd=a;this.s=393216;this.A=0},ds.prototype.J=function(a,b){return new ds(b)},ds.prototype.I=function(){return this.Jd},ds.prototype.zb=$APP.Qc,ds.prototype.Ta=$APP.Qc,ds.prototype.Na=function(){return $APP.wl},ds.prototype.Oa=function(){return null},ds.prototype.Ma=function(a,b,c,d){var e=this,Df=$APP.vk(function(h){return $APP.Sk?$APP.Sk(h,d):Tk.call(null,h,d)},c);a=new $APP.vi(function(){return Gl(e,
b,Df,sk,d)});c=$APP.O(Df);var g=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof es)es=function(h,Wm,m,p,r,t,v,x,A){this.Jd=h;this.parent=Wm;this.N=m;this.children=p;this.options=r;this.form=t;this.schema=v;this.cache=x;this.dg=A;this.s=393216;this.A=0},es.prototype.J=function(h,Wm){return new es(this.Jd,this.parent,this.N,this.children,this.options,this.form,this.schema,this.cache,Wm)},es.prototype.I=function(){return this.dg},es.prototype.zb=$APP.Qc,es.prototype.wd=
function(){return Ds(this)},es.prototype.Ua=$APP.Qc,es.prototype.Ea=function(){return mk(this.schema)},es.prototype.Ra=function(){return $APP.pk(this.schema)},es.prototype.Ya=function(){return this.N},es.prototype.Va=function(){return new $APP.X(null,1,5,$APP.Z,[this.schema],null)},es.prototype.Wa=function(){return $APP.$b(this.form)},es.prototype.Qa=function(h,Wm){return nk(this.schema,Wm)},es.prototype.Xa=function(){return this.parent},es.prototype.td=$APP.Qc,es.prototype.vd=function(){return this.cache},
es.prototype.Pa=function(h,Wm,m){return $APP.vd.h(0,Wm)?this.schema:m},es.prototype.Lc=$APP.Qc,es.prototype.sd=function(){return this.schema},es.R=!0,es.P="malli.core/t_malli$core28671",es.S=function(h){return pc(h,"malli.core/t_malli$core28671")};return new es(this.Jd,e,b,Df,d,a,c,g,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},ds.R=!0,ds.P="malli.core/t_malli$core28668",ds.S=function(a){return pc(a,"malli.core/t_malli$core28668")};return new ds(new $APP.n(null,1,[$APP.Gk,yl],null))};
rB=function(){var a=new $APP.n(null,1,[Yl,!0],null);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof fs)fs=function(b,c){this.aa=b;this.Kd=c;this.s=393216;this.A=0},fs.prototype.J=function(b,c){return new fs(this.aa,c)},fs.prototype.I=function(){return this.Kd},fs.prototype.zb=$APP.Qc,fs.prototype.Ta=$APP.Qc,fs.prototype.Na=function(){return $APP.xq},fs.prototype.Oa=function(){return null},fs.prototype.Ma=function(b,c,d,e){var Df=$APP.Ef(c),g=$APP.R.h(Df,dA),h=this,Wm=dn(d,
this.aa,e);b=new $APP.vi(function(){return Hl(h,Df,Wm,e)});var m=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof gs)gs=function(p,r,t,v,x,A,E,M,U,W,ba,T,q,w){this.form=p;this.options=r;this.N=t;this.closed=v;this.children=x;this.Jc=A;this.parent=E;this.Bg=M;this.Kd=U;this.ib=W;this.cache=ba;this.Ff=T;this.aa=q;this.eg=w;this.s=393216;this.A=0},gs.prototype.J=function(p,r){return new gs(this.form,this.options,this.N,this.closed,this.children,this.Jc,this.parent,this.Bg,
this.Kd,this.ib,this.cache,this.Ff,this.aa,r)},gs.prototype.I=function(){return this.eg},gs.prototype.zb=$APP.Qc,gs.prototype.wd=function(){return zs(this,fj(this.Jc))},gs.prototype.Ua=$APP.Qc,gs.prototype.Ea=function(){var p=this,r=this,t=fj(r.Jc),v=function(){var A=$APP.vk(function(E){var M=$APP.Q(E,0,null),U=$APP.Q(E,1,null);U=$APP.Ef(U);U=$APP.R.h(U,$APP.pq);E=$APP.Q(E,2,null);var W=mk(E),ba=$APP.ce(U);return function(T){T=pe(T,M);return $APP.z(T)?(T=$APP.Ub(T),W.g?W.g(T):W.call(null,T)):ba}},
r.Va(null));return $APP.z(p.closed)?$APP.Qe.h(A,function(E){return $APP.tb(function(M,U){return $APP.ne(t,U)?M:kd(!1)},!0,$APP.Fh(E))}):A}(),x=de(v);return function(A){var E=$APP.Td(A);return E?x(A):E}},gs.prototype.Ra=function(){return this.options},gs.prototype.Ya=function(){return this.N},gs.prototype.Va=function(){return gj(this.Jc)},gs.prototype.Wa=function(){return $APP.$b(this.form)},gs.prototype.Qa=function(p,r){var t=this,v=this,x=fj(v.Jc),A=function(){var E=$APP.vk(function(M){var U=$APP.Q(M,
0,null),W=$APP.Q(M,1,null);W=$APP.Ef(W);var ba=$APP.R.h(W,$APP.pq);M=$APP.Q(M,2,null);var T=nk(M,$APP.Qe.h(r,U));return function(q,w,y){q=pe(q,U);return $APP.z(q)?(q=$APP.Ub(q),w=$APP.Qe.h(w,U),T.i?T.i(q,w,y):T.call(null,q,w,y)):$APP.ib(ba)?$APP.Qe.h(y,hj($APP.Qe.h(r,U),$APP.Qe.h(w,U),v,null,lr)):y}},v.Va(null));return $APP.z(t.closed)?$APP.Qe.h(E,function(M,U,W){return $APP.tb(function(ba,T){return $APP.ne(x,T)?ba:$APP.Qe.h(ba,hj($APP.Qe.h(r,T),$APP.Qe.h(U,T),v,null,mp))},W,$APP.Fh(M))}):E}();return function(E,
M,U){return $APP.Td(E)?$APP.tb(function(W,ba){return ba.i?ba.i(E,M,W):ba.call(null,E,M,W)},U,A):$APP.Qe.h(U,hj(r,M,v,E,El))}},gs.prototype.Xa=function(){return this.parent},gs.prototype.Bd=$APP.Qc,gs.prototype.Ad=function(){return ak(this.Jc)},gs.prototype.Ed=function(){return this.Jc},gs.prototype.td=$APP.Qc,gs.prototype.vd=function(){return this.cache},gs.prototype.Pa=function(p,r,t){return Qk(this,r,t)},gs.R=!0,gs.P="malli.core/t_malli$core28687",gs.S=function(p){return pc(p,"malli.core/t_malli$core28687")};
return new gs(b,e,Df,g,d,Wm,h,c,this.Kd,function(p,r){var t=fj($APP.gk(p)),v=function(){var x=$APP.vk(function(A){var E=$APP.Q(A,0,null),M=$APP.Q(A,1,null);M=$APP.Ef(M);var U=$APP.R.h(M,$APP.pq);A=$APP.Q(A,2,null);var W=r.g?r.g(A):r.call(null,A);return function(ba){var T=pe(ba,E);if($APP.z(T)){T=$APP.Ub(T);var q=W.g?W.g(T):W.call(null,T);return $APP.We(q,dj)?kd(q):q===T?ba:$APP.kg.i(ba,E,q)}return $APP.z(U)?ba:kd(dj)}},$APP.qk(p));return $APP.z(g)?$APP.Te(function(A){return $APP.tb(function(E,M){return $APP.ne(t,
M)?E:kd(kd(dj))},A,$APP.Fh(A))},x):x}();return function(x){return $APP.Td(x)?$APP.tb(function(A,E){return E.g?E.g(A):E.call(null,A)},x,v):dj}},m,Df,this.aa,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},fs.R=!0,fs.P="malli.core/t_malli$core28676",fs.S=function(b){return pc(b,"malli.core/t_malli$core28676")};return new fs(a,new $APP.n(null,1,[$APP.Gk,yl],null))};
uB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof hs)hs=function(a){this.Ld=a;this.s=393216;this.A=0},hs.prototype.J=function(a,b){return new hs(b)},hs.prototype.I=function(){return this.Ld},hs.prototype.zb=$APP.Qc,hs.prototype.Ta=$APP.Qc,hs.prototype.Na=function(){return $APP.$q},hs.prototype.Oa=function(){return null},hs.prototype.Ma=function(a,b,c,d){var e=$APP.Ef(b);a=$APP.R.h(e,$APP.Ck);var Df=$APP.R.h(e,$APP.Dk),g=this;tk($APP.$q,e,c,2,2);var h=$APP.vk(function(t){return $APP.Sk?
$APP.Sk(t,d):Tk.call(null,t,d)},c),Wm=$APP.Q(h,0,null),m=$APP.Q(h,1,null);c=new $APP.vi(function(){return Gl(g,e,h,sk,d)});var p=jl(),r=sl(a,Df);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof is)is=function(t,v,x,A,E,M,U,W,ba,T,q,w,y,B,C,D,F){this.form=t;this.options=v;this.Gf=x;this.Ld=A;this.N=E;this.children=M;this.min=U;this.se=W;this.parent=ba;this.ke=T;this.Pg=q;this.Eg=w;this.ib=y;this.cache=B;this.ob=C;this.max=D;this.fg=F;this.s=393216;this.A=0},is.prototype.J=
function(t,v){return new is(this.form,this.options,this.Gf,this.Ld,this.N,this.children,this.min,this.se,this.parent,this.ke,this.Pg,this.Eg,this.ib,this.cache,this.ob,this.max,v)},is.prototype.I=function(){return this.fg},is.prototype.zb=$APP.Qc,is.prototype.wd=function(){return ws(new $APP.n(null,3,[$APP.Gk,$APP.$q,$APP.UA,xs?xs(this.ke):rp.call(null,this.ke),$APP.Vl,xs?xs(this.se):rp.call(null,this.se)],null),this.N,this.options)},is.prototype.Ua=$APP.Qc,is.prototype.Ea=function(){var t=this,v=
mk(t.ke),x=mk(t.se);return function(A){var E=$APP.Td(A);return E?(E=t.ob.g?t.ob.g(A):t.ob.call(null,A),$APP.z(E)?De(function(M,U,W){M=v.g?v.g(U):v.call(null,U);W=$APP.z(M)?x.g?x.g(W):x.call(null,W):M;return $APP.z(W)?W:kd(!1)},!0,A):E):E}},is.prototype.Ra=function(){return this.options},is.prototype.Ya=function(){return this.N},is.prototype.Va=function(){return this.children},is.prototype.Wa=function(){return $APP.$b(this.form)},is.prototype.Qa=function(t,v){var x=this,A=this,E=nk(x.ke,$APP.Qe.h(v,
0)),M=nk(x.se,$APP.Qe.h(v,1));return function(U,W,ba){return $APP.Td(U)?$APP.ib(x.ob.g?x.ob.g(U):x.ob.call(null,U))?$APP.Qe.h(ba,hj(v,W,A,U,BA)):De(function(T,q,w){var y=$APP.Qe.h(W,q);T=E.i?E.i(q,y,T):E.call(null,q,y,T);return M.i?M.i(w,y,T):M.call(null,w,y,T)},ba,U):$APP.Qe.h(ba,hj(v,W,A,U,El))}},is.prototype.Xa=function(){return this.parent},is.prototype.td=$APP.Qc,is.prototype.vd=function(){return this.cache},is.prototype.Pa=function(t,v,x){return $APP.R.i(this.children,v,x)},is.R=!0,is.P="malli.core/t_malli$core28734",
is.S=function(t){return pc(t,"malli.core/t_malli$core28734")};return new is(c,d,e,this.Ld,e,h,a,m,g,Wm,h,b,function(t){var v=t.g?t.g(Wm):t.call(null,Wm),x=t.g?t.g(m):t.call(null,m);return function(A){return $APP.Td(A)?De(function(E,M,U){M=v.g?v.g(M):v.call(null,M);U=x.g?x.g(U):x.call(null,U);return $APP.We(M,dj)||$APP.We(U,dj)?kd(dj):$APP.kg.i(E,M,U)},$APP.Fd(A),A):dj}},p,r,Df,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},hs.R=!0,hs.P="malli.core/t_malli$core28722",hs.S=function(a){return pc(a,"malli.core/t_malli$core28722")};
return new hs(new $APP.n(null,1,[$APP.Gk,yl],null))};
xB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof js)js=function(a){this.Pd=a;this.s=393216;this.A=0},js.prototype.J=function(a,b){return new js(b)},js.prototype.I=function(){return this.Pd},js.prototype.Ta=$APP.Qc,js.prototype.Na=function(){return $APP.dB},js.prototype.Oa=function(){return null},js.prototype.Ma=function(a,b,c,d){var e=this,Df=$APP.vk(function(h){return $APP.Sk?$APP.Sk(h,d):Tk.call(null,h,d)},c);a=new $APP.vi(function(){return Gl(e,b,Df,sk,d)});
var g=$APP.ud(Df);c=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof ks)ks=function(h,Wm,m,p,r,t,v,x,A,E){this.form=h;this.options=Wm;this.Pd=m;this.N=p;this.children=r;this.parent=t;this.size=v;this.ib=x;this.cache=A;this.jg=E;this.s=393216;this.A=0},ks.prototype.J=function(h,Wm){return new ks(this.form,this.options,this.Pd,this.N,this.children,this.parent,this.size,this.ib,this.cache,Wm)},ks.prototype.I=function(){return this.jg},ks.prototype.Ua=$APP.Qc,ks.prototype.Ea=
function(){var h=this,Wm=$APP.hg.h($APP.Jf,$APP.Vf($APP.Sf,$APP.on.h(mk,h.children)));return function(m){var p=$APP.Vd(m);return p?(p=$APP.vd.h($APP.ud(m),h.size))?De(function(r,t,v){t=$APP.wd(m,t);v=v.g?v.g(t):v.call(null,t);return $APP.z(v)?r:kd(!1)},!0,Wm):p:p}},ks.prototype.Ra=function(){return this.options},ks.prototype.Ya=function(){return this.N},ks.prototype.Va=function(){return this.children},ks.prototype.Wa=function(){return $APP.$b(this.form)},ks.prototype.Qa=function(h,Wm){var m=this,
p=this,r=$APP.vk(function(t){var v=$APP.Q(t,0,null);t=$APP.Q(t,1,null);return nk(t,$APP.Qe.h(Wm,v))},$APP.Vf($APP.Sf,m.children));return function(t,v,x){if($APP.Vd(t)){if($APP.Kh.h($APP.ud(t),m.size))return $APP.Qe.h(x,hj(Wm,v,p,t,Kz));var A=$APP.J(t);$APP.O(A);$APP.P(A);A=$APP.J(r);$APP.O(A);$APP.P(A);A=0;for(var E=t,M=r;;){t=x;x=A;E=$APP.J(E);A=$APP.O(E);var U=$APP.P(E);E=A;A=U;U=$APP.J(M);M=$APP.O(U);var W=$APP.P(U);U=M;M=W;W=$APP.Qe.h(v,x);t=U.i?U.i(E,W,t):U.call(null,E,W,t);if(A)E=x+1,U=A,x=
t,A=E,E=U;else return t}}else return $APP.Qe.h(x,hj(Wm,v,p,t,El))}},ks.prototype.Xa=function(){return this.parent},ks.prototype.td=$APP.Qc,ks.prototype.vd=function(){return this.cache},ks.prototype.Pa=function(h,Wm,m){return $APP.R.i(this.children,Wm,m)},ks.R=!0,ks.P="malli.core/t_malli$core28774",ks.S=function(h){return pc(h,"malli.core/t_malli$core28774")};return new ks(a,d,this.Pd,b,Df,e,g,function(h){var Wm=$APP.hg.i($APP.Jf,$APP.No.h($APP.ig.g(h),Uf()),Df);return function(m){return $APP.Vd(m)?
$APP.Kh.h($APP.ud(m),g)?dj:De(function(p,r,t){var v=$APP.R.h(p,r);t=t.g?t.g(v):t.call(null,v);return $APP.We(t,dj)?kd(t):t===v?p:$APP.kg.i(p,r,t)},m,Wm):dj}},c,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},js.R=!0,js.P="malli.core/t_malli$core28771",js.S=function(a){return pc(a,"malli.core/t_malli$core28771")};return new js(new $APP.n(null,1,[$APP.Gk,yl],null))};
AB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof ls)ls=function(a){this.Qd=a;this.s=393216;this.A=0},ls.prototype.J=function(a,b){return new ls(b)},ls.prototype.I=function(){return this.Qd},ls.prototype.zb=$APP.Qc,ls.prototype.Ta=$APP.Qc,ls.prototype.Na=function(){return $APP.dr},ls.prototype.Oa=function(){return null},ls.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.dr,b,c,1,null);var Df=$APP.Cg(c);a=$APP.Rh(Df);c=new $APP.vi(function(){return Gl(e,b,Df,
$APP.Ee,d)});var g=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof ps)ps=function(h,Wm,m,p,r,t,v,x,A){this.Qd=h;this.parent=Wm;this.N=m;this.children=p;this.options=r;this.schema=t;this.form=v;this.cache=x;this.kg=A;this.s=393216;this.A=0},ps.prototype.J=function(h,Wm){return new ps(this.Qd,this.parent,this.N,this.children,this.options,this.schema,this.form,this.cache,Wm)},ps.prototype.I=function(){return this.kg},ps.prototype.zb=$APP.Qc,ps.prototype.wd=function(){return new $APP.n(null,
2,[$APP.Gk,$APP.dr,$APP.Fy,this.children],null)},ps.prototype.Ua=$APP.Qc,ps.prototype.Ea=function(){var h=this;return function(Wm){return $APP.ne(h.schema,Wm)}},ps.prototype.Ra=function(){return this.options},ps.prototype.Ya=function(){return this.N},ps.prototype.Va=function(){return this.children},ps.prototype.Wa=function(){return $APP.$b(this.form)},ps.prototype.Qa=function(h,Wm){var m=this,p=m.Ea(null);return function(r,t,v){return $APP.ib(p.g?p.g(r):p.call(null,r))?$APP.Qe.h(v,mb(Wm,t,m,r)):v}},
ps.prototype.Xa=function(){return this.parent},ps.prototype.td=$APP.Qc,ps.prototype.vd=function(){return this.cache},ps.prototype.Pa=function(h,Wm,m){return $APP.R.i(this.children,Wm,m)},ps.R=!0,ps.P="malli.core/t_malli$core28813",ps.S=function(h){return pc(h,"malli.core/t_malli$core28813")};return new ps(this.Qd,e,b,Df,d,a,c,g,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},ls.R=!0,ls.P="malli.core/t_malli$core28810",ls.S=function(a){return pc(a,"malli.core/t_malli$core28810")};return new ls(new $APP.n(null,
1,[$APP.Gk,yl],null))};
Cl=function(a){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof qs)qs=function(b,c){this.Pc=b;this.Rd=c;this.s=393216;this.A=0},qs.prototype.J=function(b,c){return new qs(this.Pc,c)},qs.prototype.I=function(){return this.Rd},qs.prototype.zb=$APP.Qc,qs.prototype.Ta=$APP.Qc,qs.prototype.Na=function(){return $APP.Al},qs.prototype.Oa=function(){return null},qs.prototype.Ma=function(b,c,d,e){var Df=this;b=$APP.Q(d,0,null);var g=this;tk($APP.Al,c,d,1,1);var h=$APP.Cg(d),Wm=ei(b),
m=new $APP.vi(function(){return $APP.z(Df.Pc)?Wm:Gl(g,c,h,$APP.Ee,e)}),p=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof rs)rs=function(r,t,v,x,A,E,M,U,W,ba,T,q,w){this.form=r;this.options=t;this.sb=v;this.N=x;this.Rd=A;this.children=E;this.parent=M;this.re=U;this.Pc=W;this.fh=ba;this.Jg=T;this.cache=q;this.lg=w;this.s=393216;this.A=0},rs.prototype.J=function(r,t){return new rs(this.form,this.options,this.sb,this.N,this.Rd,this.children,this.parent,this.re,this.Pc,this.fh,
this.Jg,this.cache,t)},rs.prototype.I=function(){return this.lg},rs.prototype.zb=$APP.Qc,rs.prototype.wd=function(){return Hs(this)},rs.prototype.Ua=$APP.Qc,rs.prototype.Ea=function(){var r=this;return Bk(function(t){return di(r.re,t)})},rs.prototype.Ra=function(){return this.options},rs.prototype.Ya=function(){return this.N},rs.prototype.Va=function(){return this.children},rs.prototype.Wa=function(){return $APP.$b(this.form)},rs.prototype.Qa=function(r,t){var v=this,x=this;return function(A,E,M){try{return $APP.ib(di(v.re,
A))?$APP.Qe.h(M,mb(t,E,x,A)):M}catch(U){if(U instanceof Error)return $APP.Qe.h(M,hj(t,E,x,A,$APP.Gk.g(U instanceof $APP.Wi?U.data:null)));throw U;}}},rs.prototype.Xa=function(){return this.parent},rs.prototype.td=$APP.Qc,rs.prototype.vd=function(){return this.cache},rs.prototype.Pa=function(r,t,v){return $APP.R.i(this.children,t,v)},rs.R=!0,rs.P="malli.core/t_malli$core28824",rs.S=function(r){return pc(r,"malli.core/t_malli$core28824")};return new rs(m,e,b,c,Df.Rd,h,g,Wm,Df.Pc,d,d,p,new $APP.n(null,
1,[$APP.Gk,$APP.Om],null))},qs.R=!0,qs.P="malli.core/t_malli$core28817",qs.S=function(b){return pc(b,"malli.core/t_malli$core28817")};return new qs(a,new $APP.n(null,1,[$APP.Gk,yl],null))};
FB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof ss)ss=function(a){this.Ud=a;this.s=393216;this.A=0},ss.prototype.J=function(a,b){return new ss(b)},ss.prototype.I=function(){return this.Ud},ss.prototype.zb=$APP.Qc,ss.prototype.Ta=$APP.Qc,ss.prototype.Na=function(){return $APP.OA},ss.prototype.Oa=function(){return null},ss.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.OA,b,c,1,1);var Df=$APP.Cg(c);a=function(){var h=$APP.O(Df);return $APP.Zl?$APP.Zl(h,d):
$l.call(null,h,d)}();c=new $APP.vi(function(){return Gl(e,b,Df,$APP.Ee,d)});var g=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof us)us=function(h,Wm,m,p,r,t,v,x,A){this.Ud=h;this.parent=Wm;this.N=m;this.children=p;this.options=r;this.f=t;this.form=v;this.cache=x;this.mg=A;this.s=393216;this.A=0},us.prototype.J=function(h,Wm){return new us(this.Ud,this.parent,this.N,this.children,this.options,this.f,this.form,this.cache,Wm)},us.prototype.I=function(){return this.mg},
us.prototype.zb=$APP.Qc,us.prototype.wd=function(){return Hs(this)},us.prototype.Ua=$APP.Qc,us.prototype.Ea=function(){return Bk(this.f)},us.prototype.Ra=function(){return this.options},us.prototype.Ya=function(){return this.N},us.prototype.Va=function(){return this.children},us.prototype.Wa=function(){return $APP.$b(this.form)},us.prototype.Qa=function(h,Wm){var m=this,p=this;return function(r,t,v){try{return $APP.ib(m.f.g?m.f.g(r):m.f.call(null,r))?$APP.Qe.h(v,mb(Wm,t,p,r)):v}catch(x){if(x instanceof
Error)return $APP.Qe.h(v,hj(Wm,t,p,r,$APP.Gk.g(x instanceof $APP.Wi?x.data:null)));throw x;}}},us.prototype.Xa=function(){return this.parent},us.prototype.td=$APP.Qc,us.prototype.vd=function(){return this.cache},us.prototype.Pa=function(h,Wm,m){return $APP.R.i(this.children,Wm,m)},us.R=!0,us.P="malli.core/t_malli$core28833",us.S=function(h){return pc(h,"malli.core/t_malli$core28833")};return new us(this.Ud,e,b,Df,d,a,c,g,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},ss.R=!0,ss.P="malli.core/t_malli$core28828",
ss.S=function(a){return pc(a,"malli.core/t_malli$core28828")};return new ss(new $APP.n(null,1,[$APP.Gk,yl],null))};
IB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof vs)vs=function(a){this.Vd=a;this.s=393216;this.A=0},vs.prototype.J=function(a,b){return new vs(b)},vs.prototype.I=function(){return this.Vd},vs.prototype.zb=$APP.Qc,vs.prototype.Ta=$APP.Qc,vs.prototype.Na=function(){return $APP.mz},vs.prototype.Oa=function(){return null},vs.prototype.Ma=function(a,b,c,d){var e=this;tk($APP.mz,b,c,1,1);var Df=$APP.vk(function(h){return $APP.Sk?$APP.Sk(h,d):Tk.call(null,h,d)},c),
g=$APP.Q(Df,0,null);a=new $APP.vi(function(){return Gl(e,b,Df,sk,d)});c=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof eB)eB=function(h,Wm,m,p,r,t,v,x,A,E,M){this.Vd=h;this.form=Wm;this.options=m;this.N=p;this.schema=r;this.children=t;this.parent=v;this.gh=x;this.ib=A;this.cache=E;this.ng=M;this.s=393216;this.A=0},eB.prototype.J=function(h,Wm){return new eB(this.Vd,this.form,this.options,this.N,this.schema,this.children,this.parent,this.gh,this.ib,this.cache,Wm)},eB.prototype.I=
function(){return this.ng},eB.prototype.zb=$APP.Qc,eB.prototype.wd=function(){return Ds(this)},eB.prototype.Ua=$APP.Qc,eB.prototype.Ea=function(){var h=mk(this.schema);return function(Wm){var m=null==Wm;return m?m:h.g?h.g(Wm):h.call(null,Wm)}},eB.prototype.Ra=function(){return this.options},eB.prototype.Ya=function(){return this.N},eB.prototype.Va=function(){return this.children},eB.prototype.Wa=function(){return $APP.$b(this.form)},eB.prototype.Qa=function(h,Wm){var m=nk(this.schema,$APP.Qe.h(Wm,
0));return function(p,r,t){return null==p?t:m.i?m.i(p,r,t):m.call(null,p,r,t)}},eB.prototype.Xa=function(){return this.parent},eB.prototype.td=$APP.Qc,eB.prototype.vd=function(){return this.cache},eB.prototype.Pa=function(h,Wm,m){return $APP.vd.h(0,Wm)?this.schema:m},eB.R=!0,eB.P="malli.core/t_malli$core28844",eB.S=function(h){return pc(h,"malli.core/t_malli$core28844")};return new eB(this.Vd,a,d,b,g,Df,e,Df,function(h){var Wm=h.g?h.g(g):h.call(null,g);return function(m){return null==m?m:Wm.g?Wm.g(m):
Wm.call(null,m)}},c,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},vs.R=!0,vs.P="malli.core/t_malli$core28838",vs.S=function(a){return pc(a,"malli.core/t_malli$core28838")};return new vs(new $APP.n(null,1,[$APP.Gk,yl],null))};
LB=function(){var a=new $APP.n(null,1,[Yl,!0],null);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof ts)ts=function(b,c){this.aa=b;this.vg=c;this.s=393216;this.A=0},ts.prototype.J=function(b,c){return new ts(this.aa,c)},ts.prototype.I=function(){return this.vg},ts.prototype.zb=$APP.Qc,ts.prototype.Ta=$APP.Qc,ts.prototype.Na=function(){var b=$APP.Gk.g(this.aa);return $APP.z(b)?b:$APP.bz},ts.prototype.Oa=function(){return $APP.Um.g(this.aa)},ts.prototype.Ma=function(b,c,d,e){var Df=
this;b=$APP.Fk.j($APP.Bd([this.aa,Lh(c)]));var g=dn(d,b,e),h=new $APP.vi(function(){return Hl(Df,c,g,e)}),Wm=jl(),m=function(){var r=Iq.g(c);return $APP.Zl?$APP.Zl(r,e):$l.call(null,r,e)}(),p=new $APP.vi(function(){return $APP.hg.h($APP.Jf,ak(g))});$APP.z(m)||$APP.Ek.h(sz,new $APP.n(null,1,[$APP.UA,Iq],null));if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof fB)fB=function(r,t,v,x,A,E,M,U,W,ba,T,q,w,y){this.form=r;this.options=t;this.N=v;this.children=x;this.Jc=A;this.parent=
E;this.sg=M;this.Qb=U;this.cache=W;this.nc=ba;this.aa=T;this.Ee=q;this.vg=w;this.og=y;this.s=393216;this.A=0},fB.prototype.J=function(r,t){return new fB(this.form,this.options,this.N,this.children,this.Jc,this.parent,this.sg,this.Qb,this.cache,this.nc,this.aa,this.Ee,this.vg,t)},fB.prototype.I=function(){return this.og},fB.prototype.zb=$APP.Qc,fB.prototype.wd=function(){return zs(this,fj(this.Jc))},fB.prototype.Ua=$APP.Qc,fB.prototype.Ea=function(){var r=this,t=function(){var v=De(function(x,A,E){return $APP.kg.i(x,
A,mk(E))},$APP.Jf,$APP.$b(r.Ee));return r.nc.g?r.nc.g(v):r.nc.call(null,v)}();return function(v){var x=r.Qb.g?r.Qb.g(v):r.Qb.call(null,v);x=t.g?t.g(x):t.call(null,x);return $APP.z(x)?x.g?x.g(v):x.call(null,v):!1}},fB.prototype.Ra=function(){return this.options},fB.prototype.Ya=function(){return this.N},fB.prototype.Va=function(){return gj(this.Jc)},fB.prototype.Wa=function(){return $APP.$b(this.form)},fB.prototype.Qa=function(r,t){var v=this,x=this,A=function(){var M=$APP.tb(function(U,W){var ba=
$APP.Q(W,0,null);W=$APP.Q(W,1,null);return $APP.kg.i(U,ba,nk(W,$APP.Qe.h(t,ba)))},$APP.Jf,x.Ad(null));return v.nc.g?v.nc.g(M):v.nc.call(null,M)}(),E=v.Qb instanceof $APP.u?function(M){return $APP.Qe.h(M,v.Qb)}:$APP.Ee;return function(M,U,W){var ba=v.Qb.g?v.Qb.g(M):v.Qb.call(null,M);ba=A.g?A.g(ba):A.call(null,ba);return $APP.z(ba)?ba.i?ba.i(M,U,W):ba.call(null,M,U,W):$APP.Qe.h(W,hj(E.g?E.g(t):E.call(null,t),E.g?E.g(U):E.call(null,U),x,M,Bp))}},fB.prototype.Xa=function(){return this.parent},fB.prototype.Bd=
$APP.Qc,fB.prototype.Ad=function(){return ak(this.Jc)},fB.prototype.Ed=function(){return this.Jc},fB.prototype.td=$APP.Qc,fB.prototype.vd=function(){return this.cache},fB.prototype.Pa=function(r,t,v){return Qk(this,t,v)},fB.R=!0,fB.P="malli.core/t_malli$core28858",fB.S=function(r){return pc(r,"malli.core/t_malli$core28858")};return new fB(h,e,c,d,g,Df,b,m,Wm,function(r){var t=$APP.Ef(r),v=$APP.R.h(t,KA);return function(x){return t.h?t.h(x,v):t.call(null,x,v)}},this.aa,p,this.vg,new $APP.n(null,1,
[$APP.Gk,$APP.Om],null))},ts.R=!0,ts.P="malli.core/t_malli$core28851",ts.S=function(b){return pc(b,"malli.core/t_malli$core28851")};return new ts(a,new $APP.n(null,1,[$APP.Gk,yl],null))};Wk=function(a){switch(arguments.length){case 0:return Vk(null);case 1:return Vk(arguments[0]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
Vk=function(a){var b=$APP.Ef(a),c=$APP.R.h(b,qm),d=$APP.R.h(b,$APP.Um);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof hB)hB=function(e,Df,g,h,Wm){this.He=e;this.$=Df;this.ed=g;this.ld=h;this.Wd=Wm;this.s=393216;this.A=0},hB.prototype.J=function(e,Df){return new hB(this.He,this.$,this.ed,this.ld,Df)},hB.prototype.I=function(){return this.Wd},hB.prototype.zb=$APP.Qc,hB.prototype.Ta=$APP.Qc,hB.prototype.Na=function(){return $APP.Uk},hB.prototype.Oa=function(){return this.ld},
hB.prototype.Ma=function(e,Df,g,h){var Wm=this,m=$APP.Q(g,0,null),p=$APP.Ef(h),r=$APP.R.h(p,Em),t=this;tk($APP.Uk,Df,g,1,1);Mk(m)||$APP.Ek.h(bm,new $APP.n(null,1,[$APP.Uk,m],null));var v=function(){var E=function(){var M=Wm.ed;return $APP.z(M)?Ok(function(){var U=Xj(el(p),m);return $APP.Sk?$APP.Sk(U,p):Tk.call(null,U,p)}):M}();if($APP.z(E))return E;E=function(){var M=Xj(el(p),m);return $APP.z(M)?Ok(function(){return $APP.Sk?$APP.Sk(M,p):Tk.call(null,M,p)}):null}();return $APP.z(E)?E:$APP.z(r)?null:
$APP.Ek.h(bm,new $APP.n(null,2,[$APP.Gk,$APP.Uk,$APP.Uk,m],null))}(),x=$APP.Cg(g);e=new $APP.vi(function(){return Gl(t,Df,x,$APP.Ee,p)});var A=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Ks)Ks=function(E,M,U,W,ba,T,q,w,y,B,C,D,F,I,K,N,S,V,Y,ca){this.form=E;this.options=M;this.N=U;this.children=W;this.ld=ba;this.Lg=T;this.hh=q;this.parent=w;this.Jf=y;this.Kg=B;this.$=C;this.ref=D;this.ib=F;this.cache=I;this.ed=K;this.He=N;this.Wd=S;this.Ve=V;this.rb=Y;this.Re=ca;
this.s=393216;this.A=0},Ks.prototype.J=function(E,M){return new Ks(this.form,this.options,this.N,this.children,this.ld,this.Lg,this.hh,this.parent,this.Jf,this.Kg,this.$,this.ref,this.ib,this.cache,this.ed,this.He,this.Wd,this.Ve,this.rb,M)},Ks.prototype.I=function(){return this.Re},Ks.prototype.zb=$APP.Qc,Ks.prototype.wd=function(){return Hs(this)},Ks.prototype.Ua=$APP.Qc,Ks.prototype.Ea=function(){var E=this,M=Ok(function(){return mk(E.rb.l?E.rb.l():E.rb.call(null))});return function(U){var W=M();
return W.g?W.g(U):W.call(null,U)}},Ks.prototype.Ra=function(){return this.options},Ks.prototype.Ya=function(){return this.N},Ks.prototype.Va=function(){return this.children},Ks.prototype.Wa=function(){return $APP.$b(this.form)},Ks.prototype.Qa=function(E,M){var U=this,W=Ok(function(){return nk(U.rb.l?U.rb.l():U.rb.call(null),$APP.Qe.h(M,0))});return function(ba,T,q){var w=W();return w.i?w.i(ba,T,q):w.call(null,ba,T,q)}},Ks.prototype.Xa=function(){return this.parent},Ks.prototype.td=$APP.Qc,Ks.prototype.vd=
function(){return this.cache},Ks.prototype.Pa=function(E,M,U){return $APP.vd.h(M,0)?Lk(this.ref,this.rb.l?this.rb.l():this.rb.call(null),this.options):U},Ks.prototype.Lc=$APP.Qc,Ks.prototype.sd=function(){return this.rb.l?this.rb.l():this.rb.call(null)},Ks.prototype.hd=function(){return!1},Ks.prototype.jd=function(){return $APP.Ek.h($m,this)},Ks.prototype.fd=function(){return $APP.Ek.h($m,this)},Ks.prototype.gd=function(){return $APP.Ek.h($m,this)},Ks.R=!0,Ks.P="malli.core/t_malli$core28893",Ks.S=
function(E){return pc(E,"malli.core/t_malli$core28893")};return new Ks(e,p,Df,x,Wm.ld,h,g,t,p,g,Wm.$,m,function(E){var M=Ok(function(){var U=v.l?v.l():v.call(null);return E.g?E.g(U):E.call(null,U)});return function(U){var W=M();return W.g?W.g(U):W.call(null,U)}},A,Wm.ed,Wm.He,Wm.Wd,r,v,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},hB.R=!0,hB.P="malli.core/t_malli$core28880",hB.S=function(e){return pc(e,"malli.core/t_malli$core28880")};return new hB(a,b,c,d,new $APP.n(null,1,[$APP.Gk,yl],null))};
Kk=function(a){var b=$APP.Ef(a),c=$APP.R.h(b,Pl),d=$APP.R.h(b,Fl),e=$APP.z(c)?c:d,Df=$APP.z(e)?$APP.Om:$APP.Cm;if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof iB)iB=function(g,h,Wm,m,p,r,t){this.Oe=g;this.Wf=h;this.id=Wm;this.raw=m;this.yd=p;this.type=r;this.Xd=t;this.s=393216;this.A=0},iB.prototype.J=function(g,h){return new iB(this.Oe,this.Wf,this.id,this.raw,this.yd,this.type,h)},iB.prototype.I=function(){return this.Xd},iB.prototype.zb=$APP.Qc,iB.prototype.Ta=$APP.Qc,
iB.prototype.Na=function(){return this.type},iB.prototype.Oa=function(){return null},iB.prototype.Ma=function(g,h,Wm,m){var p=this,r=this;tk(p.type,h,Wm,1,1);var t=$APP.vk(function(x){return $APP.Sk?$APP.Sk(x,m):Tk.call(null,x,m)},Wm),v=$APP.wd(t,0);g=new $APP.vi(function(){var x=function(){var A=$APP.Od(h);if(A){A=p.id;if($APP.z(A))return A;A=p.raw;return $APP.z(A)?sk(v):A}return A}();return $APP.z(x)?x:Gl(r,h,t,sk,m)});Wm=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof Zu)Zu=
function(x,A,E,M,U,W,ba,T,q,w,y,B,C,D,F){this.form=x;this.options=A;this.sb=E;this.N=M;this.children=U;this.Wf=W;this.parent=ba;this.Xd=T;this.raw=q;this.type=w;this.yd=y;this.Oe=B;this.cache=C;this.id=D;this.wg=F;this.s=393216;this.A=0},Zu.prototype.J=function(x,A){return new Zu(this.form,this.options,this.sb,this.N,this.children,this.Wf,this.parent,this.Xd,this.raw,this.type,this.yd,this.Oe,this.cache,this.id,A)},Zu.prototype.I=function(){return this.wg},Zu.prototype.zb=$APP.Qc,Zu.prototype.wd=
function(){return $APP.z(this.id)?ws(new $APP.n(null,2,[$APP.Gk,this.type,$APP.Vl,this.id],null),this.N,this.Ra(null)):$APP.z(this.raw)?Hs(this):Ds(this)},Zu.prototype.Ua=$APP.Qc,Zu.prototype.Ea=function(){return mk(this.sb)},Zu.prototype.Ra=function(){return this.options},Zu.prototype.Ya=function(){return this.N},Zu.prototype.Va=function(){return this.children},Zu.prototype.Wa=function(){return $APP.$b(this.form)},Zu.prototype.Qa=function(x,A){return nk(this.sb,$APP.Qe.h(A,0))},Zu.prototype.Xa=function(){return this.parent},
Zu.prototype.td=$APP.Qc,Zu.prototype.vd=function(){return this.cache},Zu.prototype.Pa=function(x,A,E){return $APP.vd.h(A,0)?this.sb:E},Zu.prototype.Lc=$APP.Qc,Zu.prototype.sd=function(){return this.sb},Zu.prototype.hd=function(){return!1},Zu.prototype.jd=function(){return $APP.z(this.yd)?yk(this.sb):qj(mk(this.sb))},Zu.prototype.fd=function(x,A){return $APP.z(this.yd)?zk(this.sb,A):rj(A,this.sb,nk(this.sb,A))},Zu.prototype.gd=function(){return Ak(this.sb)},Zu.R=!0,Zu.P="malli.core/t_malli$core28906",
Zu.S=function(x){return pc(x,"malli.core/t_malli$core28906")};return new Zu(g,m,v,h,t,p.Wf,r,p.Xd,p.raw,p.type,p.yd,p.Oe,Wm,p.id,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},iB.R=!0,iB.P="malli.core/t_malli$core28902",iB.S=function(g){return pc(g,"malli.core/t_malli$core28902")};return new iB(a,b,c,d,e,Df,$APP.Jf)};
SB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof lB)lB=function(a){this.Yd=a;this.s=393216;this.A=0},lB.prototype.J=function(a,b){return new lB(b)},lB.prototype.I=function(){return this.Yd},lB.prototype.zb=$APP.Qc,lB.prototype.Ta=$APP.Qc,lB.prototype.Na=function(){return $APP.nl},lB.prototype.Oa=function(){return null},lB.prototype.Ma=function(a,b,c,d){var e=$APP.Ef(d),Df=$APP.R.h(e,Qz),g=this;tk($APP.nl,b,c,2,2);var h=$APP.vk(function(r){return $APP.Sk?$APP.Sk(r,
e):Tk.call(null,r,e)},c),Wm=$APP.Q(h,0,null);a=$APP.Q(h,1,null);c=new $APP.vi(function(){return Gl(g,b,h,sk,e)});var m=jl(),p=$APP.z(Df)?function(r){return Df.h?Df.h(r,e):Df.call(null,r,e)}:Qf(null);$APP.z(function(){var r=$APP.ml.g?$APP.ml.g(Wm):$APP.ml.call(null,Wm),t=new $APP.Nh(null,new $APP.n(null,2,[$APP.Uz,null,$APP.nA,null],null),null);return t.g?t.g(r):t.call(null,r)}())||$APP.Ek.h(cv,new $APP.n(null,1,[$APP.pl,Wm],null));if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===
typeof nB)nB=function(r,t,v,x,A,E,M,U,W,ba,T,q,w,y,B){this.form=r;this.input=t;this.options=v;this.N=x;this.children=A;this.parent=E;this.hb=M;this.Rf=U;this.ih=W;this.Kf=ba;this.Yd=T;this.ie=q;this.cache=w;this.Mg=y;this.pg=B;this.s=393216;this.A=0},nB.prototype.J=function(r,t){return new nB(this.form,this.input,this.options,this.N,this.children,this.parent,this.hb,this.Rf,this.ih,this.Kf,this.Yd,this.ie,this.cache,this.Mg,t)},nB.prototype.I=function(){return this.pg},nB.prototype.zb=$APP.Qc,nB.prototype.wd=
function(){var r=new $APP.n(null,3,[$APP.Gk,$APP.nl,$APP.pl,xs?xs(this.input):rp.call(null,this.input),$APP.Im,xs?xs(this.Rf):rp.call(null,this.Rf)],null);return $APP.z(this.N)?$APP.kg.i(r,Hk,this.N):r},nB.prototype.Ua=$APP.Qc,nB.prototype.Ea=function(){var r=this.hb.g?this.hb.g(this):this.hb.call(null,this);return $APP.z(r)?function(t){var v;if(v=ee(t))v=null==(r.g?r.g(t):r.call(null,t));return v}:ee},nB.prototype.Ra=function(){return this.options},nB.prototype.Ya=function(){return this.N},nB.prototype.Va=
function(){return this.children},nB.prototype.Wa=function(){return $APP.$b(this.form)},nB.prototype.Qa=function(r,t){var v=this,x=this.hb.g?this.hb.g(v):this.hb.call(null,v);if($APP.z(x))return function(E,M,U){if(Id(E)){var W=x.g?x.g(E):x.call(null,E);return $APP.z(W)?$APP.Qe.h(U,$APP.kg.i(mb(t,M,v,E),sq,W)):U}return $APP.Qe.h(U,mb(t,M,v,E))};var A=v.Ea(null);return function(E,M,U){return $APP.ib(A.g?A.g(E):A.call(null,E))?$APP.Qe.h(U,mb(t,M,v,E)):U}},nB.prototype.Xa=function(){return this.parent},
nB.prototype.td=$APP.Qc,nB.prototype.vd=function(){return this.cache},nB.prototype.Pa=function(r,t,v){return $APP.R.i(this.children,t,v)},nB.R=!0,nB.P="malli.core/t_malli$core28924",nB.S=function(r){return pc(r,"malli.core/t_malli$core28924")};return new nB(c,Wm,e,b,h,g,p,a,h,e,this.Yd,Df,m,d,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},lB.R=!0,lB.P="malli.core/t_malli$core28912",lB.S=function(a){return pc(a,"malli.core/t_malli$core28912")};return new lB(new $APP.n(null,1,[$APP.Gk,yl],null))};
YB=function(){if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof oB)oB=function(a,b){this.md=a;this.ue=b;this.s=393216;this.A=0},oB.prototype.J=function(a,b){return new oB(this.md,b)},oB.prototype.I=function(){return this.ue},oB.prototype.Ta=$APP.Qc,oB.prototype.Na=function(){return $APP.Vu},oB.prototype.Oa=function(){return null},oB.prototype.Ma=function(a,b,c,d){var e=$APP.Ef(d),Df=$APP.R.h(e,Qz),g=this;tk($APP.Vu,b,c,1,null);var h=$APP.vk(function(m){return $APP.Sk?$APP.Sk(m,
e):Tk.call(null,m,e)},c);a=new $APP.vi(function(){return Gl(g,b,h,sk,e)});c=jl();var Wm=$APP.z(Df)?function(m){return Df.h?Df.h(m,e):Df.call(null,m,e)}:Qf(null);$APP.Nf(function(m){return $APP.vd.h($APP.nl,$APP.ml.g?$APP.ml.g(m):$APP.ml.call(null,m))},h)||$APP.Ek.h(Hz,new $APP.n(null,1,[$APP.Ol,h],null));$APP.$k(Tb($APP.ql,h));if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof pB)pB=function(m,p,r,t,v,x,A,E,M,U,W,ba,T){this.form=m;this.options=p;this.N=r;this.Ng=t;this.children=
v;this.parent=x;this.md=A;this.Lf=E;this.hb=M;this.ie=U;this.ue=W;this.cache=ba;this.qg=T;this.s=393216;this.A=0},pB.prototype.J=function(m,p){return new pB(this.form,this.options,this.N,this.Ng,this.children,this.parent,this.md,this.Lf,this.hb,this.ie,this.ue,this.cache,p)},pB.prototype.I=function(){return this.qg},pB.prototype.Ua=$APP.Qc,pB.prototype.Ea=function(){var m=this.hb.g?this.hb.g(this):this.hb.call(null,this);return $APP.z(m)?function(p){var r;if(r=ee(p))r=null==(m.g?m.g(p):m.call(null,
p));return r}:ee},pB.prototype.Ra=function(){return this.options},pB.prototype.Ya=function(){return this.N},pB.prototype.Va=function(){return this.children},pB.prototype.Wa=function(){return $APP.$b(this.form)},pB.prototype.Qa=function(m,p){var r=this,t=this.hb.g?this.hb.g(r):this.hb.call(null,r);if($APP.z(t))return function(x,A,E){if(Id(x)){var M=t.g?t.g(x):t.call(null,x);return $APP.z(M)?$APP.Qe.h(E,$APP.kg.i(mb(p,A,r,x),sq,M)):E}return $APP.Qe.h(E,mb(p,A,r,x))};var v=r.Ea(null);return function(x,
A,E){return $APP.ib(v.g?v.g(x):v.call(null,x))?$APP.Qe.h(E,mb(p,A,r,x)):E}},pB.prototype.Xa=function(){return this.parent},pB.prototype.td=$APP.Qc,pB.prototype.vd=function(){return this.cache},pB.prototype.Pa=function(m,p,r){return $APP.R.i(this.children,p,r)},pB.R=!0,pB.P="malli.core/t_malli$core28936",pB.S=function(m){return pc(m,"malli.core/t_malli$core28936")};return new pB(a,e,b,d,h,g,this.md,e,Wm,Df,this.ue,c,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},oB.R=!0,oB.P="malli.core/t_malli$core28931",
oB.S=function(a){return pc(a,"malli.core/t_malli$core28931")};return new oB(null,new $APP.n(null,1,[$APP.Gk,yl],null))};
Nl=function(a){var b=$APP.Ef(a),c=$APP.R.h(b,Il);c=$APP.Ef(c);var d=$APP.R.h(c,$APP.Ck),e=$APP.R.h(c,$APP.Dk),Df=$APP.R.h(b,$APP.Gk),g=$APP.R.h(b,qB),h=$APP.R.h(b,hn),Wm=$APP.R.h(b,kn),m=$APP.R.h(b,Jl),p=$APP.R.h(b,mn),r=$APP.R.h(b,Kl);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof kB)kB=function(t,v,x,A,E,M,U,W,ba,T,q,w,y){this.ac=t;this.dc=v;this.mb=x;this.vf=A;this.lb=E;this.min=M;this.Tb=U;this.Vb=W;this.type=ba;this.Ub=T;this.max=q;this.nb=w;this.Af=y;this.s=393216;
this.A=0},kB.prototype.J=function(t,v){return new kB(this.ac,this.dc,this.mb,this.vf,this.lb,this.min,this.Tb,this.Vb,this.type,this.Ub,this.max,this.nb,v)},kB.prototype.I=function(){return this.Af},kB.prototype.Ta=$APP.Qc,kB.prototype.Na=function(){return this.type},kB.prototype.Oa=function(){return null},kB.prototype.Ma=function(t,v,x,A){var E=this;tk(this.type,v,x,this.min,this.max);var M=$APP.vk(function(U){return $APP.Sk?$APP.Sk(U,A):Tk.call(null,U,A)},x);t=new $APP.vi(function(){return Gl(E,
v,M,sk,A)});x=jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof sB)sB=function(U,W,ba,T,q,w,y,B,C,D,F,I,K,N,S,V,Y,ca,ea,ia){this.form=U;this.ac=W;this.options=ba;this.dc=T;this.mb=q;this.vf=w;this.N=y;this.lb=B;this.children=C;this.min=D;this.Tb=F;this.parent=I;this.Vb=K;this.type=N;this.cache=S;this.Ub=V;this.max=Y;this.Af=ca;this.nb=ea;this.rg=ia;this.s=393216;this.A=0},sB.prototype.J=function(U,W){return new sB(this.form,this.ac,this.options,this.dc,this.mb,this.vf,
this.N,this.lb,this.children,this.min,this.Tb,this.parent,this.Vb,this.type,this.cache,this.Ub,this.max,this.Af,this.nb,W)},sB.prototype.I=function(){return this.rg},sB.prototype.Ua=$APP.Qc,sB.prototype.Ea=function(){return Tj(yk(this))},sB.prototype.Ra=function(){return this.options},sB.prototype.Ya=function(){return this.N},sB.prototype.Va=function(){return this.children},sB.prototype.Wa=function(){return $APP.$b(this.form)},sB.prototype.Qa=function(U,W){return Vj(this,W,zk(this,W))},sB.prototype.Xa=
function(){return this.parent},sB.prototype.td=$APP.Qc,sB.prototype.vd=function(){return this.cache},sB.prototype.Pa=function(U,W,ba){return $APP.R.i(this.children,W,ba)},sB.prototype.hd=function(){return!0},sB.prototype.jd=function(){var U=this.N,W=Tb(yk,this.children);return this.nb.h?this.nb.h(U,W):this.nb.call(null,U,W)},sB.prototype.fd=function(U,W){U=this.N;var ba=$APP.Vf(function(T,q){return zk(q,$APP.Qe.h(W,T))},this.children);return this.lb.h?this.lb.h(U,ba):this.lb.call(null,U,ba)},sB.prototype.gd=
function(){return this.mb.h?this.mb.h(this.N,this.children):this.mb.call(null,this.N,this.children)},sB.R=!0,sB.P="malli.core/t_malli$core28947",sB.S=function(U){return pc(U,"malli.core/t_malli$core28947")};return new sB(t,this.ac,A,this.dc,this.mb,this.vf,v,this.lb,M,this.min,this.Tb,E,this.Vb,this.type,x,this.Ub,this.max,this.Af,this.nb,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},kB.R=!0,kB.P="malli.core/t_malli$core28944",kB.S=function(t){return pc(t,"malli.core/t_malli$core28944")};return new kB(b,
c,r,a,h,d,Wm,m,Df,p,e,g,new $APP.n(null,1,[$APP.Gk,yl],null))};
Ql=function(a){var b=$APP.Ef(a),c=$APP.R.h(b,Il);c=$APP.Ef(c);var d=$APP.R.h(c,$APP.Ck),e=$APP.R.h(c,$APP.Dk),Df=$APP.R.h(b,$APP.Gk),g=$APP.R.h(b,qB),h=$APP.R.h(b,hn),Wm=$APP.R.h(b,kn),m=$APP.R.h(b,Jl),p=$APP.R.h(b,mn),r=$APP.R.h(b,Kl);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof tB)tB=function(t,v,x,A,E,M,U,W,ba,T,q,w,y,B){this.Zc=t;this.mb=v;this.zf=x;this.wc=A;this.lb=E;this.min=M;this.Tb=U;this.Vb=W;this.type=ba;this.Ub=T;this.max=q;this.aa=w;this.nb=y;this.Ge=B;this.s=
393216;this.A=0},tB.prototype.J=function(t,v){return new tB(this.Zc,this.mb,this.zf,this.wc,this.lb,this.min,this.Tb,this.Vb,this.type,this.Ub,this.max,this.aa,this.nb,v)},tB.prototype.I=function(){return this.Ge},tB.prototype.zb=$APP.Qc,tB.prototype.Ta=$APP.Qc,tB.prototype.Na=function(){return this.type},tB.prototype.Oa=function(){return null},tB.prototype.Ma=function(t,v,x,A){var E=this;tk(this.type,v,x,this.min,this.max);var M=dn(x,this.aa,A);t=new $APP.vi(function(){return Hl(E,v,M,A)});var U=
jl();if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof zB)zB=function(W,ba,T,q,w,y,B,C,D,F,I,K,N,S,V,Y,ca,ea,ia,la,ra,Ca){this.form=W;this.Zc=ba;this.Ge=T;this.options=q;this.mb=w;this.zf=y;this.wc=B;this.N=C;this.lb=D;this.children=F;this.min=I;this.Tb=K;this.Jc=N;this.parent=S;this.Vb=V;this.type=Y;this.cache=ca;this.Ub=ea;this.max=ia;this.aa=la;this.nb=ra;this.tg=Ca;this.s=393216;this.A=0},zB.prototype.J=function(W,ba){return new zB(this.form,this.Zc,this.Ge,this.options,
this.mb,this.zf,this.wc,this.N,this.lb,this.children,this.min,this.Tb,this.Jc,this.parent,this.Vb,this.type,this.cache,this.Ub,this.max,this.aa,this.nb,ba)},zB.prototype.I=function(){return this.tg},zB.prototype.zb=$APP.Qc,zB.prototype.wd=function(){return zs(this,fj(this.Jc))},zB.prototype.Ua=$APP.Qc,zB.prototype.Ea=function(){return Tj(yk(this))},zB.prototype.Ra=function(){return this.options},zB.prototype.Ya=function(){return this.N},zB.prototype.Va=function(){return gj(this.Jc)},zB.prototype.Wa=
function(){return $APP.$b(this.form)},zB.prototype.Qa=function(W,ba){return Vj(this,ba,zk(this,ba))},zB.prototype.Xa=function(){return this.parent},zB.prototype.td=$APP.Qc,zB.prototype.vd=function(){return this.cache},zB.prototype.Pa=function(W,ba,T){return Qk(this,ba,T)},zB.prototype.Bd=$APP.Qc,zB.prototype.Ad=function(){return ak(this.Jc)},zB.prototype.Ed=function(){return this.Jc},zB.prototype.hd=function(){return!0},zB.prototype.jd=function(){var W=this.N,ba=$APP.vk(function(T){var q=$APP.Q(T,
0,null);$APP.Q(T,1,null);T=$APP.Q(T,2,null);return new $APP.X(null,2,5,$APP.Z,[q,yk(T)],null)},this.Va(null));return this.nb.h?this.nb.h(W,ba):this.nb.call(null,W,ba)},zB.prototype.fd=function(W,ba){W=this.N;var T=$APP.vk(function(q){var w=$APP.Q(q,0,null);$APP.Q(q,1,null);q=$APP.Q(q,2,null);return new $APP.X(null,2,5,$APP.Z,[w,zk(q,$APP.Qe.h(ba,w))],null)},this.Va(null));return this.lb.h?this.lb.h(W,T):this.lb.call(null,W,T)},zB.prototype.gd=function(){var W=this.N,ba=this.Va(null);return this.mb.h?
this.mb.h(W,ba):this.mb.call(null,W,ba)},zB.R=!0,zB.P="malli.core/t_malli$core28966",zB.S=function(W){return pc(W,"malli.core/t_malli$core28966")};return new zB(t,this.Zc,this.Ge,A,this.mb,this.zf,this.wc,v,this.lb,x,this.min,this.Tb,M,E,this.Vb,this.type,U,this.Ub,this.max,this.aa,this.nb,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},tB.R=!0,tB.P="malli.core/t_malli$core28963",tB.S=function(t){return pc(t,"malli.core/t_malli$core28963")};return new tB(c,r,a,b,h,d,Wm,m,Df,p,e,b,g,new $APP.n(null,1,
[$APP.Gk,yl],null))};hl=function(a){return null!=a?$APP.Qc===a.Ta?!0:!1:!1};$APP.Rl=function(a,b,c,d){var e=$APP.z(b)?0<$APP.ud(b)?b:null:null,Df=$APP.z(e)?e.g?e.g(cl):e.call(null,cl):null;b=$APP.z(Df)?Nk(d,function(g){return ek($APP.Bd([Df,$APP.z(g)?g:el(d)]))}):d;e=$APP.z(Df)?$APP.kg.i(e,cl,kl(Df,b,$APP.Ee)):e;return $APP.kk(gl(a,hl,b),e,c,b)};$APP.Sl=function(a){return jk($APP.rk($APP.Sk?$APP.Sk(a,null):Tk.call(null,a,null)))};
Tk=function(a){switch(arguments.length){case 1:return $APP.Sk(arguments[0],null);case 2:return $APP.Sk(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
$APP.Sk=function(a,b){for(;;){if(null!=a&&$APP.Qc===a.Ua)return a;if(hl(a))return $APP.kk(a,null,null,b);if($APP.Vd(a)){var c=a,d=$APP.wd(c,0),e=$APP.ud(c);c=1<e?$APP.wd(c,1):null;return null==c||$APP.Td(c)?$APP.Rl(d,c,2<e?$APP.Ig(null,a,2,e|0,null):null,b):$APP.Rl(d,null,1<e?$APP.Ig(null,a,1,e|0,null):null,b)}d=(d=Mk(a))?fl(a,b):d;if($APP.z(d))return Lk(a,$APP.Sk(d,b),b);a=gl(a,null,b)}};$APP.Ul=function(a,b,c){a=$APP.Tl.h(a,c);return a.g?a.g(b):a.call(null,b)};
$APP.Wl=function(a,b){var c=$APP.Sk(a,b),d=$APP.ll(c,MC,function(e){return nk(e,$APP.fg)});return function(){function e(h,Wm,m){return(Wm=$APP.J(d.i?d.i(h,Wm,m):d.call(null,h,Wm,m)))?new $APP.n(null,3,[$APP.Cm,c,$APP.Vl,h,Sn,Wm],null):null}function Df(h){return g.i(h,$APP.fg,$APP.fg)}var g=null;g=function(h,Wm,m){switch(arguments.length){case 1:return Df.call(this,h);case 3:return e.call(this,h,Wm,m)}throw Error("Invalid arity: "+arguments.length);};g.g=Df;g.i=e;return g}()};
rp=function(a){switch(arguments.length){case 1:return xs(arguments[0]);case 2:return Oo(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};xs=function(a){return Oo(a,null)};Oo=function(a,b){var c=$APP.Sk(a,b);if(null!=c&&$APP.Qc===c.zb)return cj(c,b);var d=$APP.qk(c);return ws(function(){var e=new $APP.n(null,1,[$APP.Gk,$APP.ml.g(c)],null);return $APP.z(d)?$APP.kg.i(e,$APP.Ol,$APP.vk(function(Df){return Oo(Df,b)},d)):e}(),$APP.ok(c),$APP.pk(c))};
BB=function(a){return $APP.Ek.h(wo,new $APP.n(null,1,[Xl,a],null))};$l=function(a){switch(arguments.length){case 1:return $APP.Zl(arguments[0],null);case 2:return $APP.Zl(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
$APP.Zl=function(a,b){if($APP.Vd(a))return a;if(a instanceof $APP.H||"string"===typeof a||$APP.Sd(a)){if($APP.z(zo.g(b)))return BB(a);b=am.g(b);b=CB($APP.z(b)?b:new $APP.n(null,3,[cm,gr,vB,new $APP.n(null,1,[wB,yB],null),ur,new $APP.n(null,1,[Jr,new $APP.n(null,4,[Kr,$APP.dm,Lr,$APP.ml,em,$APP.fm,gm,$APP.hm],null)],null)],null),BB);b=b.l?b.l():b.call(null);return b.g?b.g(a):b.call(null,a)}return a};
cD=function(){return $APP.tb(bl,$APP.Jf,yg([new Wc(function(){return $APP.nb},TA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Ty,"cljs/core.cljs",11,1,283,283,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if given any argument.",$APP.z($APP.nb)?$APP.nb.U:null])),new Wc(function(){return $APP.jb},LA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,Vp,"cljs/core.cljs",21,1,262,262,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is not nil, false otherwise.",
$APP.jb?$APP.jb.U:null])),new Wc(function(){return $APP.hb},fy,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,iz,"cljs/core.cljs",23,1,249,249,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is a JavaScript number.",$APP.hb?$APP.hb.U:null])),new Wc(function(){return $APP.fe},ep,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,$APP.nq,"cljs/core.cljs",15,1,2280,2280,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[dy],null)),"Returns true if n is a JavaScript number with no decimal part.",
$APP.z($APP.fe)?$APP.fe.U:null])),new Wc(function(){return $APP.ge},Mq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,$APP.Cp,"cljs/core.cljs",11,1,2292,2292,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.",$APP.z($APP.ge)?$APP.ge.U:null])),new Wc(function(){return $APP.he},yy,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,$APP.Tu,"cljs/core.cljs",15,1,2300,2300,$APP.Ko(new $APP.X(null,1,5,$APP.Z,
[ev],null)),"Return true if x satisfies int? and is positive.",$APP.z($APP.he)?$APP.he.U:null])),new Wc(function(){return $APP.ie},wz,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,$APP.nz,"cljs/core.cljs",24,1,2316,2316,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x satisfies int? and is negative.",$APP.ie?$APP.ie.U:null])),new Wc(function(){return $APP.je},vA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,$APP.Mu,"cljs/core.cljs",15,1,2330,2330,$APP.Ko(new $APP.X(null,
1,5,$APP.Z,[ev],null)),"Return true if x satisfies int? and is a natural integer value.",$APP.z($APP.je)?$APP.je.U:null])),new Wc(function(){return $APP.Je},IA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,$APP.Qu,"cljs/core.cljs",20,1,2970,2970,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if num is greater than zero, else false",$APP.Je?$APP.Je.U:null])),new Wc(function(){return $APP.Le},Sp,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,$APP.uA,"cljs/core.cljs",20,1,
2979,2979,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if num is less than zero, else false",$APP.Le?$APP.Le.U:null])),new Wc(function(){return $APP.ke},cA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,np,"cljs/core.cljs",13,1,2345,2345,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true for JavaScript numbers, false otherwise.",$APP.z($APP.ke)?$APP.ke.U:null])),new Wc(function(){return $APP.le},Uq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Iz,"cljs/core.cljs",
14,1,2350,2350,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true for JavaScript numbers, false otherwise.",$APP.z($APP.le)?$APP.le.U:null])),new Wc(function(){return $APP.$d},vq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,$APP.DB,"cljs/core.cljs",15,1,2242,2242,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a Boolean",$APP.z($APP.$d)?$APP.$d.U:null])),new Wc(function(){return $APP.kb},Pu,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,$APP.vt,"cljs/core.cljs",
23,1,273,273,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is a JavaScript string.",$APP.kb?$APP.kb.U:null])),new Wc(function(){return $APP.Ye},yq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,GA,"cljs/core.cljs",13,1,3399,3399,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a symbol or keyword",$APP.z($APP.Ye)?$APP.Ye.U:null])),new Wc(function(){return $APP.Ze},kp,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Dp,"cljs/core.cljs",20,1,3403,3403,$APP.Ko(new $APP.X(null,
1,5,$APP.Z,[ev],null)),"Return true if x is a symbol or keyword without a namespace",$APP.z($APP.Ze)?$APP.Ze.U:null])),new Wc(function(){return $APP.$e},YA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Jz,"cljs/core.cljs",23,1,3407,3407,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a symbol or keyword with a namespace",$APP.z($APP.$e)?$APP.$e.U:null])),new Wc(function(){return $APP.Ve},qq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Zp,"cljs/core.cljs",15,1,3369,3369,
$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a Keyword",$APP.z($APP.Ve)?$APP.Ve.U:null])),new Wc(function(){return cf},aq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Sz,"cljs/core.cljs",22,1,3419,3419,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a keyword without a namespace",$APP.z(cf)?cf.U:null])),new Wc(function(){return $APP.df},fA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,oq,"cljs/core.cljs",25,1,3423,3423,$APP.Ko(new $APP.X(null,1,5,
$APP.Z,[ev],null)),"Return true if x is a keyword with a namespace",$APP.z($APP.df)?$APP.df.U:null])),new Wc(function(){return $APP.Tc},uq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,hq,"cljs/core.cljs",23,1,1051,1051,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a Symbol",$APP.Tc?$APP.Tc.U:null])),new Wc(function(){return af},Fu,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Up,"cljs/core.cljs",21,1,3411,3411,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a symbol without a namespace",
$APP.z(af)?af.U:null])),new Wc(function(){return $APP.bf},Bq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,gq,"cljs/core.cljs",24,1,3415,3415,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a symbol with a namespace",$APP.z($APP.bf)?$APP.bf.U:null])),new Wc(function(){return $APP.Vi},JA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,pp,"cljs/core.cljs",12,1,11604,11604,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x is a UUID.",$APP.z($APP.Vi)?$APP.Vi.U:null])),
new Wc(function(){return $APP.aj},jr,$APP.Bh([wq,Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],["1.9",bp,Op,"cljs/core.cljs",11,1,12022,12022,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true x is a goog.Uri instance.",$APP.z($APP.aj)?$APP.aj.U:null])),new Wc(function(){return $APP.id},fq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Np,"cljs/core.cljs",12,1,1417,1417,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x satisfies Inst",$APP.z($APP.id)?$APP.id.U:null])),new Wc(function(){return $APP.be},
bv,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Wq,"cljs/core.cljs",15,1,2258,2258,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[dv],null)),"Return true if the seq function is supported for s",$APP.z($APP.be)?$APP.be.U:null])),new Wc(function(){return $APP.td},yz,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Pp,"cljs/core.cljs",15,1,1540,1540,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if coll implements nth in constant time",$APP.z($APP.td)?$APP.td.U:null])),new Wc(function(){return $APP.Td},
Vy,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,QA,"cljs/core.cljs",11,1,2172,2172,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x satisfies IMap",$APP.z($APP.Td)?$APP.Td.U:null])),new Wc(function(){return $APP.Vd},gA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,sA,"cljs/core.cljs",14,1,2184,2184,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Return true if x satisfies IVector",$APP.z($APP.Vd)?$APP.Vd.U:null])),new Wc(function(){return $APP.Oe},qA,$APP.Bh([Yo,Lq,xz,Ap,ir,
dp,op,fp,$APP.tq,zp],[bp,Mz,"cljs/core.cljs",12,1,3145,3145,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x implements IList",$APP.z($APP.Oe)?$APP.Oe.U:null])),new Wc(function(){return $APP.ae},Wz,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,ot,"cljs/core.cljs",11,1,2251,2251,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[dv],null)),"Return true if s satisfies ISeq",$APP.z($APP.ae)?$APP.ae.U:null])),new Wc(function(){return $APP.lb},Aq,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Cz,
"cljs/core.cljs",12,1,278,278,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is a JavaScript string of length one.",$APP.z($APP.lb)?$APP.lb.U:null])),new Wc(function(){return $APP.Qd},Ry,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Yp,"cljs/core.cljs",11,1,2145,2145,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x satisfies ISet",$APP.z($APP.Qd)?$APP.Qd.U:null])),new Wc(function(){return $APP.fb},kr,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,Dq,"cljs/core.cljs",
20,1,237,237,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is nil, false otherwise.",$APP.fb?$APP.fb.U:null])),new Wc(function(){return $APP.Yd},Yz,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,$APP.bB,"cljs/core.cljs",22,1,2234,2234,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is the value false, false otherwise.",$APP.Yd?$APP.Yd.U:null])),new Wc(function(){return $APP.Zd},rt,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,$APP.VA,"cljs/core.cljs",
21,1,2238,2238,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x is the value true, false otherwise.",$APP.Zd?$APP.Zd.U:null])),new Wc(function(){return $APP.Ke},tA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,Pz,fp,$APP.tq,zp],[bp,cr,"cljs/core.cljs",21,1,2974,2974,XA,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if num is zero, else false",$APP.Ke?$APP.Ke.U:null])),new Wc(function(){return $APP.Pd},lp,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,HA,"cljs/core.cljs",12,1,2138,
2138,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if x satisfies ICollection",$APP.z($APP.Pd)?$APP.Pd.U:null])),new $APP.X(null,2,5,$APP.Z,[new Wc(function(){return $APP.Od},ar,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Eq,"cljs/core.cljs",13,1,2132,2132,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[yA],null)),"Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))",$APP.z($APP.Od)?$APP.Od.U:null])),function(a){return $APP.be(a)&&
$APP.Od(a)}],null),new Wc(function(){return $APP.Rd},WA,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,av,"cljs/core.cljs",19,1,2152,2152,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if coll implements IAssociative",$APP.z($APP.Rd)?$APP.Rd.U:null])),new Wc(function(){return $APP.Sd},mr,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Lp,"cljs/core.cljs",18,1,2160,2160,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[ev],null)),"Returns true if coll satisfies ISequential",$APP.z($APP.Sd)?$APP.Sd.U:
null])),new Wc(function(){return ee},tr,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,$APP.oA,"cljs/core.cljs",11,1,2275,2275,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[iq],null)),"Returns true if f returns true for fn? or satisfies IFn.",$APP.z(ee)?ee.U:null])),new Wc(function(){return Id},br,$APP.Bh([Yo,Lq,xz,Ap,ir,dp,op,fp,$APP.tq,zp],[bp,Zq,"cljs/core.cljs",10,1,2029,2029,$APP.Ko(new $APP.X(null,1,5,$APP.Z,[iq],null)),"Return true if f is a JavaScript function or satisfies the Fn protocol.",$APP.z(Id)?
Id.U:null]))],!0))};fD=function(){return De($APP.kg,null,$APP.hg.h($APP.Jf,$APP.vk(function(a){var b=$APP.Q(a,0,null),c=$APP.Q(a,1,null);return new $APP.X(null,2,5,$APP.Z,[b,$APP.ms(function(d,e){var Df=$APP.Q(e,0,null);return new $APP.n(null,6,[$APP.Gk,b,$APP.mm,Bk(function(g){return c.h?c.h(g,Df):c.call(null,g,Df)}),dD,Fs,eD,Hs,$APP.Ck,1,$APP.Dk,1],null)})],null)},new $APP.n(null,6,[$APP.Oz,Io,$APP.pt,Jo,$APP.Xu,Go,$APP.Nu,Ho,$APP.wp,$APP.vd,$APP.RA,$APP.Kh],null))))};
gD=function(){return new $APP.n(null,8,[$APP.Jp,Nl(new $APP.n(null,8,[$APP.Gk,$APP.Jp,Il,new $APP.n(null,2,[$APP.Ck,1,$APP.Dk,1],null),qB,function(a,b){a=$APP.Q(b,0,null);return zj.j(a,$APP.Bd([Aj(a)]))},hn,function(a,b){a=$APP.Q(b,0,null);return Bj.j(a,$APP.Bd([Cj(a)]))},kn,function(a,b){a=$APP.Q(b,0,null);return Ij(a)},Jl,function(a,b){a=$APP.Q(b,0,null);return Jj(a)},mn,function(a,b){a=$APP.Q(b,0,null);return Fj.j(a,$APP.Bd([Gj(a)]))},Kl,function(a,b){a=$APP.Q(b,0,null);return new $APP.n(null,
1,[$APP.Ck,$APP.Ck.g(Ak(a))],null)}],null)),$APP.kz,Nl(new $APP.n(null,8,[$APP.Gk,$APP.kz,Il,new $APP.n(null,2,[$APP.Ck,1,$APP.Dk,1],null),qB,function(a,b){a=$APP.Q(b,0,null);return Aj(a)},hn,function(a,b){a=$APP.Q(b,0,null);return Cj(a)},kn,function(a,b){a=$APP.Q(b,0,null);return Dj(a)},Jl,function(a,b){a=$APP.Q(b,0,null);return Ej(a)},mn,function(a,b){a=$APP.Q(b,0,null);return Gj(a)},Kl,function(){return new $APP.n(null,1,[$APP.Ck,0],null)}],null)),$APP.iA,Nl(new $APP.n(null,8,[$APP.Gk,$APP.iA,
Il,new $APP.n(null,2,[$APP.Ck,1,$APP.Dk,1],null),qB,function(a,b){a=$APP.Q(b,0,null);return Cr.j($APP.Bd([a,zj.l()]))},hn,function(a,b){a=$APP.Q(b,0,null);return Dr.j($APP.Bd([a,Bj.l()]))},kn,function(a,b){a=$APP.Q(b,0,null);return Er.j($APP.Bd([a,vj()]))},Jl,function(a,b){a=$APP.Q(b,0,null);return Gr.j($APP.Bd([a,wj]))},mn,function(a,b){a=$APP.Q(b,0,null);return Ir.j($APP.Bd([a,Fj.l()]))},Kl,function(a,b){a=$APP.Q(b,0,null);return new $APP.n(null,2,[$APP.Ck,0,$APP.Dk,$APP.Dk.g(Ak(a))],null)}],null)),
$APP.gp,Nl(new $APP.n(null,8,[$APP.Gk,$APP.gp,Il,new $APP.n(null,2,[$APP.Ck,1,$APP.Dk,1],null),qB,function(a,b){var c=$APP.Ef(a);a=$APP.R.i(c,$APP.Ck,0);c=$APP.R.i(c,$APP.Dk,Infinity);b=$APP.Q(b,0,null);return Kj(a,c,b)},hn,function(a,b){var c=$APP.Ef(a);a=$APP.R.i(c,$APP.Ck,0);c=$APP.R.i(c,$APP.Dk,Infinity);b=$APP.Q(b,0,null);return Lj(a,c,b)},kn,function(a,b){var c=$APP.Ef(a);a=$APP.R.i(c,$APP.Ck,0);c=$APP.R.i(c,$APP.Dk,Infinity);b=$APP.Q(b,0,null);return Mj(a,c,b)},Jl,function(a,b){var c=$APP.Ef(a);
a=$APP.R.i(c,$APP.Ck,0);c=$APP.R.i(c,$APP.Dk,Infinity);b=$APP.Q(b,0,null);return Nj(a,c,b)},mn,function(a,b){var c=$APP.Ef(a);a=$APP.R.i(c,$APP.Ck,0);c=$APP.R.i(c,$APP.Dk,Infinity);b=$APP.Q(b,0,null);return Oj(a,c,b)},Kl,function(a,b){b=$APP.Q(b,0,null);return im($APP.Fo,a,b)}],null)),$APP.Uz,Nl(new $APP.n(null,8,[$APP.Gk,$APP.Uz,Il,$APP.Jf,qB,function(a,b){return $APP.wf(zj,b)},hn,function(a,b){return $APP.wf(Bj,b)},kn,function(a,b){return $APP.wf(Hj,b)},Jl,function(a,b){return $APP.wf(Ar,b)},mn,
function(a,b){return $APP.wf(Fj,b)},Kl,function(a,b){return $APP.tb($APP.Rf(im,$APP.Eo),new $APP.n(null,2,[$APP.Ck,0,$APP.Dk,0],null),b)}],null)),$APP.Uy,Nl(new $APP.n(null,8,[$APP.Gk,$APP.Uy,Il,new $APP.n(null,1,[$APP.Ck,1],null),qB,function(a,b){return $APP.wf(Cr,b)},hn,function(a,b){return $APP.wf(Dr,b)},kn,function(a,b){return $APP.wf(Er,b)},Jl,function(a,b){return $APP.wf(Gr,b)},mn,function(a,b){return $APP.wf(Ir,b)},Kl,function(a,b){return $APP.tb(km,new $APP.n(null,1,[$APP.Dk,0],null),b)}],
null)),$APP.nA,Ql(new $APP.n(null,8,[$APP.Gk,$APP.nA,Il,$APP.Jf,qB,function(a,b){return $APP.wf(zj,b)},hn,function(a,b){return $APP.wf(Bj,b)},kn,function(a,b){return $APP.wf(zr,b)},Jl,function(a,b){return $APP.wf(Br,b)},mn,function(a,b){return $APP.wf(Fj,b)},Kl,function(a,b){return $APP.tb($APP.Rf(im,$APP.Eo),new $APP.n(null,2,[$APP.Ck,0,$APP.Dk,0],null),Tb($APP.Ed,b))}],null)),$APP.ap,Ql(new $APP.n(null,8,[$APP.Gk,$APP.ap,Il,new $APP.n(null,1,[$APP.Ck,1],null),qB,function(a,b){return $APP.wf(Cr,
b)},hn,function(a,b){return $APP.wf(Dr,b)},kn,function(a,b){return $APP.wf(Fr,b)},Jl,function(a,b){return $APP.wf(Hr,b)},mn,function(a,b){return $APP.wf(Ir,b)},Kl,function(a,b){return $APP.tb(km,new $APP.n(null,1,[$APP.Dk,0],null),Tb($APP.Ed,b))}],null))],null)};
hD=function(){return $APP.Bh([$APP.dr,$APP.Cm,$APP.OA,$APP.vr,$APP.Uk,$APP.mz,$APP.PA,$APP.Fp,$APP.Al,$APP.Az,$APP.dB,$APP.cq,$APP.Vu,$APP.nl,$APP.$q,$APP.bz,$APP.Yy,$APP.Om,$APP.Tp,$APP.xq],[AB(),Kk(null),FB(),jB(),Vk(null),IB(),ns(new $APP.n(null,2,[$APP.Gk,$APP.PA,$APP.mm,$APP.Sd],null)),gB(),Cl(!1),mB(),xB(),ns(new $APP.n(null,3,[$APP.Gk,$APP.cq,$APP.mm,$APP.Vd,Sq,$APP.fg],null)),YB(),SB(),uB(),LB(),Wy(),Kk(new $APP.n(null,1,[Fl,!0],null)),ns(new $APP.n(null,4,[$APP.Gk,$APP.Tp,$APP.mm,$APP.Qd,
Sq,$APP.Oh,Tr,function(a,b){return b}],null)),rB()])};lm=function(a){a="/(?:)/"===$APP.G.g("$")?$APP.Qe.h($APP.Cg($APP.Te("",$APP.ig.h($APP.G,$APP.J(a)))),""):$APP.Cg($APP.G.g(a).split("$"));if(1<$APP.ud(a))a:for(;;)if(""===Md(a))a=Nd(a);else break a;return a};
nm=function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.mm),c=$APP.R.h(a,Mr);return function(d){d=$APP.Ef(d);var e=$APP.R.h(d,$APP.Cm);d=$APP.R.h(d,$APP.Vl);e=$APP.dm.g(e);var Df=$APP.Ef(e);e=$APP.R.h(Df,$APP.Ck);Df=$APP.R.h(Df,$APP.Dk);return $APP.ib(b.g?b.g(d):b.call(null,d))?c:$APP.z($APP.z(e)?$APP.vd.h(e,Df):e)?["should be ",$APP.G.g(e)].join(""):$APP.z($APP.z(e)?Df:e)?["should be between ",$APP.G.g(e)," and ",$APP.G.g(Df)].join(""):$APP.z(e)?["should be at least ",$APP.G.g(e)].join(""):$APP.z(Df)?
["should be at most ",$APP.G.g(Df)].join(""):null}};om=function(a,b){return $APP.Td(a)?$APP.R.h(a,b):a};pm=function(a,b,c,d){d=$APP.z(d)?d:$APP.pk($APP.Sk($APP.Cm.g(a),null));if($APP.z(b)){var e=om(Or.g(b),c);$APP.z(e)?(e=$APP.Zl(e,d),a=e.h?e.h(a,d):e.call(null,a,d)):a=null;return $APP.z(a)?a:om($APP.Pr.g(b),c)}return null};
um=function(a,b){a=$APP.Ef(a);var c=$APP.R.h(a,$APP.Cm),d=$APP.R.h(a,$APP.Gk);b=$APP.Ef(b);var e=$APP.R.i(b,Sn,rm),Df=$APP.R.i(b,$APP.Qr,!0),g=$APP.R.h(b,Rr),h=$APP.R.i(b,Sr,sm),Wm=pm(a,$APP.dm.g(c),g,b);if($APP.z(Wm))return Wm;Wm=pm(a,$APP.Sl(c),g,b);if($APP.z(Wm))return Wm;Wm=pm(a,e.g?e.g(d):e.call(null,d),g,b);if($APP.z(Wm))return Wm;Wm=pm(a,function(){var m=$APP.ml.g(c);return e.g?e.g(m):e.call(null,m)}(),g,b);if($APP.z(Wm))return Wm;Wm=pm(a,$APP.dm.g(c),h,b);if($APP.z(Wm))return Wm;Wm=pm(a,$APP.Sl(c),
h,b);if($APP.z(Wm))return Wm;d=pm(a,e.g?e.g(d):e.call(null,d),h,b);if($APP.z(d))return d;d=pm(a,function(){var m=$APP.ml.g(c);return e.g?e.g(m):e.call(null,m)}(),h,b);if($APP.z(d))return d;g=$APP.z(Df)?pm(a,e.g?e.g(tm):e.call(null,tm),g,b):Df;return $APP.z(g)?g:$APP.z(Df)?pm(a,e.g?e.g(tm):e.call(null,tm),h,b):Df};
vm=function(a,b,c){a=$APP.Z;var d=$APP.hg.h;var e=Tr.g(b);var Df=$APP.Ef(b);var g=$APP.R.h(Df,$APP.Cm),h=$APP.Ef(c);Df=$APP.R.h(h,Rr);h=$APP.R.i(h,Sr,sm);g=$APP.dm.g(g);Df=om(Ur.g(g),Df);Df=$APP.z(Df)?Df:om(Ur.g(g),h);d=d.call($APP.hg,e,Df);return new $APP.X(null,2,5,a,[d,um(b,c)],null)};
$APP.ym=function(a){var b=$APP.Ef(a),c=$APP.R.h(b,$APP.Vl);a=$APP.R.h(b,Sn);var d=$APP.Ef(null),e=$APP.R.i(d,wm,Mr),Df=$APP.R.i(d,Vr,vm);return $APP.z(a)?$APP.tb(function(g,h){var Wm=Df.i?Df.i(b,h,d):Df.call(null,b,h,d),m=$APP.Q(Wm,0,null);Wm=$APP.Q(Wm,1,null);h=$APP.kg.i(h,Mr,Wm);h=e.g?e.g(h):e.call(null,h);return xm(g,c,m,h)},null,a):null};zm=function(a){this.f=a;this.ic=null;this.s=32768;this.A=0};Bm=function(a){return $APP.wf($APP.$b(EB),a)};Dm=function(a){return $APP.wf($APP.$b(GB),a)};
Fm=function(a){return $APP.wf($APP.$b(HB),a)};Hm=function(a){return $APP.wf($APP.$b(JB),a)};Jm=function(a){return $APP.wf($APP.$b(KB),a)};$APP.Lm=function(a){return $APP.wf($APP.$b(MB),a)};Nm=function(a){return $APP.wf($APP.$b(NB),a)};Pm=function(a){return $APP.wf($APP.$b(OB),a)};Rm=function(a){return $APP.wf($APP.$b(PB),a)};Tm=function(a){return $APP.wf($APP.$b(QB),a)};Vm=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(RB)};
Xm=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(TB)};Zm=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(UB)};an=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(VB)};cn=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(WB)};
en=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(XB)};gn=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(ZB)};jn=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b($B)};ln=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(bC)};
nn=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(KC)};pn=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(LC)};rn=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return $APP.$b(NC)};sn=function(a){return null!=Xe(a)};
tn=function(a,b){if(null!=a&&null!=a.Gc)a=a.Gc(a,b);else{var c=tn[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=tn._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("Spec.conform*",a);}return a};un=function(a,b){if(null!=a&&null!=a.Hc)a=a.Hc(a,b);else{var c=un[$APP.aa(null==a?null:a)];if(null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else if(c=un._,null!=c)a=c.h?c.h(a,b):c.call(null,a,b);else throw $APP.qb("Spec.with-gen*",a);}return a};
wn=function(a){if($APP.Ye(a)){var b=$APP.$b(vn);a=$APP.R.h(b,a);if($APP.Ye(a))a:for(;;)if($APP.Ye(a))a=$APP.R.h(b,a);else{b=a;break a}else b=a;return b}return a};xn=function(a){if($APP.Ye(a)){var b=wn(a);if($APP.z(b))return b;throw Error(["Unable to resolve spec: ",$APP.G.g(a)].join(""));}return a};yn=function(a){return null!=a&&$APP.Qc===a.Yc?a:null};zn=function(a){var b=ys.g(a);return $APP.z(b)?a:b};
Bn=function(a,b){return $APP.Ye(a)?a:$APP.z(zn(a))?$APP.kg.i(a,An,b):null!=a&&(a.s&131072||$APP.Qc===a.de)?Kd(a,$APP.kg.i(Ld(a),An,b)):null};Cn=function(a){return $APP.Ye(a)?a:$APP.z(zn(a))?An.g(a):null!=a&&(a.s&131072||$APP.Qc===a.de)?An.g(Ld(a)):null};En=function(a){var b=function(){var c=(c=$APP.Ye(a))?wn(a):c;if($APP.z(c))return c;c=yn(a);if($APP.z(c))return c;c=zn(a);return $APP.z(c)?c:null}();return $APP.z(zn(b))?Bn(Dn(b,null),Cn(b)):b};
Fn=function(a){var b=En(a);if($APP.z(b))return b;if($APP.Ye(a))throw Error(["Unable to resolve spec: ",$APP.G.g(a)].join(""));return null};Hn=function(a){if(Aa(null==a?"":String(a)))return null;a=$APP.ig.h($i,lm(a));if(2<=$APP.ud(a)&&$APP.Nf(function(c){return!Aa(null==c?"":String(c))},a)){var b=bi()(a);a=$APP.Q(b,0,null);b=$APP.Q(b,1,null);return $APP.ri.g([$APP.Gn.h(".",a),"/",$APP.G.g(b)].join(""))}return null};In=function(a){return $APP.We(As,a)};
Kn=function(a,b){a=wn(a);return $APP.z(zn(a))?$APP.kg.i(a,Bs,b):un(Jn.g(a),b)};Nn=function(a,b,c){if(null==c)$APP.Ei.i(vn,$APP.Ln,a);else{var d=yn(c);$APP.z(d)||(d=zn(c),d=$APP.z(d)?d:$APP.R.h($APP.$b(vn),c));b=$APP.z(d)?c:Mn(b,c,null,null,null);$APP.Ei.K(vn,$APP.kg,a,Bn(b,a))}};
On=function(a,b,c){if($APP.z(a)){var d=Fn(a);if($APP.z(d))return tn(Jn.g(d),b);if(ee(a))return $APP.z(null)?a.g?a.g(b):a.call(null,b):$APP.z(a.g?a.g(b):a.call(null,b))?b:As;throw Error([qi($APP.Bd([c]))," is not a fn, expected predicate fn"].join(""));}return b};
Mn=function(a,b,c,d,e){if($APP.z(yn(b)))return $APP.z(c)?Kn(b,c):b;if($APP.z(zn(b)))return Dn(b,c);if($APP.Ye(b))return a=Fn(b),$APP.z(c)?Kn(a,c):a;if("undefined"===typeof Gf||"undefined"===typeof Pn||"undefined"===typeof Qn||"undefined"===typeof bD)bD=function(Df,g,h,Wm,m,p){this.form=Df;this.sc=g;this.Sb=h;this.ge=Wm;this.Se=m;this.ug=p;this.s=393216;this.A=0},bD.prototype.J=function(Df,g){return new bD(this.form,this.sc,this.Sb,this.ge,this.Se,g)},bD.prototype.I=function(){return this.ug},bD.prototype.Nb=
function(){return this},bD.prototype.Ob=function(){return this},bD.prototype.Yc=$APP.Qc,bD.prototype.Gc=function(Df,g){Df=this.sc.g?this.sc.g(g):this.sc.call(null,g);return $APP.z(this.ge)?Df:$APP.z(Df)?g:As},bD.prototype.Hc=function(Df,g){return Mn(this.form,this.sc,g,this.ge,this.Se)},bD.R=!0,bD.P="cljs.spec.alpha/t_cljs$spec$alpha30179",bD.S=function(Df){return pc(Df,"cljs.spec.alpha/t_cljs$spec$alpha30179")};return new bD(a,b,c,d,e,$APP.Jf)};
Tn=function(a,b,c){var d=new $APP.vi(function(){return $APP.on.i(Jn,b,a)}),e=$APP.ud(b);if("undefined"===typeof Gf||"undefined"===typeof Pn||"undefined"===typeof Qn||"undefined"===typeof lD)lD=function(Df,g,h,Wm,m,p){this.forms=Df;this.Hb=g;this.Sb=h;this.Nc=Wm;this.C=m;this.xg=p;this.s=393216;this.A=0},lD.prototype.J=function(Df,g){return new lD(this.forms,this.Hb,this.Sb,this.Nc,this.C,g)},lD.prototype.I=function(){return this.xg},lD.prototype.Nb=function(){return this},lD.prototype.Ob=function(){return this},
lD.prototype.Yc=$APP.Qc,lD.prototype.Gc=function(Df,g){Df=$APP.$b(this.Nc);if($APP.Vd(g)&&$APP.vd.h($APP.ud(g),this.C))for(var h=g,Wm=0;;){if($APP.vd.h(Wm,this.C))return h;var m=g.g?g.g(Wm):g.call(null,Wm),p=tn(Df.g?Df.g(Wm):Df.call(null,Wm),m);if(In(p))return As;h=p===m?h:$APP.kg.i(h,Wm,p);Wm+=1}else return As},lD.prototype.Hc=function(Df,g){return Tn(this.forms,this.Hb,g)},lD.R=!0,lD.P="cljs.spec.alpha/t_cljs$spec$alpha30204",lD.S=function(Df){return pc(Df,"cljs.spec.alpha/t_cljs$spec$alpha30204")};
return new lD(a,b,c,d,e,$APP.Jf)};Un=function(a,b){return new $APP.oe(a,b)};Vn=function(a,b,c){var d=$APP.J(b);$APP.O(d);$APP.P(d);d=$APP.J(c);$APP.O(d);$APP.P(d);for(d=c;;){c=a;b=$APP.J(b);a=$APP.O(b);b=$APP.P(b);var e=$APP.J(d);d=$APP.O(e);e=$APP.P(e);var Df=d;d=e;if($APP.z(a)){c=On(a,c,Df);if(In(c))return As;a=c}else return c}};Xn=function(a){return new $APP.n(null,2,[ys,Wn,Es,a],null)};Yn=function(a){a=$APP.Ef(a);a=$APP.R.h(a,ys);return $APP.vd.h(Wn,a)};
bo=function(a,b,c,d,e){return $APP.z(a)?(d=new $APP.n(null,5,[ys,Zn,$n,b,ao,d,Zk,e,Pl,Ui()],null),Yn(a)?$APP.kg.j(d,Gs,b,$APP.Bd([Es,$APP.Qe.h(c,Es.g(a))])):$APP.kg.j(d,Gs,a,$APP.Bd([Es,c]))):null};
co=function(a,b,c,d){return $APP.z($APP.z(b)?b:c)?(a=$APP.dg(function(e){e=$APP.O(e);return d.g?d.g(e):d.call(null,e)},$APP.ig.K($APP.Sf,a,function(){var e=$APP.J(b);return e?e:new bg(null,-1,null,null)}(),function(){var e=$APP.J(c);return e?e:new bg(null,-1,null,null)}())),new $APP.X(null,3,5,$APP.Z,[$APP.J($APP.ig.h($APP.O,a)),$APP.z(b)?$APP.J($APP.ig.h($APP.Dd,a)):null,$APP.z(c)?$APP.J($APP.ig.h(function(e){return $APP.wd(e,2)},a)):null],null)):new $APP.X(null,3,5,$APP.Z,[$APP.J($APP.dg(d,a)),
b,c],null)};ho=function(a,b,c){var d=co(a,b,c,$APP.Ee);b=$APP.Q(d,0,null);c=$APP.J(b);a=$APP.O(c);c=$APP.P(c);var e=$APP.Q(d,1,null),Df=$APP.Q(e,0,null);d=$APP.Q(d,2,null);return $APP.z(b)?(b=new $APP.n(null,4,[ys,eo,fo,b,go,e,Zk,d],null),null==c?$APP.z(Df)?Yn(a)?Xn(Un(Df,Es.g(a))):b:a:b):null};io=function(a,b){return $APP.z($APP.z(a)?b:a)?ho($APP.Bd([a,b]),null,null):$APP.z(a)?a:b};
no=function(a,b,c){a=xn(a);var d=$APP.Ef(a),e=$APP.R.h(d,ys);$APP.R.h(d,fo);a=$APP.R.h(d,ao);if($APP.vd.h(null,e))return b;if($APP.vd.h(eo,e)||$APP.vd.h(Wn,e)||$APP.vd.h(lo,e))return a=jo(d),$APP.vd.h(a,ko)?b:$APP.Qe.h(b,$APP.z(c)?Xg([c,a]):a);if($APP.vd.h(Zn,e)||$APP.vd.h(mo,e))return d=jo(d),$APP.Od(d)||(c=$APP.z(c)?Xg([c,d]):d,a=$APP.z(a)?$APP.hg:$APP.Qe,b=a.h?a.h(b,c):a.call(null,b,c)),b;throw Error(["No matching clause: ",$APP.G.g(e)].join(""));};
qo=function(a,b){for(;;){var c=$APP.J(b),d=$APP.O(c);c=$APP.P(c);if($APP.Od(b))return $APP.z(oo(a))?(a=jo(a),$APP.vd.h(a,ko)?null:a):As;a=po(a,d);if($APP.z(a))b=c;else return As}};ro=function(a){return["Oops, ",$APP.G.g(a)].join("")};fa="closure_uid_"+(1E9*Math.random()>>>0);ha=0;var xa,na,oa;
$APP.ka=class{constructor(a,b){this.da=a|0;this.V=b|0}isSafeInteger(){var a=this.V>>21;return 0==a||-1==a&&!(0==this.da&&-2097152==this.V)}toString(a){a=a||10;if(2>a||36<a)throw Error("radix out of range: "+a);if(this.isSafeInteger()){var b=$APP.ta(this);return 10==a?""+b:b.toString(a)}b=14-(a>>2);var c=Math.pow(a,b),d=$APP.ma(c,c/4294967296);c=ya(this,d);var e=Math,Df=e.abs;d=c.multiply(d);d=this.add($APP.pa(d));e=Df.call(e,$APP.ta(d));Df=10==a?""+e:e.toString(a);Df.length<b&&(Df="0000000000000".substr(Df.length-b)+
Df);e=$APP.ta(c);return(10==a?e:e.toString(a))+Df}compare(a){return this.V==a.V?this.da==a.da?0:this.da>>>0>a.da>>>0?1:-1:this.V>a.V?1:-1}add(a){var b=this.V>>>16,c=this.V&65535,d=this.da>>>16,e=a.V>>>16,Df=a.V&65535,g=a.da>>>16;a=(this.da&65535)+(a.da&65535);g=(a>>>16)+(d+g);d=g>>>16;d+=c+Df;b=(d>>>16)+(b+e)&65535;return $APP.ma((g&65535)<<16|a&65535,b<<16|d&65535)}multiply(a){if(ua(this))return this;if(ua(a))return a;var b=this.V>>>16,c=this.V&65535,d=this.da>>>16,e=this.da&65535,Df=a.V>>>16,g=
a.V&65535,h=a.da>>>16;a=a.da&65535;var Wm=e*a;var m=(Wm>>>16)+d*a;var p=m>>>16;m=(m&65535)+e*h;p+=m>>>16;p+=c*a;var r=p>>>16;p=(p&65535)+d*h;r+=p>>>16;p=(p&65535)+e*g;r=r+(p>>>16)+(b*a+c*h+d*g+e*Df)&65535;return $APP.ma((m&65535)<<16|Wm&65535,r<<16|p&65535)}not(){return $APP.ma(~this.da,~this.V)}and(a){return $APP.ma(this.da&a.da,this.V&a.V)}or(a){return $APP.ma(this.da|a.da,this.V|a.V)}xor(a){return $APP.ma(this.da^a.da,this.V^a.V)}shiftLeft(a){a&=63;if(0==a)return this;var b=this.da;return 32>a?
$APP.ma(b<<a,this.V<<a|b>>>32-a):$APP.ma(0,b<<a-32)}};$APP.qa=$APP.ma(0,0);$APP.wa=$APP.ma(1,0);xa=$APP.ma(-1,-1);na=$APP.ma(4294967295,2147483647);oa=$APP.ma(0,2147483648);var Ra=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?\x3d[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");$APP.l=La.prototype;$APP.l.toString=function(){var a=[],b=this.ec;b&&a.push(Ua(b,so,!0),":");var c=this.Rb;if(c||"file"==b)a.push("//"),(b=this.vc)&&a.push(Ua(b,so,!0),"@"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),c=this.Mc,null!=c&&a.push(":",String(c));if(c=this.Gb)this.Rb&&"/"!=c.charAt(0)&&a.push("/"),a.push(Ua(c,"/"==c.charAt(0)?to:uo,!0));(c=this.Fb.toString())&&a.push("?",c);(c=this.pc)&&a.push("#",Ua(c,vo));return a.join("")};
$APP.l.resolve=function(a){var b=this.clone(),c=!!a.ec;c?Na(b,a.ec):c=!!a.vc;if(c){var d=a.vc;Oa(b);b.vc=d}else c=!!a.Rb;c?(d=a.Rb,Oa(b),b.Rb=d):c=null!=a.Mc;d=a.Gb;if(c)Pa(b,a.Mc);else if(c=!!a.Gb){if("/"!=d.charAt(0))if(this.Rb&&!this.Gb)d="/"+d;else{var e=b.Gb.lastIndexOf("/");-1!=e&&(d=b.Gb.substr(0,e+1)+d)}e=d;if(".."==e||"."==e)d="";else if(-1!=e.indexOf("./")||-1!=e.indexOf("/.")){d=0==e.lastIndexOf("/",0);e=e.split("/");for(var Df=[],g=0;g<e.length;){var h=e[g++];"."==h?d&&g==e.length&&Df.push(""):
".."==h?((1<Df.length||1==Df.length&&""!=Df[0])&&Df.pop(),d&&g==e.length&&Df.push("")):(Df.push(h),d=!0)}d=Df.join("/")}else d=e}c?(Oa(b),b.Gb=d):c=""!==a.Fb.toString();c?Qa(b,a.Fb.clone()):c=!!a.pc;c&&(a=a.pc,Oa(b),b.pc=a);return b};$APP.l.clone=function(){return new La(this)};$APP.l.getQuery=function(){return this.Fb.toString()};$APP.l.removeParameter=function(a){Oa(this);this.Fb.remove(a);return this};$APP.l.Ef=function(a){this.yb=a;this.Fb&&this.Fb.Ef(a)};
var so=/[#\/\?@]/g,uo=/[#\?:]/g,to=/[#\?]/g,Va=/[#\?@]/g,vo=/#/g;$APP.l=Ta.prototype;$APP.l.add=function(a,b){Xa(this);this.ub=null;a=Ya(this,a);var c=this.Ja.get(a);c||this.Ja.set(a,c=[]);c.push(b);this.pb+=1;return this};$APP.l.remove=function(a){Xa(this);a=Ya(this,a);return this.Ja.has(a)?(this.ub=null,this.pb-=this.Ja.get(a).length,this.Ja.delete(a)):!1};$APP.l.clear=function(){this.Ja=this.ub=null;this.pb=0};
$APP.l.forEach=function(a,b){Xa(this);this.Ja.forEach(function(c,d){c.forEach(function(e){a.call(b,e,d,this)},this)},this)};$APP.l.je=function(){Xa(this);const a=Array.from(this.Ja.values()),b=Array.from(this.Ja.keys()),c=[];for(let d=0;d<b.length;d++){const e=a[d];for(let Df=0;Df<e.length;Df++)c.push(b[d])}return c};$APP.l.qc=function(a){Xa(this);let b=[];if("string"===typeof a)Za(this,a)&&(b=b.concat(this.Ja.get(Ya(this,a))));else{a=Array.from(this.Ja.values());for(let c=0;c<a.length;c++)b=b.concat(a[c])}return b};
$APP.l.set=function(a,b){Xa(this);this.ub=null;a=Ya(this,a);Za(this,a)&&(this.pb-=this.Ja.get(a).length);this.Ja.set(a,[b]);this.pb+=1;return this};$APP.l.get=function(a,b){if(!a)return b;a=this.qc(a);return 0<a.length?String(a[0]):b};
$APP.l.toString=function(){if(this.ub)return this.ub;if(!this.Ja)return"";const a=[],b=Array.from(this.Ja.keys());for(var c=0;c<b.length;c++){var d=b[c];const Df=encodeURIComponent(String(d)),g=this.qc(d);for(d=0;d<g.length;d++){var e=Df;""!==g[d]&&(e+="\x3d"+encodeURIComponent(String(g[d])));a.push(e)}}return this.ub=a.join("\x26")};$APP.l.clone=function(){var a=new Ta;a.ub=this.ub;this.Ja&&(a.Ja=new Map(this.Ja),a.pb=this.pb);return a};
$APP.l.Ef=function(a){a&&!this.yb&&(Xa(this),this.ub=null,this.Ja.forEach(function(b,c){var d=c.toLowerCase();if(c!=d&&(this.remove(c),this.remove(d),0<b.length)){this.ub=null;c=this.Ja;var e=c.set;d=Ya(this,d);var Df=b.length;if(0<Df){const g=Array(Df);for(let h=0;h<Df;h++)g[h]=b[h];Df=g}else Df=[];e.call(c,d,Df);this.pb+=b.length}},this));this.yb=a};$APP.l.extend=function(a){for(var b=0;b<arguments.length;b++)Ja(arguments[b],function(c,d){this.add(d,c)},this)};$APP.l=$a.prototype;$APP.l.hc="";$APP.l.set=function(a){this.hc=""+a};$APP.l.append=function(a,b,c){this.hc+=String(a);if(null!=b)for(let d=1;d<arguments.length;d++)this.hc+=arguments[d];return this};$APP.l.clear=function(){this.hc=""};$APP.l.toString=function(){return this.hc};var Gf,Hf,Rn,fi,Zc,te,Yi,mD,oD,me,Cf,Qo,Ro,So,Uo;Gf={};Hf={};$APP.Qc={};fi=null;Zc="undefined"!==typeof Symbol&&"function"===$APP.aa(Symbol)?Symbol.iterator:"@@iterator";te={_RBRACE_:"}",_COLON_:":",_BANG_:"!",_QMARK_:"?",_BSLASH_:"\\\\",_SLASH_:"/",_PERCENT_:"%",_PLUS_:"+",_SHARP_:"#",_LBRACE_:"{",_BAR_:"|",_LBRACK_:"[",_EQ_:"\x3d",_:"-",_TILDE_:"~",_RBRACK_:"]",_GT_:"\x3e",_SINGLEQUOTE_:"'",_CIRCA_:"@",_AMPERSAND_:"\x26",_DOUBLEQUOTE_:'\\"',_CARET_:"^",_LT_:"\x3c",_STAR_:"*"};Yi=null;
mD=function(){function a(d,e,Df){var g=$APP.Gd[$APP.aa(null==d?null:d)];if(null!=g)return g.i?g.i(d,e,Df):g.call(null,d,e,Df);g=$APP.Gd._;if(null!=g)return g.i?g.i(d,e,Df):g.call(null,d,e,Df);throw $APP.qb("IIndexed.-nth",d);}function b(d,e){var Df=$APP.Gd[$APP.aa(null==d?null:d)];if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);Df=$APP.Gd._;if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);throw $APP.qb("IIndexed.-nth",d);}var c=null;c=function(d,e,Df){switch(arguments.length){case 2:return b.call(this,
d,e);case 3:return a.call(this,d,e,Df)}throw Error("Invalid arity: "+arguments.length);};c.h=b;c.i=a;return c}();$APP.Gd=function Gd(a){switch(arguments.length){case 2:return Gd.h(arguments[0],arguments[1]);case 3:return Gd.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.Gd.h=function(a,b){return null!=a&&null!=a.ha?a.ha(a,b):mD(a,b)};$APP.Gd.i=function(a,b,c){return null!=a&&null!=a.La?a.La(a,b,c):mD(a,b,c)};
$APP.Gd.B=3;
oD=function(){function a(d,e,Df){var g=$APP.xo[$APP.aa(null==d?null:d)];if(null!=g)return g.i?g.i(d,e,Df):g.call(null,d,e,Df);g=$APP.xo._;if(null!=g)return g.i?g.i(d,e,Df):g.call(null,d,e,Df);throw $APP.qb("ILookup.-lookup",d);}function b(d,e){var Df=$APP.xo[$APP.aa(null==d?null:d)];if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);Df=$APP.xo._;if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);throw $APP.qb("ILookup.-lookup",d);}var c=null;c=function(d,e,Df){switch(arguments.length){case 2:return b.call(this,d,
e);case 3:return a.call(this,d,e,Df)}throw Error("Invalid arity: "+arguments.length);};c.h=b;c.i=a;return c}();$APP.xo=function xo(a){switch(arguments.length){case 2:return xo.h(arguments[0],arguments[1]);case 3:return xo.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.xo.h=function(a,b){return null!=a&&null!=a.xa?a.xa(a,b):oD(a,b)};$APP.xo.i=function(a,b,c){return null!=a&&null!=a.T?a.T(a,b,c):oD(a,b,c)};$APP.xo.B=3;
var pD=function(){function a(d,e,Df){var g=Ce[$APP.aa(null==d?null:d)];if(null!=g)return g.i?g.i(d,e,Df):g.call(null,d,e,Df);g=Ce._;if(null!=g)return g.i?g.i(d,e,Df):g.call(null,d,e,Df);throw $APP.qb("IReduce.-reduce",d);}function b(d,e){var Df=Ce[$APP.aa(null==d?null:d)];if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);Df=Ce._;if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);throw $APP.qb("IReduce.-reduce",d);}var c=null;c=function(d,e,Df){switch(arguments.length){case 2:return b.call(this,
d,e);case 3:return a.call(this,d,e,Df)}throw Error("Invalid arity: "+arguments.length);};c.h=b;c.i=a;return c}(),Ce=function Ce(a){switch(arguments.length){case 2:return Ce.h(arguments[0],arguments[1]);case 3:return Ce.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};Ce.h=function(a,b){return null!=a&&null!=a.Fa?a.Fa(a,b):pD(a,b)};Ce.i=function(a,b,c){return null!=a&&null!=a.Ga?a.Ga(a,b,c):pD(a,b,c)};Ce.B=3;
var qD=function(){function a(Df,g,h,Wm,m){var p=Ao[$APP.aa(null==Df?null:Df)];if(null!=p)return p.G?p.G(Df,g,h,Wm,m):p.call(null,Df,g,h,Wm,m);p=Ao._;if(null!=p)return p.G?p.G(Df,g,h,Wm,m):p.call(null,Df,g,h,Wm,m);throw $APP.qb("ISwap.-swap!",Df);}function b(Df,g,h,Wm){var m=Ao[$APP.aa(null==Df?null:Df)];if(null!=m)return m.K?m.K(Df,g,h,Wm):m.call(null,Df,g,h,Wm);m=Ao._;if(null!=m)return m.K?m.K(Df,g,h,Wm):m.call(null,Df,g,h,Wm);throw $APP.qb("ISwap.-swap!",Df);}function c(Df,g,h){var Wm=Ao[$APP.aa(null==
Df?null:Df)];if(null!=Wm)return Wm.i?Wm.i(Df,g,h):Wm.call(null,Df,g,h);Wm=Ao._;if(null!=Wm)return Wm.i?Wm.i(Df,g,h):Wm.call(null,Df,g,h);throw $APP.qb("ISwap.-swap!",Df);}function d(Df,g){var h=Ao[$APP.aa(null==Df?null:Df)];if(null!=h)return h.h?h.h(Df,g):h.call(null,Df,g);h=Ao._;if(null!=h)return h.h?h.h(Df,g):h.call(null,Df,g);throw $APP.qb("ISwap.-swap!",Df);}var e=null;e=function(Df,g,h,Wm,m){switch(arguments.length){case 2:return d.call(this,Df,g);case 3:return c.call(this,Df,g,h);case 4:return b.call(this,
Df,g,h,Wm);case 5:return a.call(this,Df,g,h,Wm,m)}throw Error("Invalid arity: "+arguments.length);};e.h=d;e.i=c;e.K=b;e.G=a;return e}(),Ao=function Ao(a){switch(arguments.length){case 2:return Ao.h(arguments[0],arguments[1]);case 3:return Ao.i(arguments[0],arguments[1],arguments[2]);case 4:return Ao.K(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return Ao.G(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));
}};Ao.h=function(a,b){return null!=a&&null!=a.jf?a.jf(a,b):qD(a,b)};Ao.i=function(a,b,c){return null!=a&&null!=a.kf?a.kf(a,b,c):qD(a,b,c)};Ao.K=function(a,b,c,d){return null!=a&&null!=a.lf?a.lf(a,b,c,d):qD(a,b,c,d)};Ao.G=function(a,b,c,d,e){return null!=a&&null!=a.mf?a.mf(a,b,c,d,e):qD(a,b,c,d,e)};Ao.B=5;Hc.prototype.Ae=function(a,b){return this.Hg.append(b)};
var Jc="undefined"!==typeof Math&&"undefined"!==typeof Math.imul?function(a,b){return Math.imul(a,b)}:function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0},Oc={},Nc=0;$APP.l=$APP.H.prototype;$APP.l.toString=function(){return this.Ib};$APP.l.fa=function(a,b){return b instanceof $APP.H?this.Ib===b.Ib:!1};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return $APP.R.h?$APP.R.h(a,this):$APP.R.call(null,a,this)};$APP.l.h=function(a,b){return $APP.R.i?$APP.R.i(a,this,b):$APP.R.call(null,a,this,b)};$APP.l.I=function(){return this.xb};
$APP.l.J=function(a,b){return new $APP.H(this.eb,this.name,this.Ib,this.xc,b)};$APP.l.ga=function(){var a=this.xc;return null!=a?a:this.xc=a=Uc(this)};$APP.l.Tc=function(){return this.name};$APP.l.Uc=function(){return this.eb};$APP.l.Z=function(a,b){return pc(b,this.Ib)};$APP.ri=function ri(a){switch(arguments.length){case 1:return ri.g(arguments[0]);case 2:return ri.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
$APP.ri.g=function(a){for(;;){if(a instanceof $APP.H)return a;if("string"===typeof a){var b=a.indexOf("/");return 1>b?$APP.ri.h(null,a):$APP.ri.h(a.substring(0,b),a.substring(b+1,a.length))}if(a instanceof Wc)return a.uc;if(a instanceof $APP.u)a=a.cb;else throw Error("no conversion to symbol");}};$APP.ri.h=function(a,b){var c=null!=a?[$APP.G.g(a),"/",$APP.G.g(b)].join(""):b;return new $APP.H(a,b,c,null,null)};$APP.ri.B=2;$APP.l=Wc.prototype;$APP.l.toString=function(){return["#'",$APP.G.g(this.uc)].join("")};
$APP.l.Mb=function(){return this.o.l?this.o.l():this.o.call(null)};$APP.l.I=function(){return this.xb};$APP.l.J=function(a,b){return new Wc(this.o,this.uc,b)};$APP.l.fa=function(a,b){return b instanceof Wc?(a=this.uc,b=b.uc,$APP.vd.h?$APP.vd.h(a,b):$APP.vd.call(null,a,b)):!1};$APP.l.ga=function(){return Uc(this.uc)};$APP.l.ve=$APP.Qc;
$APP.l.call=function(a){switch(arguments.length-1){case 0:return this.l();case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);case 3:return this.i(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.G(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.O(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.X(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.ca(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.ka(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ma(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.na(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.oa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.pa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.qa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.ra(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.sa(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.ta(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.ua(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.ud(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.l=function(){var a=this.o.l?this.o.l():this.o.call(null);return a.l?a.l():a.call(null)};$APP.l.g=function(a){var b=this.o.l?this.o.l():this.o.call(null);return b.g?b.g(a):b.call(null,a)};
$APP.l.h=function(a,b){var c=this.o.l?this.o.l():this.o.call(null);return c.h?c.h(a,b):c.call(null,a,b)};$APP.l.i=function(a,b,c){var d=this.o.l?this.o.l():this.o.call(null);return d.i?d.i(a,b,c):d.call(null,a,b,c)};$APP.l.K=function(a,b,c,d){var e=this.o.l?this.o.l():this.o.call(null);return e.K?e.K(a,b,c,d):e.call(null,a,b,c,d)};$APP.l.G=function(a,b,c,d,e){var Df=this.o.l?this.o.l():this.o.call(null);return Df.G?Df.G(a,b,c,d,e):Df.call(null,a,b,c,d,e)};
$APP.l.O=function(a,b,c,d,e,Df){var g=this.o.l?this.o.l():this.o.call(null);return g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df)};$APP.l.X=function(a,b,c,d,e,Df,g){var h=this.o.l?this.o.l():this.o.call(null);return h.X?h.X(a,b,c,d,e,Df,g):h.call(null,a,b,c,d,e,Df,g)};$APP.l.ca=function(a,b,c,d,e,Df,g,h){var Wm=this.o.l?this.o.l():this.o.call(null);return Wm.ca?Wm.ca(a,b,c,d,e,Df,g,h):Wm.call(null,a,b,c,d,e,Df,g,h)};
$APP.l.va=function(a,b,c,d,e,Df,g,h,Wm){var m=this.o.l?this.o.l():this.o.call(null);return m.va?m.va(a,b,c,d,e,Df,g,h,Wm):m.call(null,a,b,c,d,e,Df,g,h,Wm)};$APP.l.ka=function(a,b,c,d,e,Df,g,h,Wm,m){var p=this.o.l?this.o.l():this.o.call(null);return p.ka?p.ka(a,b,c,d,e,Df,g,h,Wm,m):p.call(null,a,b,c,d,e,Df,g,h,Wm,m)};$APP.l.la=function(a,b,c,d,e,Df,g,h,Wm,m,p){var r=this.o.l?this.o.l():this.o.call(null);return r.la?r.la(a,b,c,d,e,Df,g,h,Wm,m,p):r.call(null,a,b,c,d,e,Df,g,h,Wm,m,p)};
$APP.l.ma=function(a,b,c,d,e,Df,g,h,Wm,m,p,r){var t=this.o.l?this.o.l():this.o.call(null);return t.ma?t.ma(a,b,c,d,e,Df,g,h,Wm,m,p,r):t.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r)};$APP.l.na=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t){var v=this.o.l?this.o.l():this.o.call(null);return v.na?v.na(a,b,c,d,e,Df,g,h,Wm,m,p,r,t):v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t)};
$APP.l.oa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v){var x=this.o.l?this.o.l():this.o.call(null);return x.oa?x.oa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v):x.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v)};$APP.l.pa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x){var A=this.o.l?this.o.l():this.o.call(null);return A.pa?A.pa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x):A.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x)};
$APP.l.qa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A){var E=this.o.l?this.o.l():this.o.call(null);return E.qa?E.qa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A):E.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A)};$APP.l.ra=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E){var M=this.o.l?this.o.l():this.o.call(null);return M.ra?M.ra(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E):M.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E)};
$APP.l.sa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M){var U=this.o.l?this.o.l():this.o.call(null);return U.sa?U.sa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M):U.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M)};$APP.l.ta=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U){var W=this.o.l?this.o.l():this.o.call(null);return W.ta?W.ta(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U):W.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U)};
$APP.l.ua=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W){var ba=this.o.l?this.o.l():this.o.call(null);return ba.ua?ba.ua(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W):ba.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W)};$APP.l.ud=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba){var T=this.o.l?this.o.l():this.o.call(null);return Bf.jc?Bf.jc(T,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba):Bf.call(null,T,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba)};
$APP.vd=function vd(a){switch(arguments.length){case 1:return vd.g(arguments[0]);case 2:return vd.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return vd.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.vd.g=function(){return!0};$APP.vd.h=function(a,b){return null==a?null==b:a===b||gc(a,b)};
$APP.vd.j=function(a,b,c){for(;;)if($APP.vd.h(a,b))if($APP.P(c))a=b,b=$APP.O(c),c=$APP.P(c);else return $APP.vd.h(b,$APP.O(c));else return!1};$APP.vd.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.vd.B=2;cd.prototype.next=function(){if(null!=this.W){var a=$APP.O(this.W);this.W=$APP.P(this.W);return{value:a,done:!1}}return{value:null,done:!0}};ed.prototype.ia=function(){return this};ed.prototype.Da=function(){return this.value};
ed.prototype.Ha=function(){null==this.Zd&&(this.Zd=$c.g?$c.g(this.Kc):$c.call(null,this.Kc));return this.Zd};var Co=Mc(Lc(0,Kc(1)),0),Do=Mc(Lc(0,Kc(0)),0);yb["null"]=!0;zb["null"]=function(){return 0};Date.prototype.fa=function(a,b){return b instanceof Date&&this.valueOf()===b.valueOf()};Date.prototype.yc=$APP.Qc;Date.prototype.Zb=function(a,b){if(b instanceof Date)return Ea(this.valueOf(),b.valueOf());throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};
Date.prototype.pf=$APP.Qc;gc.number=function(a,b){return a===b};wb["function"]=!0;ac["function"]=!0;bc["function"]=function(){return null};hc._=function(a){return ja(a)};jd.prototype.Mb=function(){return this.o};Ad.prototype.Ia=function(){return this.D<this.arr.length};Ad.prototype.next=function(){var a=this.arr[this.D];this.D+=1;return a};$APP.l=$APP.Yc.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud.g?$APP.ud.g(this):$APP.ud.call(null,this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.ha=function(a,b){a=b+this.D;if(0<=a&&a<this.arr.length)return this.arr[a];throw Error("Index out of bounds");};
$APP.l.La=function(a,b,c){a=b+this.D;return 0<=a&&a<this.arr.length?this.arr[a]:c};$APP.l.gb=function(){return new Ad(this.arr,this.D)};$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return this.D+1<this.arr.length?new $APP.Yc(this.arr,this.D+1,null):null};$APP.l.ja=function(){var a=this.arr.length-this.D;return 0>a?0:a};$APP.l.Wc=function(){var a=this.ja(null);return 0<a?new Cd(this,a-1,null):null};$APP.l.ga=function(){return fd(this)};
$APP.l.fa=function(a,b){return Me.h?Me.h(this,b):Me.call(null,this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return rd(this.arr,b,this.arr[this.D],this.D+1)};$APP.l.Ga=function(a,b,c){return rd(this.arr,b,c,this.D)};$APP.l.Da=function(){return this.arr[this.D]};$APP.l.Ha=function(){return this.D+1<this.arr.length?new $APP.Yc(this.arr,this.D+1,null):$APP.ad};$APP.l.ia=function(){return this.D<this.arr.length?this:null};
$APP.l.J=function(a,b){return b===this.H?this:new $APP.Yc(this.arr,this.D,b)};$APP.l.Aa=function(a,b){return $APP.Te.h?$APP.Te.h(b,this):$APP.Te.call(null,b,this)};$APP.Yc.prototype[Zc]=function(){return dd(this)};$APP.l=Cd.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud.g?$APP.ud.g(this):$APP.ud.call(null,this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return 0<this.D?new Cd(this.od,this.D-1,null):null};$APP.l.ja=function(){return this.D+1};$APP.l.ga=function(){return fd(this)};
$APP.l.fa=function(a,b){return Me.h?Me.h(this,b):Me.call(null,this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we?we(b,this):ye.call(null,b,this)};$APP.l.Ga=function(a,b,c){return xe?xe(b,c,this):ye.call(null,b,c,this)};$APP.l.Da=function(){return $APP.Gd(this.od,this.D)};$APP.l.Ha=function(){return 0<this.D?new Cd(this.od,this.D-1,null):$APP.ad};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.H?this:new Cd(this.od,this.D,b)};
$APP.l.Aa=function(a,b){return $APP.Te.h?$APP.Te.h(b,this):$APP.Te.call(null,b,this)};Cd.prototype[Zc]=function(){return dd(this)};gc._=function(a,b){return a===b};$APP.Qe=function Qe(a){switch(arguments.length){case 0:return Qe.l();case 1:return Qe.g(arguments[0]);case 2:return Qe.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Qe.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.Qe.l=function(){return $APP.fg};
$APP.Qe.g=function(a){return a};$APP.Qe.h=function(a,b){return null!=a?$APP.Db(a,b):new $APP.Ne(null,b,null,1,null)};$APP.Qe.j=function(a,b,c){for(;;)if($APP.z(c))a=$APP.Qe.h(a,b),b=$APP.O(c),c=$APP.P(c);else return $APP.Qe.h(a,b)};$APP.Qe.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.Qe.B=2;
$APP.R=function R(a){switch(arguments.length){case 2:return R.h(arguments[0],arguments[1]);case 3:return R.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.R.h=function(a,b){return null==a?null:null!=a&&(a.s&256||$APP.Qc===a.cf)?a.xa(null,b):$APP.gb(a)?null!=b&&b<a.length?a[b|0]:null:"string"===typeof a?null!=b&&-1<b&&b<a.length?a.charAt(b|0):null:$APP.ob(Kb,a)?$APP.xo(a,b):null};
$APP.R.i=function(a,b,c){return null!=a?null!=a&&(a.s&256||$APP.Qc===a.cf)?a.T(null,b,c):$APP.gb(a)?null!=b&&-1<b&&b<a.length?a[b|0]:c:"string"===typeof a?null!=b&&-1<b&&b<a.length?a.charAt(b|0):c:$APP.ob(Kb,a)?$APP.xo(a,b,c):c:c};$APP.R.B=3;
$APP.kg=function kg(a){switch(arguments.length){case 3:return kg.i(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return kg.j(arguments[0],arguments[1],arguments[2],new $APP.Yc(c.slice(3),0,null))}};$APP.kg.i=function(a,b,c){return null!=a&&(a.s&512||$APP.Qc===a.we)?a.tb(null,b,c):null!=a?Nb(a,b,c):Xg([b,c])};
$APP.kg.j=function(a,b,c,d){for(;;)if(a=$APP.kg.i(a,b,c),$APP.z(d))b=$APP.O(d),c=$APP.Dd(d),d=$APP.P($APP.P(d));else return a};$APP.kg.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);var d=$APP.P(c);c=$APP.O(d);d=$APP.P(d);return this.j(b,a,c,d)};$APP.kg.B=3;
$APP.Ln=function Ln(a){switch(arguments.length){case 1:return Ln.g(arguments[0]);case 2:return Ln.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ln.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.Ln.g=function(a){return a};$APP.Ln.h=function(a,b){return null==a?null:Rb(a,b)};$APP.Ln.j=function(a,b,c){for(;;){if(null==a)return null;a=$APP.Ln.h(a,b);if($APP.z(c))b=$APP.O(c),c=$APP.P(c);else return a}};
$APP.Ln.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.Ln.B=2;$APP.l=Jd.prototype;$APP.l.I=function(){return this.H};$APP.l.J=function(a,b){return new Jd(this.u,b)};$APP.l.ve=$APP.Qc;
$APP.l.call=function(a){switch(arguments.length-1){case 0:return this.l();case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);case 3:return this.i(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.G(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.O(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.X(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.ca(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.ka(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ma(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.na(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.oa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.pa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.qa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.ra(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.sa(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.ta(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.ua(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.ud(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.l=function(){return this.u.l?this.u.l():this.u.call(null)};$APP.l.g=function(a){return this.u.g?this.u.g(a):this.u.call(null,a)};$APP.l.h=function(a,b){return this.u.h?this.u.h(a,b):this.u.call(null,a,b)};
$APP.l.i=function(a,b,c){return this.u.i?this.u.i(a,b,c):this.u.call(null,a,b,c)};$APP.l.K=function(a,b,c,d){return this.u.K?this.u.K(a,b,c,d):this.u.call(null,a,b,c,d)};$APP.l.G=function(a,b,c,d,e){return this.u.G?this.u.G(a,b,c,d,e):this.u.call(null,a,b,c,d,e)};$APP.l.O=function(a,b,c,d,e,Df){return this.u.O?this.u.O(a,b,c,d,e,Df):this.u.call(null,a,b,c,d,e,Df)};$APP.l.X=function(a,b,c,d,e,Df,g){return this.u.X?this.u.X(a,b,c,d,e,Df,g):this.u.call(null,a,b,c,d,e,Df,g)};
$APP.l.ca=function(a,b,c,d,e,Df,g,h){return this.u.ca?this.u.ca(a,b,c,d,e,Df,g,h):this.u.call(null,a,b,c,d,e,Df,g,h)};$APP.l.va=function(a,b,c,d,e,Df,g,h,Wm){return this.u.va?this.u.va(a,b,c,d,e,Df,g,h,Wm):this.u.call(null,a,b,c,d,e,Df,g,h,Wm)};$APP.l.ka=function(a,b,c,d,e,Df,g,h,Wm,m){return this.u.ka?this.u.ka(a,b,c,d,e,Df,g,h,Wm,m):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m)};
$APP.l.la=function(a,b,c,d,e,Df,g,h,Wm,m,p){return this.u.la?this.u.la(a,b,c,d,e,Df,g,h,Wm,m,p):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p)};$APP.l.ma=function(a,b,c,d,e,Df,g,h,Wm,m,p,r){return this.u.ma?this.u.ma(a,b,c,d,e,Df,g,h,Wm,m,p,r):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r)};$APP.l.na=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t){return this.u.na?this.u.na(a,b,c,d,e,Df,g,h,Wm,m,p,r,t):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t)};
$APP.l.oa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v){return this.u.oa?this.u.oa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v)};$APP.l.pa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x){return this.u.pa?this.u.pa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x)};$APP.l.qa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A){return this.u.qa?this.u.qa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A)};
$APP.l.ra=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E){return this.u.ra?this.u.ra(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E)};$APP.l.sa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M){return this.u.sa?this.u.sa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M)};
$APP.l.ta=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U){return this.u.ta?this.u.ta(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U)};$APP.l.ua=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W){return this.u.ua?this.u.ua(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W):this.u.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W)};
$APP.l.ud=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba){return Bf.jc?Bf.jc(this.u,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba):Bf.call(null,this.u,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba)};me={};
$APP.Eo=function Eo(a){switch(arguments.length){case 0:return Eo.l();case 1:return Eo.g(arguments[0]);case 2:return Eo.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Eo.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.Eo.l=function(){return 0};$APP.Eo.g=function(a){return a};$APP.Eo.h=function(a,b){return a+b};$APP.Eo.j=function(a,b,c){return $APP.tb($APP.Eo,a+b,c)};
$APP.Eo.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.Eo.B=2;$APP.Fo=function Fo(a){switch(arguments.length){case 0:return Fo.l();case 1:return Fo.g(arguments[0]);case 2:return Fo.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Fo.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.Fo.l=function(){return 1};$APP.Fo.g=function(a){return a};
$APP.Fo.h=function(a,b){return a*b};$APP.Fo.j=function(a,b,c){return $APP.tb($APP.Fo,a*b,c)};$APP.Fo.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.Fo.B=2;var Go=function Go(a){switch(arguments.length){case 1:return Go.g(arguments[0]);case 2:return Go.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Go.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};Go.g=function(){return!0};
Go.h=function(a,b){return a<b};Go.j=function(a,b,c){for(;;)if(a<b)if($APP.P(c))a=b,b=$APP.O(c),c=$APP.P(c);else return b<$APP.O(c);else return!1};Go.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};Go.B=2;
var Ho=function Ho(a){switch(arguments.length){case 1:return Ho.g(arguments[0]);case 2:return Ho.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ho.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};Ho.g=function(){return!0};Ho.h=function(a,b){return a<=b};Ho.j=function(a,b,c){for(;;)if(a<=b)if($APP.P(c))a=b,b=$APP.O(c),c=$APP.P(c);else return b<=$APP.O(c);else return!1};
Ho.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};Ho.B=2;var Io=function Io(a){switch(arguments.length){case 1:return Io.g(arguments[0]);case 2:return Io.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Io.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};Io.g=function(){return!0};Io.h=function(a,b){return a>b};
Io.j=function(a,b,c){for(;;)if(a>b)if($APP.P(c))a=b,b=$APP.O(c),c=$APP.P(c);else return b>$APP.O(c);else return!1};Io.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};Io.B=2;var Jo=function Jo(a){switch(arguments.length){case 1:return Jo.g(arguments[0]);case 2:return Jo.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Jo.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};
Jo.g=function(){return!0};Jo.h=function(a,b){return a>=b};Jo.j=function(a,b,c){for(;;)if(a>=b)if($APP.P(c))a=b,b=$APP.O(c),c=$APP.P(c);else return b>=$APP.O(c);else return!1};Jo.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};Jo.B=2;
var Ik=function Ik(a){switch(arguments.length){case 1:return Ik.g(arguments[0]);case 2:return Ik.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ik.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};Ik.g=function(a){return a};Ik.h=function(a,b){return a>b?a:b};Ik.j=function(a,b,c){return $APP.tb(Ik,a>b?a:b,c)};Ik.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};Ik.B=2;
$APP.G=function G(a){switch(arguments.length){case 0:return G.l();case 1:return G.g(arguments[0]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return G.j(arguments[0],new $APP.Yc(c.slice(1),0,null))}};$APP.G.l=function(){return""};$APP.G.g=function(a){return null==a?"":[a].join("")};$APP.G.j=function(a,b){for(a=new $a($APP.G.g(a));;)if($APP.z(b))a=a.append($APP.G.g($APP.O(b))),b=$APP.P(b);else return a.toString()};
$APP.G.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};$APP.G.B=1;$APP.l=$APP.Ne.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,this.count)}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return 1===this.count?null:this.Wb};$APP.l.ja=function(){return this.count};$APP.l.Cc=function(){return this.first};$APP.l.Dc=function(){return this.Ha(null)};
$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.cc($APP.ad,this.H)};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return this.first};$APP.l.Ha=function(){return 1===this.count?$APP.ad:this.Wb};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.H?this:new $APP.Ne(b,this.first,this.Wb,this.count,this.M)};
$APP.l.Aa=function(a,b){return new $APP.Ne(this.H,b,this,this.count+1,null)};$APP.Ne.prototype[Zc]=function(){return dd(this)};$APP.l=Pe.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return null};$APP.l.ja=function(){return 0};$APP.l.Cc=function(){return null};$APP.l.Dc=function(){throw Error("Can't pop empty list");};$APP.l.ga=function(){return Co};
$APP.l.fa=function(a,b){return $APP.Oe(b)||$APP.Sd(b)?null==$APP.J(b):!1};$APP.l.Ba=function(){return this};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return null};$APP.l.Ha=function(){return $APP.ad};$APP.l.ia=function(){return null};$APP.l.J=function(a,b){return b===this.H?this:new Pe(b)};$APP.l.Aa=function(a,b){return new $APP.Ne(this.H,b,null,1,null)};$APP.ad=new Pe(null);Pe.prototype[Zc]=function(){return dd(this)};
$APP.Ko=function Ko(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ko.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};$APP.Ko.j=function(a){if(a instanceof $APP.Yc&&0===a.D)var b=a.arr;else a:for(b=[];;)if(null!=a)b.push(Gb(a)),a=Jb(a);else break a;a=b.length;for(var c=$APP.ad;;)if(0<a){var d=a-1;c=$APP.Db(c,b[a-1]);a=d}else return c};$APP.Ko.B=0;$APP.Ko.F=function(a){return this.j($APP.J(a))};$APP.l=Se.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return null==this.Wb?null:$APP.J(this.Wb)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};
$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return this.first};$APP.l.Ha=function(){return null==this.Wb?$APP.ad:this.Wb};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.H?this:new Se(b,this.first,this.Wb,this.M)};$APP.l.Aa=function(a,b){return new Se(null,b,this,null)};Se.prototype[Zc]=function(){return dd(this)};$APP.l=$APP.u.prototype;
$APP.l.toString=function(){return[":",$APP.G.g(this.cb)].join("")};$APP.l.fa=function(a,b){return b instanceof $APP.u?this.cb===b.cb:!1};$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return $APP.R.h(a,this)};
$APP.l.h=function(a,b){return $APP.R.i(a,this,b)};$APP.l.ga=function(){var a=this.xc;return null!=a?a:this.xc=a=Uc(this)+2654435769|0};$APP.l.Tc=function(){return this.name};$APP.l.Uc=function(){return this.eb};$APP.l.Z=function(a,b){return pc(b,[":",$APP.G.g(this.cb)].join(""))};$APP.mi=function mi(a){switch(arguments.length){case 1:return mi.g(arguments[0]);case 2:return mi.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
$APP.mi.g=function(a){if(a instanceof $APP.u)return a;if(a instanceof $APP.H)return new $APP.u(Xe(a),$APP.Uh.g?$APP.Uh.g(a):$APP.Uh.call(null,a),a.Ib,null);if($APP.vd.h("/",a))return new $APP.u(null,a,a,null);if("string"===typeof a){var b=a.split("/");return 2===b.length?new $APP.u(b[0],b[1],a,null):new $APP.u(null,b[0],a,null)}return null};
$APP.mi.h=function(a,b){a=a instanceof $APP.u?$APP.Uh.g?$APP.Uh.g(a):$APP.Uh.call(null,a):a instanceof $APP.H?$APP.Uh.g?$APP.Uh.g(a):$APP.Uh.call(null,a):a;b=b instanceof $APP.u?$APP.Uh.g?$APP.Uh.g(b):$APP.Uh.call(null,b):b instanceof $APP.H?$APP.Uh.g?$APP.Uh.g(b):$APP.Uh.call(null,b):b;return new $APP.u(a,b,[$APP.z(a)?[$APP.G.g(a),"/"].join(""):null,$APP.G.g(b)].join(""),null)};$APP.mi.B=2;$APP.l=$APP.ef.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){this.ia(null);return null==this.W?null:$APP.P(this.W)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};
$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.cc($APP.ad,this.H)};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){this.ia(null);return null==this.W?null:$APP.O(this.W)};$APP.l.Ha=function(){this.ia(null);return null!=this.W?$APP.bd(this.W):$APP.ad};$APP.l.ia=function(){ff(this);if(null==this.W)return null;for(var a=this.W;;)if(a instanceof $APP.ef)a=ff(a);else return this.W=a,$APP.J(this.W)};
$APP.l.J=function(a,b){var c=this;return b===this.H?c:new $APP.ef(b,function(){return c.ia(null)},this.M)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};$APP.ef.prototype[Zc]=function(){return dd(this)};gf.prototype.add=function(a){this.ae[this.end]=a;return this.end+=1};gf.prototype.ba=function(){var a=new jf(this.ae,0,this.end);this.ae=null;return a};gf.prototype.ja=function(){return this.end};$APP.l=jf.prototype;$APP.l.ja=function(){return this.end-this.Za};
$APP.l.ha=function(a,b){return this.arr[this.Za+b]};$APP.l.La=function(a,b,c){return 0<=b&&b<this.end-this.Za?this.arr[this.Za+b]:c};$APP.l.ce=function(){if(this.Za===this.end)throw Error("-drop-first of empty chunk");return new jf(this.arr,this.Za+1,this.end)};$APP.l.Fa=function(a,b){return rd(this.arr,b,this.arr[this.Za],this.Za+1)};$APP.l.Ga=function(a,b,c){return rd(this.arr,b,c,this.Za)};$APP.l=kf.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return 1<zb(this.ba)?new kf(yc(this.ba),this.Cb,null,null):null==this.Cb?null:jc(this.Cb)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};
$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Da=function(){return $APP.Gd(this.ba,0)};$APP.l.Ha=function(){return 1<zb(this.ba)?new kf(yc(this.ba),this.Cb,null,null):null==this.Cb?$APP.ad:this.Cb};$APP.l.ia=function(){return this};$APP.l.Qc=function(){return this.ba};$APP.l.Yb=function(){return null==this.Cb?$APP.ad:this.Cb};$APP.l.J=function(a,b){return b===this.H?this:new kf(this.ba,this.Cb,b,this.M)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};
$APP.l.pd=function(){return null==this.Cb?null:this.Cb};kf.prototype[Zc]=function(){return dd(this)};Cf=function Cf(a){if(null==a)return null;var c=$APP.P(a);return null==c?$APP.J($APP.O(a)):$APP.Te($APP.O(a),Cf.g?Cf.g(c):Cf.call(null,c))};
$APP.Lo=function Lo(a){switch(arguments.length){case 0:return Lo.l();case 1:return Lo.g(arguments[0]);case 2:return Lo.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Lo.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.Lo.l=function(){return new $APP.ef(null,function(){return null},null)};$APP.Lo.g=function(a){return new $APP.ef(null,function(){return a},null)};
$APP.Lo.h=function(a,b){return new $APP.ef(null,function(){var c=$APP.J(a);return c?$APP.Wd(c)?$APP.lf($APP.zc(c),$APP.Lo.h($APP.Ac(c),b)):$APP.Te($APP.O(c),$APP.Lo.h($APP.bd(c),b)):b},null)};$APP.Lo.j=function(a,b,c){return function g(e,Df){return new $APP.ef(null,function(){var h=$APP.J(e);return h?$APP.Wd(h)?$APP.lf($APP.zc(h),g($APP.Ac(h),Df)):$APP.Te($APP.O(h),g($APP.bd(h),Df)):$APP.z(Df)?g($APP.O(Df),$APP.P(Df)):null},null)}($APP.Lo.h(a,b),c)};
$APP.Lo.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.Lo.B=2;$APP.Kh=function Kh(a){switch(arguments.length){case 1:return Kh.g(arguments[0]);case 2:return Kh.h(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Kh.j(arguments[0],arguments[1],new $APP.Yc(c.slice(2),0,null))}};$APP.Kh.g=function(){return!1};$APP.Kh.h=function(a,b){return!$APP.vd.h(a,b)};
$APP.Kh.j=function(a,b,c){return $APP.ib(yf($APP.vd,a,b,c))};$APP.Kh.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);c=$APP.P(c);return this.j(b,a,c)};$APP.Kh.B=2;var Lf={},Mo={};Mf.prototype.Ia=function(){this.Oc===Lf?(this.Oc=Mo,this.fc=$APP.J(this.fc)):this.Oc===this.fc&&(this.fc=$APP.P(this.Oc));return null!=this.fc};Mf.prototype.next=function(){if(this.Ia())return this.Oc=this.fc,$APP.O(this.fc);throw Error("No such element");};Mf.prototype.remove=function(){return Error("Unsupported operation")};
$APP.No=function No(a){switch(arguments.length){case 0:return No.l();case 1:return No.g(arguments[0]);case 2:return No.h(arguments[0],arguments[1]);case 3:return No.i(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return No.j(arguments[0],arguments[1],arguments[2],new $APP.Yc(c.slice(3),0,null))}};$APP.No.l=function(){return $APP.Ee};$APP.No.g=function(a){return a};
$APP.No.h=function(a,b){return function(){function c(Wm,m,p){Wm=b.i?b.i(Wm,m,p):b.call(null,Wm,m,p);return a.g?a.g(Wm):a.call(null,Wm)}function d(Wm,m){Wm=b.h?b.h(Wm,m):b.call(null,Wm,m);return a.g?a.g(Wm):a.call(null,Wm)}function e(Wm){Wm=b.g?b.g(Wm):b.call(null,Wm);return a.g?a.g(Wm):a.call(null,Wm)}function Df(){var Wm=b.l?b.l():b.call(null);return a.g?a.g(Wm):a.call(null,Wm)}var g=null,h=function(){function Wm(p,r,t,v){var x=null;if(3<arguments.length){x=0;for(var A=Array(arguments.length-3);x<
A.length;)A[x]=arguments[x+3],++x;x=new $APP.Yc(A,0,null)}return m.call(this,p,r,t,x)}function m(p,r,t,v){p=zf(b,p,r,t,v);return a.g?a.g(p):a.call(null,p)}Wm.B=3;Wm.F=function(p){var r=$APP.O(p);p=$APP.P(p);var t=$APP.O(p);p=$APP.P(p);var v=$APP.O(p);p=$APP.bd(p);return m(r,t,v,p)};Wm.j=m;return Wm}();g=function(Wm,m,p,r){switch(arguments.length){case 0:return Df.call(this);case 1:return e.call(this,Wm);case 2:return d.call(this,Wm,m);case 3:return c.call(this,Wm,m,p);default:var t=null;if(3<arguments.length){t=
0;for(var v=Array(arguments.length-3);t<v.length;)v[t]=arguments[t+3],++t;t=new $APP.Yc(v,0,null)}return h.j(Wm,m,p,t)}throw Error("Invalid arity: "+arguments.length);};g.B=3;g.F=h.F;g.l=Df;g.g=e;g.h=d;g.i=c;g.j=h.j;return g}()};
$APP.No.i=function(a,b,c){return function(){function d(m,p,r){m=c.i?c.i(m,p,r):c.call(null,m,p,r);m=b.g?b.g(m):b.call(null,m);return a.g?a.g(m):a.call(null,m)}function e(m,p){m=c.h?c.h(m,p):c.call(null,m,p);m=b.g?b.g(m):b.call(null,m);return a.g?a.g(m):a.call(null,m)}function Df(m){m=c.g?c.g(m):c.call(null,m);m=b.g?b.g(m):b.call(null,m);return a.g?a.g(m):a.call(null,m)}function g(){var m=c.l?c.l():c.call(null);m=b.g?b.g(m):b.call(null,m);return a.g?a.g(m):a.call(null,m)}var h=null,Wm=function(){function m(r,
t,v,x){var A=null;if(3<arguments.length){A=0;for(var E=Array(arguments.length-3);A<E.length;)E[A]=arguments[A+3],++A;A=new $APP.Yc(E,0,null)}return p.call(this,r,t,v,A)}function p(r,t,v,x){r=zf(c,r,t,v,x);r=b.g?b.g(r):b.call(null,r);return a.g?a.g(r):a.call(null,r)}m.B=3;m.F=function(r){var t=$APP.O(r);r=$APP.P(r);var v=$APP.O(r);r=$APP.P(r);var x=$APP.O(r);r=$APP.bd(r);return p(t,v,x,r)};m.j=p;return m}();h=function(m,p,r,t){switch(arguments.length){case 0:return g.call(this);case 1:return Df.call(this,
m);case 2:return e.call(this,m,p);case 3:return d.call(this,m,p,r);default:var v=null;if(3<arguments.length){v=0;for(var x=Array(arguments.length-3);v<x.length;)x[v]=arguments[v+3],++v;v=new $APP.Yc(x,0,null)}return Wm.j(m,p,r,v)}throw Error("Invalid arity: "+arguments.length);};h.B=3;h.F=Wm.F;h.l=g;h.g=Df;h.h=e;h.i=d;h.j=Wm.j;return h}()};
$APP.No.j=function(a,b,c,d){var e=Re($APP.Te(a,$APP.Te(b,$APP.Te(c,d))));return function(){function Df(h){var Wm=null;if(0<arguments.length){Wm=0;for(var m=Array(arguments.length-0);Wm<m.length;)m[Wm]=arguments[Wm+0],++Wm;Wm=new $APP.Yc(m,0,null)}return g.call(this,Wm)}function g(h){h=$APP.wf($APP.O(e),h);for(var Wm=$APP.P(e);;)if(Wm){var m=$APP.O(Wm);h=m.g?m.g(h):m.call(null,h);Wm=$APP.P(Wm)}else return h}Df.B=0;Df.F=function(h){h=$APP.J(h);return g(h)};Df.j=g;return Df}()};
$APP.No.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);var d=$APP.P(c);c=$APP.O(d);d=$APP.P(d);return this.j(b,a,c,d)};$APP.No.B=3;Xf.prototype.fa=function(a,b){return this===b};Xf.prototype.Mb=function(){return this.state};Xf.prototype.I=function(){return this.H};Xf.prototype.ga=function(){return ja(this)};
$APP.Ei=function Ei(a){switch(arguments.length){case 2:return Ei.h(arguments[0],arguments[1]);case 3:return Ei.i(arguments[0],arguments[1],arguments[2]);case 4:return Ei.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ei.j(arguments[0],arguments[1],arguments[2],arguments[3],new $APP.Yc(c.slice(4),0,null))}};
$APP.Ei.h=function(a,b){if(a instanceof Xf){var c=a.state;b=b.g?b.g(c):b.call(null,c);a=Zf(a,b)}else a=Ao(a,b);return a};$APP.Ei.i=function(a,b,c){if(a instanceof Xf){var d=a.state;b=b.h?b.h(d,c):b.call(null,d,c);a=Zf(a,b)}else a=Ao(a,b,c);return a};$APP.Ei.K=function(a,b,c,d){if(a instanceof Xf){var e=a.state;b=b.i?b.i(e,c,d):b.call(null,e,c,d);a=Zf(a,b)}else a=Ao(a,b,c,d);return a};$APP.Ei.j=function(a,b,c,d,e){return a instanceof Xf?Zf(a,zf(b,a.state,c,d,e)):Ao(a,b,c,d,e)};
$APP.Ei.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);var d=$APP.P(c);c=$APP.O(d);var e=$APP.P(d);d=$APP.O(e);e=$APP.P(e);return this.j(b,a,c,d,e)};$APP.Ei.B=4;$f.prototype.ee=function(a,b){return this.state=b};$f.prototype.Mb=function(){return this.state};
$APP.ig=function ig(a){switch(arguments.length){case 1:return ig.g(arguments[0]);case 2:return ig.h(arguments[0],arguments[1]);case 3:return ig.i(arguments[0],arguments[1],arguments[2]);case 4:return ig.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return ig.j(arguments[0],arguments[1],arguments[2],arguments[3],new $APP.Yc(c.slice(4),0,null))}};
$APP.ig.g=function(a){return function(b){return function(){function c(h,Wm){Wm=a.g?a.g(Wm):a.call(null,Wm);return b.h?b.h(h,Wm):b.call(null,h,Wm)}function d(h){return b.g?b.g(h):b.call(null,h)}function e(){return b.l?b.l():b.call(null)}var Df=null,g=function(){function h(m,p,r){var t=null;if(2<arguments.length){t=0;for(var v=Array(arguments.length-2);t<v.length;)v[t]=arguments[t+2],++t;t=new $APP.Yc(v,0,null)}return Wm.call(this,m,p,t)}function Wm(m,p,r){p=$APP.xf(a,p,r);return b.h?b.h(m,p):b.call(null,
m,p)}h.B=2;h.F=function(m){var p=$APP.O(m);m=$APP.P(m);var r=$APP.O(m);m=$APP.bd(m);return Wm(p,r,m)};h.j=Wm;return h}();Df=function(h,Wm,m){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,h);case 2:return c.call(this,h,Wm);default:var p=null;if(2<arguments.length){p=0;for(var r=Array(arguments.length-2);p<r.length;)r[p]=arguments[p+2],++p;p=new $APP.Yc(r,0,null)}return g.j(h,Wm,p)}throw Error("Invalid arity: "+arguments.length);};Df.B=2;Df.F=g.F;Df.l=e;Df.g=d;Df.h=c;
Df.j=g.j;return Df}()}};$APP.ig.h=function(a,b){return new $APP.ef(null,function(){var c=$APP.J(b);if(c){if($APP.Wd(c)){for(var d=$APP.zc(c),e=$APP.ud(d),Df=$APP.hf(e),g=0;;)if(g<e)mf(Df,function(){var h=$APP.Gd(d,g);return a.g?a.g(h):a.call(null,h)}()),g+=1;else break;return $APP.lf(Df.ba(),$APP.ig.h(a,$APP.Ac(c)))}return $APP.Te(function(){var h=$APP.O(c);return a.g?a.g(h):a.call(null,h)}(),$APP.ig.h(a,$APP.bd(c)))}return null},null)};
$APP.ig.i=function(a,b,c){return new $APP.ef(null,function(){var d=$APP.J(b),e=$APP.J(c);if(d&&e){var Df=$APP.O(d);var g=$APP.O(e);Df=a.h?a.h(Df,g):a.call(null,Df,g);d=$APP.Te(Df,$APP.ig.i(a,$APP.bd(d),$APP.bd(e)))}else d=null;return d},null)};
$APP.ig.K=function(a,b,c,d){return new $APP.ef(null,function(){var e=$APP.J(b),Df=$APP.J(c),g=$APP.J(d);if(e&&Df&&g){var h=$APP.O(e);var Wm=$APP.O(Df),m=$APP.O(g);h=a.i?a.i(h,Wm,m):a.call(null,h,Wm,m);e=$APP.Te(h,$APP.ig.K(a,$APP.bd(e),$APP.bd(Df),$APP.bd(g)))}else e=null;return e},null)};
$APP.ig.j=function(a,b,c,d,e){return $APP.ig.h(function(Df){return $APP.wf(a,Df)},function h(g){return new $APP.ef(null,function(){var Wm=$APP.ig.h($APP.J,g);return $APP.Nf($APP.Ee,Wm)?$APP.Te($APP.ig.h($APP.O,Wm),h($APP.ig.h($APP.bd,Wm))):null},null)}($APP.Qe.j(e,d,$APP.Bd([c,b]))))};$APP.ig.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);var d=$APP.P(c);c=$APP.O(d);var e=$APP.P(d);d=$APP.O(e);e=$APP.P(e);return this.j(b,a,c,d,e)};$APP.ig.B=4;
$APP.Wh=function Wh(a){switch(arguments.length){case 1:return Wh.g(arguments[0]);case 2:return Wh.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};
$APP.Wh.g=function(a){return function(b){var c=Tf(a);return function(){function d(h,Wm){var m=$APP.$b(c),p=c.ee(null,c.Mb(null)-1);h=0<m?b.h?b.h(h,Wm):b.call(null,h,Wm):h;return 0<p?h:$APP.ld(h)?h:kd(h)}function e(h){return b.g?b.g(h):b.call(null,h)}function Df(){return b.l?b.l():b.call(null)}var g=null;g=function(h,Wm){switch(arguments.length){case 0:return Df.call(this);case 1:return e.call(this,h);case 2:return d.call(this,h,Wm)}throw Error("Invalid arity: "+arguments.length);};g.l=Df;g.g=e;g.h=
d;return g}()}};$APP.Wh.h=function(a,b){return new $APP.ef(null,function(){if(0<a){var c=$APP.J(b);return c?$APP.Te($APP.O(c),$APP.Wh.h(a-1,$APP.bd(c))):null}return null},null)};$APP.Wh.B=2;$APP.l=bg.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,this.count)}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return null==this.next?1<this.count?this.next=new bg(null,this.count-1,this.o,null):-1===this.count?this:null:this.next};
$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){if(-1===this.count)for(var c=b.h?b.h(this.o,this.o):b.call(null,this.o,this.o);;){if($APP.ld(c))return $APP.$b(c);c=b.h?b.h(c,this.o):b.call(null,c,this.o)}else for(a=1,c=this.o;;)if(a<this.count){c=b.h?b.h(c,this.o):b.call(null,c,this.o);if($APP.ld(c))return $APP.$b(c);a+=1}else return c};
$APP.l.Ga=function(a,b,c){if(-1===this.count)for(c=b.h?b.h(c,this.o):b.call(null,c,this.o);;){if($APP.ld(c))return $APP.$b(c);c=b.h?b.h(c,this.o):b.call(null,c,this.o)}else for(a=0;;)if(a<this.count){c=b.h?b.h(c,this.o):b.call(null,c,this.o);if($APP.ld(c))return $APP.$b(c);a+=1}else return c};$APP.l.Da=function(){return this.o};$APP.l.Ha=function(){return null==this.next?1<this.count?this.next=new bg(null,this.count-1,this.o,null):-1===this.count?this:$APP.ad:this.next};$APP.l.ia=function(){return this};
$APP.l.J=function(a,b){return b===this.H?this:new bg(b,this.count,this.o,this.next)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};$APP.hg=function hg(a){switch(arguments.length){case 0:return hg.l();case 1:return hg.g(arguments[0]);case 2:return hg.h(arguments[0],arguments[1]);case 3:return hg.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.hg.l=function(){return $APP.fg};$APP.hg.g=function(a){return a};
$APP.hg.h=function(a,b){return null!=a?null!=a&&(a.A&4||$APP.Qc===a.Xe)?$APP.cc($APP.uc($APP.tb($APP.tc,$APP.sc(a),b)),Ld(a)):$APP.tb($APP.Db,a,b):$APP.tb($APP.Qe,a,b)};
$APP.hg.i=function(a,b,c){if(null!=a&&(a.A&4||$APP.Qc===a.Xe)){var d=Ld(a);return Fe(b,function(){function e(g){return $APP.cc($APP.uc(g),d)}var Df=null;Df=function(g,h){switch(arguments.length){case 1:return e.call(this,g);case 2:return $APP.tc(g,h)}throw Error("Invalid arity: "+arguments.length);};Df.g=e;Df.h=function(g,h){return $APP.tc(g,h)};return Df}(),$APP.sc(a),c)}return Fe(b,$APP.Qe,a,c)};$APP.hg.B=3;
$APP.on=function on(a){switch(arguments.length){case 2:return on.h(arguments[0],arguments[1]);case 3:return on.i(arguments[0],arguments[1],arguments[2]);case 4:return on.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return on.j(arguments[0],arguments[1],arguments[2],arguments[3],new $APP.Yc(c.slice(4),0,null))}};
$APP.on.h=function(a,b){return $APP.uc($APP.tb(function(c,d){return $APP.Ma(c,a.g?a.g(d):a.call(null,d))},$APP.sc($APP.fg),b))};$APP.on.i=function(a,b,c){return $APP.hg.h($APP.fg,$APP.ig.i(a,b,c))};$APP.on.K=function(a,b,c,d){return $APP.hg.h($APP.fg,$APP.ig.K(a,b,c,d))};$APP.on.j=function(a,b,c,d,e){return $APP.hg.h($APP.fg,Af($APP.ig,a,b,c,d,$APP.Bd([e])))};
$APP.on.F=function(a){var b=$APP.O(a),c=$APP.P(a);a=$APP.O(c);var d=$APP.P(c);c=$APP.O(d);var e=$APP.P(d);d=$APP.O(e);e=$APP.P(e);return this.j(b,a,c,d,e)};$APP.on.B=4;$APP.Po=function Po(a,b,c){var e=$APP.J(b);b=$APP.O(e);var Df=$APP.P(e);if(Df){e=$APP.kg.i;var g=$APP.R.h(a,b);c=Po.i?Po.i(g,Df,c):Po.call(null,g,Df,c);a=e.call($APP.kg,a,b,c)}else a=$APP.kg.i(a,b,c);return a};
Qo=function Qo(a,b,c,d){var Df=og(c),g=a.C-1>>>b&31;5===b?Df.arr[g]=d:(c=c.arr[g],null!=c?(b-=5,a=Qo.K?Qo.K(a,b,c,d):Qo.call(null,a,b,c,d)):a=qg(null,b-5,d),Df.arr[g]=a);return Df};Ro=function Ro(a,b,c,d,e){var g=og(c);if(0===b)g.arr[d&31]=e;else{var h=d>>>b&31;b-=5;c=c.arr[h];a=Ro.G?Ro.G(a,b,c,d,e):Ro.call(null,a,b,c,d,e);g.arr[h]=a}return g};
So=function So(a,b,c){var e=a.C-2>>>b&31;if(5<b){b-=5;var Df=c.arr[e];a=So.i?So.i(a,b,Df):So.call(null,a,b,Df);if(null==a&&0===e)return null;c=og(c);c.arr[e]=a;return c}if(0===e)return null;c=og(c);c.arr[e]=null;return c};ug.prototype.Ia=function(){return this.D<this.end};ug.prototype.next=function(){32===this.D-this.$d&&(this.arr=sg(this.Ka,this.D),this.$d+=32);var a=this.arr[this.D&31];this.D+=1;return a};$APP.l=$APP.X.prototype;$APP.l.Rc=$APP.Qc;
$APP.l.Ac=function(a,b){return 0<=b&&b<this.C?new $APP.oe(b,sg(this,b)[b&31]):null};$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.xa=function(a,b){return this.T(null,b,null)};$APP.l.T=function(a,b,c){return"number"===typeof b?this.La(null,b,c):c};
$APP.l.kc=function(a,b,c){a=0;for(var d=c;;)if(a<this.C){var e=sg(this,a);c=e.length;a:for(var Df=0;;)if(Df<c){var g=Df+a,h=e[Df];d=b.i?b.i(d,g,h):b.call(null,d,g,h);if($APP.ld(d)){e=d;break a}Df+=1}else{e=d;break a}if($APP.ld(e))return $APP.$b(e);a+=c;d=e}else return d};$APP.l.be=$APP.Qc;$APP.l.ha=function(a,b){return tg(this,b)[b&31]};$APP.l.La=function(a,b,c){return 0<=b&&b<this.C?sg(this,b)[b&31]:c};
$APP.l.lc=function(a,b,c){if(0<=b&&b<this.C)return pg(this)<=b?(a=sb(this.bb),a[b&31]=c,new $APP.X(this.H,this.C,this.shift,this.root,a,null)):new $APP.X(this.H,this.C,this.shift,Ro(this,this.shift,this.root,b,c),this.bb,null);if(b===this.C)return this.Aa(null,c);throw Error(["Index ",$APP.G.g(b)," out of bounds  [0,",$APP.G.g(this.C),"]"].join(""));};$APP.l.gb=function(){return vg(this,0,this.C)};$APP.l.I=function(){return this.H};$APP.l.ja=function(){return this.C};
$APP.l.Cc=function(){return 0<this.C?this.ha(null,this.C-1):null};$APP.l.Dc=function(){if(0===this.C)throw Error("Can't pop empty vector");if(1===this.C)return $APP.cc($APP.fg,this.H);if(1<this.C-pg(this))return new $APP.X(this.H,this.C-1,this.shift,this.root,this.bb.slice(0,-1),null);var a=sg(this,this.C-2),b=So(this,this.shift,this.root);b=null==b?$APP.Z:b;var c=this.C-1;return 5<this.shift&&null==b.arr[1]?new $APP.X(this.H,c,this.shift-5,b.arr[0],a,null):new $APP.X(this.H,c,this.shift,b,a,null)};
$APP.l.Wc=function(){return 0<this.C?new Cd(this,this.C-1,null):null};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){if(b instanceof $APP.X)if(this.C===$APP.ud(b))for(a=this.gb(null),b=b.gb(null);;)if(a.Ia()){var c=a.next(),d=b.next();if(!$APP.vd.h(c,d))return!1}else return!0;else return!1;else return Me(this,b)};$APP.l.zc=function(){return new Mg(this.C,this.shift,Kg.g?Kg.g(this.root):Kg.call(null,this.root),Lg.g?Lg.g(this.bb):Lg.call(null,this.bb))};
$APP.l.Ba=function(){return $APP.cc($APP.fg,this.H)};$APP.l.Fa=function(a,b){return xg(this,b,0,this.C)};$APP.l.Ga=function(a,b,c){a=0;for(var d=c;;)if(a<this.C){var e=sg(this,a);c=e.length;a:for(var Df=0;;)if(Df<c){var g=e[Df];d=b.h?b.h(d,g):b.call(null,d,g);if($APP.ld(d)){e=d;break a}Df+=1}else{e=d;break a}if($APP.ld(e))return $APP.$b(e);a+=c;d=e}else return d};$APP.l.tb=function(a,b,c){if("number"===typeof b)return this.lc(null,b,c);throw Error("Vector's key for assoc must be a number.");};
$APP.l.Lb=function(a,b){return $APP.fe(b)?0<=b&&b<this.C:!1};$APP.l.ia=function(){if(0===this.C)return null;if(32>=this.C)return new $APP.Yc(this.bb,0,null);a:{var a=this.root;for(var b=this.shift;;)if(0<b)b-=5,a=a.arr[0];else{a=a.arr;break a}}return Eg?Eg(this,a,0,0):Gg.call(null,this,a,0,0)};$APP.l.J=function(a,b){return b===this.H?this:new $APP.X(b,this.C,this.shift,this.root,this.bb,this.M)};
$APP.l.Aa=function(a,b){if(32>this.C-pg(this)){a=this.bb.length;for(var c=Array(a+1),d=0;;)if(d<a)c[d]=this.bb[d],d+=1;else break;c[a]=b;return new $APP.X(this.H,this.C+1,this.shift,this.root,c,null)}a=(c=this.C>>>5>1<<this.shift)?this.shift+5:this.shift;c?(c=ng(null),c.arr[0]=this.root,d=qg(null,this.shift,new mg(null,this.bb)),c.arr[1]=d):c=Qo(this,this.shift,this.root,new mg(null,this.bb));return new $APP.X(this.H,this.C+1,a,c,[b],null)};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){if("number"===typeof a)return this.ha(null,a);throw Error("Key must be integer");};
$APP.Z=new mg(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]);$APP.fg=new $APP.X(null,0,5,$APP.Z,[],Co);$APP.X.prototype[Zc]=function(){return dd(this)};$APP.Sf=function Sf(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Sf.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};
$APP.Sf.j=function(a){return a instanceof $APP.Yc&&0===a.D?yg(a.arr,!$APP.gb(a.arr)):$APP.Cg(a)};$APP.Sf.B=0;$APP.Sf.F=function(a){return this.j($APP.J(a))};$APP.l=Dg.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){if(this.Za+1<this.node.length){var a=this.qb;var b=this.node,c=this.D,d=this.Za+1;a=Eg?Eg(a,b,c,d):Gg.call(null,a,b,c,d);return null==a?null:a}return this.pd()};
$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return xg(this.qb,b,this.D+this.Za,$APP.ud(this.qb))};$APP.l.Ga=function(a,b,c){return wg(this.qb,b,c,this.D+this.Za,$APP.ud(this.qb))};$APP.l.Da=function(){return this.node[this.Za]};
$APP.l.Ha=function(){if(this.Za+1<this.node.length){var a=this.qb;var b=this.node,c=this.D,d=this.Za+1;a=Eg?Eg(a,b,c,d):Gg.call(null,a,b,c,d);return null==a?$APP.ad:a}return this.Yb(null)};$APP.l.ia=function(){return this};$APP.l.Qc=function(){var a=this.node;return new jf(a,this.Za,a.length)};$APP.l.Yb=function(){var a=this.D+this.node.length;if(a<zb(this.qb)){var b=this.qb,c=sg(this.qb,a);return Eg?Eg(b,c,a,0):Gg.call(null,b,c,a,0)}return $APP.ad};
$APP.l.J=function(a,b){return b===this.H?this:Fg?Fg(this.qb,this.node,this.D,this.Za,b):Gg.call(null,this.qb,this.node,this.D,this.Za,b)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};$APP.l.pd=function(){var a=this.D+this.node.length;if(a<zb(this.qb)){var b=this.qb,c=sg(this.qb,a);return Eg?Eg(b,c,a,0):Gg.call(null,b,c,a,0)}return null};Dg.prototype[Zc]=function(){return dd(this)};$APP.l=Hg.prototype;$APP.l.Rc=$APP.Qc;
$APP.l.Ac=function(a,b){if(0>b)return null;a=this.start+b;return a<this.end?new $APP.oe(b,$APP.xo(this.Ka,a)):null};$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.xa=function(a,b){return this.T(null,b,null)};$APP.l.T=function(a,b,c){return"number"===typeof b?this.La(null,b,c):c};
$APP.l.kc=function(a,b,c){a=this.start;for(var d=0;;)if(a<this.end){var e=d,Df=$APP.Gd(this.Ka,a);c=b.i?b.i(c,e,Df):b.call(null,c,e,Df);if($APP.ld(c))return $APP.$b(c);d+=1;a+=1}else return c};$APP.l.ha=function(a,b){return 0>b||this.end<=this.start+b?rg(b,this.end-this.start):$APP.Gd(this.Ka,this.start+b)};$APP.l.La=function(a,b,c){return 0>b||this.end<=this.start+b?c:$APP.Gd(this.Ka,this.start+b,c)};
$APP.l.lc=function(a,b,c){a=this.start+b;if(0>b||this.end+1<=a)throw Error(["Index ",$APP.G.g(b)," out of bounds [0,",$APP.G.g(this.ja(null)),"]"].join(""));b=this.H;c=$APP.kg.i(this.Ka,a,c);var d=this.start,e=this.end;a+=1;a=e>a?e:a;return $APP.Ig.G?$APP.Ig.G(b,c,d,a,null):$APP.Ig.call(null,b,c,d,a,null)};$APP.l.gb=function(){return null!=this.Ka&&$APP.Qc===this.Ka.be?vg(this.Ka,this.start,this.end):new Mf(this)};$APP.l.I=function(){return this.H};$APP.l.ja=function(){return this.end-this.start};
$APP.l.Cc=function(){return this.start===this.end?null:$APP.Gd(this.Ka,this.end-1)};$APP.l.Dc=function(){if(this.start===this.end)throw Error("Can't pop empty vector");var a=this.H,b=this.Ka,c=this.start,d=this.end-1;return $APP.Ig.G?$APP.Ig.G(a,b,c,d,null):$APP.Ig.call(null,a,b,c,d,null)};$APP.l.Wc=function(){return this.start!==this.end?new Cd(this,this.end-this.start-1,null):null};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};
$APP.l.Ba=function(){return $APP.cc($APP.fg,this.H)};$APP.l.Fa=function(a,b){return null!=this.Ka&&$APP.Qc===this.Ka.be?xg(this.Ka,b,this.start,this.end):nd(this,b)};$APP.l.Ga=function(a,b,c){return null!=this.Ka&&$APP.Qc===this.Ka.be?wg(this.Ka,b,c,this.start,this.end):od(this,b,c)};$APP.l.tb=function(a,b,c){if("number"===typeof b)return this.lc(null,b,c);throw Error("Subvec's key for assoc must be a number.");};$APP.l.Lb=function(a,b){return $APP.fe(b)?0<=b&&b<this.end-this.start:!1};
$APP.l.ia=function(){var a=this;return function d(c){return c===a.end?null:$APP.Te($APP.Gd(a.Ka,c),new $APP.ef(null,function(){return d(c+1)},null))}(a.start)};$APP.l.J=function(a,b){return b===this.H?this:$APP.Ig.G?$APP.Ig.G(b,this.Ka,this.start,this.end,this.M):$APP.Ig.call(null,b,this.Ka,this.start,this.end,this.M)};$APP.l.Aa=function(a,b){a=this.H;b=Zb(this.Ka,this.end,b);var c=this.start,d=this.end+1;return $APP.Ig.G?$APP.Ig.G(a,b,c,d,null):$APP.Ig.call(null,a,b,c,d,null)};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.ha(null,a)};$APP.l.h=function(a,b){return this.La(null,a,b)};Hg.prototype[Zc]=function(){return dd(this)};
var To=function To(a,b,c,d){c=Jg(a.root.wa,c);var Df=a.C-1>>>b&31;if(5===b)a=d;else{var g=c.arr[Df];null!=g?(b-=5,a=To.K?To.K(a,b,g,d):To.call(null,a,b,g,d)):a=qg(a.root.wa,b-5,d)}c.arr[Df]=a;return c};$APP.l=Mg.prototype;
$APP.l.Fc=function(a,b){if(this.root.wa){if(32>this.C-pg(this))this.bb[this.C&31]=b;else{a=new mg(this.root.wa,this.bb);var c=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];c[0]=b;this.bb=c;this.C>>>5>1<<this.shift?(b=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],c=this.shift+
5,b[0]=this.root,b[1]=qg(this.root.wa,this.shift,a),this.root=new mg(this.root.wa,b),this.shift=c):this.root=To(this,this.shift,this.root,a)}this.C+=1;return this}throw Error("conj! after persistent!");};$APP.l.Xc=function(){if(this.root.wa){this.root.wa=null;var a=this.C-pg(this),b=Array(a);Xd(this.bb,0,b,0,a);return new $APP.X(null,this.C,this.shift,this.root,b,null)}throw Error("persistent! called twice");};
$APP.l.Ec=function(a,b,c){if("number"===typeof b)return Ng(this,b,c);throw Error("TransientVector's key for assoc! must be a number.");};$APP.l.ja=function(){if(this.root.wa)return this.C;throw Error("count after persistent!");};$APP.l.ha=function(a,b){if(this.root.wa)return tg(this,b)[b&31];throw Error("nth after persistent!");};$APP.l.La=function(a,b,c){return 0<=b&&b<this.C?this.ha(null,b):c};$APP.l.xa=function(a,b){return this.T(null,b,null)};
$APP.l.T=function(a,b,c){if(this.root.wa)return"number"===typeof b?this.La(null,b,c):c;throw Error("lookup after persistent!");};$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.xa(null,a)};
$APP.l.h=function(a,b){return this.T(null,a,b)};Og.prototype.fa=function(){return!1};var Pg=new Og;Sg.prototype.next=function(){if(null!=this.W){var a=$APP.O(this.W),b=$APP.Q(a,0,null);a=$APP.Q(a,1,null);this.W=$APP.P(this.W);return{value:[b,a],done:!1}}return{value:null,done:!0}};Tg.prototype.next=function(){if(null!=this.W){var a=$APP.O(this.W);this.W=$APP.P(this.W);return{value:[a,a],done:!1}}return{value:null,done:!0}};$APP.l=$APP.oe.prototype;$APP.l.Rc=$APP.Qc;
$APP.l.Ac=function(a,b){switch(b){case 0:return new $APP.oe(0,this.key);case 1:return new $APP.oe(1,this.o);default:return null}};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.xa=function(a,b){return this.La(null,b,null)};$APP.l.T=function(a,b,c){return this.La(null,b,c)};
$APP.l.ha=function(a,b){if(0===b)return this.key;if(1===b)return this.o;throw Error("Index out of bounds");};$APP.l.La=function(a,b,c){return 0===b?this.key:1===b?this.o:c};$APP.l.lc=function(a,b,c){return(new $APP.X(null,2,5,$APP.Z,[this.key,this.o],null)).lc(null,b,c)};$APP.l.I=function(){return null};$APP.l.ja=function(){return 2};$APP.l.df=function(){return this.key};$APP.l.ef=function(){return this.o};$APP.l.Cc=function(){return this.o};
$APP.l.Dc=function(){return new $APP.X(null,1,5,$APP.Z,[this.key],null)};$APP.l.Wc=function(){return new $APP.Yc([this.o,this.key],0,null)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return null};$APP.l.Fa=function(a,b){return nd(this,b)};$APP.l.Ga=function(a,b,c){return od(this,b,c)};$APP.l.tb=function(a,b,c){return $APP.kg.i(new $APP.X(null,2,5,$APP.Z,[this.key,this.o],null),b,c)};
$APP.l.Lb=function(a,b){return 0===b||1===b};$APP.l.ia=function(){return new $APP.Yc([this.key,this.o],0,null)};$APP.l.J=function(a,b){return Kd(new $APP.X(null,2,5,$APP.Z,[this.key,this.o],null),b)};$APP.l.Aa=function(a,b){return new $APP.X(null,3,5,$APP.Z,[this.key,this.o,b],null)};$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};
$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.ha(null,a)};$APP.l.h=function(a,b){return this.La(null,a,b)};$APP.l=Vg.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.xb};$APP.l.Ca=function(){return this.D<this.arr.length-2?new Vg(this.arr,this.D+2,null):null};$APP.l.ja=function(){return(this.arr.length-this.D)/2};$APP.l.ga=function(){return fd(this)};
$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return new $APP.oe(this.arr[this.D],this.arr[this.D+1])};$APP.l.Ha=function(){return this.D<this.arr.length-2?new Vg(this.arr,this.D+2,null):$APP.ad};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.xb?this:new Vg(this.arr,this.D,b)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};
Vg.prototype[Zc]=function(){return dd(this)};Wg.prototype.Ia=function(){return this.D<this.C};Wg.prototype.next=function(){var a=new $APP.oe(this.arr[this.D],this.arr[this.D+1]);this.D+=2;return a};$APP.l=$APP.n.prototype;$APP.l.Rc=$APP.Qc;$APP.l.Ac=function(a,b){a=Ug(this.arr,b);return-1===a?null:new $APP.oe(this.arr[a],this.arr[a+1])};$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.keys=function(){return dd($APP.Fh.g?$APP.Fh.g(this):$APP.Fh.call(null,this))};$APP.l.entries=function(){return new Sg($APP.J($APP.J(this)))};
$APP.l.values=function(){return dd(Hh.g?Hh.g(this):Hh.call(null,this))};$APP.l.has=function(a){return $APP.ne(this,a)};$APP.l.get=function(a,b){return this.T(null,a,b)};
$APP.l.forEach=function(a){for(var b=$APP.J(this),c=null,d=0,e=0;;)if(e<d){var Df=c.ha(null,e),g=$APP.Q(Df,0,null);Df=$APP.Q(Df,1,null);a.h?a.h(Df,g):a.call(null,Df,g);e+=1}else if(b=$APP.J(b))$APP.Wd(b)?(c=$APP.zc(b),b=$APP.Ac(b),g=c,d=$APP.ud(c),c=g):(c=$APP.O(b),g=$APP.Q(c,0,null),Df=$APP.Q(c,1,null),a.h?a.h(Df,g):a.call(null,Df,g),b=$APP.P(b),c=null,d=0),e=0;else return null};$APP.l.xa=function(a,b){return this.T(null,b,null)};
$APP.l.T=function(a,b,c){a=Ug(this.arr,b);return-1===a?c:this.arr[a+1]};$APP.l.kc=function(a,b,c){a=this.arr.length;for(var d=0;;)if(d<a){var e=this.arr[d],Df=this.arr[d+1];c=b.i?b.i(c,e,Df):b.call(null,c,e,Df);if($APP.ld(c))return $APP.$b(c);d+=2}else return c};$APP.l.gb=function(){return new Wg(this.arr,2*this.C)};$APP.l.I=function(){return this.H};$APP.l.ja=function(){return this.C};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=$APP.gd(this)};
$APP.l.fa=function(a,b){if($APP.Td(b)&&!$APP.Ud(b))if(a=this.arr.length,this.C===b.ja(null))for(var c=0;;)if(c<a){var d=b.T(null,this.arr[c],me);if(d!==me)if($APP.vd.h(this.arr[c+1],d))c+=2;else return!1;else return!1}else return!0;else return!1;else return!1};$APP.l.zc=function(){return new Yg(this.arr.length,sb(this.arr))};$APP.l.Ba=function(){return $APP.cc($APP.Jf,this.H)};$APP.l.Fa=function(a,b){return ze(this,b)};$APP.l.Ga=function(a,b,c){return Ae(this,b,c)};
$APP.l.Sc=function(a,b){if(0<=Ug(this.arr,b)){a=this.arr.length;var c=a-2;if(0===c)return this.Ba(null);c=Array(c);for(var d=0,e=0;;){if(d>=a)return new $APP.n(this.H,this.C-1,c,null);$APP.vd.h(b,this.arr[d])?d+=2:(c[e]=this.arr[d],c[e+1]=this.arr[d+1],e+=2,d+=2)}}else return this};
$APP.l.tb=function(a,b,c){a=Ug(this.arr,b);if(-1===a){if(this.C<Uo){a=this.arr;for(var d=a.length,e=Array(d+2),Df=0;;)if(Df<d)e[Df]=a[Df],Df+=1;else break;e[d]=b;e[d+1]=c;return new $APP.n(this.H,this.C+1,e,null)}return $APP.cc(Nb($APP.hg.h(Zg,this),b,c),this.H)}if(c===this.arr[a+1])return this;b=sb(this.arr);b[a+1]=c;return new $APP.n(this.H,this.C,b,null)};$APP.l.Lb=function(a,b){return-1!==Ug(this.arr,b)};$APP.l.ia=function(){var a=this.arr;return 0<=a.length-2?new Vg(a,0,null):null};
$APP.l.J=function(a,b){return b===this.H?this:new $APP.n(b,this.C,this.arr,this.M)};$APP.l.Aa=function(a,b){if($APP.Vd(b))return this.tb(null,$APP.Gd(b,0),$APP.Gd(b,1));a=this;for(b=$APP.J(b);;){if(null==b)return a;var c=$APP.O(b);if($APP.Vd(c))a=Nb(a,$APP.Gd(c,0),$APP.Gd(c,1)),b=$APP.P(b);else throw Error("conj on a map takes map entries or seqables of map entries");}};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.xa(null,a)};$APP.l.h=function(a,b){return this.T(null,a,b)};$APP.Jf=new $APP.n(null,0,[],Do);Uo=8;$APP.n.prototype[Zc]=function(){return dd(this)};$APP.l=Yg.prototype;
$APP.l.ja=function(){if(this.Ic)return $APP.He(this.rc,2);throw Error("count after persistent!");};$APP.l.xa=function(a,b){return this.T(null,b,null)};$APP.l.T=function(a,b,c){if(this.Ic)return a=Ug(this.arr,b),-1===a?c:this.arr[a+1];throw Error("lookup after persistent!");};
$APP.l.Fc=function(a,b){if(this.Ic){if($APP.zg(b))return this.Ec(null,Ag.g?Ag.g(b):Ag.call(null,b),Bg.g?Bg.g(b):Bg.call(null,b));if($APP.Vd(b))return this.Ec(null,b.g?b.g(0):b.call(null,0),b.g?b.g(1):b.call(null,1));a=$APP.J(b);for(b=this;;){var c=$APP.O(a);if($APP.z(c))a=$APP.P(a),b=vc(b,Ag.g?Ag.g(c):Ag.call(null,c),Bg.g?Bg.g(c):Bg.call(null,c));else return b}}else throw Error("conj! after persistent!");};
$APP.l.Xc=function(){if(this.Ic)return this.Ic=!1,new $APP.n(null,$APP.He(this.rc,2),this.arr,null);throw Error("persistent! called twice");};$APP.l.Ec=function(a,b,c){if(this.Ic){a=Ug(this.arr,b);if(-1===a)return this.rc+2<=2*Uo?(this.rc+=2,this.arr.push(b),this.arr.push(c),this):$APP.pf($g.h?$g.h(this.rc,this.arr):$g.call(null,this.rc,this.arr),b,c);c!==this.arr[a+1]&&(this.arr[a+1]=c);return this}throw Error("assoc! after persistent!");};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.T(null,a,null)};$APP.l.h=function(a,b){return this.T(null,a,b)};
gh.prototype.advance=function(){for(var a=this.arr.length;;)if(this.D<a){var b=this.arr[this.D],c=this.arr[this.D+1];null!=b?b=this.kd=new $APP.oe(b,c):null!=c?(b=$APP.Gc(c),b=b.Ia()?this.Db=b:!1):b=!1;this.D+=2;if(b)return!0}else return!1};gh.prototype.Ia=function(){var a=null!=this.kd;return a?a:(a=null!=this.Db)?a:this.advance()};
gh.prototype.next=function(){if(null!=this.kd){var a=this.kd;this.kd=null;return a}if(null!=this.Db)return a=this.Db.next(),this.Db.Ia()||(this.Db=null),a;if(this.advance())return this.next();throw Error("No such element");};gh.prototype.remove=function(){return Error("Unsupported operation")};$APP.l=hh.prototype;$APP.l.mc=function(a){if(a===this.wa)return this;var b=Ie(this.ya),c=Array(0>b?4:2*(b+1));Xd(this.arr,0,c,0,2*b);return new hh(a,this.ya,c)};
$APP.l.bd=function(){return rh?rh(this.arr):th.call(null,this.arr)};$APP.l.dd=function(a,b){return fh(this.arr,a,b)};$APP.l.cc=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.ya&e))return d;var Df=Ie(this.ya&e-1);e=this.arr[2*Df];Df=this.arr[2*Df+1];return null==e?Df.cc(a+5,b,c,d):bh(c,e)?Df:d};
$APP.l.Bb=function(a,b,c,d,e,Df){var g=1<<(c>>>b&31),h=Ie(this.ya&g-1);if(0===(this.ya&g)){var Wm=Ie(this.ya);if(2*Wm<this.arr.length){a=this.mc(a);b=a.arr;Df.o=!0;c=2*(Wm-h);Df=2*h+(c-1);for(Wm=2*(h+1)+(c-1);0!==c;)b[Wm]=b[Df],--Wm,--c,--Df;b[2*h]=d;b[2*h+1]=e;a.ya|=g;return a}if(16<=Wm){h=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];h[c>>>b&31]=ph.Bb(a,b+5,c,d,e,Df);for(e=d=0;;)if(32>
d)0===(this.ya>>>d&1)?d+=1:(h[d]=null!=this.arr[e]?ph.Bb(a,b+5,Rc(this.arr[e]),this.arr[e],this.arr[e+1],Df):this.arr[e+1],e+=2,d+=1);else break;return new jh(a,Wm+1,h)}b=Array(2*(Wm+4));Xd(this.arr,0,b,0,2*h);b[2*h]=d;b[2*h+1]=e;Xd(this.arr,2*h,b,2*(h+1),2*(Wm-h));Df.o=!0;a=this.mc(a);a.arr=b;a.ya|=g;return a}Wm=this.arr[2*h];g=this.arr[2*h+1];if(null==Wm)return Wm=g.Bb(a,b+5,c,d,e,Df),Wm===g?this:eh(this,a,2*h+1,Wm);if(bh(d,Wm))return e===g?this:eh(this,a,2*h+1,e);Df.o=!0;Df=b+5;d=nh?nh(a,Df,Wm,
g,c,d,e):oh.call(null,a,Df,Wm,g,c,d,e);e=2*h;h=2*h+1;a=this.mc(a);a.arr[e]=null;a.arr[h]=d;return a};
$APP.l.Ab=function(a,b,c,d,e){var Df=1<<(b>>>a&31),g=Ie(this.ya&Df-1);if(0===(this.ya&Df)){var h=Ie(this.ya);if(16<=h){g=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];g[b>>>a&31]=ph.Ab(a+5,b,c,d,e);for(d=c=0;;)if(32>c)0===(this.ya>>>c&1)?c+=1:(g[c]=null!=this.arr[d]?ph.Ab(a+5,Rc(this.arr[d]),this.arr[d],this.arr[d+1],e):this.arr[d+1],d+=2,c+=1);else break;return new jh(null,h+1,g)}a=
Array(2*(h+1));Xd(this.arr,0,a,0,2*g);a[2*g]=c;a[2*g+1]=d;Xd(this.arr,2*g,a,2*(g+1),2*(h-g));e.o=!0;return new hh(null,this.ya|Df,a)}var Wm=this.arr[2*g];Df=this.arr[2*g+1];if(null==Wm)return h=Df.Ab(a+5,b,c,d,e),h===Df?this:new hh(null,this.ya,ch(this.arr,2*g+1,h));if(bh(c,Wm))return d===Df?this:new hh(null,this.ya,ch(this.arr,2*g+1,d));e.o=!0;e=this.ya;h=this.arr;a+=5;a=mh?mh(a,Wm,Df,b,c,d):oh.call(null,a,Wm,Df,b,c,d);c=2*g;g=2*g+1;d=sb(h);d[c]=null;d[g]=a;return new hh(null,e,d)};
$APP.l.ad=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.ya&e))return d;var Df=Ie(this.ya&e-1);e=this.arr[2*Df];Df=this.arr[2*Df+1];return null==e?Df.ad(a+5,b,c,d):bh(c,e)?new $APP.oe(e,Df):d};
$APP.l.cd=function(a,b,c){var d=1<<(b>>>a&31);if(0===(this.ya&d))return this;var e=Ie(this.ya&d-1),Df=this.arr[2*e],g=this.arr[2*e+1];return null==Df?(a=g.cd(a+5,b,c),a===g?this:null!=a?new hh(null,this.ya,ch(this.arr,2*e+1,a)):this.ya===d?null:new hh(null,this.ya^d,dh(this.arr,e))):bh(c,Df)?this.ya===d?null:new hh(null,this.ya^d,dh(this.arr,e)):this};$APP.l.gb=function(){return new gh(this.arr)};var ph=new hh(null,0,[]);
ih.prototype.Ia=function(){for(var a=this.arr.length;;){if(null!=this.Db&&this.Db.Ia())return!0;if(this.D<a){var b=this.arr[this.D];this.D+=1;null!=b&&(this.Db=$APP.Gc(b))}else return!1}};ih.prototype.next=function(){if(this.Ia())return this.Db.next();throw Error("No such element");};ih.prototype.remove=function(){return Error("Unsupported operation")};$APP.l=jh.prototype;$APP.l.mc=function(a){return a===this.wa?this:new jh(a,this.C,sb(this.arr))};
$APP.l.bd=function(){return wh?wh(this.arr):yh.call(null,this.arr)};$APP.l.dd=function(a,b){for(var c=this.arr.length,d=0;;)if(d<c){var e=this.arr[d];if(null!=e){b=e.dd(a,b);if($APP.ld(b))return b;d+=1}else d+=1}else return b};$APP.l.cc=function(a,b,c,d){var e=this.arr[b>>>a&31];return null!=e?e.cc(a+5,b,c,d):d};$APP.l.Bb=function(a,b,c,d,e,Df){var g=c>>>b&31,h=this.arr[g];if(null==h)return a=eh(this,a,g,ph.Bb(a,b+5,c,d,e,Df)),a.C+=1,a;b=h.Bb(a,b+5,c,d,e,Df);return b===h?this:eh(this,a,g,b)};
$APP.l.Ab=function(a,b,c,d,e){var Df=b>>>a&31,g=this.arr[Df];if(null==g)return new jh(null,this.C+1,ch(this.arr,Df,ph.Ab(a+5,b,c,d,e)));a=g.Ab(a+5,b,c,d,e);return a===g?this:new jh(null,this.C,ch(this.arr,Df,a))};$APP.l.ad=function(a,b,c,d){var e=this.arr[b>>>a&31];return null!=e?e.ad(a+5,b,c,d):d};
$APP.l.cd=function(a,b,c){var d=b>>>a&31,e=this.arr[d];if(null!=e){a=e.cd(a+5,b,c);if(a===e)d=this;else if(null==a)if(8>=this.C)a:{e=this.arr;a=e.length;b=Array(2*(this.C-1));c=0;for(var Df=1,g=0;;)if(c<a)c!==d&&null!=e[c]?(b[Df]=e[c],Df+=2,g|=1<<c,c+=1):c+=1;else{d=new hh(null,g,b);break a}}else d=new jh(null,this.C-1,ch(this.arr,d,a));else d=new jh(null,this.C,ch(this.arr,d,a));return d}return this};$APP.l.gb=function(){return new ih(this.arr)};$APP.l=lh.prototype;
$APP.l.mc=function(a){if(a===this.wa)return this;var b=Array(2*(this.C+1));Xd(this.arr,0,b,0,2*this.C);return new lh(a,this.Pb,this.C,b)};$APP.l.bd=function(){return rh?rh(this.arr):th.call(null,this.arr)};$APP.l.dd=function(a,b){return fh(this.arr,a,b)};$APP.l.cc=function(a,b,c,d){a=kh(this.arr,this.C,c);return 0>a?d:bh(c,this.arr[a])?this.arr[a+1]:d};
$APP.l.Bb=function(a,b,c,d,e,Df){if(c===this.Pb){b=kh(this.arr,this.C,d);if(-1===b){if(this.arr.length>2*this.C)return b=2*this.C,c=2*this.C+1,a=this.mc(a),a.arr[b]=d,a.arr[c]=e,Df.o=!0,a.C+=1,a;c=this.arr.length;b=Array(c+2);Xd(this.arr,0,b,0,c);b[c]=d;b[c+1]=e;Df.o=!0;d=this.C+1;a===this.wa?(this.arr=b,this.C=d,a=this):a=new lh(this.wa,this.Pb,d,b);return a}return this.arr[b+1]===e?this:eh(this,a,b+1,e)}return(new hh(a,1<<(this.Pb>>>b&31),[null,this,null,null])).Bb(a,b,c,d,e,Df)};
$APP.l.Ab=function(a,b,c,d,e){return b===this.Pb?(a=kh(this.arr,this.C,c),-1===a?(a=2*this.C,b=Array(a+2),Xd(this.arr,0,b,0,a),b[a]=c,b[a+1]=d,e.o=!0,new lh(null,this.Pb,this.C+1,b)):$APP.vd.h(this.arr[a+1],d)?this:new lh(null,this.Pb,this.C,ch(this.arr,a+1,d))):(new hh(null,1<<(this.Pb>>>a&31),[null,this])).Ab(a,b,c,d,e)};$APP.l.ad=function(a,b,c,d){a=kh(this.arr,this.C,c);return 0>a?d:bh(c,this.arr[a])?new $APP.oe(this.arr[a],this.arr[a+1]):d};
$APP.l.cd=function(a,b,c){a=kh(this.arr,this.C,c);return-1===a?this:1===this.C?null:new lh(null,this.Pb,this.C-1,dh(this.arr,$APP.He(a,2)))};$APP.l.gb=function(){return new gh(this.arr)};$APP.l=qh.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};
$APP.l.Ca=function(){if(null==this.W){var a=this.Eb,b=this.D+2;return sh?sh(a,b,null):th.call(null,a,b,null)}a=this.Eb;b=this.D;var c=$APP.P(this.W);return sh?sh(a,b,c):th.call(null,a,b,c)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};
$APP.l.Da=function(){return null==this.W?new $APP.oe(this.Eb[this.D],this.Eb[this.D+1]):$APP.O(this.W)};$APP.l.Ha=function(){var a=this,b=null==a.W?function(){var c=a.Eb,d=a.D+2;return sh?sh(c,d,null):th.call(null,c,d,null)}():function(){var c=a.Eb,d=a.D,e=$APP.P(a.W);return sh?sh(c,d,e):th.call(null,c,d,e)}();return null!=b?b:$APP.ad};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.H?this:new qh(b,this.Eb,this.D,this.W,this.M)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};
qh.prototype[Zc]=function(){return dd(this)};$APP.l=uh.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.H};$APP.l.Ca=function(){var a=this.Eb,b=this.D,c=$APP.P(this.W);return xh?xh(a,b,c):yh.call(null,a,b,c)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};
$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return $APP.O(this.W)};$APP.l.Ha=function(){var a=this.Eb;var b=this.D,c=$APP.P(this.W);a=xh?xh(a,b,c):yh.call(null,a,b,c);return null!=a?a:$APP.ad};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.H?this:new uh(b,this.Eb,this.D,this.W,this.M)};
$APP.l.Aa=function(a,b){return $APP.Te(b,this)};uh.prototype[Zc]=function(){return dd(this)};zh.prototype.Ia=function(){return!this.qe||this.Qe.Ia()};zh.prototype.next=function(){if(this.qe)return this.Qe.next();this.qe=!0;return new $APP.oe(null,this.ab)};zh.prototype.remove=function(){return Error("Unsupported operation")};$APP.l=Ah.prototype;$APP.l.Rc=$APP.Qc;$APP.l.Ac=function(a,b){return null==b?this.$a?new $APP.oe(null,this.ab):null:null==this.root?null:this.root.ad(0,Rc(b),b,null)};
$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.keys=function(){return dd($APP.Fh.g?$APP.Fh.g(this):$APP.Fh.call(null,this))};$APP.l.entries=function(){return new Sg($APP.J($APP.J(this)))};$APP.l.values=function(){return dd(Hh.g?Hh.g(this):Hh.call(null,this))};$APP.l.has=function(a){return $APP.ne(this,a)};$APP.l.get=function(a,b){return this.T(null,a,b)};
$APP.l.forEach=function(a){for(var b=$APP.J(this),c=null,d=0,e=0;;)if(e<d){var Df=c.ha(null,e),g=$APP.Q(Df,0,null);Df=$APP.Q(Df,1,null);a.h?a.h(Df,g):a.call(null,Df,g);e+=1}else if(b=$APP.J(b))$APP.Wd(b)?(c=$APP.zc(b),b=$APP.Ac(b),g=c,d=$APP.ud(c),c=g):(c=$APP.O(b),g=$APP.Q(c,0,null),Df=$APP.Q(c,1,null),a.h?a.h(Df,g):a.call(null,Df,g),b=$APP.P(b),c=null,d=0),e=0;else return null};$APP.l.xa=function(a,b){return this.T(null,b,null)};
$APP.l.T=function(a,b,c){return null==b?this.$a?this.ab:c:null==this.root?c:this.root.cc(0,Rc(b),b,c)};$APP.l.kc=function(a,b,c){a=this.$a?b.i?b.i(c,null,this.ab):b.call(null,c,null,this.ab):c;$APP.ld(a)?b=$APP.$b(a):null!=this.root?(b=this.root.dd(b,a),b=$APP.ld(b)?md.g?md.g(b):md.call(null,b):b):b=a;return b};$APP.l.gb=function(){var a=this.root?$APP.Gc(this.root):$APP.Kf();return this.$a?new zh(this.ab,a):a};$APP.l.I=function(){return this.H};$APP.l.ja=function(){return this.C};
$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=$APP.gd(this)};$APP.l.fa=function(a,b){return Qg(this,b)};$APP.l.zc=function(){return new Ch(this.root,this.C,this.$a,this.ab)};$APP.l.Ba=function(){return $APP.cc(Zg,this.H)};$APP.l.Sc=function(a,b){if(null==b)return this.$a?new Ah(this.H,this.C-1,this.root,!1,null,null):this;if(null==this.root)return this;a=this.root.cd(0,Rc(b),b);return a===this.root?this:new Ah(this.H,this.C-1,a,this.$a,this.ab,null)};
$APP.l.tb=function(a,b,c){if(null==b)return this.$a&&c===this.ab?this:new Ah(this.H,this.$a?this.C:this.C+1,this.root,!0,c,null);a=new ah;b=(null==this.root?ph:this.root).Ab(0,Rc(b),b,c,a);return b===this.root?this:new Ah(this.H,a.o?this.C+1:this.C,b,this.$a,this.ab,null)};$APP.l.Lb=function(a,b){return null==b?this.$a:null==this.root?!1:this.root.cc(0,Rc(b),b,me)!==me};
$APP.l.ia=function(){if(0<this.C){var a=null!=this.root?this.root.bd():null;return this.$a?$APP.Te(new $APP.oe(null,this.ab),a):a}return null};$APP.l.J=function(a,b){return b===this.H?this:new Ah(b,this.C,this.root,this.$a,this.ab,this.M)};
$APP.l.Aa=function(a,b){if($APP.Vd(b))return this.tb(null,$APP.Gd(b,0),$APP.Gd(b,1));a=this;for(b=$APP.J(b);;){if(null==b)return a;var c=$APP.O(b);if($APP.Vd(c))a=Nb(a,$APP.Gd(c,0),$APP.Gd(c,1)),b=$APP.P(b);else throw Error("conj on a map takes map entries or seqables of map entries");}};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.xa(null,a)};$APP.l.h=function(a,b){return this.T(null,a,b)};var Zg=new Ah(null,0,null,!1,null,Do);Ah.prototype[Zc]=function(){return dd(this)};$APP.l=Ch.prototype;
$APP.l.ja=function(){if(this.wa)return this.count;throw Error("count after persistent!");};$APP.l.xa=function(a,b){return null==b?this.$a?this.ab:null:null==this.root?null:this.root.cc(0,Rc(b),b)};$APP.l.T=function(a,b,c){return null==b?this.$a?this.ab:c:null==this.root?c:this.root.cc(0,Rc(b),b,c)};
$APP.l.Fc=function(a,b){a:if(this.wa)if($APP.zg(b))a=Dh(this,Ag.g?Ag.g(b):Ag.call(null,b),Bg.g?Bg.g(b):Bg.call(null,b));else if($APP.Vd(b))a=Dh(this,b.g?b.g(0):b.call(null,0),b.g?b.g(1):b.call(null,1));else for(a=$APP.J(b),b=this;;){var c=$APP.O(a);if($APP.z(c))a=$APP.P(a),b=Dh(b,Ag.g?Ag.g(c):Ag.call(null,c),Bg.g?Bg.g(c):Bg.call(null,c));else{a=b;break a}}else throw Error("conj! after persistent");return a};
$APP.l.Xc=function(){if(this.wa){this.wa=null;var a=new Ah(null,this.count,this.root,this.$a,this.ab,null)}else throw Error("persistent! called twice");return a};$APP.l.Ec=function(a,b,c){return Dh(this,b,c)};$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};
$APP.l.g=function(a){return this.xa(null,a)};$APP.l.h=function(a,b){return this.T(null,a,b)};$APP.Ci=function Ci(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ci.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};$APP.Ci.j=function(a){a=a instanceof $APP.Yc&&0===a.D?a.arr:vb(a);if(!$APP.eg(a.length))throw Error(["No value supplied for key: ",$APP.G.g($APP.Ed(a))].join(""));return Xg(a)};$APP.Ci.B=0;$APP.Ci.F=function(a){return this.j($APP.J(a))};
$APP.l=Eh.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.xb};
$APP.l.Ca=function(){var a=(null!=this.Y?this.Y.s&128||$APP.Qc===this.Y.Vc||(this.Y.s?0:$APP.ob(Ib,this.Y)):$APP.ob(Ib,this.Y))?this.Y.Ca(null):$APP.P(this.Y);return null==a?null:new Eh(a,null)};$APP.l.ga=function(){return fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return this.Y.Da(null).key};
$APP.l.Ha=function(){var a=(null!=this.Y?this.Y.s&128||$APP.Qc===this.Y.Vc||(this.Y.s?0:$APP.ob(Ib,this.Y)):$APP.ob(Ib,this.Y))?this.Y.Ca(null):$APP.P(this.Y);return null!=a?new Eh(a,null):$APP.ad};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.xb?this:new Eh(this.Y,b)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};Eh.prototype[Zc]=function(){return dd(this)};$APP.l=Gh.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();$APP.l.I=function(){return this.xb};
$APP.l.Ca=function(){var a=(null!=this.Y?this.Y.s&128||$APP.Qc===this.Y.Vc||(this.Y.s?0:$APP.ob(Ib,this.Y)):$APP.ob(Ib,this.Y))?this.Y.Ca(null):$APP.P(this.Y);return null==a?null:new Gh(a,null)};$APP.l.ga=function(){return fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){return xe(b,c,this)};$APP.l.Da=function(){return this.Y.Da(null).o};
$APP.l.Ha=function(){var a=(null!=this.Y?this.Y.s&128||$APP.Qc===this.Y.Vc||(this.Y.s?0:$APP.ob(Ib,this.Y)):$APP.ob(Ib,this.Y))?this.Y.Ca(null):$APP.P(this.Y);return null!=a?new Gh(a,null):$APP.ad};$APP.l.ia=function(){return this};$APP.l.J=function(a,b){return b===this.xb?this:new Gh(this.Y,b)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};Gh.prototype[Zc]=function(){return dd(this)};
$APP.Fk=function Fk(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Fk.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};$APP.Fk.j=function(a){return $APP.z($APP.Of($APP.Ee,a))?Be(function(b,c){return $APP.Qe.h($APP.z(b)?b:$APP.Jf,c)},a):null};$APP.Fk.B=0;$APP.Fk.F=function(a){return this.j($APP.J(a))};Mh.prototype.Ia=function(){return this.Kc.Ia()};Mh.prototype.next=function(){if(this.Kc.Ia())return this.Kc.next().key;throw Error("No such element");};
Mh.prototype.remove=function(){return Error("Unsupported operation")};$APP.l=$APP.Nh.prototype;$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.keys=function(){return dd($APP.J(this))};$APP.l.entries=function(){return new Tg($APP.J($APP.J(this)))};$APP.l.values=function(){return dd($APP.J(this))};$APP.l.has=function(a){return $APP.ne(this,a)};
$APP.l.forEach=function(a){for(var b=$APP.J(this),c=null,d=0,e=0;;)if(e<d){var Df=c.ha(null,e),g=$APP.Q(Df,0,null);Df=$APP.Q(Df,1,null);a.h?a.h(Df,g):a.call(null,Df,g);e+=1}else if(b=$APP.J(b))$APP.Wd(b)?(c=$APP.zc(b),b=$APP.Ac(b),g=c,d=$APP.ud(c),c=g):(c=$APP.O(b),g=$APP.Q(c,0,null),Df=$APP.Q(c,1,null),a.h?a.h(Df,g):a.call(null,Df,g),b=$APP.P(b),c=null,d=0),e=0;else return null};$APP.l.xa=function(a,b){return this.T(null,b,null)};
$APP.l.T=function(a,b,c){a=Pb(this.bc,b);return $APP.z(a)?$APP.Sb(a):c};$APP.l.gb=function(){return new Mh($APP.Gc(this.bc))};$APP.l.I=function(){return this.H};$APP.l.ja=function(){return zb(this.bc)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=$APP.gd(this)};$APP.l.fa=function(a,b){if(a=$APP.Qd(b))if(a=$APP.ud(this)===$APP.ud(b))try{return De(function(c,d){return(c=$APP.ne(b,d))?c:kd(!1)},!0,this.bc)}catch(c){if(c instanceof Error)return!1;throw c;}else return a;else return a};
$APP.l.zc=function(){return new Qh($APP.sc(this.bc))};$APP.l.Ba=function(){return $APP.cc($APP.Oh,this.H)};$APP.l.ia=function(){return $APP.Fh(this.bc)};$APP.l.J=function(a,b){return b===this.H?this:new $APP.Nh(b,this.bc,this.M)};$APP.l.Aa=function(a,b){return new $APP.Nh(this.H,$APP.kg.i(this.bc,b,null),null)};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return this.xa(null,a)};$APP.l.h=function(a,b){return this.T(null,a,b)};$APP.Oh=new $APP.Nh(null,$APP.Jf,Do);$APP.Nh.prototype[Zc]=function(){return dd(this)};$APP.l=Qh.prototype;
$APP.l.Fc=function(a,b){this.Xb=vc(this.Xb,b,null);return this};$APP.l.Xc=function(){return new $APP.Nh(null,$APP.uc(this.Xb),null)};$APP.l.ja=function(){return $APP.ud(this.Xb)};$APP.l.xa=function(a,b){return this.T(null,b,null)};$APP.l.T=function(a,b,c){return $APP.xo(this.Xb,b,me)===me?c:b};
$APP.l.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.g=function(a){return $APP.xo(this.Xb,a,me)===me?null:a};$APP.l.h=function(a,b){return $APP.xo(this.Xb,a,me)===me?b:a};$APP.l=Yh.prototype;$APP.l.ja=function(){return this.count};$APP.l.Da=function(){return this.start};
$APP.l.ha=function(a,b){return this.start+b*this.step};$APP.l.La=function(a,b,c){return 0<=b&&b<this.count?this.start+b*this.step:c};$APP.l.ce=function(){if(1>=this.count)throw Error("-drop-first of empty chunk");return new Yh(this.start+this.step,this.step,this.count-1)};Zh.prototype.Ia=function(){return 0<this.step?this.D<this.end:this.D>this.end};Zh.prototype.next=function(){var a=this.D;this.D+=this.step;return a};$APP.l=$APP.$h.prototype;$APP.l.toString=function(){return $APP.Ic(this)};
$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();
$APP.l.$c=function(){if(null==this.ba){var a=this.ja(null);32<a?(this.Kb=new $APP.$h(null,this.start+32*this.step,this.end,this.step,null,null,null),this.ba=new Yh(this.start,this.step,32)):this.ba=new Yh(this.start,this.step,a)}};$APP.l.ha=function(a,b){if(0<=b&&b<this.ja(null))return this.start+b*this.step;if(0<=b&&this.start>this.end&&0===this.step)return this.start;throw Error("Index out of bounds");};
$APP.l.La=function(a,b,c){return 0<=b&&b<this.ja(null)?this.start+b*this.step:0<=b&&this.start>this.end&&0===this.step?this.start:c};$APP.l.gb=function(){return new Zh(this.start,this.end,this.step)};$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return 0<this.step?this.start+this.step<this.end?new $APP.$h(null,this.start+this.step,this.end,this.step,null,null,null):null:this.start+this.step>this.end?new $APP.$h(null,this.start+this.step,this.end,this.step,null,null,null):null};
$APP.l.ja=function(){return Math.ceil((this.end-this.start)/this.step)};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};$APP.l.Fa=function(a,b){return nd(this,b)};$APP.l.Ga=function(a,b,c){for(a=this.start;;)if(0<this.step?a<this.end:a>this.end){c=b.h?b.h(c,a):b.call(null,c,a);if($APP.ld(c))return $APP.$b(c);a+=this.step}else return c};$APP.l.Da=function(){return this.start};
$APP.l.Ha=function(){var a=this.Ca(null);return null==a?$APP.ad:a};$APP.l.ia=function(){return this};$APP.l.Qc=function(){this.$c();return this.ba};$APP.l.Yb=function(){this.$c();return null==this.Kb?$APP.ad:this.Kb};$APP.l.J=function(a,b){return b===this.H?this:new $APP.$h(b,this.start,this.end,this.step,this.ba,this.Kb,this.M)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};$APP.l.pd=function(){return $APP.J(this.Yb(null))};$APP.$h.prototype[Zc]=function(){return dd(this)};$APP.l=$APP.ai.prototype;
$APP.l.toString=function(){return $APP.Ic(this)};$APP.l.indexOf=function(){var a=null;a=function(b,c){switch(arguments.length){case 1:return yd(this,b,0);case 2:return yd(this,b,c)}throw Error("Invalid arity: "+arguments.length);};a.g=function(b){return yd(this,b,0)};a.h=function(b,c){return yd(this,b,c)};return a}();
$APP.l.lastIndexOf=function(){function a(c){return zd(this,c,$APP.ud(this))}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return zd(this,c,d)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return zd(this,c,d)};return b}();
$APP.l.$c=function(){if(null==this.ba){var a=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];a:{var b=0;for(var c=this.start;;)if(32>b){if(a[b]=c,b+=1,c+=this.step,!(0<this.step?c<this.end:c>this.end)){b=this.ba=new jf(a,0,b);break a}}else{b=c;break a}}null==this.ba&&(this.ba=new jf(a,0,32),(0<this.step?b<this.end:b>this.end)&&(this.Kb=new $APP.ai(null,b,this.end,this.step,null,null,null)))}};
$APP.l.gb=function(){return new Zh(this.start,this.end,this.step)};$APP.l.I=function(){return this.H};$APP.l.Ca=function(){return 0<this.step?this.start+this.step<this.end?new $APP.ai(null,this.start+this.step,this.end,this.step,null,null,null):null:this.start+this.step>this.end?new $APP.ai(null,this.start+this.step,this.end,this.step,null,null,null):null};$APP.l.ga=function(){var a=this.M;return null!=a?a:this.M=a=fd(this)};$APP.l.fa=function(a,b){return Me(this,b)};$APP.l.Ba=function(){return $APP.ad};
$APP.l.Fa=function(a,b){return we(b,this)};$APP.l.Ga=function(a,b,c){for(a=this.start;;)if(0<this.step?a<this.end:a>this.end){c=b.h?b.h(c,a):b.call(null,c,a);if($APP.ld(c))return $APP.$b(c);a+=this.step}else return c};$APP.l.Da=function(){return this.start};$APP.l.Ha=function(){var a=this.Ca(null);return null==a?$APP.ad:a};$APP.l.ia=function(){return this};$APP.l.Qc=function(){this.$c();return this.ba};$APP.l.Yb=function(){this.$c();return null==this.Kb?$APP.ad:this.Kb};
$APP.l.J=function(a,b){return b===this.H?this:new $APP.ai(b,this.start,this.end,this.step,this.ba,this.Kb,this.M)};$APP.l.Aa=function(a,b){return $APP.Te(b,this)};$APP.l.pd=function(){return $APP.J(this.Yb(null))};$APP.ai.prototype[Zc]=function(){return dd(this)};var ii={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"};$f.prototype.za=$APP.Qc;
$f.prototype.Z=function(a,b,c){pc(b,"#object[cljs.core.Volatile ");$APP.li(new $APP.n(null,1,[Vo,this.state],null),b,c);return pc(b,"]")};Wc.prototype.za=$APP.Qc;Wc.prototype.Z=function(a,b,c){pc(b,"#'");return $APP.li(this.uc,b,c)};$APP.Yc.prototype.za=$APP.Qc;$APP.Yc.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};$APP.ef.prototype.za=$APP.Qc;$APP.ef.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};$APP.oe.prototype.za=$APP.Qc;
$APP.oe.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"["," ","]",c,this)};qh.prototype.za=$APP.Qc;qh.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};Vg.prototype.za=$APP.Qc;Vg.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};ed.prototype.za=$APP.Qc;ed.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};Dg.prototype.za=$APP.Qc;Dg.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};
Se.prototype.za=$APP.Qc;Se.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};Cd.prototype.za=$APP.Qc;Cd.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};$APP.$h.prototype.za=$APP.Qc;$APP.$h.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};Ah.prototype.za=$APP.Qc;Ah.prototype.Z=function(a,b,c){return ni(this,$APP.li,b,c)};uh.prototype.za=$APP.Qc;uh.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};
Hg.prototype.za=$APP.Qc;Hg.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"["," ","]",c,this)};$APP.Nh.prototype.za=$APP.Qc;$APP.Nh.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"#{"," ","}",c,this)};kf.prototype.za=$APP.Qc;kf.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};Xf.prototype.za=$APP.Qc;Xf.prototype.Z=function(a,b,c){pc(b,"#object[cljs.core.Atom ");$APP.li(new $APP.n(null,1,[Vo,this.state],null),b,c);return pc(b,"]")};Gh.prototype.za=$APP.Qc;
Gh.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};bg.prototype.za=$APP.Qc;bg.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};$APP.X.prototype.za=$APP.Qc;$APP.X.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"["," ","]",c,this)};Pe.prototype.za=$APP.Qc;Pe.prototype.Z=function(a,b){return pc(b,"()")};$APP.n.prototype.za=$APP.Qc;$APP.n.prototype.Z=function(a,b,c){return ni(this,$APP.li,b,c)};$APP.ai.prototype.za=$APP.Qc;
$APP.ai.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};Eh.prototype.za=$APP.Qc;Eh.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};$APP.Ne.prototype.za=$APP.Qc;$APP.Ne.prototype.Z=function(a,b,c){return $APP.gi(b,$APP.li,"("," ",")",c,this)};$APP.H.prototype.yc=$APP.Qc;$APP.H.prototype.Zb=function(a,b){if(b instanceof $APP.H)return Vc(this,b);throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};$APP.u.prototype.yc=$APP.Qc;
$APP.u.prototype.Zb=function(a,b){if(b instanceof $APP.u)return Ue(this,b);throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};Hg.prototype.yc=$APP.Qc;Hg.prototype.Zb=function(a,b){if($APP.Vd(b))return qn(this,b);throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};$APP.X.prototype.yc=$APP.Qc;$APP.X.prototype.Zb=function(a,b){if($APP.Vd(b))return qn(this,b);throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};
$APP.oe.prototype.yc=$APP.Qc;$APP.oe.prototype.Zb=function(a,b){if($APP.Vd(b))return qn(this,b);throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};$APP.vi.prototype.Mb=function(){$APP.z(this.f)&&(this.value=this.f.l?this.f.l():this.f.call(null),this.f=null);return this.value};$APP.vi.prototype.Z=function(a,b,c){pc(b,"#object[cljs.core.Delay ");$APP.li(new $APP.n(null,2,[Ls,null==this.f?Wo:Ms,Vo,this.value],null),b,c);return pc(b,"]")};
$APP.Xo=function Xo(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Xo.j(arguments[0],1<c.length?new $APP.Yc(c.slice(1),0,null):null)};
$APP.Xo.j=function(a,b){b=$APP.Ef(b);var c=$APP.R.i(b,nt,$APP.Uh),d=function g(Df){if(null==Df)return null;if(null!=Df?$APP.Qc===Df.af||(Df.jb?0:$APP.ob(wi,Df)):$APP.ob(wi,Df))return xi(Df);if(Df instanceof $APP.u)return c.g?c.g(Df):c.call(null,Df);if(Df instanceof $APP.H)return $APP.G.g(Df);if($APP.Td(Df)){var h={};Df=$APP.J(Df);for(var Wm=null,m=0,p=0;;)if(p<m){var r=Wm.ha(null,p),t=$APP.Q(r,0,null);r=$APP.Q(r,1,null);t=yi(t,d);r=g(r);h[t]=r;p+=1}else if(Df=$APP.J(Df))$APP.Wd(Df)?(m=$APP.zc(Df),
Df=$APP.Ac(Df),Wm=m,m=$APP.ud(m)):(m=$APP.O(Df),Wm=$APP.Q(m,0,null),m=$APP.Q(m,1,null),Wm=yi(Wm,d),m=g(m),h[Wm]=m,Df=$APP.P(Df),Wm=null,m=0),p=0;else break;return h}if($APP.Pd(Df)){h=[];Df=$APP.J($APP.ig.h(g,Df));Wm=null;for(p=m=0;;)if(p<m)t=Wm.ha(null,p),h.push(t),p+=1;else if(Df=$APP.J(Df))Wm=Df,$APP.Wd(Wm)?(Df=$APP.zc(Wm),p=$APP.Ac(Wm),Wm=Df,m=$APP.ud(Df),Df=p):(Df=$APP.O(Wm),h.push(Df),Df=$APP.P(Wm),Wm=null,m=0),p=0;else break;return h}return Df};return d(a)};$APP.Xo.B=1;
$APP.Xo.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};
var Gi=null,Mi=function Mi(a,b,c){var e=function(){var Df=$APP.$b(c);return Df.g?Df.g(a):Df.call(null,a)}();e=$APP.z($APP.z(e)?e.g?e.g(b):e.call(null,b):e)?!0:null;if($APP.z(e))return e;e=function(){for(var Df=Ki(b);;)if(0<$APP.ud(Df)){var g=$APP.O(Df);Mi.i?Mi.i(a,g,c):Mi.call(null,a,g,c);Df=$APP.bd(Df)}else return null}();if($APP.z(e))return e;e=function(){for(var Df=Ki(a);;)if(0<$APP.ud(Df)){var g=$APP.O(Df);Mi.i?Mi.i(g,b,c):Mi.call(null,g,b,c);Df=$APP.bd(Df)}else return null}();return $APP.z(e)?
e:!1},Ri=function Ri(a,b,c,d,e,Df,g,h){var m=$APP.tb(function(r,t){var v=$APP.Q(t,0,null);$APP.Q(t,1,null);if(Ji($APP.$b(c),b,v)){r=null==r||Ni(v,$APP.O(r),e,$APP.$b(c))?t:r;if(!Ni($APP.O(r),v,e,$APP.$b(c)))throw Error(["Multiple methods in multimethod '",$APP.G.g(a),"' match dispatch value: ",$APP.G.g(b)," -\x3e ",$APP.G.g(v)," and ",$APP.G.g($APP.O(r)),", and neither is preferred"].join(""));return r}return r},null,$APP.$b(d)),p=function(){var r;if(r=null==m)r=$APP.$b(d),r=r.g?r.g(h):r.call(null,
h);return $APP.z(r)?new $APP.X(null,2,5,$APP.Z,[h,r],null):m}();if($APP.z(p)){if($APP.vd.h($APP.$b(g),$APP.$b(c)))return $APP.Ei.K(Df,$APP.kg,b,$APP.Dd(p)),$APP.Dd(p);Li(Df,d,g,c);return Ri.ca?Ri.ca(a,b,c,d,e,Df,g,h):Ri.call(null,a,b,c,d,e,Df,g,h)}return null};$APP.l=$APP.Pi.prototype;
$APP.l.call=function(a){switch(arguments.length-1){case 0:return this.l();case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);case 3:return this.i(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.G(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.O(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.X(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.ca(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.ka(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ma(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.na(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.oa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.pa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.qa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.ra(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.sa(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.ta(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.ua(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.ud(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.l=function(){var a=this.v.l?this.v.l():this.v.call(null),b=Si(this,a);$APP.z(b)||Oi(this.name,a);return b.l?b.l():b.call(null)};$APP.l.g=function(a){var b=this.v.g?this.v.g(a):this.v.call(null,a),c=Si(this,b);$APP.z(c)||Oi(this.name,b);return c.g?c.g(a):c.call(null,a)};
$APP.l.h=function(a,b){var c=this.v.h?this.v.h(a,b):this.v.call(null,a,b),d=Si(this,c);$APP.z(d)||Oi(this.name,c);return d.h?d.h(a,b):d.call(null,a,b)};$APP.l.i=function(a,b,c){var d=this.v.i?this.v.i(a,b,c):this.v.call(null,a,b,c),e=Si(this,d);$APP.z(e)||Oi(this.name,d);return e.i?e.i(a,b,c):e.call(null,a,b,c)};$APP.l.K=function(a,b,c,d){var e=this.v.K?this.v.K(a,b,c,d):this.v.call(null,a,b,c,d),Df=Si(this,e);$APP.z(Df)||Oi(this.name,e);return Df.K?Df.K(a,b,c,d):Df.call(null,a,b,c,d)};
$APP.l.G=function(a,b,c,d,e){var Df=this.v.G?this.v.G(a,b,c,d,e):this.v.call(null,a,b,c,d,e),g=Si(this,Df);$APP.z(g)||Oi(this.name,Df);return g.G?g.G(a,b,c,d,e):g.call(null,a,b,c,d,e)};$APP.l.O=function(a,b,c,d,e,Df){var g=this.v.O?this.v.O(a,b,c,d,e,Df):this.v.call(null,a,b,c,d,e,Df),h=Si(this,g);$APP.z(h)||Oi(this.name,g);return h.O?h.O(a,b,c,d,e,Df):h.call(null,a,b,c,d,e,Df)};
$APP.l.X=function(a,b,c,d,e,Df,g){var h=this.v.X?this.v.X(a,b,c,d,e,Df,g):this.v.call(null,a,b,c,d,e,Df,g),Wm=Si(this,h);$APP.z(Wm)||Oi(this.name,h);return Wm.X?Wm.X(a,b,c,d,e,Df,g):Wm.call(null,a,b,c,d,e,Df,g)};$APP.l.ca=function(a,b,c,d,e,Df,g,h){var Wm=this.v.ca?this.v.ca(a,b,c,d,e,Df,g,h):this.v.call(null,a,b,c,d,e,Df,g,h),m=Si(this,Wm);$APP.z(m)||Oi(this.name,Wm);return m.ca?m.ca(a,b,c,d,e,Df,g,h):m.call(null,a,b,c,d,e,Df,g,h)};
$APP.l.va=function(a,b,c,d,e,Df,g,h,Wm){var m=this.v.va?this.v.va(a,b,c,d,e,Df,g,h,Wm):this.v.call(null,a,b,c,d,e,Df,g,h,Wm),p=Si(this,m);$APP.z(p)||Oi(this.name,m);return p.va?p.va(a,b,c,d,e,Df,g,h,Wm):p.call(null,a,b,c,d,e,Df,g,h,Wm)};$APP.l.ka=function(a,b,c,d,e,Df,g,h,Wm,m){var p=this.v.ka?this.v.ka(a,b,c,d,e,Df,g,h,Wm,m):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m),r=Si(this,p);$APP.z(r)||Oi(this.name,p);return r.ka?r.ka(a,b,c,d,e,Df,g,h,Wm,m):r.call(null,a,b,c,d,e,Df,g,h,Wm,m)};
$APP.l.la=function(a,b,c,d,e,Df,g,h,Wm,m,p){var r=this.v.la?this.v.la(a,b,c,d,e,Df,g,h,Wm,m,p):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p),t=Si(this,r);$APP.z(t)||Oi(this.name,r);return t.la?t.la(a,b,c,d,e,Df,g,h,Wm,m,p):t.call(null,a,b,c,d,e,Df,g,h,Wm,m,p)};
$APP.l.ma=function(a,b,c,d,e,Df,g,h,Wm,m,p,r){var t=this.v.ma?this.v.ma(a,b,c,d,e,Df,g,h,Wm,m,p,r):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r),v=Si(this,t);$APP.z(v)||Oi(this.name,t);return v.ma?v.ma(a,b,c,d,e,Df,g,h,Wm,m,p,r):v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r)};
$APP.l.na=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t){var v=this.v.na?this.v.na(a,b,c,d,e,Df,g,h,Wm,m,p,r,t):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t),x=Si(this,v);$APP.z(x)||Oi(this.name,v);return x.na?x.na(a,b,c,d,e,Df,g,h,Wm,m,p,r,t):x.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t)};
$APP.l.oa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v){var x=this.v.oa?this.v.oa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v),A=Si(this,x);$APP.z(A)||Oi(this.name,x);return A.oa?A.oa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v):A.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v)};
$APP.l.pa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x){var A=this.v.pa?this.v.pa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x),E=Si(this,A);$APP.z(E)||Oi(this.name,A);return E.pa?E.pa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x):E.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x)};
$APP.l.qa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A){var E=this.v.qa?this.v.qa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A),M=Si(this,E);$APP.z(M)||Oi(this.name,E);return M.qa?M.qa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A):M.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A)};
$APP.l.ra=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E){var M=this.v.ra?this.v.ra(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E),U=Si(this,M);$APP.z(U)||Oi(this.name,M);return U.ra?U.ra(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E):U.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E)};
$APP.l.sa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M){var U=this.v.sa?this.v.sa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M),W=Si(this,U);$APP.z(W)||Oi(this.name,U);return W.sa?W.sa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M):W.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M)};
$APP.l.ta=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U){var W=this.v.ta?this.v.ta(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U),ba=Si(this,W);$APP.z(ba)||Oi(this.name,W);return ba.ta?ba.ta(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U):ba.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U)};
$APP.l.ua=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W){var ba=this.v.ua?this.v.ua(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W):this.v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W),T=Si(this,ba);$APP.z(T)||Oi(this.name,ba);return T.ua?T.ua(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W):T.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W)};
$APP.l.ud=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba){var T=Af(this.v,a,b,c,d,$APP.Bd([e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba])),q=Si(this,T);$APP.z(q)||Oi(this.name,T);return Af(q,a,b,c,d,$APP.Bd([e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba]))};$APP.l.Tc=function(){return Bc(this.name)};$APP.l.Uc=function(){return Cc(this.name)};$APP.l.ga=function(){return ja(this)};$APP.l=$APP.Ti.prototype;$APP.l.nf=$APP.Qc;$APP.l.toString=function(){return this.uuid};
$APP.l.fa=function(a,b){return(a=null!=b?$APP.Qc===b.nf?!0:!1:!1)?this.uuid===b.uuid:a};$APP.l.Z=function(a,b){return pc(b,['#uuid "',$APP.G.g(this.uuid),'"'].join(""))};$APP.l.ga=function(){null==this.M&&(this.M=Rc(this.uuid));return this.M};$APP.l.Zb=function(a,b){if(b instanceof $APP.Ti)return Ea(this.uuid,b.uuid);throw Error(["Cannot compare ",$APP.G.g(this)," to ",$APP.G.g(b)].join(""));};$APP.Wi.prototype.__proto__=Error.prototype;$APP.Wi.prototype.za=$APP.Qc;
$APP.Wi.prototype.Z=function(a,b,c){pc(b,"#error {:message ");$APP.li(this.message,b,c);$APP.z(this.data)&&(pc(b,", :data "),$APP.li(this.data,b,c));$APP.z(this.cause)&&(pc(b,", :cause "),$APP.li(this.cause,b,c));return pc(b,"}")};$APP.Wi.prototype.toString=function(){return $APP.Ic(this)};var Yo,Zo,ot,gm,bp,rt,$n,Gs,cp,dp,cm,ep,Em,lp,xt,Fu,op,pp,Gu,go,lo,Hu,Iu,eo,Ju,Ls,mn,Hi,Il,tp,ko,yp,Lu,Ap,Ur,Pk,Bp,fo,cl,Ep,dk,Ou,wm,Hp,wB,iD,Pu,ur,bm,Ru,Lp,Su,Pp,Qp,Sp,Up,An,Vp,Uu,am,Xp,tj,Yp,Zp,$p,nt,Wu,bq,dq,Yu,fq,$u,av,gq,hq,bv,iq,jq,kq,cv,dv,ev,Vr,mq,ys,Kv,by,dy,qq,sD,rq,sq,Xl,al,il,bb,yq,El,Sr,fy,yy,Ry,Sy,Ml,Cs,Dq,Fq,Jl,Ty,$m,Vy,Jq,Rr,Mq,Xy,Nq,Oq,Pq,Zy,Qq,$y,Sq,vB,tm,Uq,fz,gz,Wq,hz,db,iz,jz,Yq,Zq,ar,cr,lz,oz,Zk,pz,qz,hr,Mr,rz,jr,dj,sz,tz,lr,mr,uz,vz,jD,gr,wz,Ms,As,mo,ab,xz,yz,zz,rr,tr,Cz,Or,
Ez,Bl,Fz,dD,Vo,Gz,fp,Hz,Jh,Iz,Jz,ip,kp,Kz,MC,Km,mp,np,Mz,qp,Wn,yB,Pz,Qz,up,vp,Rz,Sz,zp,Dp,pi,Vz,qB,Wz,Xz,Yz,Zz,aA,bA,Fl,Kp,If,cA,dA,Mp,eA,fA,gA,Np,Op,Rp,kA,Kr,lA,xl,aq,Es,Kl,kD,qm,pA,wo,yl,lq,qA,vl,oq,rA,sA,tA,Wo,uq,kn,vA,wA,vq,wq,xA,Bs,yA,zA,AA,Lr,BA,Aq,Bq,Eq,CA,Gq,eD,ao,Iq,hn,em,Jr,Lq,EA,FA,GA,Rq,HA,IA,Hk,JA,KA,LA,MA,cb,Zn,NA,QA,uD,Yl,br,sm,fr,TA,ir,Qm,zo,WA,XA,Dl,kr,YA,zl,ZA,Tr,pr,qr,$A,bn,Pl,Rk,aB,sr,cB,wr,Sn;Yo=new $APP.u(null,"ns","ns",441598760);
Zo=new $APP.H("clojure.test.check.generators","list","clojure.test.check.generators/list",506971058,null);$APP.Gm=new $APP.u(null,"arity","arity",-1808556135);ot=new $APP.H(null,"seq?","seq?",-1951934719,null);$APP.$o=new $APP.u(null,"password","password",417022471);gm=new $APP.H(null,"entries","entries",1553588366,null);bp=new $APP.H(null,"cljs.core","cljs.core",770546058,null);$APP.pt=new $APP.u(null,"\x3e\x3d","\x3e\x3d",-623615505);
rt=new $APP.H("cljs.core","true?","cljs.core/true?",-77973136,null);$n=new $APP.u(null,"p2","p2",905500641);Gs=new $APP.u(null,"p1","p1",-936759954);cp=new $APP.u(null,"native-array","native-array",1549686442);dp=new $APP.u(null,"line","line",212345235);cm=new $APP.u(null,"preset","preset",777387345);ep=new $APP.H("cljs.core","integer?","cljs.core/integer?",1710697810,null);$APP.gp=new $APP.u(null,"repeat","repeat",832692087);$APP.vt=new $APP.H(null,"string?","string?",-1129175764,null);
$APP.hp=new $APP.u("gen","elements","gen/elements",657813311);Em=new $APP.u("malli.core","allow-invalid-refs","malli.core/allow-invalid-refs",-1863169617);lp=new $APP.H("cljs.core","coll?","cljs.core/coll?",1208130522,null);$APP.wt=new $APP.u(null,"string","string",-1989541586);xt=new $APP.u(null,"data","data",-232669377);Fu=new $APP.H("cljs.core","simple-symbol?","cljs.core/simple-symbol?",-1951205629,null);op=new $APP.u(null,"end-line","end-line",1837326455);
pp=new $APP.H(null,"uuid?","uuid?",400077689,null);Gu=new $APP.H(null,"fn*","fn*",-752876845,null);go=new $APP.u(null,"ks","ks",1900203942);lo=new $APP.u("cljs.spec.alpha","amp","cljs.spec.alpha/amp",831147508);Hu=new $APP.u("malli.error","error","malli.error/error",-522553785);Iu=new $APP.u(null,"warning-reporting","warning-reporting",-319054391);eo=new $APP.u("cljs.spec.alpha","alt","cljs.spec.alpha/alt",523685437);Ju=new $APP.H("cljs.core","fn","cljs.core/fn",-1065745098,null);
Ls=new $APP.u(null,"status","status",-1997798413);mn=new $APP.u(null,"re-transformer","re-transformer",-1516368461);Hi=new $APP.u(null,"descendants","descendants",1824886031);$APP.sp=new $APP.u(null,"report","report",1394055010);$APP.Ku=new $APP.u(null,"boolean","boolean",-1919418404);$APP.Im=new $APP.u(null,"output","output",-1105869043);Il=new $APP.u(null,"child-bounds","child-bounds",1368514738);tp=new $APP.H(null,"get-punch-access","get-punch-access",1112963648,null);
$APP.Al=new $APP.u(null,"re","re",228676202);ko=new $APP.u("cljs.spec.alpha","nil","cljs.spec.alpha/nil",1733813950);yp=new $APP.u("oops.sdefs","obj-path","oops.sdefs/obj-path",692461382);Lu=new $APP.u(null,"unexpected-object-value","unexpected-object-value",-1214439301);Ap=new $APP.u(null,"end-column","end-column",1425389514);$APP.Mu=new $APP.H(null,"nat-int?","nat-int?",-1879663400,null);Ur=new $APP.u("error","path","error/path",-419192760);Pk=new $APP.u("malli.core","find","malli.core/find",163301512);
Bp=new $APP.u("malli.core","invalid-dispatch-value","malli.core/invalid-dispatch-value",516707675);$APP.Cp=new $APP.H(null,"int?","int?",1799729645,null);fo=new $APP.u(null,"ps","ps",292358046);cl=new $APP.u(null,"registry","registry",1021159018);Ep=new $APP.H("clojure.test.check.generators","string-alphanumeric","clojure.test.check.generators/string-alphanumeric",836374939,null);$APP.Nu=new $APP.u(null,"\x3c\x3d","\x3c\x3d",-395636158);
dk=new $APP.u("cljs.core","not-found","cljs.core/not-found",-1572889185);$APP.Fp=new $APP.u(null,"or","or",235744169);Ou=new $APP.u("malli.core","duplicate-arities","malli.core/duplicate-arities",-374423504);wm=new $APP.u(null,"wrap","wrap",851669987);Hp=new $APP.u("oops.sdefs","obj-selector","oops.sdefs/obj-selector",655346305);wB=new $APP.H(null,"str","str",-1564826950,null);iD=new $APP.u(null,"parse","parse",-1162164619);Pu=new $APP.H("cljs.core","string?","cljs.core/string?",-2072921719,null);
$APP.Ip=new $APP.u("malli.core","invalid-input","malli.core/invalid-input",2010057279);ur=new $APP.u(null,"namespaces","namespaces",-1444157469);bm=new $APP.u("malli.core","invalid-ref","malli.core/invalid-ref",-1109933109);$APP.Fy=new $APP.u(null,"values","values",372645556);$APP.Qu=new $APP.H(null,"pos?","pos?",-244377722,null);Ru=new $APP.H("clojure.test.check.generators","such-that","clojure.test.check.generators/such-that",-1754178732,null);
Lp=new $APP.H(null,"sequential?","sequential?",1102351463,null);Su=new $APP.H("clojure.test.check.generators","any-printable","clojure.test.check.generators/any-printable",-1570493991,null);$APP.wl=new $APP.u("malli.core","val","malli.core/val",39501268);Pp=new $APP.H(null,"indexed?","indexed?",1234610384,null);Qp=new $APP.H("clojure.test.check.generators","return","clojure.test.check.generators/return",1744522038,null);Sp=new $APP.H("cljs.core","neg?","cljs.core/neg?",2002812728,null);
$APP.Tp=new $APP.u(null,"set","set",304602554);Up=new $APP.H(null,"simple-symbol?","simple-symbol?",1408454822,null);An=new $APP.u("cljs.spec.alpha","name","cljs.spec.alpha/name",205233570);Vp=new $APP.H(null,"some?","some?",234752293,null);$APP.Tu=new $APP.H(null,"pos-int?","pos-int?",-1205815015,null);Uu=new $APP.u(null,"error","error",-978969032);am=new $APP.u("malli.core","sci-options","malli.core/sci-options",905728020);Xp=new $APP.H("cljs.core","every?","cljs.core/every?",1416822717,null);
tj=new $APP.u("malli.core","input-remaining","malli.core/input-remaining",372310422);Yp=new $APP.H(null,"set?","set?",1636014792,null);$APP.Vu=new $APP.u(null,"function","function",-2127255473);Zp=new $APP.H(null,"keyword?","keyword?",1917797069,null);$p=new $APP.u("oops.sdefs","obj-path-mode","oops.sdefs/obj-path-mode",1253821198);nt=new $APP.u(null,"keyword-fn","keyword-fn",-64566675);Wu=new $APP.H(null,"get-dot-access","get-dot-access",-1468450704,null);
$APP.Pr=new $APP.u("error","message","error/message",-502809098);bq=new $APP.H("cljs.core","partial","cljs.core/partial",1483172485,null);dq=new $APP.u("malli.error","misspelled-key","malli.error/misspelled-key",616486174);$APP.Xu=new $APP.u(null,"\x3c","\x3c",-646864291);Yu=new $APP.H("cljs.spec.alpha","*","cljs.spec.alpha/*",-1238084288,null);fq=new $APP.H("cljs.core","inst?","cljs.core/inst?",1216133710,null);
$u=new $APP.H("clojure.test.check.generators","symbol","clojure.test.check.generators/symbol",-1305461065,null);av=new $APP.H(null,"associative?","associative?",-141666771,null);gq=new $APP.H(null,"qualified-symbol?","qualified-symbol?",98763807,null);hq=new $APP.H(null,"symbol?","symbol?",1820680511,null);bv=new $APP.H("cljs.core","seqable?","cljs.core/seqable?",-745394886,null);iq=new $APP.H(null,"f","f",43394975,null);
jq=new $APP.H("clojure.test.check.generators","double","clojure.test.check.generators/double",668331090,null);kq=new $APP.u(null,"error-reporting","error-reporting",1274700782);$APP.Gk=new $APP.u(null,"type","type",1174270348);cv=new $APP.u("malli.core","invalid-input-schema","malli.core/invalid-input-schema",-833477915);dv=new $APP.H(null,"s","s",-948495851,null);ev=new $APP.H(null,"x","x",-555367584,null);Vr=new $APP.u(null,"resolve","resolve",-1584445482);
mq=new $APP.H(null,"v","v",1661996586,null);ys=new $APP.u("cljs.spec.alpha","op","cljs.spec.alpha/op",-1269055252);Kv=new $APP.u(null,"expected-function-value","expected-function-value",-1399123630);by=new $APP.H(null,"k","k",-505765866,null);$APP.nq=new $APP.H(null,"integer?","integer?",1303791671,null);dy=new $APP.H(null,"n","n",-2092305744,null);$APP.pq=new $APP.u(null,"optional","optional",2053951509);qq=new $APP.H("cljs.core","keyword?","cljs.core/keyword?",713156450,null);
sD=new $APP.H(null,"p1__30488#","p1__30488#",453745284,null);rq=new $APP.H("cljs.core","partition-all","cljs.core/partition-all",1634835208,null);sq=new $APP.u(null,"check","check",1226308904);Xl=new $APP.u(null,"code","code",1586293142);al=new $APP.u(null,"keys","keys",1068423698);il=new $APP.u("malli.core","invalid-schema","malli.core/invalid-schema",1923990979);bb=new $APP.u(null,"meta","meta",1499536964);$APP.ey=new $APP.u(null,"namespace","namespace",-377510372);
yq=new $APP.H("cljs.core","ident?","cljs.core/ident?",1567441535,null);El=new $APP.u("malli.core","invalid-type","malli.core/invalid-type",-1367388450);Sr=new $APP.u(null,"default-locale","default-locale",-677515761);fy=new $APP.H("cljs.core","number?","cljs.core/number?",-811857295,null);yy=new $APP.H("cljs.core","pos-int?","cljs.core/pos-int?",-2115888030,null);Ry=new $APP.H("cljs.core","set?","cljs.core/set?",-1176684971,null);$APP.Um=new $APP.u(null,"type-properties","type-properties",-1728352126);
Sy=new $APP.H("cljs.spec.alpha","or","cljs.spec.alpha/or",-831679639,null);Ml=new $APP.u("malli.core","child-error","malli.core/child-error",-473817473);Cs=new $APP.u(null,"child","child",623967545);$APP.Cq=new $APP.u(null,"max-elements","max-elements",433034073);Dq=new $APP.H(null,"nil?","nil?",1612038930,null);Fq=new $APP.H("clojure.test.check.generators","vector","clojure.test.check.generators/vector",1081775325,null);Jl=new $APP.u(null,"re-unparser","re-unparser",1432943079);
Ty=new $APP.H(null,"any?","any?",-318999933,null);$APP.Uy=new $APP.u(null,"alt","alt",-3214426);$m=new $APP.u("malli.core","potentially-recursive-seqex","malli.core/potentially-recursive-seqex",-1574993850);Vy=new $APP.H("cljs.core","map?","cljs.core/map?",-1390345523,null);Jq=new $APP.H("clojure.test.check.generators","fmap","clojure.test.check.generators/fmap",1957997092,null);$APP.Kq=new $APP.u(null,"qualified-keyword","qualified-keyword",736041675);Rr=new $APP.u(null,"locale","locale",-2115712697);
$APP.ol=new $APP.u(null,"varargs","varargs",1030150858);Mq=new $APP.H("cljs.core","int?","cljs.core/int?",50730120,null);Xy=new $APP.u(null,"missing-object-key","missing-object-key",-1300201731);$APP.Cm=new $APP.u(null,"schema","schema",-1582001791);Nq=new $APP.H("sci.core","eval-string*","sci.core/eval-string*",2134763594,null);Oq=new $APP.u(null,"amp","amp",271690571);$APP.Yy=new $APP.u(null,"and","and",-971899817);Pq=new $APP.u(null,"_value","_value",1295875052);
Zy=new $APP.H("sci.core","fork","sci.core/fork",-1806691042,null);Qq=new $APP.H("clojure.test.check.generators","elements","clojure.test.check.generators/elements",438991326,null);$y=new $APP.H("clojure.test.check.generators","char","clojure.test.check.generators/char",-1426343459,null);Sq=new $APP.u(null,"empty","empty",767870958);vB=new $APP.u(null,"aliases","aliases",1346874714);$APP.az=new $APP.u(null,"mnemonic","mnemonic",-621218493);$APP.bz=new $APP.u(null,"multi","multi",-190293005);
$APP.Tq=new $APP.u(null,"any","any",1705907423);$APP.cz=new $APP.u(null,"child-factory","child-factory",-1019029066);$APP.dz=new $APP.u(null,"default","default",-1987822328);tm=new $APP.u("malli.error","unknown","malli.error/unknown",594142330);$APP.ez=new $APP.u("gen","fmap","gen/fmap",-1585733563);Uq=new $APP.H("cljs.core","double?","cljs.core/double?",1757455529,null);$APP.Ol=new $APP.u(null,"children","children",-940561982);fz=new $APP.u("oops.sdefs","obj-path-key","oops.sdefs/obj-path-key",-1566573562);
gz=new $APP.u("oops.sdefs","obj-path-item","oops.sdefs/obj-path-item",-77633674);Wq=new $APP.H(null,"seqable?","seqable?",72462495,null);hz=new $APP.H("sci.core","init","sci.core/init",-622666095,null);db=new $APP.u(null,"print-length","print-length",1931866356);$APP.Xq=new $APP.u(null,"nil","nil",99600501);iz=new $APP.H(null,"number?","number?",-1747282210,null);jz=new $APP.u(null,"flavor","flavor",-1331636636);$APP.kz=new $APP.u(null,"*","*",-1294732318);
Yq=new $APP.H("clojure.test.check.generators","uuid","clojure.test.check.generators/uuid",1589373144,null);Zq=new $APP.H(null,"fn?","fn?",1820990818,null);$APP.$q=new $APP.u(null,"map-of","map-of",1189682355);ar=new $APP.H("cljs.core","empty?","cljs.core/empty?",1866613644,null);cr=new $APP.H(null,"zero?","zero?",325758897,null);lz=new $APP.H("cljs.spec.alpha","tuple","cljs.spec.alpha/tuple",-415901908,null);$APP.dr=new $APP.u(null,"enum","enum",1679018432);
$APP.mz=new $APP.u(null,"maybe","maybe",-314397560);$APP.nz=new $APP.H(null,"neg-int?","neg-int?",-1610409390,null);oz=new $APP.H("cljs.core","let","cljs.core/let",-308701135,null);Zk=new $APP.u(null,"forms","forms",2045992350);pz=new $APP.H("cljs.spec.alpha","and","cljs.spec.alpha/and",-2060279705,null);$APP.Bi=new $APP.u(null,"keywordize-keys","keywordize-keys",1310784252);qz=new $APP.H("cljs.core","and","cljs.core/and",-6692549,null);hr=new $APP.u("cljs.spec.alpha","v","cljs.spec.alpha/v",552625740);
Mr=new $APP.u(null,"message","message",-406056002);rz=new $APP.u("cljs.spec.alpha","k","cljs.spec.alpha/k",-1602615178);jr=new $APP.H("cljs.core","uri?","cljs.core/uri?",1085729367,null);dj=new $APP.u("malli.core","invalid","malli.core/invalid",362080900);sz=new $APP.u("malli.core","missing-property","malli.core/missing-property",-818756333);tz=new $APP.H(null,"pairs","pairs",-2039825990,null);lr=new $APP.u("malli.core","missing-key","malli.core/missing-key",1439107666);
mr=new $APP.H("cljs.core","sequential?","cljs.core/sequential?",1777854658,null);uz=new $APP.H(null,"%","%",-950237169,null);vz=new $APP.H("clojure.test.check.generators","one-of","clojure.test.check.generators/one-of",-183339191,null);jD=new $APP.u(null,"validator","validator",-1966190681);$APP.DB=new $APP.H(null,"boolean?","boolean?",1790940868,null);gr=new $APP.u(null,"termination-safe","termination-safe",-1845225130);wz=new $APP.H("cljs.core","neg-int?","cljs.core/neg-int?",-933447883,null);
Ms=new $APP.u(null,"pending","pending",-220036727);As=new $APP.u("cljs.spec.alpha","invalid","cljs.spec.alpha/invalid",-1220295119);mo=new $APP.u("cljs.spec.alpha","pcat","cljs.spec.alpha/pcat",26406623);ab=new $APP.u(null,"readably","readably",1129599760);xz=new $APP.u(null,"file","file",-1269645878);yz=new $APP.H("cljs.core","indexed?","cljs.core/indexed?",-1311257161,null);zz=new $APP.u(null,"js-obj","js-obj",-1298148277);rr=new $APP.u(null,"frozen?","frozen?",613726824);
tr=new $APP.H("cljs.core","ifn?","cljs.core/ifn?",1573873861,null);$APP.Az=new $APP.u(null,"not","not",-595976884);$APP.Bz=new $APP.u(null,"merge","merge",-1804319409);Cz=new $APP.H(null,"char?","char?",-1072221244,null);$APP.Dz=new $APP.u(null,"qualified-symbol","qualified-symbol",-665513695);Or=new $APP.u("error","fn","error/fn",-1263293860);Ez=new $APP.u(null,"object-is-frozen","object-is-frozen",-1391578096);Bl=new $APP.u(null,"ancestors","ancestors",-776045424);
Fz=new $APP.H(null,"get-soft-access","get-soft-access",-1996253487,null);dD=new $APP.u(null,"from-ast","from-ast",-246238449);$APP.ap=new $APP.u(null,"altn","altn",1717854417);Vo=new $APP.u(null,"val","val",128701612);Gz=new $APP.H("cljs.core","zipmap","cljs.core/zipmap",-1902130674,null);fp=new $APP.u(null,"arglists","arglists",1661989754);Hz=new $APP.u("malli.core","non-function-childs","malli.core/non-function-childs",-1591582832);Jh=new $APP.u(null,"lazy-refs","lazy-refs",409178818);
Iz=new $APP.H(null,"double?","double?",-2146564276,null);Jz=new $APP.H(null,"qualified-ident?","qualified-ident?",-928894763,null);ip=new $APP.u("cljs.spec.alpha","kvs-\x3emap","cljs.spec.alpha/kvs-\x3emap",579713455);$APP.jp=new $APP.u(null,"gen","gen",142575302);kp=new $APP.H("cljs.core","simple-ident?","cljs.core/simple-ident?",1674885558,null);Kz=new $APP.u("malli.core","tuple-size","malli.core/tuple-size",-1004468077);MC=new $APP.u(null,"explainer","explainer",-2002221924);
Km=new $APP.u(null,"order","order",-1254677256);mp=new $APP.u("malli.core","extra-key","malli.core/extra-key",574816512);np=new $APP.H(null,"float?","float?",673884616,null);$APP.Lz=new $APP.u(null,"uuid","uuid",-2145095719);Mz=new $APP.H(null,"list?","list?",-1494629,null);$APP.Om=new $APP.u("malli.core","schema","malli.core/schema",-1780373863);qp=new $APP.H("clojure.test.check.generators","keyword","clojure.test.check.generators/keyword",24530530,null);
Wn=new $APP.u("cljs.spec.alpha","accept","cljs.spec.alpha/accept",370988198);$APP.Nz=new $APP.u(null,"max-tries","max-tries",-1824441792);$APP.pl=new $APP.u(null,"input","input",556931961);yB=new $APP.H(null,"clojure.string","clojure.string",-1415552165,null);$APP.Oz=new $APP.u(null,"\x3e","\x3e",-555517146);Pz=new $APP.u(null,"tag","tag",-1290361223);Qz=new $APP.u("malli.core","function-checker","malli.core/function-checker",-792030936);up=new $APP.H("cljs.core","vec","cljs.core/vec",307622519,null);
vp=new $APP.H(null,"native-array-aware-*","native-array-aware-*",97903386,null);Rz=new $APP.u("malli","error","malli/error",-1152359159);$APP.wp=new $APP.u(null,"\x3d","\x3d",1152933628);Sz=new $APP.H(null,"simple-keyword?","simple-keyword?",-367134735,null);$APP.xp=new $APP.u(null,"num-elements","num-elements",1960422107);$APP.Tz=new $APP.u(null,"arities","arities",-1781122917);zp=new $APP.u(null,"test","test",577538877);Dp=new $APP.H(null,"simple-ident?","simple-ident?",194189851,null);
$APP.Uz=new $APP.u(null,"cat","cat",-1457810207);pi=new $APP.u(null,"alt-impl","alt-impl",670969595);Vz=new $APP.H("clojure.test.check.generators","symbol-ns","clojure.test.check.generators/symbol-ns",-862629490,null);qB=new $APP.u(null,"re-validator","re-validator",-180375208);Wz=new $APP.H("cljs.core","seq?","cljs.core/seq?",-1302056292,null);Xz=new $APP.u(null,"unexpected-empty-selector","unexpected-empty-selector",-572791900);Yz=new $APP.H("cljs.core","false?","cljs.core/false?",-1660815306,null);
Zz=new $APP.u(null,"path","path",-188191168);$APP.Gp=new $APP.u(null,"min-elements","min-elements",949370780);$APP.$z=new $APP.u(null,"int","int",-1741416922);aA=new $APP.H("clojure.test.check.generators","large-integer*","clojure.test.check.generators/large-integer*",-437830670,null);bA=new $APP.H("clojure.test.check.generators","keyword-ns","clojure.test.check.generators/keyword-ns",-1492628482,null);$APP.Jp=new $APP.u(null,"+","+",1913524883);Fl=new $APP.u(null,"raw","raw",1604651272);
Kp=new $APP.u(null,"property-pred","property-pred",1813304729);If=new $APP.u(null,"flush-on-newline","flush-on-newline",-151457939);cA=new $APP.H("cljs.core","float?","cljs.core/float?",-941017745,null);dA=new $APP.u(null,"closed","closed",-919675359);Mp=new $APP.H("clojure.test.check.generators","map","clojure.test.check.generators/map",45738796,null);eA=new $APP.u(null,"soft?","soft?",-1339668477);fA=new $APP.H("cljs.core","qualified-keyword?","cljs.core/qualified-keyword?",-308091478,null);
gA=new $APP.H("cljs.core","vector?","cljs.core/vector?",-1550392028,null);Np=new $APP.H(null,"inst?","inst?",1614698981,null);Op=new $APP.H(null,"uri?","uri?",2029475116,null);Rp=new $APP.H(null,"arr","arr",2115492975,null);$APP.hA=new $APP.u(null,"hierarchy","hierarchy",-1053470341);$APP.iA=new $APP.u(null,"?","?",-1703165233);$APP.jA=new $APP.u(null,"f","f",-1597136552);kA=new $APP.H("cljs.core","array?","cljs.core/array?",-1655912448,null);
Kr=new $APP.H(null,"properties","properties",-1968616217,null);lA=new $APP.H("clojure.test.check.generators","large-integer","clojure.test.check.generators/large-integer",-865967138,null);$APP.Wp=new $APP.u(null,"double","double",884886883);$APP.mA=new $APP.u(null,"symbol","symbol",-1038572696);$APP.nA=new $APP.u(null,"catn","catn",-48807277);$APP.Uk=new $APP.u(null,"ref","ref",1289896967);$APP.Vl=new $APP.u(null,"value","value",305978217);xl=new $APP.u(null,"fallback-impl","fallback-impl",-1501286995);
aq=new $APP.H("cljs.core","simple-keyword?","cljs.core/simple-keyword?",39474330,null);Es=new $APP.u(null,"ret","ret",-468222814);Kl=new $APP.u(null,"re-min-max","re-min-max",1020871707);kD=new $APP.u(null,"unparse","unparse",-1504915552);qm=new $APP.u(null,"lazy","lazy",-424547181);$APP.oA=new $APP.H(null,"ifn?","ifn?",-2106461064,null);$APP.cq=new $APP.u(null,"vector","vector",1902966158);$APP.tD=new $APP.u(null,"select-keys","select-keys",1945879180);
pA=new $APP.u(null,"unexpected-soft-selector","unexpected-soft-selector",-1117708580);wo=new $APP.u("malli.core","sci-not-available","malli.core/sci-not-available",-1400847277);yl=new $APP.u("malli.core","into-schema","malli.core/into-schema",1522165759);lq=new $APP.H("cljs.spec.alpha","conformer","cljs.spec.alpha/conformer",2140085535,null);qA=new $APP.H("cljs.core","list?","cljs.core/list?",-684796618,null);$APP.Qr=new $APP.u(null,"unknown","unknown",-935977881);
vl=new $APP.u(null,"more-marker","more-marker",-14717935);oq=new $APP.H(null,"qualified-keyword?","qualified-keyword?",375456001,null);rA=new $APP.u("malli.error","misspelled-value","malli.error/misspelled-value",-1135752848);sA=new $APP.H(null,"vector?","vector?",-61367869,null);tA=new $APP.H("cljs.core","zero?","cljs.core/zero?",-341242858,null);$APP.tq=new $APP.u(null,"doc","doc",1913296891);Wo=new $APP.u(null,"ready","ready",1086465795);$APP.uA=new $APP.H(null,"neg?","neg?",-1902175577,null);
uq=new $APP.H("cljs.core","symbol?","cljs.core/symbol?",1422196122,null);kn=new $APP.u(null,"re-parser","re-parser",-1229625564);vA=new $APP.H("cljs.core","nat-int?","cljs.core/nat-int?",-164364171,null);wA=new $APP.u(null,"infos","infos",-927309652);vq=new $APP.H("cljs.core","boolean?","cljs.core/boolean?",1400713761,null);wq=new $APP.u(null,"added","added",2057651688);xA=new $APP.H("clojure.test.check.generators","set","clojure.test.check.generators/set",-1027639543,null);
Bs=new $APP.u("cljs.spec.alpha","gfn","cljs.spec.alpha/gfn",-593120375);yA=new $APP.H(null,"coll","coll",-1006698606,null);zA=new $APP.u(null,"object-is-sealed","object-is-sealed",-1791813926);$APP.xq=new $APP.u(null,"map","map",1371690461);$APP.zq=new $APP.u(null,"props","props",453281727);AA=new $APP.u(null,"unexpected-punching-selector","unexpected-punching-selector",-1934135338);Lr=new $APP.H(null,"type","type",-1480165421,null);BA=new $APP.u("malli.core","limits","malli.core/limits",-1343466863);
Aq=new $APP.H("cljs.core","char?","cljs.core/char?",416405281,null);$APP.Dk=new $APP.u(null,"max","max",61366548);Bq=new $APP.H("cljs.core","qualified-symbol?","cljs.core/qualified-symbol?",1570873476,null);Eq=new $APP.H(null,"empty?","empty?",76408555,null);CA=new $APP.u("oops.sdefs","obj-key","oops.sdefs/obj-key",-2004347356);Gq=new $APP.u(null,"invalid-selector","invalid-selector",1262807990);$APP.DA=new $APP.u(null,"scope","scope",-439358418);
$APP.Hq=new $APP.u("malli.core","invalid-arity","malli.core/invalid-arity",577014581);eD=new $APP.u(null,"to-ast","to-ast",-21935298);ao=new $APP.u(null,"splice","splice",449588165);Iq=new $APP.u(null,"dispatch","dispatch",1319337009);hn=new $APP.u(null,"re-explainer","re-explainer",-1266871200);em=new $APP.H(null,"children","children",699969545,null);Jr=new $APP.H(null,"malli.core","malli.core",-2051169970,null);Lq=new $APP.u(null,"name","name",1843675177);EA=new $APP.u(null,"warn","warn",-436710552);
FA=new $APP.u(null,"use-envelope","use-envelope",-2007197780);GA=new $APP.H(null,"ident?","ident?",-2061359468,null);$APP.mm=new $APP.u(null,"pred","pred",1927423397);Rq=new $APP.u(null,"selector","selector",762528866);HA=new $APP.H(null,"coll?","coll?",-1874821441,null);IA=new $APP.H("cljs.core","pos?","cljs.core/pos?",-652182749,null);Hk=new $APP.u(null,"properties","properties",685819552);JA=new $APP.H("cljs.core","uuid?","cljs.core/uuid?",-15131116,null);
KA=new $APP.u("malli.core","default","malli.core/default",-1706204176);LA=new $APP.H("cljs.core","some?","cljs.core/some?",-440439360,null);$APP.nl=new $APP.u(null,"\x3d\x3e","\x3d\x3e",1841166128);MA=new $APP.H("cljs.core","map","cljs.core/map",-338988913,null);cb=new $APP.u(null,"dup","dup",556298533);Zn=new $APP.u("cljs.spec.alpha","rep","cljs.spec.alpha/rep",1483217317);NA=new $APP.u(null,"throw","throw",-1044625833);$APP.OA=new $APP.u(null,"fn","fn",-1175266204);
$APP.Vq=new $APP.u(null,"args","args",1315556576);$APP.PA=new $APP.u(null,"sequential","sequential",-1082983960);QA=new $APP.H(null,"map?","map?",-1780568534,null);uD=new $APP.H(null,"p1__30487#","p1__30487#",536836434,null);Yl=new $APP.u(null,"naked-keys","naked-keys",-90769828);$APP.RA=new $APP.u(null,"not\x3d","not\x3d",-173995323);br=new $APP.H("cljs.core","fn?","cljs.core/fn?",71876239,null);$APP.SA=new $APP.u("malli.core","invalid-output","malli.core/invalid-output",-147363519);
sm=new $APP.u(null,"en","en",88457073);$APP.er=new $APP.u(null,"union","union",2142937499);fr=new $APP.u(null,"console","console",1228072057);TA=new $APP.H("cljs.core","any?","cljs.core/any?",-2068111842,null);$APP.Ck=new $APP.u(null,"min","min",444991522);ir=new $APP.u(null,"column","column",2078222095);$APP.UA=new $APP.u(null,"key","key",-1516042587);Qm=new $APP.u("malli.core","duplicate-keys","malli.core/duplicate-keys",1684166326);
zo=new $APP.u("malli.core","disable-sci","malli.core/disable-sci",-907669760);$APP.VA=new $APP.H(null,"true?","true?",-1600332395,null);WA=new $APP.H("cljs.core","associative?","cljs.core/associative?",-540020088,null);XA=new $APP.H(null,"boolean","boolean",-278886877,null);Dl=new $APP.u("malli.core","end-of-input","malli.core/end-of-input",-491237771);kr=new $APP.H("cljs.core","nil?","cljs.core/nil?",945071861,null);
YA=new $APP.H("cljs.core","qualified-ident?","cljs.core/qualified-ident?",-1863492566,null);zl=new $APP.u(null,"parents","parents",-2027538891);$APP.nr=new $APP.u(null,"regex","regex",939488856);ZA=new $APP.H("cljs.spec.alpha","valid?","cljs.spec.alpha/valid?",-142132235,null);Tr=new $APP.u(null,"in","in",-1531184865);pr=new $APP.u("cljs.spec.alpha","unknown","cljs.spec.alpha/unknown",651034818);qr=new $APP.u("malli.error","likely-misspelling-of","malli.error/likely-misspelling-of",1504085033);
$A=new $APP.H("clojure.test.check.generators","simple-type-printable","clojure.test.check.generators/simple-type-printable",-58489962,null);bn=new $APP.u("malli.core","lazy-entries","malli.core/lazy-entries",762112361);Pl=new $APP.u(null,"id","id",-1388402092);Rk=new $APP.u("malli.core","multiple-varargs","malli.core/multiple-varargs",1982057671);aB=new $APP.u(null,"throw-errors-from-macro-call-sites","throw-errors-from-macro-call-sites",-1338743049);
sr=new $APP.H("clojure.test.check.generators","boolean","clojure.test.check.generators/boolean",1586992347,null);$APP.bB=new $APP.H(null,"false?","false?",-1522377573,null);cB=new $APP.u(null,"rep+","rep+",-281382396);$APP.vr=new $APP.u(null,"orn","orn",738436484);wr=new $APP.u(null,"object-key-not-writable","object-key-not-writable",206336031);$APP.dB=new $APP.u(null,"tuple","tuple",-472667284);$APP.xr=new $APP.u("malli.core","missing-function","malli.core/missing-function",1913462487);
$APP.yr=new $APP.u(null,"keyword","keyword",811389747);Sn=new $APP.u(null,"errors","errors",-908790718);var Yj;Yj={};$APP.jm=Number.MAX_VALUE;var zj=function zj(a){switch(arguments.length){case 0:return zj.l();default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return zj.j(arguments[0],new $APP.Yc(c.slice(1),0,null))}};zj.l=function(){return function(a,b,c,d,e){return e.h?e.h(c,d):e.call(null,c,d)}};
zj.j=function(a,b){return $APP.tb(function(c,d){var e=yj(d);return function(Df,g,h,Wm,m){function p(r,t){return e.G?e.G(Df,g,r,t,m):e.call(null,Df,g,r,t,m)}return c.G?c.G(Df,g,h,Wm,p):c.call(null,Df,g,h,Wm,p)}},yj(a),b)};zj.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};zj.B=1;
var Bj=function Bj(a){switch(arguments.length){case 0:return Bj.l();default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Bj.j(arguments[0],new $APP.Yc(c.slice(1),0,null))}};Bj.l=function(){return function(a,b,c,d,e){return e.h?e.h(c,d):e.call(null,c,d)}};
Bj.j=function(a,b){return $APP.tb(function(c,d){var e=yj(d);return function(Df,g,h,Wm,m){function p(r,t){return e.G?e.G(Df,g,r,t,m):e.call(null,Df,g,r,t,m)}return c.G?c.G(Df,g,h,Wm,p):c.call(null,Df,g,h,Wm,p)}},yj(a),b)};Bj.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};Bj.B=1;
var Hj=function Hj(a){switch(arguments.length){case 0:return Hj.l();default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Hj.j(arguments[0],new $APP.Yc(c.slice(1),0,null))}};Hj.l=function(){return function(a,b,c,d,e){return e.i?e.i($APP.fg,c,d):e.call(null,$APP.fg,c,d)}};
Hj.j=function(a,b){var c=$APP.tb(function(d,e){return function(Df,g,h,Wm,m,p){function r(t,v,x){t=$APP.Qe.h(h,t);return d.O?d.O(Df,g,t,v,x,p):d.call(null,Df,g,t,v,x,p)}return e.G?e.G(Df,g,Wm,m,r):e.call(null,Df,g,Wm,m,r)}},function(d,e,Df,g,h,Wm){return Wm.i?Wm.i(Df,g,h):Wm.call(null,Df,g,h)},Re($APP.Te(a,b)));return function(d,e,Df,g,h){return c.O?c.O(d,e,$APP.fg,Df,g,h):c.call(null,d,e,$APP.fg,Df,g,h)}};Hj.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};Hj.B=1;
var zr=function zr(a){switch(arguments.length){case 0:return zr.l();default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return zr.j(arguments[0],new $APP.Yc(c.slice(1),0,null))}};zr.l=function(){return function(a,b,c,d,e){return e.i?e.i($APP.Jf,c,d):e.call(null,$APP.Jf,c,d)}};
zr.j=function(a,b){var c=$APP.tb(function(d,e){var Df=$APP.Q(e,0,null),g=$APP.Q(e,1,null);return function(h,Wm,m,p,r,t){function v(x,A,E){x=$APP.kg.i(m,Df,x);return d.O?d.O(h,Wm,x,A,E,t):d.call(null,h,Wm,x,A,E,t)}return g.G?g.G(h,Wm,p,r,v):g.call(null,h,Wm,p,r,v)}},function(d,e,Df,g,h,Wm){return Wm.i?Wm.i(Df,g,h):Wm.call(null,Df,g,h)},Re($APP.Te(a,b)));return function(d,e,Df,g,h){return c.O?c.O(d,e,$APP.Jf,Df,g,h):c.call(null,d,e,$APP.Jf,Df,g,h)}};
zr.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};zr.B=1;var Ar=function Ar(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ar.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Ar.j=function(a){var b=$APP.Cg(a);return function(c){return $APP.Vd(c)&&$APP.vd.h($APP.ud(c),$APP.ud(b))?jg(function(d,e,Df){return ej(function(g){return $APP.hg.h(d,g)},function(){var g=$APP.R.h(c,e);return Df.g?Df.g(g):Df.call(null,g)}())},b):dj}};Ar.B=0;Ar.F=function(a){return this.j($APP.J(a))};
var Br=function Br(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Br.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Br.j=function(a){var b=$APP.hg.h($APP.Jf,a);return function(c){return $APP.Td(c)&&$APP.vd.h($APP.ud(c),$APP.ud(b))?jg(function(d,e,Df){var g=pe(c,e);return null==g?dj:ej(function(h){return $APP.hg.h(d,h)},function(){var h=$APP.Ub(g);return Df.g?Df.g(h):Df.call(null,h)}())},b):dj}};Br.B=0;Br.F=function(a){return this.j($APP.J(a))};
var Fj=function Fj(a){switch(arguments.length){case 0:return Fj.l();default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Fj.j(arguments[0],new $APP.Yc(c.slice(1),0,null))}};Fj.l=function(){return function(a,b,c,d,e,Df){return Df.i?Df.i(c,d,e):Df.call(null,c,d,e)}};
Fj.j=function(a,b){return $APP.tb(function(c,d){var e=yj(d);return function(Df,g,h,Wm,m,p){function r(t,v,x){return e.O?e.O(Df,g,t,v,x,p):e.call(null,Df,g,t,v,x,p)}return c.O?c.O(Df,g,h,Wm,m,r):c.call(null,Df,g,h,Wm,m,r)}},yj(a),b)};Fj.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};Fj.B=1;var Cr=function Cr(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Cr.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};
Cr.j=function(a){return Be(function(b,c){var d=yj(b),e=yj(c);return function(Df,g,h,Wm,m){jj(Df,e,g,h,Wm,m);return jj(Df,d,g,h,Wm,m)}},a)};Cr.B=0;Cr.F=function(a){return this.j($APP.J(a))};var Dr=function Dr(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Dr.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Dr.j=function(a){return Be(function(b,c){var d=yj(b),e=yj(c);return function(Df,g,h,Wm,m){lj(Df,e,g,h,Wm,m);return lj(Df,d,g,h,Wm,m)}},a)};Dr.B=0;
Dr.F=function(a){return this.j($APP.J(a))};var Er=function Er(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Er.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Er.j=function(a){return Be(function(b,c){return function(d,e,Df,g,h){jj(d,c,e,Df,g,h);return jj(d,b,e,Df,g,h)}},a)};Er.B=0;Er.F=function(a){return this.j($APP.J(a))};
var Fr=function Fr(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Fr.j(arguments[0],1<c.length?new $APP.Yc(c.slice(1),0,null):null)};Fr.j=function(a,b){return $APP.tb(function(c,d){var e=$APP.Q(d,0,null);d=$APP.Q(d,1,null);var Df=xj(function(g){return new $APP.oe(e,g)},d);return function(g,h,Wm,m,p){jj(g,Df,h,Wm,m,p);return jj(g,c,h,Wm,m,p)}},function(){var c=$APP.Q(a,0,null),d=$APP.Q(a,1,null);return xj(function(e){return new $APP.oe(c,e)},d)}(),b)};
Fr.B=1;Fr.F=function(a){var b=$APP.O(a);a=$APP.P(a);return this.j(b,a)};var Gr=function Gr(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Gr.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Gr.j=function(a){return function(b){return $APP.tb(function(c,d){return ej(kd,d.g?d.g(b):d.call(null,b))},dj,a)}};Gr.B=0;Gr.F=function(a){return this.j($APP.J(a))};
var Hr=function Hr(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Hr.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Hr.j=function(a){var b=$APP.hg.h($APP.Jf,a);return function(c){if(c instanceof $APP.oe){var d=pe(b,$APP.Sb(c));if(null==d)return dj;c=$APP.Ub(c);d=$APP.Ub(d);return d.g?d.g(c):d.call(null,c)}return dj}};Hr.B=0;Hr.F=function(a){return this.j($APP.J(a))};
var Ir=function Ir(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ir.j(0<c.length?new $APP.Yc(c.slice(0),0,null):null)};Ir.j=function(a){return Be(function(b,c){var d=yj(b),e=yj(c);return function(Df,g,h,Wm,m,p){pj(Df,e,g,h,Wm,m,p);return pj(Df,d,g,h,Wm,m,p)}},a)};Ir.B=0;Ir.F=function(a){return this.j($APP.J(a))};
Rj.prototype.Ie=function(a,b,c,d){if(this.size+1>this.values.length>>1){var e=this.values.length<<1;a=nf(e);--e;for(var Df=this.values.length,g=0;;)if(g<Df){var h=g+1;a:if(g=this.values[g],null!=g)for(var Wm=g.hash&e,m=0;;)if($APP.z(a[Wm])){var p=m+=1;Wm=Wm+m&e;m=p}else{a[Wm]=g;break a}g=h}else break;this.values=a}a=this.values.length-1;e=Sc(Sc(Rc(b),Rc(c)),Rc(d));Df=e&a;for(h=0;;){g=this.values[Df];if(null==g)return this.values[Df]=new Qj(e,b,c,d),this.size+=1,!1;if(g=$APP.vd.h(g.hash,e)&&$APP.vd.h(g.f,
b)&&$APP.vd.h(g.pos,c)&&$APP.vd.h(g.Gg,d))return g;g=h+=1;Df=Df+h&a;h=g}};Sj.prototype.ne=function(a,b,c,d,e,Df){var g=this;return this.stack.push(function(){return b.G?b.G(g,c,d,e,Df):b.call(null,g,c,d,e,Df)})};Sj.prototype.Me=function(a,b,c,d,e,Df){return $APP.z(Pj(this.cache,b,d,c))?null:this.ne(null,b,c,d,e,Df)};Uj.prototype.me=function(a,b,c,d,e,Df){var g=this;return this.stack.push(function(){return b.G?b.G(g,c,d,e,Df):b.call(null,g,c,d,e,Df)})};
Uj.prototype.Ke=function(a,b,c,d,e,Df){return $APP.z(Pj(this.cache,b,d,c))?null:this.me(null,b,c,d,e,Df)};Uj.prototype.Le=function(a,b){return $APP.Qe.h(this.vb,b)};Uj.prototype.Je=function(a,b,c){return b>this.he?(this.he=b,this.errors=c):$APP.vd.h(b,this.he)?this.errors=$APP.hg.h(this.errors,c):null};var Zj={},JD,yo,KD,Bo,nD=$APP.Yf(bk($APP.Jf));$APP.l=bj.prototype;$APP.l.Mb=function(){if(null!=this.ic)return this.ic;var a=this.f.l?this.f.l():this.f.call(null);null!=a&&(this.ic=a);return a};
$APP.l.call=function(a){switch(arguments.length-1){case 0:return this.l();case 1:return this.g(arguments[1]);case 2:return this.h(arguments[1],arguments[2]);case 3:return this.i(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.G(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.O(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.X(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.ca(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.ka(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ma(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.na(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.oa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.pa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.qa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.ra(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.sa(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.ta(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.ua(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.ud(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length-1)].join(""));}};$APP.l.apply=function(a,b){return this.call.apply(this,[this].concat(sb(b)))};$APP.l.l=function(){var a=$APP.$b(this);return a.l?a.l():a.call(null)};$APP.l.g=function(a){var b=$APP.$b(this);return b.g?b.g(a):b.call(null,a)};$APP.l.h=function(a,b){var c=$APP.$b(this);return c.h?c.h(a,b):c.call(null,a,b)};
$APP.l.i=function(a,b,c){var d=$APP.$b(this);return d.i?d.i(a,b,c):d.call(null,a,b,c)};$APP.l.K=function(a,b,c,d){var e=$APP.$b(this);return e.K?e.K(a,b,c,d):e.call(null,a,b,c,d)};$APP.l.G=function(a,b,c,d,e){var Df=$APP.$b(this);return Df.G?Df.G(a,b,c,d,e):Df.call(null,a,b,c,d,e)};$APP.l.O=function(a,b,c,d,e,Df){var g=$APP.$b(this);return g.O?g.O(a,b,c,d,e,Df):g.call(null,a,b,c,d,e,Df)};
$APP.l.X=function(a,b,c,d,e,Df,g){var h=$APP.$b(this);return h.X?h.X(a,b,c,d,e,Df,g):h.call(null,a,b,c,d,e,Df,g)};$APP.l.ca=function(a,b,c,d,e,Df,g,h){var Wm=$APP.$b(this);return Wm.ca?Wm.ca(a,b,c,d,e,Df,g,h):Wm.call(null,a,b,c,d,e,Df,g,h)};$APP.l.va=function(a,b,c,d,e,Df,g,h,Wm){var m=$APP.$b(this);return m.va?m.va(a,b,c,d,e,Df,g,h,Wm):m.call(null,a,b,c,d,e,Df,g,h,Wm)};
$APP.l.ka=function(a,b,c,d,e,Df,g,h,Wm,m){var p=$APP.$b(this);return p.ka?p.ka(a,b,c,d,e,Df,g,h,Wm,m):p.call(null,a,b,c,d,e,Df,g,h,Wm,m)};$APP.l.la=function(a,b,c,d,e,Df,g,h,Wm,m,p){var r=$APP.$b(this);return r.la?r.la(a,b,c,d,e,Df,g,h,Wm,m,p):r.call(null,a,b,c,d,e,Df,g,h,Wm,m,p)};$APP.l.ma=function(a,b,c,d,e,Df,g,h,Wm,m,p,r){var t=$APP.$b(this);return t.ma?t.ma(a,b,c,d,e,Df,g,h,Wm,m,p,r):t.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r)};
$APP.l.na=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t){var v=$APP.$b(this);return v.na?v.na(a,b,c,d,e,Df,g,h,Wm,m,p,r,t):v.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t)};$APP.l.oa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v){var x=$APP.$b(this);return x.oa?x.oa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v):x.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v)};$APP.l.pa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x){var A=$APP.$b(this);return A.pa?A.pa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x):A.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x)};
$APP.l.qa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A){var E=$APP.$b(this);return E.qa?E.qa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A):E.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A)};$APP.l.ra=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E){var M=$APP.$b(this);return M.ra?M.ra(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E):M.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E)};
$APP.l.sa=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M){var U=$APP.$b(this);return U.sa?U.sa(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M):U.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M)};$APP.l.ta=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U){var W=$APP.$b(this);return W.ta?W.ta(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U):W.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U)};
$APP.l.ua=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W){var ba=$APP.$b(this);return ba.ua?ba.ua(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W):ba.call(null,a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W)};$APP.l.ud=function(a,b,c,d,e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba){return Af($APP.$b(this),a,b,c,d,$APP.Bd([e,Df,g,h,Wm,m,p,r,t,v,x,A,E,M,U,W,ba]))};var ul={},Yr,Zr,LD,MD,$r,rD,as,Nr,Wr,Xr,bs,cs,ds,es,fs,gs,hs,is,QD,TD,js,ks,ls,ps,qs,rs,ss,us,vs,eB,ts,fB,hB,Ks,iB,Zu,lB,nB,oB,pB,kB,sB,tB,zB,ns;$APP.xk._=function(){return!1};yk._=function(a){return $APP.lk(a)?yk($APP.wk(a)):qj(mk(a))};zk._=function(a,b){return $APP.lk(a)?zk($APP.wk(a),b):rj(b,a,nk(a,b))};Ak._=function(){return new $APP.n(null,2,[$APP.Ck,1,$APP.Dk,1],null)};
$APP.Ek=function Ek(a){switch(arguments.length){case 1:return Ek.g(arguments[0]);case 2:return Ek.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.Ek.g=function(a){return $APP.Ek.h(a,null)};$APP.Ek.h=function(a,b){throw $APP.Xi([$APP.G.g(a)," ",qi($APP.Bd([b]))].join(""),new $APP.n(null,3,[$APP.Gk,a,Mr,a,xt,b],null));};$APP.Ek.B=2;
$APP.ms=function ms(a){var c=$APP.Ef($APP.Td(a)?a:null),d=$APP.R.h(c,$APP.Gk),e=$APP.R.h(c,$APP.Um),Df=$APP.R.h(c,$APP.mm),g=$APP.R.h(c,Kp),h=$APP.R.i(c,$APP.Ck,0),Wm=$APP.R.i(c,$APP.Dk,0),m=$APP.R.i(c,dD,Fs),p=$APP.R.i(c,eD,Is);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof LD)LD=function(r,t,v,x,A,E,M,U,W,ba,T){this.Dg=r;this.xd=t;this.min=v;this.ld=x;this.sc=A;this.m=E;this.type=M;this.Dd=U;this.Sa=W;this.max=ba;this.Fd=T;this.s=393216;this.A=0},LD.prototype.J=function(r,
t){return new LD(this.Dg,this.xd,this.min,this.ld,this.sc,this.m,this.type,this.Dd,this.Sa,this.max,t)},LD.prototype.I=function(){return this.Fd},LD.prototype.zb=$APP.Qc,LD.prototype.Ta=$APP.Qc,LD.prototype.Na=function(){return this.type},LD.prototype.Oa=function(){return this.ld},LD.prototype.Ma=function(r,t,v,x){var A=this,E=this;if(Id(A.Sa))return $APP.kk(function(){var U=A.Sa.h?A.Sa.h(t,v):A.Sa.call(null,t,v);return ms.g?ms.g(U):ms.call(null,U)}(),t,v,x);r=new $APP.vi(function(){return Gl(E,t,
v,$APP.Ee,x)});var M=jl();tk(A.type,t,v,A.min,A.max);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof MD)MD=function(U,W,ba,T,q,w,y,B,C,D,F,I,K,N,S,V,Y,ca){this.form=U;this.options=W;this.Dg=ba;this.xd=T;this.Fd=q;this.N=w;this.children=y;this.min=B;this.ld=C;this.parent=D;this.sc=F;this.m=I;this.type=K;this.Dd=N;this.cache=S;this.Sa=V;this.max=Y;this.bg=ca;this.s=393216;this.A=0},MD.prototype.J=function(U,W){return new MD(this.form,this.options,this.Dg,this.xd,this.Fd,this.N,
this.children,this.min,this.ld,this.parent,this.sc,this.m,this.type,this.Dd,this.cache,this.Sa,this.max,W)},MD.prototype.I=function(){return this.bg},MD.prototype.zb=$APP.Qc,MD.prototype.wd=function(){return this.xd.g?this.xd.g(this):this.xd.call(null,this)},MD.prototype.Ua=$APP.Qc,MD.prototype.Ea=function(){var U=this,W=$APP.z(U.Dg)?U.Dg.g?U.Dg.g(U.N):U.Dg.call(null,U.N):null;return $APP.z(W)?function(ba){var T=U.sc.g?U.sc.g(ba):U.sc.call(null,ba);return $APP.z(T)?W.g?W.g(ba):W.call(null,ba):T}:
U.sc},MD.prototype.Ra=function(){return this.options},MD.prototype.Ya=function(){return this.N},MD.prototype.Va=function(){return this.children},MD.prototype.Wa=function(){return $APP.$b(this.form)},MD.prototype.Qa=function(U,W){var ba=this,T=ba.Ea(null);return function(q,w,y){return $APP.ib(T.g?T.g(q):T.call(null,q))?$APP.Qe.h(y,mb(W,w,ba,q)):y}},MD.prototype.Xa=function(){return this.parent},MD.prototype.td=$APP.Qc,MD.prototype.vd=function(){return this.cache},MD.prototype.Pa=function(U,W,ba){return ba},
MD.R=!0,MD.P="malli.core/t_malli$core28590",MD.S=function(U){return pc(U,"malli.core/t_malli$core28590")};return new MD(r,x,A.Dg,A.xd,A.Fd,t,v,A.min,A.ld,E,A.sc,A.m,A.type,A.Dd,M,A.Sa,A.max,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},LD.R=!0,LD.P="malli.core/t_malli$core28586",LD.S=function(r){return pc(r,"malli.core/t_malli$core28586")};return new LD(g,p,h,e,Df,c,d,m,a,Wm,new $APP.n(null,1,[$APP.Gk,yl],null))};
ns=function ns(a){var c=$APP.Yf($APP.Td(a)?a:null);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof QD)QD=function(d,e,Df){this.Sa=d;this.kb=e;this.Nd=Df;this.s=393216;this.A=0},QD.prototype.J=function(d,e){return new QD(this.Sa,this.kb,e)},QD.prototype.I=function(){return this.Nd},QD.prototype.zb=$APP.Qc,QD.prototype.Ta=$APP.Qc,QD.prototype.Na=function(){return $APP.Gk.g($APP.$b(this.kb))},QD.prototype.Oa=function(){return $APP.Um.g($APP.$b(this.kb))},QD.prototype.Ma=function(d,
e,Df,g){var h=this,Wm=$APP.Ef(e);d=$APP.R.h(Wm,$APP.Ck);var m=$APP.R.h(Wm,$APP.Dk),p=this;if(Id(h.Sa))return $APP.kk(function(){var w=h.Sa.h?h.Sa.h(Wm,Df):h.Sa.call(null,Wm,Df);return ns.g?ns.g(w):ns.call(null,w)}(),Wm,Df,g);var r=$APP.Ef(h.Sa),t=$APP.R.h(r,$APP.mm),v=$APP.R.h(r,Sq),x=$APP.R.i(r,Tr,function(w){return w}),A=$APP.R.h(r,$APP.Gk),E=$APP.R.h(r,iD),M=$APP.R.h(r,kD);Zf(h.kb,h.Sa);tk(A,Wm,Df,1,1);var U=$APP.vk(function(w){return $APP.Sk?$APP.Sk(w,g):Tk.call(null,w,g)},Df),W=$APP.Q(U,0,null),
ba=new $APP.vi(function(){return Gl(p,Wm,U,sk,g)}),T=jl(),q=sl(d,m);if("undefined"===typeof Yj||"undefined"===typeof ul||"undefined"===typeof TD)TD=function(w,y,B,C,D,F,I,K,N,S,V,Y,ca,ea,ia,la,ra,Ca,CD,DD,ED,FD,GD,HD,ID){this.form=w;this.Qg=y;this.options=B;this.Hf=C;this.oc=D;this.qd=F;this.N=I;this.lh=K;this.schema=N;this.children=S;this.min=V;this.parent=Y;this.kb=ca;this.type=ea;this.Nd=ia;this.ib=la;this.If=ra;this.sf=Ca;this.cache=CD;this.ob=DD;this.Sa=ED;this.max=FD;this.parse=GD;this.Ig=HD;
this.ig=ID;this.s=393216;this.A=0},TD.prototype.J=function(w,y){return new TD(this.form,this.Qg,this.options,this.Hf,this.oc,this.qd,this.N,this.lh,this.schema,this.children,this.min,this.parent,this.kb,this.type,this.Nd,this.ib,this.If,this.sf,this.cache,this.ob,this.Sa,this.max,this.parse,this.Ig,y)},TD.prototype.I=function(){return this.ig},TD.prototype.zb=$APP.Qc,TD.prototype.wd=function(){return Ds(this)},TD.prototype.Ua=$APP.Qc,TD.prototype.Ea=function(){var w=this,y=mk(w.schema);return function(B){var C=
w.oc.g?w.oc.g(B):w.oc.call(null,B);return $APP.z(C)?(C=w.ob.g?w.ob.g(B):w.ob.call(null,B),$APP.z(C)?$APP.tb(function(D,F){return $APP.z(y.g?y.g(F):y.call(null,F))?D:kd(!1)},!0,B):C):C}},TD.prototype.Ra=function(){return this.options},TD.prototype.Ya=function(){return this.N},TD.prototype.Va=function(){return this.children},TD.prototype.Wa=function(){return $APP.$b(this.form)},TD.prototype.Qa=function(w,y){var B=this,C=this,D=nk(B.schema,$APP.Qe.h(y,0));return function(F,I,K){if($APP.ib(B.oc.g?B.oc.g(F):
B.oc.call(null,F)))return $APP.Qe.h(K,hj(y,I,C,F,El));if($APP.ib(B.ob.g?B.ob.g(F):B.ob.call(null,F)))return $APP.Qe.h(K,hj(y,I,C,F,BA));var N=$APP.ud(F),S=$APP.J(F);$APP.O(S);$APP.P(S);for(S=0;;){var V=$APP.J(F);F=$APP.O(V);V=$APP.P(V);var Y=F;F=V;if(S<N){V=Y;Y=$APP.Qe.h(I,B.qd.h?B.qd.h(S,Y):B.qd.call(null,S,Y));var ca=K;V=D.i?D.i(V,Y,ca):D.call(null,V,Y,ca);K=$APP.z(V)?V:K;if(F)S+=1;else return K}else return K}}},TD.prototype.Xa=function(){return this.parent},TD.prototype.td=$APP.Qc,TD.prototype.vd=
function(){return this.cache},TD.prototype.Pa=function(){return this.schema},TD.R=!0,TD.P="malli.core/t_malli$core28753",TD.S=function(w){return pc(w,"malli.core/t_malli$core28753")};return new TD(ba,U,g,Wm,t,x,Wm,M,W,U,d,p,h.kb,A,h.Nd,function(w,y){var B=w.g?w.g(W):w.call(null,W);return function(C){if($APP.ib(t.g?t.g(C):t.call(null,C))||$APP.ib(q.g?q.g(C):q.call(null,C)))return dj;C=$APP.tb(function(D,F){F=B.g?B.g(F):B.call(null,F);return $APP.We(F,dj)?kd(dj):$APP.Qe.h(D,F)},$APP.fg,C);return $APP.We(C,
dj)?C:$APP.z(y)?y.g?y.g(C):y.call(null,C):$APP.z(v)?$APP.hg.h(v,C):C}},r,v,T,q,h.Sa,m,E,e,new $APP.n(null,1,[$APP.Gk,$APP.Om],null))},QD.R=!0,QD.P="malli.core/t_malli$core28743",QD.S=function(d){return pc(d,"malli.core/t_malli$core28743")};return new QD(a,c,new $APP.n(null,1,[$APP.Gk,yl],null))};
$APP.ml=function ml(a){switch(arguments.length){case 1:return ml.g(arguments[0]);case 2:return ml.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.ml.g=function(a){return $APP.ml.h(a,null)};$APP.ml.h=function(a,b){return ik($APP.rk($APP.Sk?$APP.Sk(a,b):Tk.call(null,a,b)))};$APP.ml.B=2;
$APP.os=function os(a){switch(arguments.length){case 1:return os.g(arguments[0]);case 2:return os.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.os.g=function(a){return $APP.os.h(a,null)};$APP.os.h=function(a,b){return sk($APP.Sk(a,b))};$APP.os.B=2;
$APP.dm=function dm(a){switch(arguments.length){case 1:return dm.g(arguments[0]);case 2:return dm.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.dm.g=function(a){return $APP.dm.h(a,null)};$APP.dm.h=function(a,b){return $APP.ok($APP.Sk(a,b))};$APP.dm.B=2;
$APP.fm=function fm(a){switch(arguments.length){case 1:return fm.g(arguments[0]);case 2:return fm.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.fm.g=function(a){return $APP.fm.h(a,null)};$APP.fm.h=function(a,b){a=$APP.Sk(a,b);return $APP.qk(a)};$APP.fm.B=2;
$APP.Tl=function Tl(a){switch(arguments.length){case 1:return Tl.g(arguments[0]);case 2:return Tl.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.Tl.g=function(a){return $APP.Tl.h(a,null)};$APP.Tl.h=function(a,b){return $APP.ll($APP.Sk(a,b),jD,mk)};$APP.Tl.B=2;
$APP.hm=function hm(a){switch(arguments.length){case 1:return hm.g(arguments[0]);case 2:return hm.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.hm.g=function(a){return $APP.hm.h(a,null)};$APP.hm.h=function(a,b){a=$APP.Sk(a,b);return $APP.z(a)?null!=a&&$APP.Qc===a.Bd?uk(a):null:null};$APP.hm.B=2;
var CB=$APP.Fi(function(a,b){var c=new bj(function(){if("undefined"!==typeof sci&&"undefined"!==typeof sci.$b&&"undefined"!==typeof sci.$b.rf)return sci.$b.rf;var Df=pe(new $APP.n(null,1,[$APP.dz,null],null),$APP.dz);if($APP.z(Df))return $APP.Ub(Df);throw Error(["Var ",$APP.G.g(Nq)," does not exist, ",Xe(Nq)," never required"].join(""));}),d=new bj(function(){if("undefined"!==typeof sci&&"undefined"!==typeof sci.$b&&"undefined"!==typeof sci.$b.wf)return sci.$b.wf;var Df=pe(new $APP.n(null,1,[$APP.dz,
null],null),$APP.dz);if($APP.z(Df))return $APP.Ub(Df);throw Error(["Var ",$APP.G.g(hz)," does not exist, ",Xe(hz)," never required"].join(""));}),e=new bj(function(){if("undefined"!==typeof sci&&"undefined"!==typeof sci.$b&&"undefined"!==typeof sci.$b.uf)return sci.$b.uf;var Df=pe(new $APP.n(null,1,[$APP.dz,null],null),$APP.dz);if($APP.z(Df))return $APP.Ub(Df);throw Error(["Var ",$APP.G.g(Zy)," does not exist, ",Xe(Zy)," never required"].join(""));});return function(){if($APP.z(function(){var g=$APP.$b(c);
return $APP.z(g)?(g=$APP.$b(d),$APP.z(g)?$APP.$b(e):g):g}())){var Df=d.g?d.g(a):d.call(null,a);c.h?c.h(Df,"(alias 'm 'malli.core)"):c.call(null,Df,"(alias 'm 'malli.core)");return function(g){var h=e.g?e.g(Df):e.call(null,Df);g=$APP.G.g(g);return c.h?c.h(h,g):c.call(null,h,g)}}return b}}),dl;
Zf(nD,ck(function(){var a=$APP.Fk.j($APP.Bd([cD(),Xg([$APP.pb(RegExp("")),Cl(!0)]),fD(),$APP.Bh([$APP.Dz,$APP.Wp,$APP.$z,$APP.mA,$APP.Kq,$APP.wt,$APP.yr,$APP.Xq,$APP.Lz,$APP.Ku,$APP.Tq],[$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.Dz,$APP.mm,$APP.bf],null)),$APP.ms(new $APP.n(null,3,[$APP.Gk,$APP.Wp,$APP.mm,$APP.le,Kp,rl(null)],null)),$APP.ms(new $APP.n(null,3,[$APP.Gk,$APP.$z,$APP.mm,$APP.ge,Kp,rl(null)],null)),$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.mA,$APP.mm,$APP.Tc],null)),$APP.ms(new $APP.n(null,
3,[$APP.Gk,$APP.Kq,$APP.mm,$APP.df,Kp,Js],null)),$APP.ms(new $APP.n(null,3,[$APP.Gk,$APP.wt,$APP.mm,$APP.kb,Kp,rl($APP.ud)],null)),$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.yr,$APP.mm,$APP.Ve],null)),$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.Xq,$APP.mm,$APP.fb],null)),$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.Lz,$APP.mm,$APP.Vi],null)),$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.Ku,$APP.mm,$APP.$d],null)),$APP.ms(new $APP.n(null,2,[$APP.Gk,$APP.Tq,$APP.mm,$APP.nb],null))]),gD(),hD()]));if("undefined"===typeof Yj||
"undefined"===typeof Zj||"undefined"===typeof JD)JD=function(b,c,d){this.zd=b;this.Sf=c;this.Vf=d;this.s=393216;this.A=0},JD.prototype.J=function(b,c){return new JD(this.zd,this.Sf,c)},JD.prototype.I=function(){return this.Vf},JD.prototype.Ne=$APP.Qc,JD.prototype.oe=function(b,c){return this.Sf.get(c)},JD.R=!0,JD.P="malli.registry/t_malli$registry23712",JD.S=function(b){return pc(b,"malli.registry/t_malli$registry23712")};return new JD(a,a,$APP.Jf)}()));var zD;
if("undefined"===typeof Yj||"undefined"===typeof Zj||"undefined"===typeof KD)KD=function(a){this.Yf=a;this.s=393216;this.A=0},KD.prototype.J=function(a,b){return new KD(b)},KD.prototype.I=function(){return this.Yf},KD.prototype.Ne=$APP.Qc,KD.prototype.oe=function(a,b){return Xj($APP.$b(nD),b)},KD.R=!0,KD.P="malli.registry/t_malli$registry23723",KD.S=function(a){return pc(a,"malli.registry/t_malli$registry23723")};zD=new KD($APP.Jf);dl=ck(zD);var Ns;Ns={};$APP.Gn=function Gn(a){switch(arguments.length){case 1:return Gn.g(arguments[0]);case 2:return Gn.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};$APP.Gn.g=function(a){var b=new $a;for(a=$APP.J(a);;)if(null!=a)b=b.append($APP.G.g($APP.O(a))),a=$APP.P(a);else return b.toString()};$APP.Gn.h=function(a,b){var c=new $a;for(b=$APP.J(b);;)if(null!=b)c.append($APP.G.g($APP.O(b))),b=$APP.P(b),null!=b&&c.append(a);else return c.toString()};
$APP.Gn.B=2;var rm=$APP.Bh([mp,$APP.VA,$APP.dr,$APP.Dz,Op,Sz,$APP.Nu,$APP.Wp,pp,Np,Dp,$APP.RA,$APP.Cp,Dq,$APP.$z,$APP.Oz,np,$APP.oA,QA,sA,Ty,$APP.mA,$APP.bB,av,$APP.Al,GA,$APP.Kq,Cz,$APP.nz,$APP.wt,hq,$APP.pt,Mz,rA,Jz,HA,$APP.nl,Zp,BA,Up,Eq,$APP.nq,lr,Kz,cr,$APP.yr,$APP.Xq,oq,$APP.vt,Dl,gq,tj,ot,$APP.Mu,Yp,Vp,$APP.Qu,$APP.DB,Zq,Lp,$APP.Lz,tm,iz,Bp,Iz,Wq,$APP.wp,$APP.Ku,$APP.Xu,$APP.uA,dq,El,$APP.Tu,$APP.Tq,Pp],[new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"disallowed key"],null)],null),new $APP.n(null,1,
[$APP.Pr,new $APP.n(null,1,[sm,"should be true"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);a=$APP.R.h(a,$APP.Cm);return["should be ",$APP.G.g($APP.vd.h(1,$APP.ud($APP.fm.g(a)))?$APP.O($APP.fm.g(a)):["either ",$APP.Gn.h(", ",Th($APP.fm.g(a)))," or ",$APP.G.g($APP.Ed($APP.fm.g(a)))].join(""))].join("")}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a qualified symbol"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a uri"],
null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a simple keyword"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.Cm);return"number"===typeof $APP.R.h(a,$APP.Vl)?["should be at most ",$APP.G.g($APP.O($APP.fm.g(b)))].join(""):"should be a number"}],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,nm(new $APP.n(null,2,[$APP.mm,$APP.le,Mr,"should be a double"],null))],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,
1,[sm,"should be a uuid"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an inst"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a simple ident"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);a=$APP.R.h(a,$APP.Cm);return["should not be ",$APP.G.g($APP.O($APP.fm.g(a)))].join("")}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an int"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,
1,[sm,"should be nil"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,nm(new $APP.n(null,2,[$APP.mm,$APP.ge,Mr,"should be an integer"],null))],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.Cm);return"number"===typeof $APP.R.h(a,$APP.Vl)?["should be larger than ",$APP.G.g($APP.O($APP.fm.g(b)))].join(""):"should be a number"}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a float"],null)],null),new $APP.n(null,
1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an ifn"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a map"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a vector"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be any"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a symbol"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be false"],null)],null),new $APP.n(null,1,[$APP.Pr,
new $APP.n(null,1,[sm,"should be an associative"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should match regex"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an ident"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a qualified keyword"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a char"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a negative int"],null)],null),new $APP.n(null,
1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.Cm);a=$APP.R.h(a,$APP.Vl);b=$APP.dm.g(b);var c=$APP.Ef(b);b=$APP.R.h(c,$APP.Ck);c=$APP.R.h(c,$APP.Dk);return"string"!==typeof a?"should be a string":$APP.z($APP.z(b)?$APP.vd.h(b,c):b)?["should be ",$APP.G.g(b)," characters"].join(""):$APP.z($APP.z(b)?c:b)?["should be between ",$APP.G.g(b)," and ",$APP.G.g(c)," characters"].join(""):$APP.z(b)?["should be at least ",$APP.G.g(b)," characters"].join(""):$APP.z(c)?["should be at most ",
$APP.G.g(c)," characters"].join(""):null}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a symbol"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.Cm);return"number"===typeof $APP.R.h(a,$APP.Vl)?["should be at least ",$APP.G.g($APP.O($APP.fm.g(b)))].join(""):"should be a number"}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a list"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,
[sm,function(a){a=$APP.Ef(a);a=$APP.R.h(a,qr);return["did you mean ",$APP.Gn.h(" or ",$APP.ig.h($APP.Ed,a))].join("")}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a qualified ident"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a coll"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"invalid function"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a keyword"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,
1,[sm,function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.Cm);$APP.R.h(a,Pq);a=$APP.dm.g(b);b=$APP.Ef(a);a=$APP.R.h(b,$APP.Ck);b=$APP.R.h(b,$APP.Dk);return $APP.z($APP.z(a)?$APP.vd.h(a,b):a)?["should have ",$APP.G.g(a)," elements"].join(""):$APP.z($APP.z(a)?b:a)?["should have between ",$APP.G.g(a)," and ",$APP.G.g(b)," elements"].join(""):$APP.z(a)?["should have at least ",$APP.G.g(a)," elements"].join(""):$APP.z(b)?["should have at most ",$APP.G.g(b)," elements"].join(""):null}],null)],null),new $APP.n(null,
1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a simple symbol"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be empty"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an integer"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"missing required key"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){var b=$APP.Ef(a);a=$APP.R.h(b,$APP.Cm);b=$APP.R.h(b,$APP.Vl);a=$APP.ud($APP.fm.g(a));return["invalid tuple size ",$APP.G.g($APP.ud(b)),
", expected ",$APP.G.g(a)].join("")}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be zero"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a keyword"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be nil"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a qualified keyword"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a string"],null)],null),new $APP.n(null,1,[$APP.Pr,
new $APP.n(null,1,[sm,"end of input"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a qualified symbol"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"input remaining"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a seq"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a non-negative int"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a set"],null)],null),new $APP.n(null,1,[$APP.Pr,
new $APP.n(null,1,[sm,"should be some"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be positive"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a boolean"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an fn"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a sequential"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a uuid"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,
1,[sm,"unknown error"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a number"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"invalid dispatch value"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a double"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a seqable"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);a=$APP.R.h(a,$APP.Cm);return["should be ",$APP.G.g($APP.O($APP.fm.g(a)))].join("")}],
null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a boolean"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);var b=$APP.R.h(a,$APP.Cm);return"number"===typeof $APP.R.h(a,$APP.Vl)?["should be smaller than ",$APP.G.g($APP.O($APP.fm.g(b)))].join(""):"should be a number"}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be negative"],null)],null),new $APP.n(null,1,[Or,new $APP.n(null,1,[sm,function(a){a=$APP.Ef(a);a=$APP.R.h(a,
qr);return["should be spelled ",$APP.Gn.h(" or ",$APP.ig.h($APP.Ed,a))].join("")}],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"invalid type"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be a positive int"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be any"],null)],null),new $APP.n(null,1,[$APP.Pr,new $APP.n(null,1,[sm,"should be an indexed"],null)],null)]),xm=function xm(a,b,c,d){var Df=$APP.J(c);c=$APP.O(Df);var g=$APP.P(Df),
h=$APP.Qd(b)||$APP.Rd(b)?$APP.R.h(b,c):null;Df=$APP.z(a)?a:$APP.Sd(b)?$APP.fg:$APP.Ud(b)?$APP.Jf:$APP.Fd(b);return $APP.z($APP.z(c)?Hu.g(Ld(Df)):c)?a:$APP.z(c)?(b=$APP.Qd(Df)||$APP.Rd(Df)?$APP.R.h(Df,c):null,d=xm.K?xm.K(b,h,g,d):xm.call(null,b,h,g,d),b="number"===typeof c&&($APP.Qd(Df)||$APP.Sd(Df))?$APP.Cg(Df):null,$APP.z(b)&&(b=$APP.ud(b),Df=c>b?$APP.hg.h(Df,$APP.cg(c+1-b,null)):Df),$APP.Qd(Df)?$APP.Qe.h(Df,d):$APP.kg.i(Df,c,d)):$APP.Td(a)?(c=new $APP.X(null,1,5,$APP.Z,[Rz],null),xm.K?xm.K(Df,b,
c,d):xm.call(null,Df,b,c,d)):$APP.z(Hu.g(Ld(Df)))?$APP.Qe.h(Df,d):$APP.Vd($APP.Ff(Df))?Df:Kd(new $APP.X(null,1,5,$APP.Z,[d],null),new $APP.n(null,1,[Hu,!0],null))};var Pn={},EB,GB,HB,JB,KB,MB,NB,OB,PB,QB,RB,TB,UB,VB,WB,XB,ZB,$B,bC,KC,LC,NC;zm.prototype.Mb=function(){if(null!=this.ic)return this.ic;var a=this.f.l?this.f.l():this.f.call(null);null!=a&&(this.ic=a);return a};EB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Rs)return $APP.Rs;throw Error(["Var ",$APP.G.g(Zo)," does not exist, ",Xe(Zo)," never required"].join(""));});
GB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Ss)return $APP.Ss;throw Error(["Var ",$APP.G.g(Mp)," does not exist, ",Xe(Mp)," never required"].join(""));});
HB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Ts)return $APP.Ts;throw Error(["Var ",$APP.G.g(xA)," does not exist, ",Xe(xA)," never required"].join(""));});
JB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Us)return $APP.Us;throw Error(["Var ",$APP.G.g(Fq)," does not exist, ",Xe(Fq)," never required"].join(""));});
KB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Vs)return $APP.Vs;throw Error(["Var ",$APP.G.g(Jq)," does not exist, ",Xe(Jq)," never required"].join(""));});
MB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Ws)return $APP.Ws;throw Error(["Var ",$APP.G.g(Qq)," does not exist, ",Xe(Qq)," never required"].join(""));});
NB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Xs)return $APP.Xs;throw Error(["Var ",$APP.G.g(vz)," does not exist, ",Xe(vz)," never required"].join(""));});
OB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Ys)return $APP.Ys;throw Error(["Var ",$APP.G.g(Ru)," does not exist, ",Xe(Ru)," never required"].join(""));});
PB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.Zs)return $APP.Zs;throw Error(["Var ",$APP.G.g(Qp)," does not exist, ",Xe(Qp)," never required"].join(""));});
QB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.$s)return $APP.$s;throw Error(["Var ",$APP.G.g(aA)," does not exist, ",Xe(aA)," never required"].join(""));});
RB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.at)return $APP.at;throw Error(["Var ",$APP.G.g(Su)," does not exist, ",Xe(Su)," never required"].join(""));});
TB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.bt)return $APP.bt;throw Error(["Var ",$APP.G.g(sr)," does not exist, ",Xe(sr)," never required"].join(""));});
UB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.ct)return $APP.ct;throw Error(["Var ",$APP.G.g($y)," does not exist, ",Xe($y)," never required"].join(""));});
VB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.dt)return $APP.dt;throw Error(["Var ",$APP.G.g(jq)," does not exist, ",Xe(jq)," never required"].join(""));});
WB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.et)return $APP.et;throw Error(["Var ",$APP.G.g(qp)," does not exist, ",Xe(qp)," never required"].join(""));});
XB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.ft)return $APP.ft;throw Error(["Var ",$APP.G.g(bA)," does not exist, ",Xe(bA)," never required"].join(""));});
ZB=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.UD)return $APP.UD;throw Error(["Var ",$APP.G.g(lA)," does not exist, ",Xe(lA)," never required"].join(""));});
$B=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.ht)return $APP.ht;throw Error(["Var ",$APP.G.g($A)," does not exist, ",Xe($A)," never required"].join(""));});
bC=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.it)return $APP.it;throw Error(["Var ",$APP.G.g(Ep)," does not exist, ",Xe(Ep)," never required"].join(""));});
KC=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.jt)return $APP.jt;throw Error(["Var ",$APP.G.g($u)," does not exist, ",Xe($u)," never required"].join(""));});
LC=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.kt)return $APP.kt;throw Error(["Var ",$APP.G.g(Vz)," does not exist, ",Xe(Vz)," never required"].join(""));});
NC=new zm(function(){if("undefined"!==typeof Ns&&"undefined"!==typeof $APP.Os&&"undefined"!==typeof $APP.Ps&&"undefined"!==typeof $APP.Qs&&"undefined"!==typeof $APP.VD)return $APP.VD;throw Error(["Var ",$APP.G.g(Yq)," does not exist, ",Xe(Yq)," never required"].join(""));});
$APP.mt=new $APP.vi(function(){var a=jn();return $APP.Bh([$APP.df,$APP.ae,$APP.Vd,$APP.nb,$APP.$d,$APP.lb,$APP.jb,$APP.id,af,$APP.Sd,$APP.ke,$APP.Qd,$APP.Td,$APP.Od,$APP.kb,$APP.aj,$APP.le,$APP.ge,$APP.Rd,$APP.Ve,$APP.td,$APP.Ke,cf,$APP.ie,$APP.fb,$APP.Ye,$APP.$e,$APP.Zd,$APP.fe,$APP.je,$APP.he,$APP.Vi,$APP.Yd,$APP.Oe,$APP.Ze,$APP.hb,$APP.bf,$APP.be,$APP.Tc,$APP.Pd],[Pm($APP.Bd([sn,en()])),Bm($APP.Bd([a])),Hm($APP.Bd([a])),Nm($APP.Bd([new $APP.X(null,2,5,$APP.Z,[Rm($APP.Bd([null])),Vm()],null)])),
Xm(),Zm(),Pm($APP.Bd([$APP.jb,Vm()])),Jm($APP.Bd([function(b){return new Date(b)},gn()])),nn(),Nm($APP.Bd([new $APP.X(null,2,5,$APP.Z,[Bm($APP.Bd([a])),Hm($APP.Bd([a]))],null)])),an(),Fm($APP.Bd([a])),Dm($APP.Bd([a,a])),$APP.Lm($APP.Bd([new $APP.X(null,5,5,$APP.Z,[null,$APP.ad,$APP.fg,$APP.Jf,$APP.Oh],null)])),ln(),Jm($APP.Bd([function(b){return new La(["http://",$APP.G.g(b),".com"].join(""))},rn()])),an(),gn(),Nm($APP.Bd([new $APP.X(null,2,5,$APP.Z,[Dm($APP.Bd([a,a])),Hm($APP.Bd([a]))],null)])),
en(),Hm($APP.Bd([a])),Rm($APP.Bd([0])),cn(),Tm($APP.Bd([new $APP.n(null,1,[$APP.Dk,-1],null)])),Rm($APP.Bd([null])),Nm($APP.Bd([new $APP.X(null,2,5,$APP.Z,[en(),pn()],null)])),Pm($APP.Bd([sn,Nm($APP.Bd([new $APP.X(null,2,5,$APP.Z,[en(),pn()],null)]))])),Rm($APP.Bd([!0])),gn(),Tm($APP.Bd([new $APP.n(null,1,[$APP.Ck,0],null)])),Tm($APP.Bd([new $APP.n(null,1,[$APP.Ck,1],null)])),rn(),Rm($APP.Bd([!1])),Bm($APP.Bd([a])),Nm($APP.Bd([new $APP.X(null,2,5,$APP.Z,[cn(),nn()],null)])),Nm($APP.Bd([new $APP.X(null,
2,5,$APP.Z,[gn(),an()],null)])),Pm($APP.Bd([sn,pn()])),Nm($APP.Bd([new $APP.X(null,6,5,$APP.Z,[Rm($APP.Bd([null])),Bm($APP.Bd([a])),Hm($APP.Bd([a])),Dm($APP.Bd([a,a])),Fm($APP.Bd([a])),ln()],null)])),pn(),Nm($APP.Bd([new $APP.X(null,4,5,$APP.Z,[Dm($APP.Bd([a,a])),Bm($APP.Bd([a])),Hm($APP.Bd([a])),Fm($APP.Bd([a]))],null)]))])});var Qn={},bD,lD,WD,XD,YD,vn=$APP.Yf($APP.Jf),ZD=function(){function a(d,e){var Df=qt[$APP.aa(null==d?null:d)];if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);Df=qt._;if(null!=Df)return Df.h?Df.h(d,e):Df.call(null,d,e);throw $APP.qb("Specize.specize*",d);}function b(d){var e=qt[$APP.aa(null==d?null:d)];if(null!=e)return e.g?e.g(d):e.call(null,d);e=qt._;if(null!=e)return e.g?e.g(d):e.call(null,d);throw $APP.qb("Specize.specize*",d);}var c=null;c=function(d,e){switch(arguments.length){case 1:return b.call(this,
d);case 2:return a.call(this,d,e)}throw Error("Invalid arity: "+arguments.length);};c.g=b;c.h=a;return c}(),qt=function qt(a){switch(arguments.length){case 1:return qt.g(arguments[0]);case 2:return qt.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};qt.g=function(a){return null!=a&&null!=a.Nb?a.Nb(a):ZD(a)};qt.h=function(a,b){return null!=a&&null!=a.Ob?a.Ob(a,b):ZD(a,b)};qt.B=2;$APP.u.prototype.Nb=function(){return qt(xn(this))};
$APP.u.prototype.Ob=function(){return qt(xn(this))};$APP.H.prototype.Nb=function(){return qt(xn(this))};$APP.H.prototype.Ob=function(){return qt(xn(this))};$APP.Nh.prototype.Nb=function(){return Mn(this,this,null,null,null)};$APP.Nh.prototype.Ob=function(a,b){return Mn(b,this,null,null,null)};
qt._=function(){function a(c){var d=(d=Id(c))?Hn(c.name):d;return $APP.z(d)?Mn(d,c,null,null,null):Mn(pr,c,null,null,null)}var b=null;b=function(c,d){switch(arguments.length){case 1:return a.call(this,c);case 2:return Mn(d,c,null,null,null)}throw Error("Invalid arity: "+arguments.length);};b.g=a;b.h=function(c,d){return Mn(d,c,null,null,null)};return b}();
var Jn=function Jn(a){switch(arguments.length){case 1:return Jn.g(arguments[0]);case 2:return Jn.h(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};Jn.g=function(a){var b=yn(a);return $APP.z(b)?b:qt(a)};Jn.h=function(a,b){var c=yn(a);return $APP.z(c)?c:qt(a,b)};Jn.B=2;
var st=function st(a){switch(arguments.length){case 2:return st.h(arguments[0],arguments[1]);case 3:return st.i(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.G.g(arguments.length)].join(""));}};st.h=function(a,b){a=Jn.g(a);return!In(tn(a,b))};st.i=function(a,b,c){a=Jn.h(a,c);return!In(tn(a,b))};st.B=3;
var tt=function tt(a,b,c,d){var Df=Ui(),g=Vh(a,c),h=new $APP.vi(function(){return $APP.on.i(Jn,c,b)}),Wm=function(){switch($APP.ud(c)){case 2:return function(m){var p=$APP.$b(h),r=tn(p.g?p.g(0):p.call(null,0),m);return In(r)?(m=tn(p.g?p.g(1):p.call(null,1),m),In(m)?As:Un(a.g?a.g(1):a.call(null,1),m)):Un(a.g?a.g(0):a.call(null,0),r)};case 3:return function(m){var p=$APP.$b(h),r=tn(p.g?p.g(0):p.call(null,0),m);return In(r)?(r=tn(p.g?p.g(1):p.call(null,1),m),In(r)?(m=tn(p.g?p.g(2):p.call(null,2),m),
In(m)?As:Un(a.g?a.g(2):a.call(null,2),m)):Un(a.g?a.g(1):a.call(null,1),r)):Un(a.g?a.g(0):a.call(null,0),r)};default:return function(m){for(var p=$APP.$b(h),r=0;;)if(r<$APP.ud(p)){var t=p.g?p.g(r):p.call(null,r);t=tn(t,m);if(In(t))r+=1;else return Un(a.g?a.g(r):a.call(null,r),t)}else return As}}}();if("undefined"===typeof Gf||"undefined"===typeof Pn||"undefined"===typeof Qn||"undefined"===typeof WD)WD=function(m,p,r,t,v,x,A,E,M){this.keys=m;this.forms=p;this.Hb=r;this.Sb=t;this.id=v;this.yf=x;this.Nc=
A;this.Jb=E;this.yg=M;this.s=393216;this.A=0},WD.prototype.J=function(m,p){return new WD(this.keys,this.forms,this.Hb,this.Sb,this.id,this.yf,this.Nc,this.Jb,p)},WD.prototype.I=function(){return this.yg},WD.prototype.Nb=function(){return this},WD.prototype.Ob=function(){return this},WD.prototype.Yc=$APP.Qc,WD.prototype.Gc=function(m,p){return this.Jb.g?this.Jb.g(p):this.Jb.call(null,p)},WD.prototype.Hc=function(m,p){return tt.K?tt.K(this.keys,this.forms,this.Hb,p):tt.call(null,this.keys,this.forms,
this.Hb,p)},WD.R=!0,WD.P="cljs.spec.alpha/t_cljs$spec$alpha30208",WD.S=function(m){return pc(m,"cljs.spec.alpha/t_cljs$spec$alpha30208")};return new WD(a,b,c,d,Df,g,h,Wm,$APP.Jf)},ut=function ut(a){var c=$APP.Ef(a),d=$APP.R.h(c,fo);a=$APP.J(d);var e=$APP.O(a);a=$APP.P(a);var Df=$APP.R.h(c,go),g=$APP.J(Df),h=$APP.O(g);g=$APP.P(g);var Wm=$APP.R.h(c,Zk),m=$APP.J(Wm);$APP.O(m);m=$APP.P(m);var p=$APP.R.h(c,Es);c=$APP.R.h(c,cB);return $APP.Nf($APP.Ee,d)?Yn(e)?(d=Es.g(e),d=$APP.Qe.h(p,$APP.z(Df)?Xg([h,d]):
d),a?(a=new $APP.n(null,4,[fo,a,go,g,Zk,m,Es,d],null),ut.g?ut.g(a):ut.call(null,a)):Xn(d)):new $APP.n(null,6,[ys,mo,fo,d,Es,p,go,Df,Zk,Wm,cB,c],null):null},oo=function oo(a){a=xn(a);var c=$APP.Ef(a),d=$APP.R.h(c,ys),e=$APP.R.h(c,fo);a=$APP.R.h(c,Gs);var Df=$APP.R.h(c,$n);c=$APP.R.h(c,Zk);if($APP.vd.h(Wn,d))return!0;if($APP.vd.h(null,d))return null;if($APP.vd.h(lo,d))return d=oo.g?oo.g(a):oo.call(null,a),$APP.z(d)?(a=Vn(jo(a),e,$APP.P(c)),!In(a)):d;if($APP.vd.h(Zn,d))return(e=a===Df)?e:oo.g?oo.g(a):
oo.call(null,a);if($APP.vd.h(mo,d))return $APP.Nf(oo,e);if($APP.vd.h(eo,d))return $APP.Of(oo,e);throw Error(["No matching clause: ",$APP.G.g(d)].join(""));},jo=function jo(a){a=xn(a);var c=$APP.Ef(a);a=$APP.R.h(c,fo);var d=$APP.J(a),e=$APP.O(d);$APP.P(d);var Df=$APP.R.h(c,go),g=$APP.Q(Df,0,null),h=$APP.R.h(c,ys);d=$APP.R.h(c,Gs);var Wm=$APP.R.h(c,Es);c=$APP.R.h(c,Zk);if($APP.vd.h(Wn,h))return Wm;if($APP.vd.h(null,h))return null;if($APP.vd.h(lo,h))return e=jo.g?jo.g(d):jo.call(null,d),(Df=$APP.vd.h(e,
ko))?d=Df:(d=ys.g(xn(d)),Df=new $APP.Nh(null,new $APP.n(null,2,[Zn,null,mo,null],null),null),d=Df.g?Df.g(d):Df.call(null,d),d=$APP.z(d)?$APP.Od(e):d,d=$APP.z(d)?d:null),$APP.z(d)?ko:Vn(e,a,c);if($APP.vd.h(Zn,h))return no(d,Wm,g);if($APP.vd.h(mo,h))return no(e,Wm,g);if($APP.vd.h(eo,h))return c=co(a,Df,c,oo),a=$APP.Q(c,0,null),a=$APP.Q(a,0,null),c=$APP.Q(c,1,null),c=$APP.Q(c,0,null),a=null==a?ko:jo.g?jo.g(a):jo.call(null,a),$APP.z(c)?Un(c,a):a;throw Error(["No matching clause: ",$APP.G.g(h)].join(""));
},po=function po(a,b){a=xn(a);var d=$APP.Ef(a),e=$APP.R.h(d,Zk),Df=$APP.R.h(d,$n);a=$APP.R.h(d,fo);var g=$APP.J(a),h=$APP.O(g),Wm=$APP.P(g),m=$APP.R.h(d,Es);g=$APP.R.h(d,ys);var p=$APP.R.h(d,ao),r=$APP.R.h(d,go),t=$APP.J(r),v=$APP.O(t),x=$APP.P(t);t=$APP.R.h(d,Oq);var A=$APP.R.h(d,Gs);if($APP.z(d)){if($APP.vd.h(Wn,g))return null;if($APP.vd.h(null,g))return a=On(d,b,d),In(a)?null:Xn(a);if($APP.vd.h(lo,g))return d=po.h?po.h(A,b):po.call(null,A,b),$APP.z(d)?$APP.vd.h(Wn,ys.g(d))?(a=Vn(jo(d),a,$APP.P(e)),
In(a)?null:Xn(a)):new $APP.n(null,5,[ys,lo,Gs,d,Oq,t,fo,a,Zk,e],null):null;if($APP.vd.h(mo,g))return io(ut(new $APP.n(null,4,[fo,$APP.Te(po.h?po.h(h,b):po.call(null,h,b),Wm),go,r,Zk,e,Es,m],null)),$APP.z(oo(h))?function(){var E=ut(new $APP.n(null,4,[fo,Wm,go,x,Zk,$APP.P(e),Es,no(h,m,v)],null));return po.h?po.h(E,b):po.call(null,E,b)}():null);if($APP.vd.h(eo,g))return ho($APP.ig.h(function(E){return po.h?po.h(E,b):po.call(null,E,b)},a),r,e);if($APP.vd.h(Zn,g))return io(bo(po.h?po.h(A,b):po.call(null,
A,b),Df,m,p,e),$APP.z(oo(A))?function(){var E=bo(Df,Df,no(A,m,null),p,e);return po.h?po.h(E,b):po.call(null,E,b)}():null);throw Error(["No matching clause: ",$APP.G.g(g)].join(""));}return null},Dn=function Dn(a,b){if("undefined"===typeof Gf||"undefined"===typeof Pn||"undefined"===typeof Qn||"undefined"===typeof YD)YD=function(d,e,Df){this.re=d;this.Sb=e;this.Ag=Df;this.s=393216;this.A=0},YD.prototype.J=function(d,e){return new YD(this.re,this.Sb,e)},YD.prototype.I=function(){return this.Ag},YD.prototype.Nb=
function(){return this},YD.prototype.Ob=function(){return this},YD.prototype.Yc=$APP.Qc,YD.prototype.Gc=function(d,e){return null==e||$APP.Sd(e)?qo(this.re,$APP.J(e)):As},YD.prototype.Hc=function(d,e){return Dn.h?Dn.h(this.re,e):Dn.call(null,this.re,e)},YD.R=!0,YD.P="cljs.spec.alpha/t_cljs$spec$alpha30476",YD.S=function(d){return pc(d,"cljs.spec.alpha/t_cljs$spec$alpha30476")};return new YD(a,b,$APP.Jf)};
Nn(ip,$APP.Ko(lq,$APP.Ko(Gu,new $APP.X(null,1,5,$APP.Z,[uD],null),$APP.Ko(Gz,$APP.Ko(MA,rz,uD),$APP.Ko(MA,hr,uD))),$APP.Ko(Gu,new $APP.X(null,1,5,$APP.Z,[sD],null),$APP.Ko(MA,$APP.Ko(Ju,new $APP.X(null,1,5,$APP.Z,[new $APP.X(null,2,5,$APP.Z,[by,mq],null)],null),new $APP.n(null,2,[rz,by,hr,mq],null)),sD))),Mn($APP.Ko(lq,$APP.Ko(Ju,new $APP.X(null,1,5,$APP.Z,[uz],null),$APP.Ko(Gz,$APP.Ko(MA,rz,uz),$APP.Ko(MA,hr,uz))),$APP.Ko(Ju,new $APP.X(null,1,5,$APP.Z,[uz],null),$APP.Ko(MA,$APP.Ko(Ju,new $APP.X(null,
1,5,$APP.Z,[new $APP.X(null,2,5,$APP.Z,[by,mq],null)],null),new $APP.n(null,2,[rz,by,hr,mq],null)),uz))),function(a){return Vh($APP.ig.h(rz,a),$APP.ig.h(hr,a))},null,!0,function(a){return $APP.ig.h(function(b){var c=$APP.Q(b,0,null);b=$APP.Q(b,1,null);return new $APP.n(null,2,[rz,c,hr,b],null)},a)}));Nn(CA,$APP.Ko(Sy,$APP.wt,Pu,$APP.yr,qq),tt(new $APP.X(null,2,5,$APP.Z,[$APP.wt,$APP.yr],null),new $APP.X(null,2,5,$APP.Z,[Pu,qq],null),new $APP.X(null,2,5,$APP.Z,[$APP.kb,$APP.Ve],null),null));
Nn(Hp,$APP.Ko(Sy,$APP.UA,CA,Rq,$APP.Ko(vp,Hp)),tt(new $APP.X(null,2,5,$APP.Z,[$APP.UA,Rq],null),new $APP.X(null,2,5,$APP.Z,[CA,$APP.Ko(vp,Hp)],null),new $APP.X(null,2,5,$APP.Z,[CA,tt(new $APP.X(null,2,5,$APP.Z,[$APP.nr,cp],null),new $APP.X(null,2,5,$APP.Z,[$APP.Ko(Yu,Hp),$APP.Ko(Ju,new $APP.X(null,1,5,$APP.Z,[uz],null),$APP.Ko(qz,$APP.Ko(kA,uz),$APP.Ko(Xp,$APP.Ko(bq,ZA,Hp),uz)))],null),new $APP.X(null,2,5,$APP.Z,[bo(Hp,Hp,$APP.fg,!1,Hp),function(a){return $APP.gb(a)&&$APP.Nf($APP.Rf(st,Hp),a)}],null),
null)],null),null));Nn($p,new $APP.Nh(null,new $APP.n(null,3,[$APP.Ko(Fz),"null",$APP.Ko(tp),"null",$APP.Ko(Wu),"null"],null),null),new $APP.Nh(null,new $APP.n(null,3,[1,null,2,null,0,null],null),null));Nn(fz,Pu,$APP.kb);var ND=$APP.Ko(lz,$p,fz),OD;OD=Tn(new $APP.X(null,2,5,$APP.Z,[$p,fz],null),new $APP.X(null,2,5,$APP.Z,[$p,fz],null),null);Nn(gz,ND,OD);
Nn(yp,$APP.Ko(pz,kA,$APP.Ko(Ju,new $APP.X(null,1,5,$APP.Z,[Rp],null),$APP.Ko(oz,new $APP.X(null,2,5,$APP.Z,[tz,$APP.Ko(MA,up,$APP.Ko(rq,2,Rp))],null),$APP.Ko(ZA,$APP.Ko(Yu,gz),tz)))),function yt(a,b,c){var e=new $APP.vi(function(){return $APP.on.i(Jn,b,a)}),Df=function(){switch($APP.ud(b)){case 2:return function(g){var h=$APP.$b(e);g=tn(h.g?h.g(0):h.call(null,0),g);return In(g)?As:tn(h.g?h.g(1):h.call(null,1),g)};case 3:return function(g){var h=$APP.$b(e);g=tn(h.g?h.g(0):h.call(null,0),g);if(In(g))return As;
g=tn(h.g?h.g(1):h.call(null,1),g);return In(g)?As:tn(h.g?h.g(2):h.call(null,2),g)};default:return function(g){for(var h=$APP.$b(e),Wm=0;;)if(Wm<$APP.ud(h)){g=tn(h.g?h.g(Wm):h.call(null,Wm),g);if(In(g))return As;Wm+=1}else return g}}}();if("undefined"===typeof Gf||"undefined"===typeof Pn||"undefined"===typeof Qn||"undefined"===typeof XD)XD=function(g,h,Wm,m,p,r){this.forms=g;this.Hb=h;this.Sb=Wm;this.Nc=m;this.Jb=p;this.zg=r;this.s=393216;this.A=0},XD.prototype.J=function(g,h){return new XD(this.forms,
this.Hb,this.Sb,this.Nc,this.Jb,h)},XD.prototype.I=function(){return this.zg},XD.prototype.Nb=function(){return this},XD.prototype.Ob=function(){return this},XD.prototype.Yc=$APP.Qc,XD.prototype.Gc=function(g,h){return this.Jb.g?this.Jb.g(h):this.Jb.call(null,h)},XD.prototype.Hc=function(g,h){return yt.i?yt.i(this.forms,this.Hb,h):yt.call(null,this.forms,this.Hb,h)},XD.R=!0,XD.P="cljs.spec.alpha/t_cljs$spec$alpha30258",XD.S=function(g){return pc(g,"cljs.spec.alpha/t_cljs$spec$alpha30258")};return new XD(a,
b,c,e,Df,$APP.Jf)}(new $APP.X(null,2,5,$APP.Z,[kA,$APP.Ko(Ju,new $APP.X(null,1,5,$APP.Z,[Rp],null),$APP.Ko(oz,new $APP.X(null,2,5,$APP.Z,[tz,$APP.Ko(MA,up,$APP.Ko(rq,2,Rp))],null),$APP.Ko(ZA,$APP.Ko(Yu,gz),tz)))],null),new $APP.X(null,2,5,$APP.Z,[$APP.gb,function(a){a=$APP.ig.h($APP.Cg,Xh(2,2,a));return st.h(bo(gz,gz,$APP.fg,!1,gz),a)}],null),null));$APP.zt=$APP.Bh([Xz,Iu,FA,kq,Ez,Kv,$APP.cz,Gq,AA,aB,zA,Lu,pA,Xy,wr],[EA,fr,!0,NA,Uu,Uu,zz,Uu,EA,!0,Uu,Uu,EA,Uu,Uu]);var At=function(){var a=$APP.Yf($APP.Jf),b=$APP.Yf($APP.Jf),c=$APP.Yf($APP.Jf),d=$APP.Yf($APP.Jf),e=$APP.R.i($APP.Jf,$APP.hA,$APP.Ii.l?$APP.Ii.l():$APP.Ii.call(null));return new $APP.Pi($APP.ri.h("oops.messages","runtime-message"),function(){function Df(g,h){if(1<arguments.length)for(var Wm=0,m=Array(arguments.length-1);Wm<m.length;)m[Wm]=arguments[Wm+1],++Wm;return g}Df.B=1;Df.F=function(g){var h=$APP.O(g);$APP.bd(g);return h};Df.j=function(g){return g};return Df}(),$APP.dz,e,a,b,c,d)}();
$APP.Qi(At,Lu,function(a,b){b=$APP.Ef(b);a=$APP.R.h(b,jz);b=$APP.R.h(b,Zz);return ro.call(null,["Unexpected object value (",$APP.G.g(a),")",$APP.Od(b)?null:[" on key path '",$APP.G.g(b),"'"].join("")].join(""))});$APP.Qi(At,Kv,function(a,b){var c=$APP.Ef(b);a=$APP.R.h(c,eA);b=$APP.R.h(c,Zz);c=$APP.R.h(c,$APP.OA);return ro.call(null,["Expected a function",$APP.z(a)?" or nil":null,$APP.Od(b)?null:[" on key path '",$APP.G.g(b),"'"].join(""),", got \x3c",$APP.G.g($APP.aa(c)),"\x3e instead"].join(""))});
$APP.Qi(At,Xy,function(a,b){b=$APP.Ef(b);a=$APP.R.h(b,$APP.UA);b=$APP.R.h(b,Zz);return ro.call(null,["Missing expected object key '",$APP.G.g(a),"'",$APP.Od(b)||$APP.vd.h(b,a)?null:[" on key path '",$APP.G.g(b),"'"].join("")].join(""))});
$APP.Qi(At,wr,function(a,b){var c=$APP.Ef(b);a=$APP.R.h(c,$APP.UA);b=$APP.R.h(c,Zz);c=$APP.R.h(c,rr);return ro.call(null,["Object key '",$APP.G.g(a),"' is not writable",$APP.Od(b)||$APP.vd.h(b,a)?null:[" on key path '",$APP.G.g(b),"'"].join(""),$APP.z(c)?" because the object is frozen":null].join(""))});
$APP.Qi(At,zA,function(a,b){b=$APP.Ef(b);a=$APP.R.h(b,$APP.UA);b=$APP.R.h(b,Zz);return ro.call(null,["Cannot create object key '",$APP.G.g(a),"'",$APP.Od(b)||$APP.vd.h(b,a)?null:[" on key path '",$APP.G.g(b),"'"].join("")," because the object is sealed"].join(""))});$APP.Qi(At,Ez,function(a,b){b=$APP.Ef(b);a=$APP.R.h(b,$APP.UA);b=$APP.R.h(b,Zz);return ro.call(null,["Cannot create object key '",$APP.G.g(a),"'",$APP.Od(b)||$APP.vd.h(b,a)?null:[" on key path '",$APP.G.g(b),"'"].join("")," because the object is frozen"].join(""))});
$APP.Qi(At,Gq,function(){return ro.call(null,"Invalid selector")});$APP.Qi(At,Xz,function(){return ro.call(null,"Unexpected empty selector")});$APP.Qi(At,AA,function(){return ro.call(null,'Unexpected punching selector ("!" makes sense only with oset!)')});$APP.Qi(At,pA,function(){return ro.call(null,'Unexpected soft selector ("?" does not make sense with oset!)')});

/***/ }),

/***/ 32356:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "g8": () => (/* binding */ branchObj),
  "te": () => (/* binding */ keepTruthy)
});

// UNUSED EXPORTS: $$reduce, $iter, Range, Reduced, add, asIterable, assocMap, assocObj, autoObj, benchmark, buildKernel1d, buildKernel2d, cat, check, choices, comp, compR, concat, conj, converge, convolve1d, convolve2d, count, curve, cycle, dedupe, deepTransform, delayed, distinct, div, drop, dropNth, dropWhile, dup, duplicate, ensureReduced, every, extendSides, fill, fillN, filter, filterFuzzy, flatten, flattenWith, frequencies, groupBinary, groupByMap, groupByObj, indexed, interleave, interpolate, interpolateHermite, interpolateLinear, interpose, isReduced, iterate, iterator, iterator1, juxtR, keep, keyPermutations, keySelector, keys, labeled, last, line, lookup1d, lookup2d, lookup3d, map, mapDeep, mapIndexed, mapKeys, mapNth, mapVals, mapcat, mapcatIndexed, matchFirst, matchLast, max, maxCompare, maxMag, mean, min, minCompare, minMag, minMax, movingAverage, movingMedian, mul, multiplex, multiplexObj, noop, normCount, normFrequencies, normFrequenciesAuto, normRange, normRange2d, normRange3d, padLast, padSides, page, pairs, palindrome, partition, partitionBy, partitionOf, partitionSort, partitionSync, partitionTime, partitionWhen, peek, permutations, permutationsN, pluck, push, pushCopy, pushSort, range, range2d, range3d, rangeNd, reduce, reduceRight, reduced, reducer, reductions, rename, renamer, repeat, repeatedly, reverse, run, sample, scan, selectKeys, sideEffect, slidingWindow, some, sortedKeys, step, str, streamShuffle, streamSort, struct, sub, swizzle, symmetric, take, takeLast, takeNth, takeWhile, throttle, throttleTime, toggle, trace, transduce, transduceRight, tween, unreduced, vals, wordWrap, wrapSides, zip

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/func/comp.js
var comp = __webpack_require__(32883);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/iterator.js + 1 modules
var iterator = __webpack_require__(46171);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/compose/juxt.js
function juxt(...fns) {
    const [a, b, c, d, e, f, g, h] = fns;
    switch (fns.length) {
        case 1:
            return (x) => [a(x)];
        case 2:
            return (x) => [a(x), b(x)];
        case 3:
            return (x) => [a(x), b(x), c(x)];
        case 4:
            return (x) => [a(x), b(x), c(x), d(x)];
        case 5:
            return (x) => [a(x), b(x), c(x), d(x), e(x)];
        case 6:
            return (x) => [a(x), b(x), c(x), d(x), e(x), f(x)];
        case 7:
            return (x) => [a(x), b(x), c(x), d(x), e(x), f(x), g(x)];
        case 8:
            return (x) => [a(x), b(x), c(x), d(x), e(x), f(x), g(x), h(x)];
        default:
            return (x) => {
                let res = new Array(fns.length);
                for (let i = fns.length; --i >= 0;) {
                    res[i] = fns[i](x);
                }
                return res;
            };
    }
}

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/internal/ensure.js
var ensure = __webpack_require__(46145);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/reduced.js
var reduced = __webpack_require__(23435);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/rfn/push.js
var push = __webpack_require__(56589);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/step.js



/**
 * Single-step transducer execution wrapper.
 * Returns array if transducer produces multiple results
 * and undefined if there was no output. Else returns single
 * result value.
 *
 * @remarks
 * Likewise, once a transducer has produced a final / reduced
 * value, all further invocations of the stepper function will
 * return undefined.
 *
 * @example
 * ```ts
 * // single result
 * step(map(x => x * 10))(1);
 * // 10
 *
 * // multiple results
 * step(mapcat(x => [x, x + 1, x + 2]))(1)
 * // [ 1, 2, 3 ]
 *
 * // no result
 * f = step(filter((x) => !(x & 1)))
 * f(1); // undefined
 * f(2); // 2
 *
 * // reduced value termination
 * f = step(take(2));
 * f(1); // 1
 * f(1); // 1
 * f(1); // undefined
 * f(1); // undefined
 * ```
 *
 * @param tx -
 */
const step = (tx) => {
    const { 1: complete, 2: reduce } = (0,ensure/* ensureTransducer */.q)(tx)((0,push/* push */.V)());
    let done = false;
    return (x) => {
        if (!done) {
            let acc = reduce([], x);
            done = (0,reduced/* isReduced */.Vp)(acc);
            if (done) {
                acc = complete(acc.deref());
            }
            return acc.length === 1 ? acc[0] : acc.length > 0 ? acc : undefined;
        }
    };
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/map.js
var xform_map = __webpack_require__(84900);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/xform/multiplex.js



function multiplex(...args) {
    return (0,xform_map/* map */.U)(juxt.apply(null, args.map(step)));
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/checks/is-array.js
const isArray = Array.isArray;

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/func/renamer.js
const renamer = (kmap) => {
    const ks = Object.keys(kmap);
    const [a2, b2, c2] = ks;
    const [a1, b1, c1] = ks.map((k) => kmap[k]);
    switch (ks.length) {
        case 3:
            return (x) => {
                const res = {};
                let v;
                (v = x[c1]), v !== undefined && (res[c2] = v);
                (v = x[b1]), v !== undefined && (res[b2] = v);
                (v = x[a1]), v !== undefined && (res[a2] = v);
                return res;
            };
        case 2:
            return (x) => {
                const res = {};
                let v;
                (v = x[b1]), v !== undefined && (res[b2] = v);
                (v = x[a1]), v !== undefined && (res[a2] = v);
                return res;
            };
        case 1:
            return (x) => {
                const res = {};
                let v = x[a1];
                v !== undefined && (res[a2] = v);
                return res;
            };
        default:
            return (x) => {
                let k, v;
                const res = {};
                for (let i = ks.length - 1; i >= 0; i--) {
                    (k = ks[i]),
                        (v = x[kmap[k]]),
                        v !== undefined && (res[k] = v);
                }
                return res;
            };
    }
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/errors/illegal-arity.js
var illegal_arity = __webpack_require__(83813);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/reduce.js
var reduce = __webpack_require__(48287);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/transduce.js




function transduce(...args) {
    return $transduce(transduce, reduce/* reduce */.u4, args);
}
function transduceRight(...args) {
    return $transduce(transduceRight, reduceRight, args);
}
const $transduce = (tfn, rfn, args) => {
    let acc, xs;
    switch (args.length) {
        case 4:
            xs = args[3];
            acc = args[2];
            break;
        case 3:
            xs = args[2];
            break;
        case 2:
            return (0,xform_map/* map */.U)((x) => tfn(args[0], args[1], x));
        default:
            (0,illegal_arity/* illegalArity */.N)(args.length);
    }
    return rfn((0,ensure/* ensureTransducer */.q)(args[0])(args[1]), acc, xs);
};

// EXTERNAL MODULE: ../../node_modules/@thi.ng/checks/is-iterable.js
var is_iterable = __webpack_require__(55157);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/func/compr.js
var compr = __webpack_require__(48008);
;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/xform/filter.js



function filter(pred, src) {
    return (0,is_iterable/* isIterable */.T)(src)
        ? (0,iterator/* iterator1 */.Vc)(filter(pred), src)
        : (rfn) => {
            const r = rfn[2];
            return (0,compr/* compR */.w)(rfn, (acc, x) => (pred(x) ? r(acc, x) : acc));
        };
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/xform/rename.js







function rename(...args) {
    const iter = args.length > 2 && (0,iterator/* $iter */.ps)(rename, args);
    if (iter) {
        return iter;
    }
    let kmap = args[0];
    if (isArray(kmap)) {
        kmap = kmap.reduce((acc, k, i) => ((acc[k] = i), acc), {});
    }
    if (args[1]) {
        const ks = Object.keys(kmap);
        return (0,xform_map/* map */.U)((y) => transduce((0,comp/* comp */.p)((0,xform_map/* map */.U)((k) => [k, y[kmap[k]]]), filter((x) => x[1] !== undefined)), args[1], ks));
    }
    else {
        return (0,xform_map/* map */.U)(renamer(kmap));
    }
}

;// CONCATENATED MODULE: ../../node_modules/@thi.ng/transducers/xform/multiplex-obj.js




function multiplexObj(...args) {
    const iter = (0,iterator/* $iter */.ps)(multiplexObj, args);
    if (iter) {
        return iter;
    }
    const [xforms, rfn] = args;
    const ks = Object.keys(xforms);
    return (0,comp/* comp */.p)(multiplex.apply(null, ks.map((k) => xforms[k])), rename(ks, rfn));
}

// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/side-effect.js
var side_effect = __webpack_require__(9572);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/keep.js
var keep = __webpack_require__(75335);
// EXTERNAL MODULE: ../../node_modules/@thi.ng/transducers/xform/pluck.js
var pluck = __webpack_require__(14848);
;// CONCATENATED MODULE: ../../packages/transducers/index.js
/**
 * @fileOverview wrap @thi.ng/transducers to add more xforms for promise
 * @name index.js
 */const check=f=>map(a=>(f(a),a));const keepTruthy=fn=>(0,comp/* comp */.p)((0,side_effect/* sideEffect */.j)(x=>{if(!x&&typeof fn==='function')fn();}),(0,keep/* keep */.C)(x=>x||null));/**
 * like multiplexObj but only branches with truthy value get executed and only
 * branches with truthy result get remained
 * @param {any} obj -
 * @returns {any} -
 */function branchObj(obj){const multiplexObjTx=Object.entries(obj).reduce((acc,[k,vs])=>{vs=Array.isArray(vs)?vs:[vs];acc[k]=(0,comp/* comp */.p)((0,pluck/* pluck */.j)(k),keepTruthy(),...vs);return acc;},{});return (0,comp/* comp */.p)(multiplexObj(multiplexObjTx),(0,xform_map/* map */.U)(d=>{return Object.entries(d).reduce((acc,[k,v])=>{if(v)acc[k]=v;return acc;},{});}));}

/***/ }),

/***/ 11818:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Iy": () => (/* binding */ randomInt),
/* harmony export */   "MT": () => (/* reexport default export from named module */ strip_hex_prefix__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   "Qi": () => (/* binding */ toBuffer),
/* harmony export */   "L_": () => (/* binding */ addHexPrefix)
/* harmony export */ });
/* unused harmony exports randomHex, zeros, padToEven, intToBuffer, isHexString, fromSigned, bufferToHex, bufferToInt, toUnsigned, intToHex, setLengthLeft, setLength, setLengthRight */
/* harmony import */ var randombytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91249);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14300);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62197);
/* harmony import */ var strip_hex_prefix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79826);
/* harmony import */ var is_hex_prefixed__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38320);
const randomHex=function(size){return'0x'+randombytes(size).toString('hex');};const randomInt=function(a){return Math.floor(Math.random()*a);};/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */const zeros=function(bytes){return Buffer.allocUnsafe(bytes).fill(0);};/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */function padToEven(value){var a=value;// eslint-disable-line
if(typeof a!=='string'){throw new Error(`[@fluent-wallet/utils] while padding to even, value must be string, is currently ${typeof a}, while padToEven.`);}if(a.length%2){a=`0${a}`;}return a;}/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */function intToBuffer(i){const hex=intToHex(i);return new buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer(padToEven(hex.slice(2)),'hex');}/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */const toBuffer=function(v){if(!buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.isBuffer(v)){if(Array.isArray(v)){v=buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(v);}else if(typeof v==='string'){if(isHexString(v)){v=buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(padToEven(strip_hex_prefix__WEBPACK_IMPORTED_MODULE_3__(v)),'hex');}else{throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);}}else if(typeof v==='number'){v=intToBuffer(v);}else if(v===null||v===undefined){v=buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.allocUnsafe(0);}else if(bn_js__WEBPACK_IMPORTED_MODULE_2__.isBN(v)){v=v.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer);}else if(v.toArray){// converts a BN to a Buffer
v=buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(v.toArray());}else{throw new Error('invalid type');}}return v;};/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */function isHexString(value,length){if(typeof value!=='string'||!value.match(/^0x[0-9A-Fa-f]*$/)){return false;}if(length&&value.length!==2+2*length){return false;}return true;}/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */const fromSigned=function(num){return new BN(num).fromTwos(256);};/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */const bufferToHex=function(buf){buf=toBuffer(buf);return'0x'+buf.toString('hex');};/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */const bufferToInt=function(buf){return new BN(toBuffer(buf)).toNumber();};/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */const addHexPrefix=function(str){if(typeof str!=='string'){return str;}return is_hex_prefixed__WEBPACK_IMPORTED_MODULE_4__(str)?str:'0x'+str;};/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */const toUnsigned=function(num){return Buffer.from(num.toTwos(256).toArray());};/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */function intToHex(i){const hex=i.toString(16);// eslint-disable-line
return`0x${hex}`;}/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer|Array)
 */const setLengthLeft=function(msg,length,right=false){const buf=zeros(length);msg=toBuffer(msg);if(right){if(msg.length<length){msg.copy(buf);return buf;}return msg.slice(0,length);}else{if(msg.length<length){msg.copy(buf,length-msg.length);return buf;}return msg.slice(-length);}};const setLength=(/* unused pure expression or super */ null && (setLengthLeft));/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @return (Buffer|Array)
 */const setLengthRight=function(msg,length){return setLength(msg,length,true);};

/***/ }),

/***/ 89063:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Big": () => (/* binding */ Big),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 *  big.js v5.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>
 *  https://github.com/MikeMcl/big.js/LICENCE
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big.
   * (This limit is not enforced or checked.)
   */
  PE = 21,            // 0 to 1000000


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 *
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }

    /*
     * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which
     * points to Object.
     */
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.version = '5.2.2';

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;

  // Minus zero?
  if (n === 0 && 1 / n < 0) n = '-0';
  else if (!NUMERIC.test(n += '')) throw Error(INVALID + 'number');

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of dp decimal places using rounding mode rm.
 * Called by stringify, P.div, P.round and P.sqrt.
 *
 * x {Big} The Big to round.
 * dp {number} Integer, 0 to MAX_DP inclusive.
 * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, dp, rm, more) {
  var xc = x.c,
    i = x.e + dp + 1;

  if (i < xc.length) {
    if (rm === 1) {

      // xc[i] is the digit after the digit that may be rounded up.
      more = xc[i] >= 5;
    } else if (rm === 2) {
      more = xc[i] > 5 || xc[i] == 5 &&
        (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0) throw Error(INVALID_RM);
    }

    if (i < 1) {
      xc.length = 1;

      if (more) {

        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        x.e = -dp;
        xc[0] = 1;
      } else {

        // Zero.
        xc[0] = x.e = 0;
      }
    } else {

      // Remove any digits after the required decimal places.
      xc.length = i--;

      // Round up?
      if (more) {

        // Rounding up may mean the previous digit has to be rounded up.
        for (; ++xc[i] > 9;) {
          xc[i] = 0;
          if (!i--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }

      // Remove trailing zeros.
      for (i = xc.length; !xc[--i];) xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 *
 * x {Big}
 * id? {number} Caller id.
 *         1 toExponential
 *         2 toFixed
 *         3 toPrecision
 *         4 valueOf
 * n? {number|undefined} Caller's argument.
 * k? {number|undefined}
 */
function stringify(x, id, n, k) {
  var e, s,
    Big = x.constructor,
    z = !x.c[0];

  if (n !== UNDEFINED) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + 'precision' : INVALID_DP);
    }

    x = new Big(x);

    // The index of the digit that may be rounded up.
    n = k - x.e;

    // Round?
    if (x.c.length > ++k) round(x, n, Big.RM);

    // toFixed: recalculate k as x.e may have changed if value rounded up.
    if (id == 2) k = x.e + n + 1;

    // Append zeros?
    for (; x.c.length < k;) x.c.push(0);
  }

  e = x.e;
  s = x.c.join('');
  n = s.length;

  // Exponential notation?
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) for (e -= n; e--;) s += '0';
    else if (e < n) s = s.slice(0, e) + '.' + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && (!z || id == 4) ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
*/
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);

  // Divisor is zero?
  if (!b[0]) throw Error(DIV_BY_ZERO);

  // Dividend is 0? Return +-0.
  if (!a[0]) return new Big(k * 0);

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    d = dp + (q.e = x.e - y.e) + 1;    // number of digits of the result

  q.s = k;
  k = d < 0 ? 0 : d;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
  }

  // Round?
  if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return !this.cmp(y);
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {

    // y is non-zero? x is non-zero? Or both are zero.
    return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) throw Error(DIV_BY_ZERO);

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var t,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero? y is non-zero? x is non-zero? Or both are zero.
  if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (a = xe - ye) {
    if (a > 0) {
      ye = xe;
      t = yc;
    } else {
      a = -a;
      t = xc;
    }

    t.reverse();
    for (; a--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  a = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (b = 0; a; xc[a] %= 10) b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (b) {
    xc.unshift(b);
    ++ye;
  }

  // Remove trailing zeros.
  for (a = xc.length; xc[--a] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor(1),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + 'exponent');
  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded using rounding mode rm
 * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a
 * multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 * If rm is not specified, use Big.RM.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
 */
P.round = function (dp, rm) {
  var Big = this.constructor;
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);
  return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big(0.5);

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) throw Error(NAME + 'No square root');

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '1e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s);
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round(r, Big.DP -= 4, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) return new Big(y.s * 0);

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = (c[j] + b) % 10;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 */
P.toExponential = function (dp) {
  return stringify(this, 1, dp, dp);
};


/*
 * Return a string representing the value of this Big in normal notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp) {
  return stringify(this, 2, dp, this.e + dp);
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Integer, 1 to MAX_DP inclusive.
 */
P.toPrecision = function (sd) {
  return stringify(this, 3, sd, sd - 1);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P.toString = function () {
  return stringify(this);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = P.toJSON = function () {
  return stringify(this, 4);
};


// Export


var Big = _Big_();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);


/***/ }),

/***/ 70229:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fL": () => (/* binding */ SEMAPHORE),
/* harmony export */   "Jw": () => (/* binding */ NO_OP)
/* harmony export */ });
/* unused harmony exports DEFAULT_EPS, EVENT_ALL, EVENT_ENABLE, EVENT_DISABLE */
const DEFAULT_EPS = 1e-6;
/**
 * Internal use only. **Do NOT use in user land code!**
 *
 * @internal
 */
const SEMAPHORE = Symbol();
/**
 * No-effect placeholder function.
 */
const NO_OP = () => { };
/**
 * Catch-all event ID
 */
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";


/***/ }),

/***/ 94556:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');

/***/ }),

/***/ 69095:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');

/***/ }),

/***/ 31955:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]');

/***/ }),

/***/ 32308:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');

/***/ }),

/***/ 48004:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]');

/***/ }),

/***/ 70061:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]');

/***/ }),

/***/ 99148:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');

/***/ }),

/***/ 17428:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');

/***/ }),

/***/ 58930:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]');

/***/ }),

/***/ 95565:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]');

/***/ }),

/***/ 40763:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"6.5.4"};

/***/ }),

/***/ 42156:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"js-conflux-sdk","description":"JavaScript Conflux Software Development Kit","version":"2.1.2","license":"LGPL-3.0","author":"pan.wang@confluxnetwork.org","repository":"https://github.com/Conflux-Chain/js-conflux-sdk.git","keywords":["conflux","sdk"],"main":"src/index.js","bin":{"cfxjs":"bin/cfxjs.js"},"types":"./dist/types/index.d.ts","browser":"dist/js-conflux-sdk.umd.min.js","browserify-browser":{"secp256k1":"secp256k1/elliptic","./src/util/jsbi":"jsbi"},"files":["dist","mock","src","types"],"scripts":{"eslint":"npx eslint ./src ./test ./mock","build":"node scripts/build-frontend.js && npm run gendts","gendts":"npx tsc && node scripts/deal-dts.js","document":"node scripts/document.js","jsdocToMd":"node scripts/jsdoc-to-md.js","jsdoc":"jsdoc --readme README.md -c jsdoc.json","prepublishOnly":"npm run build","test":"jest --coverage","react":"npm run build & cd react & yarn build & yarn start"},"browserslit":"cover 99.5%","dependencies":{"@conflux-dev/conflux-address-js":"^1.3.14","abi-util-lite":"^0.1.0","big.js":"^5.2.2","commander":"^8.0.0","keccak":"^2.0.0","lodash":"^4.17.19","rlp":"^2.2.7","scrypt-js":"^3.0.1","secp256k1":"^3.7.1","superagent":"^6.1.0","websocket":"^1.0.31"},"devDependencies":{"@babel/core":"^7.8.4","@babel/plugin-transform-runtime":"^7.8.3","@babel/preset-env":"^7.8.4","@babel/runtime":"^7.8.4","@conflux-dev/jsonrpc-spec":"^0.0.5","@geekberry/jsdoc-to-md":"0.0.8","@types/node":"^14.0.23","babel-plugin-lodash":"^3.3.4","babelify":"^10.0.0","browserify":"^16.5.1","concurrently":"^5.1.0","eslint":"^7.12.0","eslint-config-airbnb-base":"^14.0.0","eslint-plugin-import":"^2.18.2","exorcist":"^1.0.1","fs-extra":"^8.1.0","jest":"26.6.0","jsbi":"^3.1.4","jsdoc-to-markdown":"^7.1.0","minify-stream":"^2.0.1","mold-source-map":"^0.4.0","solc":"^0.6.10","tidy-jsdoc":"^1.4.1","typescript":"^4.6.4"},"resolutions":{"tinyify/acorn-node/acorn":"7.1.1","eslint/espree/acorn":"7.1.1","tinyify/unassertify/unassert/acorn":"7.1.1","**/minimist":"^1.2.3","**/kind-of":"^6.0.3","**/elliptic":"^6.5.3","**/lodash":"^4.17.20","**/babel-jest":"^26.6.0","jest/jest-cli/jest-config/jest-environment-jsdom/jsdom/acorn-globals/acorn":"6.4.1"}}');

/***/ }),

/***/ 57104:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana"},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana"},"image/avcs":{"source":"iana"},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ 63747:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"COMPRESSED_TYPE_INVALID":"compressed should be a boolean","EC_PRIVATE_KEY_TYPE_INVALID":"private key should be a Buffer","EC_PRIVATE_KEY_LENGTH_INVALID":"private key length is invalid","EC_PRIVATE_KEY_RANGE_INVALID":"private key range is invalid","EC_PRIVATE_KEY_TWEAK_ADD_FAIL":"tweak out of range or resulting private key is invalid","EC_PRIVATE_KEY_TWEAK_MUL_FAIL":"tweak out of range","EC_PRIVATE_KEY_EXPORT_DER_FAIL":"couldn\'t export to DER format","EC_PRIVATE_KEY_IMPORT_DER_FAIL":"couldn\'t import from DER format","EC_PUBLIC_KEYS_TYPE_INVALID":"public keys should be an Array","EC_PUBLIC_KEYS_LENGTH_INVALID":"public keys Array should have at least 1 element","EC_PUBLIC_KEY_TYPE_INVALID":"public key should be a Buffer","EC_PUBLIC_KEY_LENGTH_INVALID":"public key length is invalid","EC_PUBLIC_KEY_PARSE_FAIL":"the public key could not be parsed or is invalid","EC_PUBLIC_KEY_CREATE_FAIL":"private was invalid, try again","EC_PUBLIC_KEY_TWEAK_ADD_FAIL":"tweak out of range or resulting public key is invalid","EC_PUBLIC_KEY_TWEAK_MUL_FAIL":"tweak out of range","EC_PUBLIC_KEY_COMBINE_FAIL":"the sum of the public keys is not valid","ECDH_FAIL":"scalar was invalid (zero or overflow)","ECDSA_SIGNATURE_TYPE_INVALID":"signature should be a Buffer","ECDSA_SIGNATURE_LENGTH_INVALID":"signature length is invalid","ECDSA_SIGNATURE_PARSE_FAIL":"couldn\'t parse signature","ECDSA_SIGNATURE_PARSE_DER_FAIL":"couldn\'t parse DER signature","ECDSA_SIGNATURE_SERIALIZE_DER_FAIL":"couldn\'t serialize signature to DER format","ECDSA_SIGN_FAIL":"nonce generation function failed or private key is invalid","ECDSA_RECOVER_FAIL":"couldn\'t recover public key from signature","MSG32_TYPE_INVALID":"message should be a Buffer","MSG32_LENGTH_INVALID":"message length is invalid","OPTIONS_TYPE_INVALID":"options should be an Object","OPTIONS_DATA_TYPE_INVALID":"options.data should be a Buffer","OPTIONS_DATA_LENGTH_INVALID":"options.data length is invalid","OPTIONS_NONCEFN_TYPE_INVALID":"options.noncefn should be a Function","RECOVERY_ID_TYPE_INVALID":"recovery should be a Number","RECOVERY_ID_VALUE_INVALID":"recovery should have value between -1 and 4","TWEAK_TYPE_INVALID":"tweak should be a Buffer","TWEAK_LENGTH_INVALID":"tweak length is invalid"}');

/***/ }),

/***/ 84735:
/***/ ((module) => {

"use strict";
module.exports = {"version":"1.0.34"};

/***/ })

};
;